<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="cdzhang" />
  <meta name="description" content="" />
  
  
  <title>
    
      Chromium 多媒体（一） 
      
      
      |
    
     ZeronePlus&#39; Blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/images3.png">
    <link rel="icon" href="/images/images3.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img no-lazy src="/images/images3.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">ZeronePlus</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Chromium 多媒体（一）</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
          2023-06-23 13:11:37
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">
                  <a href="/categories/Chromium/" title="Chromium">
                    <b>#</b> Chromium
                  </a>
                </span>
                
                <span class="span--category">
                  <a href="/categories/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93/" title="Chromium 多媒体">
                    <b>#</b> Chromium 多媒体
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>之前做过浏览器多媒体相关的业务，打算写几篇文章总结一下相关内容。</p>
<p>这篇文章介绍一下 MSE。MSE 全称 Media Source Extensions，通过该标准，浏览器应用可以实现更精细的音视频播放控制。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>我们通过下面的代码分析 MSE 的基本流程。</p>
<p>下面的代码主要做了以下工作：</p>
<ul>
<li>创建 MediaSource 类型的对象 mediaSource</li>
<li>通过 mediaSource 创建 URL，并将该 URL 赋给 video.src</li>
<li>监听 mediaSource 的 sourceopen 事件（后续会看到该事件底层是如何触发的）</li>
<li>在 sourceopen 事件的回调函数中通过 MediaSource 的 addSourceBuffer 方法创建 SourceBuffer 类型的对象 sourceBuffer，并执行 fetch 函数，每当 fetch 函数取得数据时都将数据通过 appendBuffer 送给 sourceBuffer</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#mse-video&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> mineCodes = <span class="string">&#x27;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">MediaSource</span> &amp;&amp; <span class="title class_">MediaSource</span>.<span class="title function_">isTypeSupported</span>(mineCodes)) &#123; </span><br><span class="line">  <span class="comment">// 检测当前环境是否支持 MediaSource API以及是否支持此mineCodes</span></span><br><span class="line">  <span class="keyword">var</span> mediaSource = <span class="keyword">new</span> <span class="title class_">MediaSource</span>();</span><br><span class="line">  <span class="comment">// 使用 mediaSource对象创建blob url，并赋给video.src</span></span><br><span class="line">  video.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(mediaSource);</span><br><span class="line">  mediaSource.<span class="title function_">addEventListener</span>(<span class="string">&#x27;sourceopen&#x27;</span>, sourceOpen); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The Media Source Extensions API is not supported.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sourceOpen</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// URL.revokeObjectURL 主动释放引用</span></span><br><span class="line">  <span class="variable constant_">URL</span>.<span class="title function_">revokeObjectURL</span>(video.<span class="property">src</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> mediaSource = e.<span class="property">target</span>;</span><br><span class="line">  <span class="comment">// addSourceBuffer根据传入的mineCodes，创建一个新的 SourceBuffer 并添加到 MediaSource 的 SourceBuffers 列表</span></span><br><span class="line">  <span class="keyword">var</span> sourceBuffer = mediaSource.<span class="title function_">addSourceBuffer</span>(mineCodes);</span><br><span class="line">  <span class="keyword">var</span> videoUrl = <span class="string">&#x27;video.mp4&#x27;</span>;</span><br><span class="line">  <span class="title function_">fetch</span>(videoUrl)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">arrayBuffer</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">arrayBuffer</span>) &#123;</span><br><span class="line">      sourceBuffer.<span class="title function_">addEventListener</span>(<span class="string">&#x27;updateend&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sourceBuffer.<span class="property">updating</span> &amp;&amp; mediaSource.<span class="property">readyState</span> === <span class="string">&#x27;open&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">// 数据添加完毕后，调用endOfStream结束当前流</span></span><br><span class="line">          mediaSource.<span class="title function_">endOfStream</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 将媒体数据添加到sourceBuffer中</span></span><br><span class="line">      sourceBuffer.<span class="title function_">appendBuffer</span>(arrayBuffer); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="createObjectURL"><a href="#createObjectURL" class="headerlink" title="createObjectURL"></a>createObjectURL</h2><p>先看 createObjectURL 做了什么。</p>
<p>在 createObjectURL 中创建了 MediaSourceAttachment 对象，根据是否是在 Worker 线程中会创建 CrossThreadMediaSourceAttachment 或者 SameThreadMediaSourceAttachment</p>
<p>MediaSourceAttachment 中持有 MediaSource 的指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function">String <span class="title">URLMediaSource::createObjectURL</span><span class="params">(ScriptState* script_state,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       MediaSource* source)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Since WebWorkers previously could not obtain MediaSource objects, we should</span></span><br><span class="line">  <span class="comment">// be on the main thread unless MediaSourceInWorkers is enabled and we&#x27;re in a</span></span><br><span class="line">  <span class="comment">// dedicated worker execution context.</span></span><br><span class="line">  ExecutionContext* execution_context = ExecutionContext::<span class="built_in">From</span>(script_state);</span><br><span class="line">  <span class="built_in">DCHECK</span>(execution_context);</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>() || RuntimeEnabledFeatures::<span class="built_in">MediaSourceInWorkersEnabled</span>(</span><br><span class="line">                               execution_context));</span><br><span class="line">  <span class="built_in">DCHECK</span>(source);</span><br><span class="line"></span><br><span class="line">  MediaSourceAttachment* attachment;</span><br><span class="line">  <span class="keyword">if</span> (execution_context-&gt;<span class="built_in">IsDedicatedWorkerGlobalScope</span>()) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!<span class="built_in">IsMainThread</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PassKey usage here ensures that only we can call the constructor.</span></span><br><span class="line">    attachment = <span class="keyword">new</span> <span class="built_in">CrossThreadMediaSourceAttachment</span>(source, <span class="built_in">PassKey</span>());</span><br><span class="line">    UseCounter::<span class="built_in">Count</span>(execution_context,</span><br><span class="line">                      WebFeature::kCreateObjectURLMediaSourceFromWorker);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Other contexts outside of main window thread or conditionally a dedicated</span></span><br><span class="line">    <span class="comment">// worker thread are not supported (like Shared Worker and Service Worker).</span></span><br><span class="line">    <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>() &amp;&amp; execution_context-&gt;<span class="built_in">IsWindow</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PassKey usage here ensures that only we can call the constructor.</span></span><br><span class="line">    attachment = <span class="keyword">new</span> <span class="built_in">SameThreadMediaSourceAttachment</span>(source, <span class="built_in">PassKey</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UseCounter::<span class="built_in">Count</span>(execution_context, WebFeature::kCreateObjectURLMediaSource);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The creation of a ThreadSafeRefCounted attachment object, above, should</span></span><br><span class="line">  <span class="comment">// have a refcount of 1 immediately. It will be adopted into a scoped_refptr</span></span><br><span class="line">  <span class="comment">// in MediaSourceRegistryImpl::RegisterURL. See also MediaSourceAttachment</span></span><br><span class="line">  <span class="comment">// (and usage in HTMLMediaElement, MediaSourceRegistry&#123;Impl&#125;, and MediaSource)</span></span><br><span class="line">  <span class="comment">// for further detail.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(attachment-&gt;<span class="built_in">HasOneRef</span>());</span><br><span class="line"></span><br><span class="line">  String url = DOMURL::<span class="built_in">CreatePublicURL</span>(execution_context, attachment);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 Attachment 之后，通过 DOMURL::CreatePublicURL 来创建该 MediaSourceAttachment 对应的 String</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> String <span class="title">DOMURL::CreatePublicURL</span><span class="params">(ExecutionContext* execution_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                               URLRegistrable* registrable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> execution_context-&gt;<span class="built_in">GetPublicURLManager</span>().<span class="built_in">RegisterURL</span>(registrable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PublicURLManager&amp; <span class="title">ExecutionContext::GetPublicURLManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!public_url_manager_)</span><br><span class="line">    public_url_manager_ = <span class="built_in">MakeGarbageCollected</span>&lt;PublicURLManager&gt;(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> *public_url_manager_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">PublicURLManager::RegisterURL</span><span class="params">(URLRegistrable* registrable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is_stopped_)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>();</span><br><span class="line"></span><br><span class="line">  SecurityOrigin* origin = <span class="built_in">GetExecutionContext</span>()-&gt;<span class="built_in">GetMutableSecurityOrigin</span>();</span><br><span class="line">  <span class="type">const</span> KURL&amp; url = BlobURL::<span class="built_in">CreatePublicURL</span>(origin);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!url.<span class="built_in">IsEmpty</span>());</span><br><span class="line">  <span class="type">const</span> String&amp; url_string = url.<span class="built_in">GetString</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Collect metrics on how frequently a worker context that makes use of the</span></span><br><span class="line">  <span class="comment">// Blob URL API was created from a data URL. Note that we ignore service</span></span><br><span class="line">  <span class="comment">// workers for this since they can&#x27;t be created from data URLs.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetExecutionContext</span>()-&gt;<span class="built_in">IsWorkerGlobalScope</span>()) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (registrable-&gt;<span class="built_in">IsMojoBlob</span>()) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    URLRegistry* registry = &amp;registrable-&gt;<span class="built_in">Registry</span>();</span><br><span class="line">    registry-&gt;<span class="built_in">RegisterURL</span>(origin, url, registrable);</span><br><span class="line">    url_to_registry_.<span class="built_in">insert</span>(url_string, registry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> url_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MediaSourceAttachment 类有一个静态的 <code>URLRegistry*</code> 成员，上面 <code>registrable-&gt;Registry()</code> 返回的就是该成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">URLRegistry* MediaSourceAttachment::registry_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">URLRegistry&amp; <span class="title">MediaSourceAttachment::Registry</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *registry_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过 <code>registry-&gt;RegisterURL</code> 将 url 和 MediaSourceAttachment 注册到 <code>registry</code> 中，会把他们插入到 <code>media_sources_</code> 中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaSourceRegistryImpl::RegisterURL</span><span class="params">(SecurityOrigin*,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> KURL&amp; url,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          URLRegistrable* registrable)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLocker <span class="title">lock</span><span class="params">(map_mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(&amp;registrable-&gt;<span class="built_in">Registry</span>(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  scoped_refptr&lt;MediaSourceAttachment&gt; attachment =</span><br><span class="line">      base::<span class="built_in">AdoptRef</span>(<span class="built_in">static_cast</span>&lt;MediaSourceAttachment*&gt;(registrable));</span><br><span class="line"></span><br><span class="line">  media_sources_.<span class="built_in">Set</span>(url.<span class="built_in">GetString</span>(), std::<span class="built_in">move</span>(attachment));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WebMediaPlayer-查找-MediaSourceAttachment"><a href="#WebMediaPlayer-查找-MediaSourceAttachment" class="headerlink" title="WebMediaPlayer 查找 MediaSourceAttachment"></a>WebMediaPlayer 查找 MediaSourceAttachment</h2><p>接下来再看 WebMediaPlayer 查找 MediaSourceAttachment。</p>
<p>该过程在 HTMLMediaElement::LoadResource 函数中。</p>
<p>下面的 source 参数包装了 url 的 String，在 LoadResource 函数内会从 source 恢复 url 的 String</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HTMLMediaElement::LoadResource</span><span class="params">(<span class="type">const</span> WebMediaPlayerSource&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> String&amp; content_type)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>());</span><br><span class="line">  KURL url;</span><br><span class="line">  <span class="keyword">if</span> (source.<span class="built_in">IsURL</span>()) &#123;</span><br><span class="line">    url = source.<span class="built_in">GetAsURL</span>();</span><br><span class="line">    <span class="built_in">DCHECK</span>(<span class="built_in">IsSafeToLoadURL</span>(url, kComplain));</span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;loadResource(&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">UrlForLoggingMedia</span>(url)</span><br><span class="line">             &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; content_type &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LocalFrame* frame = <span class="built_in">GetDocument</span>().<span class="built_in">GetFrame</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The resource fetch algorithm</span></span><br><span class="line">  <span class="built_in">SetNetworkState</span>(kNetworkLoading);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set current_src_ *before* changing to the cache url, the fact that we are</span></span><br><span class="line">  <span class="comment">// loading from the app cache is an internal detail not exposed through the</span></span><br><span class="line">  <span class="comment">// media element API.</span></span><br><span class="line">  current_src_ = url;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Default this to empty, so that we use |current_src_| unless the player</span></span><br><span class="line">  <span class="comment">// provides one later.</span></span><br><span class="line">  current_src_after_redirects_ = <span class="built_in">KURL</span>();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  media_source_attachment_ =</span><br><span class="line">      MediaSourceAttachment::<span class="built_in">LookupMediaSource</span>(url.<span class="built_in">GetString</span>());</span><br><span class="line">  <span class="keyword">if</span> (media_source_attachment_) &#123;</span><br><span class="line">    <span class="type">bool</span> start_result = <span class="literal">false</span>;</span><br><span class="line">    media_source_tracer_ =</span><br><span class="line">        media_source_attachment_-&gt;<span class="built_in">StartAttachingToMediaElement</span>(<span class="keyword">this</span>,</span><br><span class="line">                                                               &amp;start_result);</span><br><span class="line">    <span class="keyword">if</span> (start_result) &#123;</span><br><span class="line">      <span class="comment">// If the associated feature is enabled, auto-revoke the MediaSource</span></span><br><span class="line">      <span class="comment">// object URL that was used for attachment on successful (start of)</span></span><br><span class="line">      <span class="comment">// attachment. This can help reduce memory bloat later if the app does not</span></span><br><span class="line">      <span class="comment">// revoke the object URL explicitly and the object URL was the only</span></span><br><span class="line">      <span class="comment">// remaining strong reference to an attached HTMLMediaElement+MediaSource</span></span><br><span class="line">      <span class="comment">// cycle of objects that could otherwise be garbage-collectable.</span></span><br><span class="line">      <span class="keyword">if</span> (base::FeatureList::<span class="built_in">IsEnabled</span>(</span><br><span class="line">              media::kRevokeMediaSourceObjectURLOnAttach)) &#123;</span><br><span class="line">        URLFileAPI::<span class="built_in">revokeObjectURL</span>(<span class="built_in">GetExecutionContext</span>(), url.<span class="built_in">GetString</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Forget our reference to the MediaSourceAttachment, so we leave it alone</span></span><br><span class="line">      <span class="comment">// while processing remainder of load failure.</span></span><br><span class="line">      media_source_attachment_.<span class="built_in">reset</span>();</span><br><span class="line">      media_source_tracer_ = <span class="literal">nullptr</span>;</span><br><span class="line">      attempt_load = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> can_load_resource =</span><br><span class="line">      source.<span class="built_in">IsMediaStream</span>() || <span class="built_in">CanLoadURL</span>(url, content_type);</span><br><span class="line">  <span class="keyword">if</span> (attempt_load &amp;&amp; can_load_resource) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!<span class="built_in">GetWebMediaPlayer</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Conditionally defer the load if effective preload is &#x27;none&#x27;.</span></span><br><span class="line">    <span class="comment">// Skip this optional deferral for MediaStream sources or any blob URL,</span></span><br><span class="line">    <span class="comment">// including MediaSource blob URLs.</span></span><br><span class="line">    <span class="keyword">if</span> (!source.<span class="built_in">IsMediaStream</span>() &amp;&amp; !url.<span class="built_in">ProtocolIs</span>(<span class="string">&quot;blob&quot;</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">EffectivePreloadType</span>() == WebMediaPlayer::kPreloadNone) &#123;</span><br><span class="line">      <span class="built_in">DVLOG</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;loadResource(&quot;</span> &lt;&lt; *<span class="keyword">this</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;) : Delaying load because preload == &#x27;none&#x27;&quot;</span>;</span><br><span class="line">      <span class="built_in">DeferLoad</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">StartPlayerLoad</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LookupMediaSource"><a href="#LookupMediaSource" class="headerlink" title="LookupMediaSource"></a>LookupMediaSource</h3><p>上面先通过 LookupMediaSource 查找 url 对应的 MediaSourceAttachment。</p>
<p><code>registry_</code> 上面已经说过，是 MediaSourceAttachment 中的静态成员，而之前已经通过 <code>registry_-&gt;RegisterURL</code> 将 MediaSourceAttachment 注册到 <code>registry_</code> 中，这里则是通过 <code>registry_-&gt;LookupMediaSource</code> 查找 MediaSourceAttachment</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function">scoped_refptr&lt;MediaSourceAttachment&gt; <span class="title">MediaSourceAttachment::LookupMediaSource</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> String&amp; url)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The only expected caller is an HTMLMediaElement on the main thread.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>());</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This cast is safe because the only setter of |registry_| is SetRegistry().</span></span><br><span class="line">  MediaSourceRegistry* ms_registry =</span><br><span class="line">      <span class="built_in">static_cast</span>&lt;MediaSourceRegistry*&gt;(registry_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ms_registry-&gt;<span class="built_in">LookupMediaSource</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">scoped_refptr&lt;MediaSourceAttachment&gt; <span class="title">MediaSourceRegistryImpl::LookupMediaSource</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> String&amp; url)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLocker <span class="title">lock</span><span class="params">(map_mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(!url.<span class="built_in">IsEmpty</span>());</span><br><span class="line">  <span class="keyword">auto</span> iter = media_sources_.<span class="built_in">find</span>(url);</span><br><span class="line">  <span class="keyword">if</span> (iter == media_sources_.<span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> iter-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StartAttachingToMediaElement"><a href="#StartAttachingToMediaElement" class="headerlink" title="StartAttachingToMediaElement"></a>StartAttachingToMediaElement</h3><p>找到 MediaSourceAttachment 之后就调用 StartAttachingToMediaElement</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MediaSourceTracer*</span></span><br><span class="line"><span class="function"><span class="title">SameThreadMediaSourceAttachment::StartAttachingToMediaElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HTMLMediaElement* element,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span>* success)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">VerifyCalledWhileContextsAliveForDebugging</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(success);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  MediaSourceTracer* tracer =</span><br><span class="line">      registered_media_source_-&gt;<span class="built_in">StartAttachingToMediaElement</span>(</span><br><span class="line">          <span class="built_in">WrapRefCounted</span>(<span class="keyword">this</span>), element);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For this same-thread attachment start, a non-nullptr tracer indicates</span></span><br><span class="line">  <span class="comment">// success here.</span></span><br><span class="line">  *success = !!tracer;</span><br><span class="line">  <span class="keyword">return</span> tracer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>registered_media_source_</code> 就是 MediaSource，下面函数<strong>将 MediaSourceAttachment 保存在 MediaSource 中</strong>，然后将 MediaSource 保存在 MediaSourceTracer 中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MediaSourceTracer* <span class="title">MediaSource::StartAttachingToMediaElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;SameThreadMediaSourceAttachment&gt; attachment,</span></span></span><br><span class="line"><span class="params"><span class="function">    HTMLMediaElement* element)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLocker <span class="title">lock</span><span class="params">(attachment_link_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(!context_already_destroyed_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsClosed</span>());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  media_source_attachment_ = attachment;</span><br><span class="line">  attachment_tracer_ =</span><br><span class="line">      <span class="built_in">MakeGarbageCollected</span>&lt;SameThreadMediaSourceTracer&gt;(element, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> attachment_tracer_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CompleteAttachingToMediaElement"><a href="#CompleteAttachingToMediaElement" class="headerlink" title="CompleteAttachingToMediaElement"></a>CompleteAttachingToMediaElement</h3><p>上面函数只是 attach 的第一部分，剩余的工作是在 CompleteAttachingToMediaElement 中，CompleteAttachingToMediaElement 被 MediaSourceOpened 函数调用，MediaSourceOpened 就对应了上面的 sourceopen 事件，后面会看到 MediaSourceOpened 会被 ChunkDemuxer 的回调函数调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HTMLMediaElement::MediaSourceOpened</span><span class="params">(WebMediaSource* web_media_source)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetShouldDelayLoadEvent</span>(<span class="literal">false</span>);</span><br><span class="line">  media_source_attachment_-&gt;<span class="built_in">CompleteAttachingToMediaElement</span>(</span><br><span class="line">      media_source_tracer_, base::<span class="built_in">WrapUnique</span>(web_media_source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SameThreadMediaSourceAttachment::CompleteAttachingToMediaElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MediaSourceTracer* tracer,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;WebMediaSource&gt; web_media_source)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">VerifyCalledWhileContextsAliveForDebugging</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetMediaSource</span>(tracer)-&gt;<span class="built_in">CompleteAttachingToMediaElement</span>(</span><br><span class="line">      std::<span class="built_in">move</span>(web_media_source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后会调用 MediaSource 的 CompleteAttachingToMediaElement</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaSource::CompleteAttachingToMediaElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;WebMediaSource&gt; web_media_source)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">AssertAttachmentsMutexHeldIfCrossThreadForDebugging</span>();</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLocker <span class="title">lock</span><span class="params">(attachment_link_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DCHECK_EQ</span>(!attachment_tracer_, !<span class="built_in">IsMainThread</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attachment_tracer_) &#123;</span><br><span class="line">      <span class="comment">// Use of a tracer means we must be using same-thread attachment.</span></span><br><span class="line">      <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_END0</span>(</span><br><span class="line">          <span class="string">&quot;media&quot;</span>, <span class="string">&quot;MediaSource::StartAttachingToMediaElement&quot;</span>,</span><br><span class="line">          <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Otherwise, we must be using a cross-thread MSE-in-Workers attachment.</span></span><br><span class="line">      <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_END0</span>(</span><br><span class="line">          <span class="string">&quot;media&quot;</span>, <span class="string">&quot;MediaSource::StartWorkerAttachingToMainThreadMediaElement&quot;</span>,</span><br><span class="line">          <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DCHECK</span>(web_media_source);</span><br><span class="line">    <span class="built_in">DCHECK</span>(!web_media_source_);</span><br><span class="line">    <span class="built_in">DCHECK</span>(media_source_attachment_);</span><br><span class="line"></span><br><span class="line">    web_media_source_ = std::<span class="built_in">move</span>(web_media_source);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetReadyState</span>(ReadyState::kOpen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 web_media_source 有 ChunkDemuxer 的指针，所以这里将 ChunkDemuxer 设置给了 MediaSource，后面往 MediaSource 中送数据就是送到 ChunkDemuxer 中</p>
<h2 id="WebMediaPlayer-以及-ChunkDemuxer-的创建"><a href="#WebMediaPlayer-以及-ChunkDemuxer-的创建" class="headerlink" title="WebMediaPlayer 以及 ChunkDemuxer 的创建"></a>WebMediaPlayer 以及 ChunkDemuxer 的创建</h2><p>接下来先不看 addSourceBuffer 相关内容，先看 WebMediaPlayer 以及 ChunkDemuxer 的创建，因为 addSourceBuffer 要在 ChunkDemuxer 初始化之后才执行，我们遵循这个调用流程。</p>
<h3 id="HTMLMediaElement-StartPlayerLoad"><a href="#HTMLMediaElement-StartPlayerLoad" class="headerlink" title="HTMLMediaElement::StartPlayerLoad"></a>HTMLMediaElement::StartPlayerLoad</h3><p>在 HTMLMediaElement::LoadResource 函数中，执行 StartAttachingToMediaElement 后，会执行 StartPlayerLoad 函数，在 StartPlayerLoad 中创建 WebMediaPlayer 以及启动 WebMediaPlayer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HTMLMediaElement::StartPlayerLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  WebMediaPlayerSource source;</span><br><span class="line">...</span><br><span class="line">  LocalFrame* frame = <span class="built_in">LocalFrameForPlayer</span>();</span><br><span class="line">  web_media_player_ =</span><br><span class="line">      frame-&gt;<span class="built_in">Client</span>()-&gt;<span class="built_in">CreateWebMediaPlayer</span>(*<span class="keyword">this</span>, source, <span class="keyword">this</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LocalFrame* <span class="title">HTMLMediaElement::LocalFrameForPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> opener_document_ ? opener_document_-&gt;<span class="built_in">GetFrame</span>()</span><br><span class="line">                          : <span class="built_in">GetDocument</span>().<span class="built_in">GetFrame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LocalFrameForPlayer 返回一个 LocalFrame 指针，而 LocalFrame 继承 Frame</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LocalFrameClient* <span class="title">LocalFrame::Client</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;LocalFrameClient*&gt;(Frame::<span class="built_in">Client</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 StartPlayerLoad 中 <code>frame-&gt;Client()</code> 返回 LocalFrameClient 指针，该指针实际指向 LocalFrameClientImpl</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// third_party/blink/renderer/core/frame/local_frame_client_impl.cc</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;WebMediaPlayer&gt; <span class="title">LocalFrameClientImpl::CreateWebMediaPlayer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HTMLMediaElement&amp; html_media_element,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebMediaPlayerSource&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebMediaPlayerClient* client)</span> </span>&#123;</span><br><span class="line">  LocalFrame* local_frame = html_media_element.<span class="built_in">LocalFrameForPlayer</span>();</span><br><span class="line">  WebLocalFrameImpl* web_frame = WebLocalFrameImpl::<span class="built_in">FromFrame</span>(local_frame);</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> CoreInitializer::<span class="built_in">GetInstance</span>().<span class="built_in">CreateWebMediaPlayer</span>(</span><br><span class="line">      web_frame-&gt;<span class="built_in">Client</span>(), html_media_element, source, client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ModulesInitializer 是 CoreInitializer 的子类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;WebMediaPlayer&gt; <span class="title">ModulesInitializer::CreateWebMediaPlayer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WebLocalFrameClient* web_frame_client,</span></span></span><br><span class="line"><span class="params"><span class="function">    HTMLMediaElement&amp; html_media_element,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebMediaPlayerSource&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebMediaPlayerClient* media_player_client)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  HTMLMediaElementEncryptedMedia&amp; encrypted_media =</span><br><span class="line">      HTMLMediaElementEncryptedMedia::<span class="built_in">From</span>(html_media_element);</span><br><span class="line">  <span class="function">WebString <span class="title">sink_id</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      HTMLMediaElementAudioOutputDevice::sinkId(html_media_element))</span></span>;</span><br><span class="line">  MediaInspectorContextImpl* context_impl = MediaInspectorContextImpl::<span class="built_in">From</span>(</span><br><span class="line">      *<span class="built_in">To</span>&lt;LocalDOMWindow&gt;(html_media_element.<span class="built_in">GetExecutionContext</span>()));</span><br><span class="line">  FrameWidget* frame_widget =</span><br><span class="line">      html_media_element.<span class="built_in">GetDocument</span>().<span class="built_in">GetFrame</span>()-&gt;<span class="built_in">GetWidgetForLocalRoot</span>();</span><br><span class="line">  <span class="keyword">return</span> base::<span class="built_in">WrapUnique</span>(web_frame_client-&gt;<span class="built_in">CreateMediaPlayer</span>(</span><br><span class="line">      source, media_player_client, context_impl, &amp;encrypted_media,</span><br><span class="line">      encrypted_media.<span class="built_in">ContentDecryptionModule</span>(), sink_id,</span><br><span class="line">      frame_widget-&gt;<span class="built_in">GetLayerTreeSettings</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>web_frame_client 实际指向的是 RenderFrameImpl，但是这些 frame 具体是怎么来的笔者也不太清楚，笔者是通过 backtrace 知道会调用到 RenderFrameImpl</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CONTENT_EXPORT</span> RenderFrameImpl</span><br><span class="line">    : <span class="keyword">public</span> RenderFrame,</span><br><span class="line">      <span class="keyword">public</span> blink::mojom::ResourceLoadInfoNotifier,</span><br><span class="line">      blink::mojom::AutoplayConfigurationClient,</span><br><span class="line">      <span class="keyword">public</span> mojom::Frame,</span><br><span class="line">      mojom::FrameBindingsControl,</span><br><span class="line">      mojom::MhtmlFileWriter,</span><br><span class="line">      <span class="keyword">public</span> blink::WebLocalFrameClient,</span><br><span class="line">      service_manager::mojom::InterfaceProvider &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以上面最终调用的是 RenderFrameImpl::CreateMediaPlayer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">blink::WebMediaPlayer* <span class="title">RenderFrameImpl::CreateMediaPlayer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> blink::WebMediaPlayerSource&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebMediaPlayerClient* client,</span></span></span><br><span class="line"><span class="params"><span class="function">    blink::MediaInspectorContext* inspector_context,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebMediaPlayerEncryptedMediaClient* encrypted_client,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebContentDecryptionModule* initial_cdm,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> blink::WebString&amp; sink_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> cc::LayerTreeSettings&amp; settings)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> media_factory_.<span class="built_in">CreateMediaPlayer</span>(</span><br><span class="line">      source, client, inspector_context, encrypted_client, initial_cdm, sink_id,</span><br><span class="line">      <span class="built_in">GetLocalRootWebFrameWidget</span>()-&gt;<span class="built_in">GetFrameSinkId</span>(), settings,</span><br><span class="line">      agent_scheduling_group_.<span class="built_in">agent_group_scheduler</span>().<span class="built_in">CompositorTaskRunner</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到上面出现了 encrypted_client 和 initial_cdm，这些和 EME 有关，放到后面来分析。</p>
<h4 id="MediaFactory-CreateMediaPlayer"><a href="#MediaFactory-CreateMediaPlayer" class="headerlink" title="MediaFactory::CreateMediaPlayer"></a>MediaFactory::CreateMediaPlayer</h4><p>在 RenderFrameImpl::CreateMediaPlayer 内部通过 MediaFactory::CreateMediaPlayer 来创建 WebMediaPlayer，MediaFactory::CreateMediaPlayer 函数则创建了 RendererFactorySelector，后面会通过该 Selector 来决定使用哪个 RendererFactory，再使用 RendererFactory 创建 Renderer，创建 Renderer 时也会创建 Decoder，创建 Decoder 也是通过 MediaFactory 实现的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">blink::WebMediaPlayer* <span class="title">MediaFactory::CreateMediaPlayer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> blink::WebMediaPlayerSource&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    blink::WebMediaPlayerClient* client,</span></span></span><br><span class="line"><span class="params"><span class="function">    blink::MediaInspectorContext* inspector_context,</span></span></span><br><span class="line"><span class="params"><span class="function">    blink::WebMediaPlayerEncryptedMediaClient* encrypted_client,</span></span></span><br><span class="line"><span class="params"><span class="function">    blink::WebContentDecryptionModule* initial_cdm,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> blink::WebString&amp; sink_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    viz::FrameSinkId parent_frame_sink_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> cc::LayerTreeSettings&amp; settings,</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">        main_thread_compositor_task_runner)</span> </span>&#123;</span><br><span class="line">  blink::WebLocalFrame* web_frame = render_frame_-&gt;<span class="built_in">GetWebFrame</span>();</span><br><span class="line">  <span class="keyword">auto</span>* delegate = <span class="built_in">GetWebMediaPlayerDelegate</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (source.<span class="built_in">IsMediaStream</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CreateWebMediaPlayerForMediaStream</span>(</span><br><span class="line">        client, inspector_context, sink_id, web_frame, parent_frame_sink_id,</span><br><span class="line">        settings, main_thread_compositor_task_runner);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If |source| was not a MediaStream, it must be a URL.</span></span><br><span class="line">  <span class="comment">// TODO(guidou): Fix this when support for other srcObject types is added.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(source.<span class="built_in">IsURL</span>());</span><br><span class="line">  blink::WebURL url = source.<span class="built_in">GetAsURL</span>();</span><br><span class="line"></span><br><span class="line">  RenderThreadImpl* render_thread = RenderThreadImpl::<span class="built_in">current</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建audio renderer</span></span><br><span class="line">  scoped_refptr&lt;media::SwitchableAudioRendererSink&gt; audio_renderer_sink =</span><br><span class="line">      blink::AudioDeviceFactory::<span class="built_in">NewSwitchableAudioRendererSink</span>(</span><br><span class="line">          blink::WebAudioDeviceSourceType::kMediaElement,</span><br><span class="line">          render_frame_-&gt;<span class="built_in">GetWebFrame</span>()-&gt;<span class="built_in">GetLocalFrameToken</span>(),</span><br><span class="line">          media::<span class="built_in">AudioSinkParameters</span>(<span class="comment">/*session_id=*/</span>base::<span class="built_in">UnguessableToken</span>(),</span><br><span class="line">                                     sink_id.<span class="built_in">Utf8</span>()));</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// This must be created for every new WebMediaPlayer, each instance generates</span></span><br><span class="line">  <span class="comment">// a new player id which is used to collate logs on the browser side.</span></span><br><span class="line">  <span class="keyword">auto</span> media_log = std::<span class="built_in">make_unique</span>&lt;BatchingMediaLog&gt;(</span><br><span class="line">      render_frame_-&gt;<span class="built_in">GetTaskRunner</span>(blink::TaskType::kInternalMedia),</span><br><span class="line">      std::<span class="built_in">move</span>(handlers));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Renderer Factory Selector</span></span><br><span class="line"><span class="comment">// Renderer Factory里面有Decoder Factory</span></span><br><span class="line">  base::WeakPtr&lt;media::MediaObserver&gt; media_observer;</span><br><span class="line">  <span class="keyword">auto</span> factory_selector = <span class="built_in">CreateRendererFactorySelector</span>(</span><br><span class="line">      media_log.<span class="built_in">get</span>(), url, render_frame_-&gt;<span class="built_in">GetRenderFrameMediaPlaybackOptions</span>(),</span><br><span class="line">      <span class="built_in">GetDecoderFactory</span>().<span class="built_in">get</span>(),</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;blink::RemotePlaybackClientWrapperImpl&gt;(client),</span><br><span class="line">      &amp;media_observer);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  mojo::PendingRemote&lt;media::mojom::MediaMetricsProvider&gt; metrics_provider;</span><br><span class="line">  interface_broker_-&gt;<span class="built_in">GetInterface</span>(</span><br><span class="line">      metrics_provider.<span class="built_in">InitWithNewPipeAndPassReceiver</span>());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  scoped_refptr&lt;base::SingleThreadTaskRunner&gt; media_task_runner =</span><br><span class="line">      render_thread-&gt;<span class="built_in">GetMediaThreadTaskRunner</span>();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> video_frame_compositor_task_runner =</span><br><span class="line">      <span class="built_in">GetOrCreateVideoFrameCompositorTaskRunner</span>(render_frame_);</span><br><span class="line">  <span class="keyword">auto</span> vfc = std::<span class="built_in">make_unique</span>&lt;blink::VideoFrameCompositor&gt;(</span><br><span class="line">      video_frame_compositor_task_runner, std::<span class="built_in">move</span>(submitter));</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;media::Demuxer&gt; demuxer_override =</span><br><span class="line">      <span class="built_in">GetContentClient</span>()-&gt;<span class="built_in">renderer</span>()-&gt;<span class="built_in">OverrideDemuxerForUrl</span>(render_frame_, url,</span><br><span class="line">                                                            media_task_runner);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> blink::WebMediaPlayerBuilder::<span class="built_in">Build</span>(</span><br><span class="line">      web_frame, client, encrypted_client, delegate,</span><br><span class="line">      std::<span class="built_in">move</span>(factory_selector), url_index_.<span class="built_in">get</span>(), std::<span class="built_in">move</span>(vfc),</span><br><span class="line">      std::<span class="built_in">move</span>(media_log),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;RenderFrameImpl::DeferMediaLoad,</span><br><span class="line">                          base::<span class="built_in">Unretained</span>(render_frame_),</span><br><span class="line">                          delegate-&gt;<span class="built_in">has_played_media</span>()),</span><br><span class="line">      std::<span class="built_in">move</span>(audio_renderer_sink), std::<span class="built_in">move</span>(media_task_runner),</span><br><span class="line">      render_thread-&gt;<span class="built_in">GetWorkerTaskRunner</span>(),</span><br><span class="line">      render_thread-&gt;<span class="built_in">compositor_task_runner</span>(),</span><br><span class="line">      std::<span class="built_in">move</span>(video_frame_compositor_task_runner),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;v8::Isolate::AdjustAmountOfExternalAllocatedMemory,</span><br><span class="line">                          base::<span class="built_in">Unretained</span>(blink::<span class="built_in">MainThreadIsolate</span>())),</span><br><span class="line">      initial_cdm, request_routing_token_cb_, media_observer,</span><br><span class="line">      enable_instant_source_buffer_gc, embedded_media_experience_enabled,</span><br><span class="line">      std::<span class="built_in">move</span>(metrics_provider),</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;blink::WebSurfaceLayerBridge::Create,</span><br><span class="line">                     parent_frame_sink_id,</span><br><span class="line">                     blink::WebSurfaceLayerBridge::ContainsVideo::kYes),</span><br><span class="line">      RenderThreadImpl::<span class="built_in">current</span>()-&gt;<span class="built_in">SharedMainThreadContextProvider</span>(),</span><br><span class="line">      use_surface_layer,</span><br><span class="line">      render_frame_-&gt;<span class="built_in">GetRenderFrameMediaPlaybackOptions</span>()</span><br><span class="line">          .is_background_suspend_enabled,</span><br><span class="line">      render_frame_-&gt;<span class="built_in">GetRenderFrameMediaPlaybackOptions</span>()</span><br><span class="line">          .is_background_video_playback_enabled,</span><br><span class="line">      render_frame_-&gt;<span class="built_in">GetRenderFrameMediaPlaybackOptions</span>()</span><br><span class="line">          .is_background_video_track_optimization_supported,</span><br><span class="line">      std::<span class="built_in">move</span>(demuxer_override),</span><br><span class="line">      blink::Platform::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetBrowserInterfaceBroker</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WebMediaPlayerImpl-的构造函数"><a href="#WebMediaPlayerImpl-的构造函数" class="headerlink" title="WebMediaPlayerImpl 的构造函数"></a>WebMediaPlayerImpl 的构造函数</h5><p>接下来再看 WebMediaPlayerImpl 的构造函数，这个构造函数参数很多，但是大部分都是把参数赋给相应的成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">WebMediaPlayerImpl::<span class="built_in">WebMediaPlayerImpl</span>(</span><br><span class="line">    WebLocalFrame* frame,</span><br><span class="line">    WebMediaPlayerClient* client,</span><br><span class="line">    WebMediaPlayerEncryptedMediaClient* encrypted_client,</span><br><span class="line">    WebMediaPlayerDelegate* delegate,</span><br><span class="line">    std::unique_ptr&lt;media::RendererFactorySelector&gt; renderer_factory_selector,</span><br><span class="line">    UrlIndex* url_index,</span><br><span class="line">    std::unique_ptr&lt;VideoFrameCompositor&gt; compositor,</span><br><span class="line">    std::unique_ptr&lt;media::MediaLog&gt; media_log,</span><br><span class="line">    WebMediaPlayerBuilder::DeferLoadCB defer_load_cb,</span><br><span class="line">    scoped_refptr&lt;media::SwitchableAudioRendererSink&gt; audio_renderer_sink,</span><br><span class="line">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt; media_task_runner,</span><br><span class="line">    scoped_refptr&lt;base::TaskRunner&gt; worker_task_runner,</span><br><span class="line">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt; compositor_task_runner,</span><br><span class="line">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt;</span><br><span class="line">        video_frame_compositor_task_runner,</span><br><span class="line">    WebMediaPlayerBuilder::AdjustAllocatedMemoryCB adjust_allocated_memory_cb,</span><br><span class="line">    WebContentDecryptionModule* initial_cdm,</span><br><span class="line">    media::RequestRoutingTokenCallback request_routing_token_cb,</span><br><span class="line">    base::WeakPtr&lt;media::MediaObserver&gt; media_observer,</span><br><span class="line">    <span class="type">bool</span> enable_instant_source_buffer_gc,</span><br><span class="line">    <span class="type">bool</span> embedded_media_experience_enabled,</span><br><span class="line">    mojo::PendingRemote&lt;media::mojom::MediaMetricsProvider&gt; metrics_provider,</span><br><span class="line">    CreateSurfaceLayerBridgeCB create_bridge_callback,</span><br><span class="line">    scoped_refptr&lt;viz::RasterContextProvider&gt; raster_context_provider,</span><br><span class="line">    <span class="type">bool</span> use_surface_layer,</span><br><span class="line">    <span class="type">bool</span> is_background_suspend_enabled,</span><br><span class="line">    <span class="type">bool</span> is_background_video_playback_enabled,</span><br><span class="line">    <span class="type">bool</span> is_background_video_track_optimization_supported,</span><br><span class="line">    std::unique_ptr&lt;media::Demuxer&gt; demuxer_override,</span><br><span class="line">    scoped_refptr&lt;ThreadSafeBrowserInterfaceBrokerProxy&gt; remote_interfaces)</span><br><span class="line">    : <span class="built_in">frame_</span>(frame),</span><br><span class="line">      <span class="built_in">main_task_runner_</span>(frame-&gt;<span class="built_in">GetTaskRunner</span>(TaskType::kMediaElementEvent)),</span><br><span class="line">      <span class="built_in">media_task_runner_</span>(std::<span class="built_in">move</span>(media_task_runner)),</span><br><span class="line">      <span class="built_in">worker_task_runner_</span>(std::<span class="built_in">move</span>(worker_task_runner)),</span><br><span class="line">      <span class="built_in">media_log_</span>(std::<span class="built_in">move</span>(media_log)),</span><br><span class="line">      <span class="built_in">client_</span>(client),</span><br><span class="line">      <span class="built_in">encrypted_client_</span>(encrypted_client),</span><br><span class="line">      <span class="built_in">delegate_</span>(delegate),</span><br><span class="line">      <span class="built_in">delegate_has_audio_</span>(<span class="built_in">HasUnmutedAudio</span>()),</span><br><span class="line">      <span class="built_in">defer_load_cb_</span>(std::<span class="built_in">move</span>(defer_load_cb)),</span><br><span class="line">      <span class="built_in">adjust_allocated_memory_cb_</span>(std::<span class="built_in">move</span>(adjust_allocated_memory_cb)),</span><br><span class="line">      <span class="built_in">tick_clock_</span>(base::DefaultTickClock::<span class="built_in">GetInstance</span>()),</span><br><span class="line">      <span class="built_in">url_index_</span>(url_index),</span><br><span class="line">      <span class="built_in">raster_context_provider_</span>(std::<span class="built_in">move</span>(raster_context_provider)),</span><br><span class="line">      <span class="built_in">vfc_task_runner_</span>(std::<span class="built_in">move</span>(video_frame_compositor_task_runner)),</span><br><span class="line">      <span class="built_in">compositor_</span>(std::<span class="built_in">move</span>(compositor)),</span><br><span class="line">      <span class="built_in">renderer_factory_selector_</span>(std::<span class="built_in">move</span>(renderer_factory_selector)),</span><br><span class="line">      <span class="built_in">observer_</span>(std::<span class="built_in">move</span>(media_observer)),</span><br><span class="line">      <span class="built_in">enable_instant_source_buffer_gc_</span>(enable_instant_source_buffer_gc),</span><br><span class="line">      <span class="built_in">embedded_media_experience_enabled_</span>(embedded_media_experience_enabled),</span><br><span class="line">      <span class="built_in">use_surface_layer_</span>(use_surface_layer),</span><br><span class="line">      <span class="built_in">create_bridge_callback_</span>(std::<span class="built_in">move</span>(create_bridge_callback)),</span><br><span class="line">      <span class="built_in">request_routing_token_cb_</span>(std::<span class="built_in">move</span>(request_routing_token_cb)),</span><br><span class="line">      <span class="built_in">media_metrics_provider_</span>(std::<span class="built_in">move</span>(metrics_provider)),</span><br><span class="line">      <span class="built_in">is_background_suspend_enabled_</span>(is_background_suspend_enabled),</span><br><span class="line">      <span class="built_in">is_background_video_playback_enabled_</span>(</span><br><span class="line">          is_background_video_playback_enabled),</span><br><span class="line">      <span class="built_in">is_background_video_track_optimization_supported_</span>(</span><br><span class="line">          is_background_video_track_optimization_supported),</span><br><span class="line">      <span class="built_in">simple_watch_timer_</span>(</span><br><span class="line">          base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnSimpleWatchTimerTick,</span><br><span class="line">                              base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)),</span><br><span class="line">          base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::GetCurrentTimeInternal,</span><br><span class="line">                              base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>))),</span><br><span class="line">      <span class="built_in">will_play_helper_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">demuxer_override_</span>(std::<span class="built_in">move</span>(demuxer_override)) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  weak_this_ = weak_factory_.<span class="built_in">GetWeakPtr</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> pipeline = std::<span class="built_in">make_unique</span>&lt;media::PipelineImpl&gt;(</span><br><span class="line">      media_task_runner_, main_task_runner_,</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::CreateRenderer,</span><br><span class="line">                          base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)),</span><br><span class="line">      media_log_.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  pipeline_controller_ = std::<span class="built_in">make_unique</span>&lt;media::PipelineController&gt;(</span><br><span class="line">      std::<span class="built_in">move</span>(pipeline),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnPipelineSeeked, weak_this_),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnPipelineSuspended, weak_this_),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnBeforePipelineResume,</span><br><span class="line">                          weak_this_),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnPipelineResumed, weak_this_),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnError, weak_this_));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (initial_cdm)</span><br><span class="line">    <span class="built_in">SetCdmInternal</span>(initial_cdm);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> on_audio_source_provider_set_client_callback = base::<span class="built_in">BindOnce</span>(</span><br><span class="line">      [](base::WeakPtr&lt;WebMediaPlayerImpl&gt; self,</span><br><span class="line">         WebMediaPlayerClient* <span class="type">const</span> client) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!self)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        client-&gt;<span class="built_in">DidDisableAudioOutputSinkChanges</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">      weak_this_, client_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(xhwang): When we use an external Renderer, many methods won&#x27;t work,</span></span><br><span class="line">  <span class="comment">// e.g. GetCurrentFrameFromCompositor(). See http://crbug.com/434861</span></span><br><span class="line">  audio_source_provider_ = <span class="keyword">new</span> <span class="built_in">WebAudioSourceProviderImpl</span>(</span><br><span class="line">      std::<span class="built_in">move</span>(audio_renderer_sink), media_log_.<span class="built_in">get</span>(),</span><br><span class="line">      std::<span class="built_in">move</span>(on_audio_source_provider_set_client_callback));</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的具体细节可以暂时不管，他创建并初始化了 WebMediaPlayerImpl 内部的一些成员，比如 Pipeline、PipelineController，这些对象的作用放在后面文章中介绍</p>
<h3 id="创建-ChunkDemuxer"><a href="#创建-ChunkDemuxer" class="headerlink" title="创建 ChunkDemuxer"></a>创建 ChunkDemuxer</h3><p>创建 ChunkDemuxer 也在 HTMLMediaElement::StartPlayerLoad()中，StartPlayerLoad 创建完 WebMediaPlayer 之后就会执行 WebMediaPlayer 的 Load 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HTMLMediaElement::StartPlayerLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(!web_media_player_);</span><br><span class="line"></span><br><span class="line">  WebMediaPlayerSource source;</span><br><span class="line">  <span class="keyword">if</span> (src_object_) &#123;</span><br><span class="line">    source = <span class="built_in">WebMediaPlayerSource</span>(<span class="built_in">WebMediaStream</span>(src_object_));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LocalFrame* frame = <span class="built_in">LocalFrameForPlayer</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  web_media_player_ =</span><br><span class="line">      frame-&gt;<span class="built_in">Client</span>()-&gt;<span class="built_in">CreateWebMediaPlayer</span>(*<span class="keyword">this</span>, source, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="comment">// Make sure if we create/re-create the WebMediaPlayer that we update our</span></span><br><span class="line">  <span class="comment">// wrapper.</span></span><br><span class="line">  audio_source_provider_.<span class="built_in">Wrap</span>(web_media_player_-&gt;<span class="built_in">GetAudioSourceProvider</span>());</span><br><span class="line">  web_media_player_-&gt;<span class="built_in">SetVolume</span>(<span class="built_in">EffectiveMediaVolume</span>());</span><br><span class="line"></span><br><span class="line">  web_media_player_-&gt;<span class="built_in">SetPoster</span>(<span class="built_in">PosterImageURL</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> preload = <span class="built_in">EffectivePreloadType</span>();</span><br><span class="line">  web_media_player_-&gt;<span class="built_in">SetPreload</span>(preload);</span><br><span class="line"></span><br><span class="line">  web_media_player_-&gt;<span class="built_in">RequestRemotePlaybackDisabled</span>(</span><br><span class="line">      <span class="built_in">FastHasAttribute</span>(html_names::kDisableremoteplaybackAttr));</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> is_cache_disabled = <span class="literal">false</span>;</span><br><span class="line">  probe::<span class="built_in">IsCacheDisabled</span>(<span class="built_in">GetDocument</span>().<span class="built_in">GetExecutionContext</span>(),</span><br><span class="line">                         &amp;is_cache_disabled);</span><br><span class="line">  <span class="keyword">auto</span> load_timing = web_media_player_-&gt;<span class="built_in">Load</span>(<span class="built_in">GetLoadType</span>(), source, <span class="built_in">CorsMode</span>(),</span><br><span class="line">                                             is_cache_disabled);</span><br><span class="line">  <span class="keyword">if</span> (load_timing == WebMediaPlayer::LoadTiming::kDeferred) &#123;</span><br><span class="line">    <span class="comment">// Deferred media loading is not part of the spec, but intuition is that</span></span><br><span class="line">    <span class="comment">// this should not hold up the Window&#x27;s &quot;load&quot; event (similar to user</span></span><br><span class="line">    <span class="comment">// gesture requirements).</span></span><br><span class="line">    <span class="built_in">SetShouldDelayLoadEvent</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Load 函数中进行 DoLoad</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WebMediaPlayer::LoadTiming <span class="title">WebMediaPlayerImpl::Load</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LoadType load_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebMediaPlayerSource&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    CorsMode cors_mode,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> is_cache_disabled)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Only URL or MSE blob URL is supported.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(source.<span class="built_in">IsURL</span>());</span><br><span class="line">  WebURL url = source.<span class="built_in">GetAsURL</span>();</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; load_type &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">GURL</span>(url) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">           &lt;&lt; cors_mode &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> is_deferred = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (defer_load_cb_) &#123;</span><br><span class="line">    is_deferred = defer_load_cb_.<span class="built_in">Run</span>(</span><br><span class="line">        base::<span class="built_in">BindOnce</span>(&amp;WebMediaPlayerImpl::DoLoad, weak_this_, load_type, url,</span><br><span class="line">                       cors_mode, is_cache_disabled));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DoLoad</span>(load_type, url, cors_mode, is_cache_disabled);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> is_deferred ? LoadTiming::kDeferred : LoadTiming::kImmediate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 DoLoad 里面调用 StartPipeline</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebMediaPlayerImpl::DoLoad</span><span class="params">(LoadType load_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> WebURL&amp; url,</span></span></span><br><span class="line"><span class="params"><span class="function">                                CorsMode cors_mode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">bool</span> is_cache_disabled)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">TRACE_EVENT1</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;WebMediaPlayerImpl::DoLoad&quot;</span>, <span class="string">&quot;id&quot;</span>, media_log_-&gt;<span class="built_in">id</span>());</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__;</span><br><span class="line">  <span class="built_in">DCHECK</span>(main_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: `url` may be very large, take care when making copies.</span></span><br><span class="line">  loaded_url_ = <span class="built_in">GURL</span>(url);</span><br><span class="line">  load_type_ = load_type;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReportMetrics</span>(load_type, loaded_url_, *frame_, media_log_.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  load_start_time_ = base::TimeTicks::<span class="built_in">Now</span>();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (demuxer_override_ || load_type == kLoadTypeMediaSource) &#123;</span><br><span class="line">    <span class="comment">// If a demuxer override was specified or a Media Source pipeline will be</span></span><br><span class="line">    <span class="comment">// used, the pipeline can start immediately.</span></span><br><span class="line">    <span class="built_in">StartPipeline</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WebMediaPlayerImpl-StartPipeline"><a href="#WebMediaPlayerImpl-StartPipeline" class="headerlink" title="WebMediaPlayerImpl::StartPipeline"></a>WebMediaPlayerImpl::StartPipeline</h4><p>下面的 EncryptedMediaInitDataCB 是给 ChunkDemuxer 的 CallBack，当 ChunkDemuxer 遇到一个加密流时会执行此回调去执行初始化行为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebMediaPlayerImpl::StartPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(main_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">  Demuxer::EncryptedMediaInitDataCB encrypted_media_init_data_cb =</span><br><span class="line">      media::<span class="built_in">BindToCurrentLoop</span>(base::<span class="built_in">BindRepeating</span>(</span><br><span class="line">          &amp;WebMediaPlayerImpl::OnEncryptedMediaInitData, weak_this_));</span><br><span class="line"></span><br><span class="line">  vfc_task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">      FROM_HERE,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;VideoFrameCompositor::SetOnNewProcessedFrameCallback,</span><br><span class="line">                     base::<span class="built_in">Unretained</span>(compositor_.<span class="built_in">get</span>()),</span><br><span class="line">                     media::<span class="built_in">BindToCurrentLoop</span>(base::<span class="built_in">BindOnce</span>(</span><br><span class="line">                         &amp;WebMediaPlayerImpl::OnFirstFrame, weak_this_))));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_ANDROID)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(IS_ANDROID)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Figure out which demuxer to use.</span></span><br><span class="line">  <span class="keyword">if</span> (demuxer_override_) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!chunk_demuxer_);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetDemuxer</span>(std::<span class="built_in">move</span>(demuxer_override_));</span><br><span class="line">    <span class="comment">// TODO(https://crbug.com/1076267): Should everything else after this block</span></span><br><span class="line">    <span class="comment">// run in the demuxer override case?</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (load_type_ != kLoadTypeMediaSource) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!chunk_demuxer_);</span><br><span class="line">    <span class="built_in">DCHECK</span>(data_source_);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(ENABLE_FFMPEG)</span></span><br><span class="line">    Demuxer::MediaTracksUpdatedCB media_tracks_updated_cb =</span><br><span class="line">        media::<span class="built_in">BindToCurrentLoop</span>(base::<span class="built_in">BindRepeating</span>(</span><br><span class="line">            &amp;WebMediaPlayerImpl::OnFFmpegMediaTracksUpdated, weak_this_));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetDemuxer</span>(std::<span class="built_in">make_unique</span>&lt;media::FFmpegDemuxer&gt;(</span><br><span class="line">        media_task_runner_, data_source_.<span class="built_in">get</span>(), encrypted_media_init_data_cb,</span><br><span class="line">        media_tracks_updated_cb, media_log_.<span class="built_in">get</span>(), <span class="built_in">IsLocalFile</span>(loaded_url_)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">OnError</span>(media::DEMUXER_ERROR_COULD_NOT_OPEN);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!chunk_demuxer_);</span><br><span class="line">    <span class="built_in">DCHECK</span>(!data_source_);</span><br><span class="line"></span><br><span class="line">    chunk_demuxer_ = <span class="keyword">new</span> media::<span class="built_in">ChunkDemuxer</span>(</span><br><span class="line">        media::<span class="built_in">BindToCurrentLoop</span>(</span><br><span class="line">            base::<span class="built_in">BindOnce</span>(&amp;WebMediaPlayerImpl::OnDemuxerOpened, weak_this_)),</span><br><span class="line">        media::<span class="built_in">BindToCurrentLoop</span>(</span><br><span class="line">            base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnProgress, weak_this_)),</span><br><span class="line">        encrypted_media_init_data_cb, media_log_.<span class="built_in">get</span>());</span><br><span class="line">    <span class="built_in">SetDemuxer</span>(std::<span class="built_in">unique_ptr</span>&lt;Demuxer&gt;(chunk_demuxer_));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base::FeatureList::<span class="built_in">IsEnabled</span>(</span><br><span class="line">            media::kMemoryPressureBasedSourceBufferGC)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If possible attempt to avoid decoder spool up until playback starts.</span></span><br><span class="line">  <span class="keyword">auto</span> start_type = media::Pipeline::StartType::kNormal;</span><br><span class="line">  <span class="keyword">if</span> (!chunk_demuxer_ &amp;&amp; preload_ == MultiBufferDataSource::METADATA &amp;&amp;</span><br><span class="line">      !client_-&gt;<span class="built_in">CouldPlayIfEnoughData</span>() &amp;&amp; !<span class="built_in">IsStreaming</span>()) &#123;</span><br><span class="line">    start_type =</span><br><span class="line">        (has_poster_ ||</span><br><span class="line">         base::FeatureList::<span class="built_in">IsEnabled</span>(media::kPreloadMetadataLazyLoad))</span><br><span class="line">            ? media::Pipeline::StartType::kSuspendAfterMetadata</span><br><span class="line">            : media::Pipeline::StartType::kSuspendAfterMetadataForAudioOnly;</span><br><span class="line">    attempting_suspended_start_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(sandersd): FileSystem objects may also be non-static, but due to our</span></span><br><span class="line">  <span class="comment">// caching layer such situations are broken already. http://crbug.com/593159</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> is_static = !chunk_demuxer_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... and we&#x27;re ready to go!</span></span><br><span class="line">  <span class="comment">// TODO(sandersd): On Android, defer Start() if the tab is not visible.</span></span><br><span class="line">  seeking_ = <span class="literal">true</span>;</span><br><span class="line">  pipeline_controller_-&gt;<span class="built_in">Start</span>(start_type, demuxer_.<span class="built_in">get</span>(), <span class="keyword">this</span>, <span class="built_in">IsStreaming</span>(),</span><br><span class="line">                              is_static);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，如果不是 MSE，将使用 FFmpegDemuxer，如果是 MSE，使用 ChunkDemuxer。</p>
<p>上面在创建 ChunkDemuxer 时给 ChunkDemuxer 设置了 WebMediaPlayerImpl::OnDemuxerOpened 作为回调，OnDemuxerOpened 内部调用 MediaSourceOpened，而 MediaSourceOpened 内部调用 CompleteAttachingToMediaElement，这和上面 CompleteAttachingToMediaElement 的调用过程一致</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebMediaPlayerImpl::OnDemuxerOpened</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(main_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line">  client_-&gt;<span class="built_in">MediaSourceOpened</span>(<span class="keyword">new</span> <span class="built_in">WebMediaSourceImpl</span>(chunk_demuxer_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>encrypted_media_init_data_cb 回调的作用上面已经说过，当 ChunkDemuxer 遇到一个加密流时会通过这个回调向 CDM 模块获得用于解密的密钥</p>
<h5 id="PipelineController-Start"><a href="#PipelineController-Start" class="headerlink" title="PipelineController::Start"></a>PipelineController::Start</h5><p>接下来再分析 ChunkDemuxer 何时调用 WebMediaPlayerImpl::OnDemuxerOpened。实际上 ChunkDemuxer 会在初始化之后调用这个回调</p>
<p>在 WebMediaPlayerImpl::StartPipeline 的最后会调用 PipelineController::Start</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PipelineController::Start</span><span class="params">(Pipeline::StartType start_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Demuxer* demuxer,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Pipeline::Client* client,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">bool</span> is_streaming,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">bool</span> is_static)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(thread_checker_.<span class="built_in">CalledOnValidThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(state_, State::STOPPED);</span><br><span class="line">  <span class="built_in">DCHECK</span>(demuxer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Once the pipeline is started, we want to call the seeked callback but</span></span><br><span class="line">  <span class="comment">// without a time update.</span></span><br><span class="line">  pending_startup_ = <span class="literal">true</span>;</span><br><span class="line">  pending_seeked_cb_ = <span class="literal">true</span>;</span><br><span class="line">  state_ = State::STARTING;</span><br><span class="line"></span><br><span class="line">  demuxer_ = demuxer;</span><br><span class="line">  is_streaming_ = is_streaming;</span><br><span class="line">  is_static_ = is_static;</span><br><span class="line">  pipeline_-&gt;<span class="built_in">Start</span>(start_type, demuxer, client,</span><br><span class="line">                   base::<span class="built_in">BindOnce</span>(&amp;PipelineController::OnPipelineStatus,</span><br><span class="line">                                  weak_factory_.<span class="built_in">GetWeakPtr</span>(),</span><br><span class="line">                                  start_type == Pipeline::StartType::kNormal</span><br><span class="line">                                      ? State::PLAYING</span><br><span class="line">                                      : State::PLAYING_OR_SUSPENDED));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PipelineController::Start 又调用 PipelineImpl::Start</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PipelineImpl::Start</span><span class="params">(StartType start_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Demuxer* demuxer,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Client* client,</span></span></span><br><span class="line"><span class="params"><span class="function">                         PipelineStatusCallback seek_cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: start_type=&quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(start_type);</span><br><span class="line">  <span class="built_in">DCHECK</span>(thread_checker_.<span class="built_in">CalledOnValidThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(demuxer);</span><br><span class="line">  <span class="built_in">DCHECK</span>(client);</span><br><span class="line">  <span class="built_in">DCHECK</span>(seek_cb);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(!client_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!seek_cb_);</span><br><span class="line">  client_ = client;</span><br><span class="line">  seek_cb_ = std::<span class="built_in">move</span>(seek_cb);</span><br><span class="line">  last_media_time_ = base::<span class="built_in">TimeDelta</span>();</span><br><span class="line">  seek_time_ = kNoTimestamp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// By default, create a default renderer to avoid additional start-to-play</span></span><br><span class="line">  <span class="comment">// latency caused by asynchronous Renderer creation. When |start_type| is</span></span><br><span class="line">  <span class="comment">// kSuspendAfterMetadata, latency is not important and the video may never</span></span><br><span class="line">  <span class="comment">// play. In this case, not creating a default renderer to reduce memory usage.</span></span><br><span class="line">  std::unique_ptr&lt;Renderer&gt; default_renderer;</span><br><span class="line">  <span class="keyword">if</span> (start_type != StartType::kSuspendAfterMetadata)</span><br><span class="line">    default_renderer = create_renderer_cb_.<span class="built_in">Run</span>(absl::<span class="literal">nullopt</span>);</span><br><span class="line"></span><br><span class="line">  media_task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">      FROM_HERE,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::Start,</span><br><span class="line">                     base::<span class="built_in">Unretained</span>(renderer_wrapper_.<span class="built_in">get</span>()), start_type,</span><br><span class="line">                     demuxer, std::<span class="built_in">move</span>(default_renderer),</span><br><span class="line">                     weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PipelineImpl::Start 先通过 <code>create_renderer_cb_</code> 创建 Renderer，然后在 <code>media_task_runner_</code> 中调用 RendererWrapper::Start</p>
<p>在 RendererWrapper::Start 中会执行一系列的任务 RendererWrapper::InitializeDemuxer、RendererWrapper::ReportMetadata、RendererWrapper::CreateRenderer、RendererWrapper::InitializeRenderer、RendererWrapper::CompleteSeek，这些任务是一个接一个的异步执行的，后面可以写一篇文章介绍一下 SerialRunner 的相关内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> PipelineImpl::RendererWrapper::<span class="built_in">Start</span>(</span><br><span class="line">    StartType start_type,</span><br><span class="line">    Demuxer* demuxer,</span><br><span class="line">    std::unique_ptr&lt;Renderer&gt; default_renderer,</span><br><span class="line">    base::WeakPtr&lt;PipelineImpl&gt; weak_pipeline) &#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(media_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(state_ == kCreated || state_ == kStopped)</span><br><span class="line">      &lt;&lt; <span class="string">&quot;Received start in unexpected state: &quot;</span> &lt;&lt; state_;</span><br><span class="line">  <span class="built_in">DCHECK</span>(!demuxer_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!renderer_ended_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!text_renderer_ended_);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetState</span>(kStarting);</span><br><span class="line">  demuxer_ = demuxer;</span><br><span class="line">  default_renderer_ = std::<span class="built_in">move</span>(default_renderer);</span><br><span class="line">  weak_pipeline_ = weak_pipeline;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setup |error_cb_| on the media thread.</span></span><br><span class="line">  error_cb_ = base::<span class="built_in">BindRepeating</span>(&amp;RendererWrapper::OnPipelineError,</span><br><span class="line">                                  weak_factory_.<span class="built_in">GetWeakPtr</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Queue asynchronous actions required to start.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(!pending_callbacks_);</span><br><span class="line">  SerialRunner::Queue fns;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize demuxer.</span></span><br><span class="line">  fns.<span class="built_in">Push</span>(base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::InitializeDemuxer,</span><br><span class="line">                          weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Once the demuxer is initialized successfully, media metadata must be</span></span><br><span class="line">  <span class="comment">// available - report the metadata to client. If starting without a renderer</span></span><br><span class="line">  <span class="comment">// we&#x27;ll complete initialization at this point.</span></span><br><span class="line">  fns.<span class="built_in">Push</span>(base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::ReportMetadata,</span><br><span class="line">                          weak_factory_.<span class="built_in">GetWeakPtr</span>(), start_type));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create renderer.</span></span><br><span class="line">  fns.<span class="built_in">Push</span>(base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::CreateRenderer,</span><br><span class="line">                          weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize renderer.</span></span><br><span class="line">  fns.<span class="built_in">Push</span>(base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::InitializeRenderer,</span><br><span class="line">                          weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run tasks.</span></span><br><span class="line">  pending_callbacks_ = SerialRunner::<span class="built_in">Run</span>(</span><br><span class="line">      std::<span class="built_in">move</span>(fns),</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::CompleteSeek, weak_factory_.<span class="built_in">GetWeakPtr</span>(),</span><br><span class="line">                     base::<span class="built_in">TimeDelta</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="RendererWrapper-InitializeDemuxer"><a href="#RendererWrapper-InitializeDemuxer" class="headerlink" title="RendererWrapper::InitializeDemuxer"></a>RendererWrapper::InitializeDemuxer</h6><p>RendererWrapper::InitializeDemuxer 中会执行 ChunkDemuxer::Initialize</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> PipelineImpl::RendererWrapper::<span class="built_in">InitializeDemuxer</span>(</span><br><span class="line">    PipelineStatusCallback done_cb) &#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(media_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">  demuxer_-&gt;<span class="built_in">Initialize</span>(<span class="keyword">this</span>, std::<span class="built_in">move</span>(done_cb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChunkDemuxer::Initialize 的最后会 <code>std::move(open_cb).Run();</code>，open_cb 就是 WebMediaPlayerImpl::OnDemuxerOpened</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChunkDemuxer::Initialize</span><span class="params">(DemuxerHost* host,</span></span></span><br><span class="line"><span class="params"><span class="function">                              PipelineStatusCallback init_cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;Initialize()&quot;</span>;</span><br><span class="line">  <span class="built_in">TRACE_EVENT_ASYNC_BEGIN0</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;ChunkDemuxer::Initialize&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  base::OnceClosure open_cb;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Locked scope</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">base::AutoLock <span class="title">auto_lock</span><span class="params">(lock_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (state_ == SHUTDOWN) &#123;</span><br><span class="line">      <span class="comment">// Init cb must only be run after this method returns, so post.</span></span><br><span class="line">      init_cb_ = <span class="built_in">BindToCurrentLoop</span>(std::<span class="built_in">move</span>(init_cb));</span><br><span class="line">      <span class="built_in">RunInitCB_Locked</span>(DEMUXER_ERROR_COULD_NOT_OPEN);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DCHECK_EQ</span>(state_, WAITING_FOR_INIT);</span><br><span class="line">    host_ = host;</span><br><span class="line">    <span class="comment">// Do not post init_cb once this function returns because if there is an</span></span><br><span class="line">    <span class="comment">// error after initialization, the error might be reported before init_cb</span></span><br><span class="line">    <span class="comment">// has a chance to run. This is because ChunkDemuxer::ReportError_Locked</span></span><br><span class="line">    <span class="comment">// directly calls DemuxerHost::OnDemuxerError: crbug.com/633016.</span></span><br><span class="line">    init_cb_ = std::<span class="built_in">move</span>(init_cb);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ChangeState_Locked</span>(INITIALIZING);</span><br><span class="line">    open_cb = std::<span class="built_in">move</span>(open_cb_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">move</span>(open_cb).<span class="built_in">Run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里我们就知道 source open 事件在何时触发了。</p>
<p>还有一点要注意，ChunkDemuxer::Initialize 的参数 init_cb 是 RendererWrapper::ReportMetadata，而该函数没有在 ChunkDemuxer::Initialize 之后立刻执行，而是先执行 <code>open_cb_</code>，也就是 WebMediaPlayerImpl::OnDemuxerOpened，在该函数执行后，上层会调用 addSourceBuffer，在 addSourceBuffer 调用中会调用 ChunkDemuxer::AddId，接着调用 ChunkDemuxer::AddIdInternal，在 ChunkDemuxer::AddIdInternal 内部把 ChunkDemuxer::OnSourceInitDone 作为 SourceBufferState 的回调，ChunkDemuxer::OnSourceInitDone 里面才去执行 <code>init_cb_</code> 来继续完成 Pipeline 的初始化。</p>
<p>这篇文章就介绍到这里，下一篇文章分析一下 ChunkDemuxer 相关的内容，Pipeline 初始化过程先不继续往下，到后面再分析。</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/06/15/Chromium-base-%E5%BA%93%E4%B9%8B-thread%EF%BC%88%E5%9B%9B%EF%BC%89/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
              2023-06-23 13:11:37
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">
                      <a href="/categories/Chromium/" title="Chromium">
                        <b>#</b> Chromium
                      </a>
                    </span>
                    
                    <span class="span--category">
                      <a href="/categories/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93/" title="Chromium 多媒体">
                        <b>#</b> Chromium 多媒体
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/06/23/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createObjectURL"><span class="toc-text">createObjectURL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebMediaPlayer-%E6%9F%A5%E6%89%BE-MediaSourceAttachment"><span class="toc-text">WebMediaPlayer 查找 MediaSourceAttachment</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LookupMediaSource"><span class="toc-text">LookupMediaSource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StartAttachingToMediaElement"><span class="toc-text">StartAttachingToMediaElement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CompleteAttachingToMediaElement"><span class="toc-text">CompleteAttachingToMediaElement</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebMediaPlayer-%E4%BB%A5%E5%8F%8A-ChunkDemuxer-%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">WebMediaPlayer 以及 ChunkDemuxer 的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTMLMediaElement-StartPlayerLoad"><span class="toc-text">HTMLMediaElement::StartPlayerLoad</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MediaFactory-CreateMediaPlayer"><span class="toc-text">MediaFactory::CreateMediaPlayer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#WebMediaPlayerImpl-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">WebMediaPlayerImpl 的构造函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-ChunkDemuxer"><span class="toc-text">创建 ChunkDemuxer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WebMediaPlayerImpl-StartPipeline"><span class="toc-text">WebMediaPlayerImpl::StartPipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PipelineController-Start"><span class="toc-text">PipelineController::Start</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#RendererWrapper-InitializeDemuxer"><span class="toc-text">RendererWrapper::InitializeDemuxer</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'fg49dbpe7aWEpf8yQgZnaNlc-gzGzoHsz',
        appKey: 'zT8ZAY6u1L6753gMkaDp8hgW',
        placeholder: '说点什么吧',
        avatar: 'retro',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" href="https://github.com/Zeroneplus">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a href="https://zeroneplus.github.io/">Copyright © 2023 ZeronePlus</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        

      </div>
    </div>
  
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body>
</html>
