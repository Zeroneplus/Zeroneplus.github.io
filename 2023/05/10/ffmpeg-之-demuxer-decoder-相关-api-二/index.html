<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="cdzhang" />
  <meta name="description" content="" />
  
  
  <title>
    
      ffmpeg 之 demuxer/decoder 相关 api (二) 
      
      
      |
    
     ZeronePlus&#39; Blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/images3.png">
    <link rel="icon" href="/images/images3.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img no-lazy src="/images/images3.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">ZeronePlus</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">ffmpeg 之 demuxer/decoder 相关 api (二)</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
          2023-05-10 21:32:20
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="分类"></i>
                
                <span class="span--category">
                  <a href="/categories/ffmpeg/" title="ffmpeg">
                    <b>#</b> ffmpeg
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>这篇文章接着上篇继续介绍 demuxer&#x2F;decoder 相关的函数。</p>
<h2 id="avformat-find-stream-info"><a href="#avformat-find-stream-info" class="headerlink" title="avformat_find_stream_info"></a>avformat_find_stream_info</h2><p>这个函数从输入源中读取数据来确定 stream 信息，这个函数对那些没有头部的格式比如 MPEG 比较有用。</p>
<p>和 av_probe_input_buffer2 不一样，这个函数读取的数据只有在没有 AVFMT_FLAG_NOBUFFER 这个 flag 时不会被消耗掉，后续的 read 还会返回这些数据，debug 发现 MP4 格式的 video 数据会缓存下来，audio 数据不会。</p>
<p>这个函数比较长，分段来看看。</p>
<h3 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h3><p>这一部分主要是对已经有的 stream 进行初始化，之前 s-&gt;iformat-&gt;read_header 时可能会创建 stream，在这里会尝试对已经创建的 stream 中的 AVCodecContext 进行 avcodec_open2。在 avcodec_open2 之前，会通过 avcodec_parameters_to_context 把 stream 中的参数拷贝到 AVCodecContext 中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(ic);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int64_t</span> read_size;</span><br><span class="line">    AVPacket *pkt1 = si-&gt;pkt;</span><br><span class="line">    <span class="type">int64_t</span> old_offset  = <span class="built_in">avio_tell</span>(ic-&gt;pb);</span><br><span class="line">    <span class="comment">// new streams might appear, no options for those</span></span><br><span class="line">    <span class="type">int</span> orig_nb_streams = ic-&gt;nb_streams;</span><br><span class="line">    <span class="type">int</span> flush_codecs;</span><br><span class="line">    <span class="type">int64_t</span> max_analyze_duration = ic-&gt;max_analyze_duration;</span><br><span class="line">    <span class="type">int64_t</span> max_stream_analyze_duration;</span><br><span class="line">    <span class="type">int64_t</span> max_subtitle_analyze_duration;</span><br><span class="line">    <span class="type">int64_t</span> probesize = ic-&gt;probesize;</span><br><span class="line">    <span class="type">int</span> eof_reached = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *missing_streams = <span class="built_in">av_opt_ptr</span>(ic-&gt;iformat-&gt;priv_class, ic-&gt;priv_data, <span class="string">&quot;missing_streams&quot;</span>);</span><br><span class="line"></span><br><span class="line">    flush_codecs = probesize &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_opt_set_int</span>(ic, <span class="string">&quot;skip_clear&quot;</span>, <span class="number">1</span>, AV_OPT_SEARCH_CHILDREN);</span><br><span class="line"></span><br><span class="line">    max_stream_analyze_duration = max_analyze_duration;</span><br><span class="line">    max_subtitle_analyze_duration = max_analyze_duration;</span><br><span class="line">    <span class="keyword">if</span> (!max_analyze_duration) &#123;</span><br><span class="line">        max_stream_analyze_duration =</span><br><span class="line">        max_analyze_duration        = <span class="number">5</span>*AV_TIME_BASE;</span><br><span class="line">        max_subtitle_analyze_duration = <span class="number">30</span>*AV_TIME_BASE;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="type">const</span> AVCodec *codec;</span><br><span class="line">        AVDictionary *thread_opt = <span class="literal">NULL</span>;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        AVCodecContext *<span class="type">const</span> avctx = sti-&gt;avctx;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||</span><br><span class="line">            st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line"><span class="comment">/*            if (!st-&gt;time_base.num)</span></span><br><span class="line"><span class="comment">                st-&gt;time_base = */</span></span><br><span class="line">            <span class="keyword">if</span> (!avctx-&gt;time_base.num)</span><br><span class="line">                avctx-&gt;time_base = st-&gt;time_base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check if the caller has overridden the codec id */</span></span><br><span class="line">        <span class="comment">// only for the split stuff</span></span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;parser &amp;&amp; !(ic-&gt;flags &amp; AVFMT_FLAG_NOPARSE) &amp;&amp; sti-&gt;request_probe &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sti-&gt;parser = <span class="built_in">av_parser_init</span>(st-&gt;codecpar-&gt;codec_id);</span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;parser) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sti-&gt;need_parsing == AVSTREAM_PARSE_HEADERS) &#123;</span><br><span class="line">                    sti-&gt;parser-&gt;flags |= PARSER_FLAG_COMPLETE_FRAMES;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sti-&gt;need_parsing == AVSTREAM_PARSE_FULL_RAW) &#123;</span><br><span class="line">                    sti-&gt;parser-&gt;flags |= PARSER_FLAG_USE_CODEC_TS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sti-&gt;need_parsing) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(ic, AV_LOG_VERBOSE, <span class="string">&quot;parser not found for codec &quot;</span></span><br><span class="line">                       <span class="string">&quot;%s, packets or times may be invalid.\n&quot;</span>,</span><br><span class="line">                       <span class="built_in">avcodec_get_name</span>(st-&gt;codecpar-&gt;codec_id));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">avcodec_parameters_to_context</span>(avctx, st-&gt;codecpar);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> find_stream_info_err;</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;request_probe &lt;= <span class="number">0</span>)</span><br><span class="line">            sti-&gt;avctx_inited = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        codec = <span class="built_in">find_probe_decoder</span>(ic, st, st-&gt;codecpar-&gt;codec_id);</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// Try to just open decoders, in case this is enough to get parameters.</span></span><br><span class="line">        <span class="comment">// Also ensure that subtitle_header is properly set.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">has_codec_parameters</span>(st, <span class="literal">NULL</span>) &amp;&amp; sti-&gt;request_probe &lt;= <span class="number">0</span> ||</span><br><span class="line">            st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (codec &amp;&amp; !avctx-&gt;codec)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(avctx, codec, options ? &amp;options[i] : &amp;thread_opt) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">av_log</span>(ic, AV_LOG_WARNING,</span><br><span class="line">                           <span class="string">&quot;Failed to open codec in %s\n&quot;</span>,__FUNCTION__);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!options)</span><br><span class="line">            <span class="built_in">av_dict_free</span>(&amp;thread_opt);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="has-codec-parameters"><a href="#has-codec-parameters" class="headerlink" title="has_codec_parameters"></a>has_codec_parameters</h4><p>对 stream 上的 AVCodecContext 进行一些检查</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">has_codec_parameters</span><span class="params">(<span class="type">const</span> AVStream *st, <span class="type">const</span> <span class="type">char</span> **errmsg_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FFStream *<span class="type">const</span> sti = <span class="built_in">cffstream</span>(st);</span><br><span class="line">    <span class="type">const</span> AVCodecContext *<span class="type">const</span> avctx = sti-&gt;avctx;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAIL(errmsg) do &#123;                                         \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (errmsg_ptr)                                           \</span></span><br><span class="line"><span class="meta">            *errmsg_ptr = errmsg;                                 \</span></span><br><span class="line"><span class="meta">        return 0;                                                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (   avctx-&gt;codec_id == AV_CODEC_ID_NONE</span><br><span class="line">        &amp;&amp; avctx-&gt;codec_type != AVMEDIA_TYPE_DATA)</span><br><span class="line">        <span class="built_in">FAIL</span>(<span class="string">&quot;unknown codec&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (avctx-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">        <span class="keyword">if</span> (!avctx-&gt;frame_size &amp;&amp; <span class="built_in">determinable_frame_size</span>(avctx))</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified frame size&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;info-&gt;found_decoder &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            avctx-&gt;sample_fmt == AV_SAMPLE_FMT_NONE)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified sample format&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!avctx-&gt;sample_rate)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified sample rate&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!avctx-&gt;ch_layout.nb_channels)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified number of channels&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;info-&gt;found_decoder &gt;= <span class="number">0</span> &amp;&amp; !sti-&gt;nb_decoded_frames &amp;&amp; avctx-&gt;codec_id == AV_CODEC_ID_DTS)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;no decodable DTS frames&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">        <span class="keyword">if</span> (!avctx-&gt;width)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified size&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;info-&gt;found_decoder &gt;= <span class="number">0</span> &amp;&amp; avctx-&gt;pix_fmt == AV_PIX_FMT_NONE)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified pixel format&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_id == AV_CODEC_ID_RV30 || st-&gt;codecpar-&gt;codec_id == AV_CODEC_ID_RV40)</span><br><span class="line">            <span class="keyword">if</span> (!st-&gt;sample_aspect_ratio.num &amp;&amp; !st-&gt;codecpar-&gt;sample_aspect_ratio.num &amp;&amp; !sti-&gt;codec_info_nb_frames)</span><br><span class="line">                <span class="built_in">FAIL</span>(<span class="string">&quot;no frame in rv30/40 and no sar&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec_id == AV_CODEC_ID_HDMV_PGS_SUBTITLE &amp;&amp; !avctx-&gt;width)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified size&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_DATA:</span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec_id == AV_CODEC_ID_NONE) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="find-probe-decoder"><a href="#find-probe-decoder" class="headerlink" title="find_probe_decoder"></a>find_probe_decoder</h4><p>通过 find_probe_decoder 找到当前 stream 对应的 codec 信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> AVCodec *<span class="title">find_probe_decoder</span><span class="params">(AVFormatContext *s, <span class="type">const</span> AVStream *st,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="keyword">enum</span> AVCodecID codec_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVCodec *codec;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_H264_DECODER</span></span><br><span class="line">    <span class="comment">/* Other parts of the code assume this decoder to be used for h264,</span></span><br><span class="line"><span class="comment">     * so force it if possible. */</span></span><br><span class="line">    <span class="keyword">if</span> (codec_id == AV_CODEC_ID_H264)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">avcodec_find_decoder_by_name</span>(<span class="string">&quot;h264&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    codec = <span class="built_in">ff_find_decoder</span>(s, st, codec_id);</span><br><span class="line">    <span class="keyword">if</span> (!codec)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (codec-&gt;capabilities &amp; AV_CODEC_CAP_AVOID_PROBING) &#123;</span><br><span class="line">        <span class="type">const</span> AVCodec *probe_codec = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">void</span> *iter = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> ((probe_codec = <span class="built_in">av_codec_iterate</span>(&amp;iter))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (probe_codec-&gt;id == codec-&gt;id &amp;&amp;</span><br><span class="line">                    <span class="built_in">av_codec_is_decoder</span>(probe_codec) &amp;&amp;</span><br><span class="line">                    !(probe_codec-&gt;capabilities &amp; (AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_EXPERIMENTAL))) &#123;</span><br><span class="line">                <span class="keyword">return</span> probe_codec;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> codec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择 codec 会优先从 AVFormatContext 中选，其次会考虑 stream 上的 codecpar 中的 codec_id</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVCodec *<span class="title">ff_find_decoder</span><span class="params">(AVFormatContext *s, <span class="type">const</span> AVStream *st,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">enum</span> AVCodecID codec_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (st-&gt;codecpar-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;video_codec)    <span class="keyword">return</span> s-&gt;video_codec;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;audio_codec)    <span class="keyword">return</span> s-&gt;audio_codec;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;subtitle_codec) <span class="keyword">return</span> s-&gt;subtitle_codec;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">avcodec_find_decoder</span>(codec_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h3><p>上面部分没有涉及从数据源读取数据，这部分代码则是尝试读取一定的数据来探测 stream、codec 等信息。</p>
<p>有一个 for 循环，这个循环会在读取到指定大小的数据后或者已经分析完所有 stream 后退出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    read_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">const</span> AVPacket *pkt;</span><br><span class="line">        AVStream *st;</span><br><span class="line">        FFStream *sti;</span><br><span class="line">        AVCodecContext *avctx;</span><br><span class="line">        <span class="type">int</span> analyzed_all_streams;</span><br><span class="line">        <span class="type">unsigned</span> i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ff_check_interrupt</span>(&amp;ic-&gt;interrupt_callback)) &#123;</span><br><span class="line">            ret = AVERROR_EXIT;</span><br><span class="line">            <span class="built_in">av_log</span>(ic, AV_LOG_DEBUG, <span class="string">&quot;interrupted\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        这个循环会遍历每个stream，并检查它的参数，如果发现它的参数需要进一步调整，</span><br><span class="line">        或者遇到第一个还没有被初始化的stream时退出，在后续的逻辑中会尝试进行probe</span><br><span class="line">        来获得关于这个stream的更多信息</span><br><span class="line">        <span class="comment">/* check if one codec still needs to be handled */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">            AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">            FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">            <span class="type">int</span> fps_analyze_framecount = <span class="number">20</span>;</span><br><span class="line">            <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">has_codec_parameters</span>(st, <span class="literal">NULL</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/* If the timebase is coarse (like the usual millisecond precision</span></span><br><span class="line"><span class="comment">             * of mkv), we need to analyze more frames to reliably arrive at</span></span><br><span class="line"><span class="comment">             * the correct fps. */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">av_q2d</span>(st-&gt;time_base) &gt; <span class="number">0.0005</span>)</span><br><span class="line">                fps_analyze_framecount *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">tb_unreliable</span>(sti-&gt;avctx))</span><br><span class="line">                fps_analyze_framecount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ic-&gt;fps_probe_size &gt;= <span class="number">0</span>)</span><br><span class="line">                fps_analyze_framecount = ic-&gt;fps_probe_size;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)</span><br><span class="line">                fps_analyze_framecount = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* variable fps and no guess at the real fps */</span></span><br><span class="line">            count = (ic-&gt;iformat-&gt;flags &amp; AVFMT_NOTIMESTAMPS) ?</span><br><span class="line">                       sti-&gt;info-&gt;codec_info_duration_fields/<span class="number">2</span> :</span><br><span class="line">                       sti-&gt;info-&gt;duration_count;</span><br><span class="line">            <span class="keyword">if</span> (!(st-&gt;r_frame_rate.num &amp;&amp; st-&gt;avg_frame_rate.num) &amp;&amp;</span><br><span class="line">                st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; fps_analyze_framecount)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Look at the first 3 frames if there is evidence of frame delay</span></span><br><span class="line">            <span class="comment">// but the decoder delay is not set.</span></span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;info-&gt;frame_delay_evidence &amp;&amp; count &lt; <span class="number">2</span> &amp;&amp; sti-&gt;avctx-&gt;has_b_frames == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!sti-&gt;avctx-&gt;extradata &amp;&amp;</span><br><span class="line">                (!sti-&gt;extract_extradata.inited || sti-&gt;extract_extradata.bsf) &amp;&amp;</span><br><span class="line">                <span class="built_in">extract_extradata_check</span>(st))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;first_dts == AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                !(ic-&gt;iformat-&gt;flags &amp; AVFMT_NOTIMESTAMPS) &amp;&amp;</span><br><span class="line">                sti-&gt;codec_info_nb_frames &lt; ((st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC) ? <span class="number">1</span> : ic-&gt;max_ts_probe) &amp;&amp;</span><br><span class="line">                (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||</span><br><span class="line">                 st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        analyzed_all_streams = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!missing_streams || !*missing_streams)</span><br><span class="line">            <span class="keyword">if</span> (i == ic-&gt;nb_streams) &#123;</span><br><span class="line">                analyzed_all_streams = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/* <span class="doctag">NOTE:</span> If the format has no header, then we need to read some</span></span><br><span class="line"><span class="comment">                 * packets to get most of the streams, so we cannot stop here. */</span></span><br><span class="line">                <span class="keyword">if</span> (!(ic-&gt;ctx_flags &amp; AVFMTCTX_NOHEADER)) &#123;</span><br><span class="line">                    <span class="comment">/* If we found the info for all the codecs, we can stop. */</span></span><br><span class="line">                    ret = count;</span><br><span class="line">                    <span class="built_in">av_log</span>(ic, AV_LOG_DEBUG, <span class="string">&quot;All info found\n&quot;</span>);</span><br><span class="line">                    flush_codecs = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">/* We did not get all the codec info, but we read too much data. */</span></span><br><span class="line">        <span class="keyword">if</span> (read_size &gt;= probesize) &#123;</span><br><span class="line">            ret = count;</span><br><span class="line">            <span class="built_in">av_log</span>(ic, AV_LOG_DEBUG,</span><br><span class="line">                   <span class="string">&quot;Probe buffer size limit of %&quot;</span>PRId64<span class="string">&quot; bytes reached\n&quot;</span>, probesize);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">                AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">                FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">                <span class="keyword">if</span> (!st-&gt;r_frame_rate.num &amp;&amp;</span><br><span class="line">                    sti-&gt;info-&gt;duration_count &lt;= <span class="number">1</span> &amp;&amp;</span><br><span class="line">                    st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp;</span><br><span class="line">                    <span class="built_in">strcmp</span>(ic-&gt;iformat-&gt;name, <span class="string">&quot;image2&quot;</span>))</span><br><span class="line">                    <span class="built_in">av_log</span>(ic, AV_LOG_WARNING,</span><br><span class="line">                           <span class="string">&quot;Stream #%d: not enough frames to estimate rate; &quot;</span></span><br><span class="line">                           <span class="string">&quot;consider increasing probesize\n&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// read_frame_internal里面会把request_probe变为-1后才返回</span></span><br><span class="line">        <span class="comment">/* <span class="doctag">NOTE:</span> A new stream can be added there if no header in file</span></span><br><span class="line"><span class="comment">         * (AVFMTCTX_NOHEADER). */</span></span><br><span class="line">        ret = <span class="built_in">read_frame_internal</span>(ic, pkt1);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* EOF or error*/</span></span><br><span class="line">            eof_reached = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)) &#123;</span><br><span class="line">            有buffer</span><br><span class="line">            ret = <span class="built_in">avpriv_packet_list_put</span>(&amp;si-&gt;packet_buffer,</span><br><span class="line">                                         pkt1, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> unref_then_goto_end;</span><br><span class="line"></span><br><span class="line">            pkt = &amp;si-&gt;packet_buffer.tail-&gt;pkt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pkt = pkt1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st  = ic-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">        sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        <span class="keyword">if</span> (!(st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC))</span><br><span class="line">            read_size += pkt-&gt;size;</span><br><span class="line"></span><br><span class="line">        avctx = sti-&gt;avctx;</span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;avctx_inited) &#123;</span><br><span class="line">            ret = <span class="built_in">avcodec_parameters_to_context</span>(avctx, st-&gt;codecpar);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> unref_then_goto_end;</span><br><span class="line">            sti-&gt;avctx_inited = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;dts != AV_NOPTS_VALUE &amp;&amp; sti-&gt;codec_info_nb_frames &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* check for non-increasing dts */</span></span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;info-&gt;fps_last_dts != AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                sti-&gt;info-&gt;fps_last_dts &gt;= pkt-&gt;dts) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(ic, AV_LOG_DEBUG,</span><br><span class="line">                       <span class="string">&quot;Non-increasing DTS in stream %d: packet %d with DTS &quot;</span></span><br><span class="line">                       <span class="string">&quot;%&quot;</span>PRId64<span class="string">&quot;, packet %d with DTS %&quot;</span>PRId64<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                       st-&gt;index, sti-&gt;info-&gt;fps_last_dts_idx,</span><br><span class="line">                       sti-&gt;info-&gt;fps_last_dts, sti-&gt;codec_info_nb_frames,</span><br><span class="line">                       pkt-&gt;dts);</span><br><span class="line">                sti-&gt;info-&gt;fps_first_dts =</span><br><span class="line">                sti-&gt;info-&gt;fps_last_dts  = AV_NOPTS_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Check for a discontinuity in dts. If the difference in dts</span></span><br><span class="line"><span class="comment">             * is more than 1000 times the average packet duration in the</span></span><br><span class="line"><span class="comment">             * sequence, we treat it as a discontinuity. */</span></span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;info-&gt;fps_last_dts != AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                sti-&gt;info-&gt;fps_last_dts_idx &gt; sti-&gt;info-&gt;fps_first_dts_idx &amp;&amp;</span><br><span class="line">                (pkt-&gt;dts - (<span class="type">uint64_t</span>)sti-&gt;info-&gt;fps_last_dts) / <span class="number">1000</span> &gt;</span><br><span class="line">                (sti-&gt;info-&gt;fps_last_dts     - (<span class="type">uint64_t</span>)sti-&gt;info-&gt;fps_first_dts) /</span><br><span class="line">                (sti-&gt;info-&gt;fps_last_dts_idx - sti-&gt;info-&gt;fps_first_dts_idx)) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(ic, AV_LOG_WARNING,</span><br><span class="line">                       <span class="string">&quot;DTS discontinuity in stream %d: packet %d with DTS &quot;</span></span><br><span class="line">                       <span class="string">&quot;%&quot;</span>PRId64<span class="string">&quot;, packet %d with DTS %&quot;</span>PRId64<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                       st-&gt;index, sti-&gt;info-&gt;fps_last_dts_idx,</span><br><span class="line">                       sti-&gt;info-&gt;fps_last_dts, sti-&gt;codec_info_nb_frames,</span><br><span class="line">                       pkt-&gt;dts);</span><br><span class="line">                sti-&gt;info-&gt;fps_first_dts =</span><br><span class="line">                sti-&gt;info-&gt;fps_last_dts  = AV_NOPTS_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update stored dts values */</span></span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;info-&gt;fps_first_dts == AV_NOPTS_VALUE) &#123;</span><br><span class="line">                sti-&gt;info-&gt;fps_first_dts     = pkt-&gt;dts;</span><br><span class="line">                sti-&gt;info-&gt;fps_first_dts_idx = sti-&gt;codec_info_nb_frames;</span><br><span class="line">            &#125;</span><br><span class="line">            sti-&gt;info-&gt;fps_last_dts     = pkt-&gt;dts;</span><br><span class="line">            sti-&gt;info-&gt;fps_last_dts_idx = sti-&gt;codec_info_nb_frames;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;codec_info_nb_frames &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int64_t</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int64_t</span> limit;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (st-&gt;time_base.den &gt; <span class="number">0</span>)</span><br><span class="line">                t = <span class="built_in">av_rescale_q</span>(sti-&gt;info-&gt;codec_info_duration, st-&gt;time_base, AV_TIME_BASE_Q);</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;avg_frame_rate.num &gt; <span class="number">0</span>)</span><br><span class="line">                t = <span class="built_in">FFMAX</span>(t, <span class="built_in">av_rescale_q</span>(sti-&gt;codec_info_nb_frames, <span class="built_in">av_inv_q</span>(st-&gt;avg_frame_rate), AV_TIME_BASE_Q));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (   t == <span class="number">0</span></span><br><span class="line">                &amp;&amp; sti-&gt;codec_info_nb_frames &gt; <span class="number">30</span></span><br><span class="line">                &amp;&amp; sti-&gt;info-&gt;fps_first_dts != AV_NOPTS_VALUE</span><br><span class="line">                &amp;&amp; sti-&gt;info-&gt;fps_last_dts  != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                <span class="type">int64_t</span> dur = <span class="built_in">av_sat_sub64</span>(sti-&gt;info-&gt;fps_last_dts, sti-&gt;info-&gt;fps_first_dts);</span><br><span class="line">                t = <span class="built_in">FFMAX</span>(t, <span class="built_in">av_rescale_q</span>(dur, st-&gt;time_base, AV_TIME_BASE_Q));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (analyzed_all_streams)                                limit = max_analyze_duration;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) limit = max_subtitle_analyze_duration;</span><br><span class="line">            <span class="keyword">else</span>                                                     limit = max_stream_analyze_duration;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t &gt;= limit) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(ic, AV_LOG_VERBOSE, <span class="string">&quot;max_analyze_duration %&quot;</span>PRId64<span class="string">&quot; reached at %&quot;</span>PRId64<span class="string">&quot; microseconds st:%d\n&quot;</span>,</span><br><span class="line">                       limit,</span><br><span class="line">                       t, pkt-&gt;stream_index);</span><br><span class="line">                <span class="keyword">if</span> (ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)</span><br><span class="line">                    <span class="built_in">av_packet_unref</span>(pkt1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pkt-&gt;duration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE &amp;&amp; pkt-&gt;pts != AV_NOPTS_VALUE &amp;&amp; st-&gt;start_time != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;pts &gt;= st-&gt;start_time</span><br><span class="line">                    &amp;&amp; (<span class="type">uint64_t</span>)pkt-&gt;pts - st-&gt;start_time &lt; INT64_MAX</span><br><span class="line">                ) &#123;</span><br><span class="line">                    sti-&gt;info-&gt;codec_info_duration = <span class="built_in">FFMIN</span>(pkt-&gt;pts - st-&gt;start_time, sti-&gt;info-&gt;codec_info_duration + pkt-&gt;duration);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    sti-&gt;info-&gt;codec_info_duration += pkt-&gt;duration;</span><br><span class="line">                sti-&gt;info-&gt;codec_info_duration_fields += sti-&gt;parser &amp;&amp; sti-&gt;need_parsing &amp;&amp; avctx-&gt;ticks_per_frame == <span class="number">2</span></span><br><span class="line">                                                         ? sti-&gt;parser-&gt;repeat_pict + <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_R_FRAME_RATE</span></span><br><span class="line">            <span class="built_in">ff_rfps_add_frame</span>(ic, st, pkt-&gt;dts);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (pkt-&gt;dts != pkt-&gt;pts &amp;&amp; pkt-&gt;dts != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">                sti-&gt;info-&gt;frame_delay_evidence = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;avctx-&gt;extradata) &#123;</span><br><span class="line">            ret = <span class="built_in">extract_extradata</span>(si, st, pkt);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> unref_then_goto_end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If still no information, we try to open the codec and to</span></span><br><span class="line"><span class="comment">         * decompress the frame. We try to avoid that in most cases as</span></span><br><span class="line"><span class="comment">         * it takes longer and uses more memory. For MPEG-4, we need to</span></span><br><span class="line"><span class="comment">         * decompress for QuickTime.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If AV_CODEC_CAP_CHANNEL_CONF is set this will force decoding of at</span></span><br><span class="line"><span class="comment">         * least one frame of codec data, this makes sure the codec initializes</span></span><br><span class="line"><span class="comment">         * the channel configuration and does not only trust the values from</span></span><br><span class="line"><span class="comment">         * the container. */</span></span><br><span class="line">        <span class="built_in">try_decode_frame</span>(ic, st, pkt,</span><br><span class="line">                         (options &amp;&amp; i &lt; orig_nb_streams) ? &amp;options[i] : <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(pkt1);</span><br><span class="line"></span><br><span class="line">        sti-&gt;codec_info_nb_frames++;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="read-frame-internal"><a href="#read-frame-internal" class="headerlink" title="read_frame_internal"></a>read_frame_internal</h4><p>当需要进行 probe 时，调用 read_frame_internal 读取数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">read_frame_internal</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    <span class="type">int</span> ret, got_packet = <span class="number">0</span>;</span><br><span class="line">    AVDictionary *metadata = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!got_packet &amp;&amp; !si-&gt;parse_queue.head) &#123;</span><br><span class="line">        AVStream *st;</span><br><span class="line">        FFStream *sti;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read next packet */</span></span><br><span class="line">        ret = <span class="built_in">ff_read_packet</span>(s, pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        st  = s-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">        sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">        st-&gt;event_flags |= AVSTREAM_EVENT_FLAG_NEW_PACKETS;</span><br><span class="line"></span><br><span class="line">        ff_read_packet里面可能会设置need_context_update，</span><br><span class="line">        因为read_packet中可能创建新的stream</span><br><span class="line">        <span class="comment">/* update context if required */</span></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;need_context_update) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">avcodec_is_open</span>(sti-&gt;avctx)) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_DEBUG, <span class="string">&quot;Demuxer context update while decoder is open, closing and trying to re-open\n&quot;</span>);</span><br><span class="line">                <span class="built_in">avcodec_close</span>(sti-&gt;avctx);</span><br><span class="line">                sti-&gt;info-&gt;found_decoder = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* close parser, because it depends on the codec */</span></span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;parser &amp;&amp; sti-&gt;avctx-&gt;codec_id != st-&gt;codecpar-&gt;codec_id) &#123;</span><br><span class="line">                <span class="built_in">av_parser_close</span>(sti-&gt;parser);</span><br><span class="line">                sti-&gt;parser = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">avcodec_parameters_to_context</span>(sti-&gt;avctx, st-&gt;codecpar);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sti-&gt;need_context_update = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;need_parsing &amp;&amp; !sti-&gt;parser &amp;&amp; !(s-&gt;flags &amp; AVFMT_FLAG_NOPARSE)) &#123;</span><br><span class="line">            sti-&gt;parser = <span class="built_in">av_parser_init</span>(st-&gt;codecpar-&gt;codec_id);</span><br><span class="line">            <span class="keyword">if</span> (!sti-&gt;parser) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_VERBOSE, <span class="string">&quot;parser not found for codec &quot;</span></span><br><span class="line">                       <span class="string">&quot;%s, packets or times may be invalid.\n&quot;</span>,</span><br><span class="line">                       <span class="built_in">avcodec_get_name</span>(st-&gt;codecpar-&gt;codec_id));</span><br><span class="line">                <span class="comment">/* no parser available: just output the raw packets */</span></span><br><span class="line">                &lt;u&gt;sti-&gt;need_parsing = AVSTREAM_PARSE_NONE;&lt;/u&gt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sti-&gt;need_parsing == AVSTREAM_PARSE_HEADERS)</span><br><span class="line">                sti-&gt;parser-&gt;flags |= PARSER_FLAG_COMPLETE_FRAMES;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sti-&gt;need_parsing == AVSTREAM_PARSE_FULL_ONCE)</span><br><span class="line">                sti-&gt;parser-&gt;flags |= PARSER_FLAG_ONCE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sti-&gt;need_parsing == AVSTREAM_PARSE_FULL_RAW)</span><br><span class="line">                sti-&gt;parser-&gt;flags |= PARSER_FLAG_USE_CODEC_TS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;need_parsing || !sti-&gt;parser) &#123;</span><br><span class="line">            <span class="comment">/* no parsing needed: we just output the packet as is */</span></span><br><span class="line">            <span class="built_in">compute_pkt_fields</span>(s, st, <span class="literal">NULL</span>, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);</span><br><span class="line">            <span class="keyword">if</span> ((s-&gt;iformat-&gt;flags &amp; AVFMT_GENERIC_INDEX) &amp;&amp;</span><br><span class="line">                (pkt-&gt;flags &amp; AV_PKT_FLAG_KEY) &amp;&amp; pkt-&gt;dts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                <span class="built_in">ff_reduce_index</span>(s, st-&gt;index);</span><br><span class="line">                <span class="built_in">av_add_index_entry</span>(st, pkt-&gt;pos, pkt-&gt;dts,</span><br><span class="line">                                   <span class="number">0</span>, <span class="number">0</span>, AVINDEX_KEYFRAME);</span><br><span class="line">            &#125;</span><br><span class="line">            got_packet = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (st-&gt;discard &lt; AVDISCARD_ALL) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">parse_packet</span>(s, pkt, pkt-&gt;stream_index, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            st-&gt;codecpar-&gt;sample_rate = sti-&gt;avctx-&gt;sample_rate;</span><br><span class="line">            st-&gt;codecpar-&gt;bit_rate = sti-&gt;avctx-&gt;bit_rate;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">av_channel_layout_copy</span>(&amp;st-&gt;codecpar-&gt;ch_layout, &amp;sti-&gt;avctx-&gt;ch_layout);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            st-&gt;codecpar-&gt;codec_id = sti-&gt;avctx-&gt;codec_id;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* free packet */</span></span><br><span class="line">            <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;flags &amp; AV_PKT_FLAG_KEY)</span><br><span class="line">            sti-&gt;skip_to_keyframe = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;skip_to_keyframe) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">            got_packet = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!got_packet &amp;&amp; si-&gt;parse_queue.head)</span><br><span class="line">        ret = <span class="built_in">avpriv_packet_list_get</span>(&amp;si-&gt;parse_queue, pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = s-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        <span class="type">int</span> discard_padding = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;first_discard_sample &amp;&amp; pkt-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">            <span class="type">int64_t</span> pts = pkt-&gt;pts - (<span class="built_in">is_relative</span>(pkt-&gt;pts) ? RELATIVE_TS_BASE : <span class="number">0</span>);</span><br><span class="line">            <span class="type">int64_t</span> sample = <span class="built_in">ts_to_samples</span>(st, pts);</span><br><span class="line">            <span class="type">int64_t</span> duration = <span class="built_in">ts_to_samples</span>(st, pkt-&gt;duration);</span><br><span class="line">            <span class="type">int64_t</span> end_sample = sample + duration;</span><br><span class="line">            <span class="keyword">if</span> (duration &gt; <span class="number">0</span> &amp;&amp; end_sample &gt;= sti-&gt;first_discard_sample &amp;&amp;</span><br><span class="line">                sample &lt; sti-&gt;last_discard_sample)</span><br><span class="line">                discard_padding = <span class="built_in">FFMIN</span>(end_sample - sti-&gt;first_discard_sample, duration);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;start_skip_samples &amp;&amp; (pkt-&gt;pts == <span class="number">0</span> || pkt-&gt;pts == RELATIVE_TS_BASE))</span><br><span class="line">            sti-&gt;skip_samples = sti-&gt;start_skip_samples;</span><br><span class="line">        sti-&gt;skip_samples = <span class="built_in">FFMAX</span>(<span class="number">0</span>, sti-&gt;skip_samples);</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;skip_samples || discard_padding) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> *p = <span class="built_in">av_packet_new_side_data</span>(pkt, AV_PKT_DATA_SKIP_SAMPLES, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                <span class="built_in">AV_WL32</span>(p, sti-&gt;skip_samples);</span><br><span class="line">                <span class="built_in">AV_WL32</span>(p + <span class="number">4</span>, discard_padding);</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_DEBUG, <span class="string">&quot;demuxer injecting skip %u / discard %u\n&quot;</span>,</span><br><span class="line">                       (<span class="type">unsigned</span>)sti-&gt;skip_samples, (<span class="type">unsigned</span>)discard_padding);</span><br><span class="line">            &#125;</span><br><span class="line">            sti-&gt;skip_samples = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;inject_global_side_data) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; st-&gt;nb_side_data; i++) &#123;</span><br><span class="line">                <span class="type">const</span> AVPacketSideData *<span class="type">const</span> src_sd = &amp;st-&gt;side_data[i];</span><br><span class="line">                <span class="type">uint8_t</span> *dst_data;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">av_packet_get_side_data</span>(pkt, src_sd-&gt;type, <span class="literal">NULL</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                dst_data = <span class="built_in">av_packet_new_side_data</span>(pkt, src_sd-&gt;type, src_sd-&gt;size);</span><br><span class="line">                <span class="keyword">if</span> (!dst_data) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(s, AV_LOG_WARNING, <span class="string">&quot;Could not inject global side data\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(dst_data, src_sd-&gt;data, src_sd-&gt;size);</span><br><span class="line">            &#125;</span><br><span class="line">            sti-&gt;inject_global_side_data = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A demuxer might have returned EOF because of an IO error, let&#x27;s</span></span><br><span class="line"><span class="comment">     * propagate this back to the user. */</span></span><br><span class="line">    <span class="keyword">if</span> (ret == AVERROR_EOF &amp;&amp; s-&gt;pb &amp;&amp; s-&gt;pb-&gt;error &lt; <span class="number">0</span> &amp;&amp; s-&gt;pb-&gt;error != <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">        ret = s-&gt;pb-&gt;error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ff-read-packet"><a href="#ff-read-packet" class="headerlink" title="ff_read_packet"></a>ff_read_packet</h5><p>这个函数会不停的 s-&gt;iformat-&gt;read_packet，同时尝试 probe_codec，直到 probe_codec 把 <code>ffstream(st)-&gt;request_probe </code> 变为 <code>&lt;=0</code> 后，才会返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_read_packet</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        PacketListEntry *pktl = si-&gt;raw_packet_buffer.head;</span><br><span class="line">        AVStream *st;</span><br><span class="line">        FFStream *sti;</span><br><span class="line">        <span class="type">const</span> AVPacket *pkt1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pktl) &#123;</span><br><span class="line">            AVStream *<span class="type">const</span> st = s-&gt;streams[pktl-&gt;pkt.stream_index];</span><br><span class="line">            <span class="keyword">if</span> (si-&gt;raw_packet_buffer_size &gt;= s-&gt;probesize)</span><br><span class="line">                <span class="keyword">if</span> ((err = <span class="built_in">probe_codec</span>(s, st, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ffstream</span>(st)-&gt;request_probe &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">avpriv_packet_list_get</span>(&amp;si-&gt;raw_packet_buffer, pkt);</span><br><span class="line">                si-&gt;raw_packet_buffer_size -= pkt-&gt;size;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = s-&gt;iformat-&gt;<span class="built_in">read_packet</span>(s, pkt);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Some demuxers return FFERROR_REDO when they consume</span></span><br><span class="line"><span class="comment">               data and discard it (ignored streams, junk, extradata).</span></span><br><span class="line"><span class="comment">               We must re-call the demuxer to get the real packet. */</span></span><br><span class="line">            <span class="keyword">if</span> (err == FFERROR_REDO)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!pktl || err == <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">                AVStream *<span class="type">const</span> st  = s-&gt;streams[i];</span><br><span class="line">                FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">                <span class="keyword">if</span> (sti-&gt;probe_packets || sti-&gt;request_probe &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> ((err = <span class="built_in">probe_codec</span>(s, st, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">                <span class="built_in">av_assert0</span>(sti-&gt;request_probe &lt;= <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">av_packet_make_refcounted</span>(pkt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">av_assert0</span>(pkt-&gt;stream_index &lt; (<span class="type">unsigned</span>)s-&gt;nb_streams &amp;&amp;</span><br><span class="line">                   <span class="string">&quot;Invalid stream index.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        st  = s-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">        sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">update_wrap_reference</span>(s, st, pkt-&gt;stream_index, pkt) &amp;&amp; sti-&gt;pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET) &#123;</span><br><span class="line">            <span class="comment">// correct first time stamps to negative values</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">is_relative</span>(sti-&gt;first_dts))</span><br><span class="line">                sti-&gt;first_dts = <span class="built_in">wrap_timestamp</span>(st, sti-&gt;first_dts);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">is_relative</span>(st-&gt;start_time))</span><br><span class="line">                st-&gt;start_time = <span class="built_in">wrap_timestamp</span>(st, st-&gt;start_time);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">is_relative</span>(sti-&gt;cur_dts))</span><br><span class="line">                sti-&gt;cur_dts = <span class="built_in">wrap_timestamp</span>(st, sti-&gt;cur_dts);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pkt-&gt;dts = <span class="built_in">wrap_timestamp</span>(st, pkt-&gt;dts);</span><br><span class="line">        pkt-&gt;pts = <span class="built_in">wrap_timestamp</span>(st, pkt-&gt;pts);</span><br><span class="line"></span><br><span class="line">        force_codec_ids(s, st);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> audio: time filter; video: frame reordering (pts != dts) */</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;use_wallclock_as_timestamps)</span><br><span class="line">            pkt-&gt;dts = pkt-&gt;pts = <span class="built_in">av_rescale_q</span>(<span class="built_in">av_gettime</span>(), AV_TIME_BASE_Q, st-&gt;time_base);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pktl &amp;&amp; sti-&gt;request_probe &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">avpriv_packet_list_put</span>(&amp;si-&gt;raw_packet_buffer,</span><br><span class="line">                                     pkt, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        pkt1 = &amp;si-&gt;raw_packet_buffer.tail-&gt;pkt;</span><br><span class="line">        si-&gt;raw_packet_buffer_size += pkt1-&gt;size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((err = &lt;u&gt;<span class="built_in">probe_codec</span>(s, st, pkt1))&lt;/u&gt; &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="probe-codec"><a href="#probe-codec" class="headerlink" title="probe_codec"></a>probe_codec</h6><p>从这个函数的逻辑可以看到，会把每一次输入的 AVPacket 的内容拷贝到 AVProbeData 中的 buf 中，当输入 pkt 为空指针时，表示进行 probe，进行 probe 后会把 sti-&gt;request_probe 置为-1，那么后面再调用 probe_codec 时会被挡住。</p>
<p>而且这次的用于 probe 的数据是分 stream 存储的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">probe_codec</span><span class="params">(AVFormatContext *s, AVStream *st, <span class="type">const</span> AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sti-&gt;request_probe &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        AVProbeData *<span class="type">const</span> pd = &amp;sti-&gt;probe_data;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        <span class="built_in">av_log</span>(s, AV_LOG_DEBUG, <span class="string">&quot;probing stream %d pp:%d\n&quot;</span>, st-&gt;index, sti-&gt;probe_packets);</span><br><span class="line">        --sti-&gt;probe_packets;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> *new_buf = <span class="built_in">av_realloc</span>(pd-&gt;buf, pd-&gt;buf_size+pkt-&gt;size+AVPROBE_PADDING_SIZE);</span><br><span class="line">            <span class="keyword">if</span> (!new_buf) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_WARNING,</span><br><span class="line">                       <span class="string">&quot;Failed to reallocate probe buffer for stream %d\n&quot;</span>,</span><br><span class="line">                       st-&gt;index);</span><br><span class="line">                <span class="keyword">goto</span> no_packet;</span><br><span class="line">            &#125;</span><br><span class="line">            pd-&gt;buf = new_buf;</span><br><span class="line">            <span class="built_in">memcpy</span>(pd-&gt;buf + pd-&gt;buf_size, pkt-&gt;data, pkt-&gt;size);</span><br><span class="line">            pd-&gt;buf_size += pkt-&gt;size;</span><br><span class="line">            <span class="built_in">memset</span>(pd-&gt;buf + pd-&gt;buf_size, <span class="number">0</span>, AVPROBE_PADDING_SIZE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">no_packet:</span><br><span class="line">            sti-&gt;probe_packets = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!pd-&gt;buf_size) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_WARNING,</span><br><span class="line">                       <span class="string">&quot;nothing to probe for stream %d\n&quot;</span>, st-&gt;index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        end = si-&gt;raw_packet_buffer_size &gt;= s-&gt;probesize</span><br><span class="line">                || sti-&gt;probe_packets &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (end || <span class="built_in">av_log2</span>(pd-&gt;buf_size) != <span class="built_in">av_log2</span>(pd-&gt;buf_size - pkt-&gt;size)) &#123;</span><br><span class="line">            <span class="type">int</span> score = <span class="built_in">set_codec_from_probe_data</span>(s, st, pd);</span><br><span class="line">            <span class="keyword">if</span> (    (st-&gt;codecpar-&gt;codec_id != AV_CODEC_ID_NONE &amp;&amp; score &gt; AVPROBE_SCORE_STREAM_RETRY)</span><br><span class="line">                || end) &#123;</span><br><span class="line">                pd-&gt;buf_size = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">av_freep</span>(&amp;pd-&gt;buf);</span><br><span class="line">                sti-&gt;request_probe = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_id != AV_CODEC_ID_NONE) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(s, AV_LOG_DEBUG, <span class="string">&quot;probed stream %d\n&quot;</span>, st-&gt;index);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">av_log</span>(s, AV_LOG_WARNING, <span class="string">&quot;probed stream %d failed\n&quot;</span>, st-&gt;index);</span><br><span class="line">            &#125;</span><br><span class="line">            force_codec_ids(s, st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>####### set_codec_from_probe_data</p>
<p>最后还是调用了 av_probe_input_format3，所以 probe 探测的就是 stream 该使用哪个 codec，具体就是确定 st-&gt;codecpar-&gt;codec_id、st-&gt;codecpar-&gt;codec_type 这几个变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">set_codec_from_probe_data</span><span class="params">(AVFormatContext *s, AVStream *st,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     AVProbeData *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">AVCodecID</span> id;</span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">AVMediaType</span> type;</span><br><span class="line">    &#125; fmt_id_type[] = &#123;</span><br><span class="line">        &#123; <span class="string">&quot;aac&quot;</span>,        AV_CODEC_ID_AAC,          AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;ac3&quot;</span>,        AV_CODEC_ID_AC3,          AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;aptx&quot;</span>,       AV_CODEC_ID_APTX,         AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;dts&quot;</span>,        AV_CODEC_ID_DTS,          AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;dvbsub&quot;</span>,     AV_CODEC_ID_DVB_SUBTITLE, AVMEDIA_TYPE_SUBTITLE &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;dvbtxt&quot;</span>,     AV_CODEC_ID_DVB_TELETEXT, AVMEDIA_TYPE_SUBTITLE &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;eac3&quot;</span>,       AV_CODEC_ID_EAC3,         AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;h264&quot;</span>,       AV_CODEC_ID_H264,         AVMEDIA_TYPE_VIDEO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;hevc&quot;</span>,       AV_CODEC_ID_HEVC,         AVMEDIA_TYPE_VIDEO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;loas&quot;</span>,       AV_CODEC_ID_AAC_LATM,     AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;m4v&quot;</span>,        AV_CODEC_ID_MPEG4,        AVMEDIA_TYPE_VIDEO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;mjpeg_2000&quot;</span>, AV_CODEC_ID_JPEG2000,     AVMEDIA_TYPE_VIDEO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;mp3&quot;</span>,        AV_CODEC_ID_MP3,          AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;mpegvideo&quot;</span>,  AV_CODEC_ID_MPEG2VIDEO,   AVMEDIA_TYPE_VIDEO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;truehd&quot;</span>,     AV_CODEC_ID_TRUEHD,       AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="number">0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="type">const</span> AVInputFormat *fmt = <span class="built_in">av_probe_input_format3</span>(pd, <span class="number">1</span>, &amp;score);</span><br><span class="line">    FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fmt) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(s, AV_LOG_DEBUG,</span><br><span class="line">               <span class="string">&quot;Probe with size=%d, packets=%d detected %s with score=%d\n&quot;</span>,</span><br><span class="line">               pd-&gt;buf_size, s-&gt;max_probe_packets - sti-&gt;probe_packets,</span><br><span class="line">               fmt-&gt;name, score);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; fmt_id_type[i].name; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(fmt-&gt;name, fmt_id_type[i].name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fmt_id_type[i].type != AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">                    st-&gt;codecpar-&gt;sample_rate)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (&lt;u&gt;sti-&gt;request_probe &gt; score&lt;/u&gt; &amp;&amp;</span><br><span class="line">                    &lt;u&gt;st-&gt;codecpar-&gt;codec_id != fmt_id_type[i].id&lt;/u&gt;)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                st-&gt;codecpar-&gt;codec_id   = fmt_id_type[i].id;</span><br><span class="line">                st-&gt;codecpar-&gt;codec_type = fmt_id_type[i].type;</span><br><span class="line">                sti-&gt;need_context_update = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> score;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="force-codec-ids"><a href="#force-codec-ids" class="headerlink" title="force_codec_ids"></a>force_codec_ids</h6><p>这个函数则是优先使用 AVFormatContext 上定义的 xxx_codec_id</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">force_codec_ids</span><span class="params">(AVFormatContext *s, AVStream *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (st-&gt;codecpar-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;video_codec_id)</span><br><span class="line">            st-&gt;codecpar-&gt;codec_id = s-&gt;video_codec_id;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;audio_codec_id)</span><br><span class="line">            st-&gt;codecpar-&gt;codec_id = s-&gt;audio_codec_id;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;subtitle_codec_id)</span><br><span class="line">            st-&gt;codecpar-&gt;codec_id = s-&gt;subtitle_codec_id;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_DATA:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;data_codec_id)</span><br><span class="line">            st-&gt;codecpar-&gt;codec_id = s-&gt;data_codec_id;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="parse-packet"><a href="#parse-packet" class="headerlink" title="parse_packet"></a>parse_packet</h5><p>这个函数就是把 demuxer 得到的 AVPacket 进行解析</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">parse_packet</span><span class="params">(AVFormatContext *s, AVPacket *pkt,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> stream_index, <span class="type">int</span> flush)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    &lt;u&gt;AVPacket *out_pkt = si-&gt;parse_pkt;&lt;/u&gt;</span><br><span class="line">    AVStream *st = s-&gt;streams[stream_index];</span><br><span class="line">    FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *data = pkt-&gt;data;</span><br><span class="line">    <span class="type">int</span> size = pkt-&gt;size;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>, got_output = flush;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!size &amp;&amp; !flush &amp;&amp; sti-&gt;parser-&gt;flags &amp; PARSER_FLAG_COMPLETE_FRAMES) &#123;</span><br><span class="line">        <span class="comment">// preserve 0-size sync packets</span></span><br><span class="line">        <span class="built_in">compute_pkt_fields</span>(s, st, sti-&gt;parser, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span> || (flush &amp;&amp; got_output)) &#123;</span><br><span class="line">        <span class="type">int64_t</span> next_pts = pkt-&gt;pts;</span><br><span class="line">        <span class="type">int64_t</span> next_dts = pkt-&gt;dts;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">        len = <span class="built_in">av_parser_parse2</span>(sti-&gt;parser, sti-&gt;avctx,</span><br><span class="line">                               &lt;u&gt;&amp;out_pkt-&gt;data&lt;/u&gt;, &lt;u&gt;&amp;out_pkt-&gt;size&lt;/u&gt;, &lt;u&gt;data&lt;/u&gt;, &lt;u&gt;size&lt;/u&gt;,</span><br><span class="line">                               pkt-&gt;pts, pkt-&gt;dts, pkt-&gt;pos);</span><br><span class="line"></span><br><span class="line">        pkt-&gt;pts = pkt-&gt;dts = AV_NOPTS_VALUE;</span><br><span class="line">        pkt-&gt;pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/* increment read pointer */</span></span><br><span class="line">        <span class="built_in">av_assert1</span>(data || !len);</span><br><span class="line">        data  = len ? data + len : data;</span><br><span class="line">        size -= len;</span><br><span class="line"></span><br><span class="line">        got_output = !!out_pkt-&gt;size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!out_pkt-&gt;size)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;buf &amp;&amp; out_pkt-&gt;data == pkt-&gt;data) &#123;</span><br><span class="line">            <span class="comment">/* reference pkt-&gt;buf only when out_pkt-&gt;data is guaranteed to point</span></span><br><span class="line"><span class="comment">             * to data in it and not in the parser&#x27;s internal buffer. */</span></span><br><span class="line">            <span class="comment">/* <span class="doctag">XXX:</span> Ensure this is the case with all parsers when sti-&gt;parser-&gt;flags</span></span><br><span class="line"><span class="comment">             * is PARSER_FLAG_COMPLETE_FRAMES and check for that instead? */</span></span><br><span class="line">            out_pkt-&gt;buf = <span class="built_in">av_buffer_ref</span>(pkt-&gt;buf);</span><br><span class="line">            <span class="keyword">if</span> (!out_pkt-&gt;buf) &#123;</span><br><span class="line">                ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = <span class="built_in">av_packet_make_refcounted</span>(out_pkt);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;side_data) &#123;</span><br><span class="line">            out_pkt-&gt;side_data       = pkt-&gt;side_data;</span><br><span class="line">            out_pkt-&gt;side_data_elems = pkt-&gt;side_data_elems;</span><br><span class="line">            pkt-&gt;side_data          = <span class="literal">NULL</span>;</span><br><span class="line">            pkt-&gt;side_data_elems    = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set the duration */</span></span><br><span class="line">        out_pkt-&gt;duration = (sti-&gt;parser-&gt;flags &amp; PARSER_FLAG_COMPLETE_FRAMES) ? pkt-&gt;duration : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;avctx-&gt;sample_rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                out_pkt-&gt;duration =</span><br><span class="line">                    <span class="built_in">av_rescale_q_rnd</span>(sti-&gt;parser-&gt;duration,</span><br><span class="line">                                     (AVRational) &#123; <span class="number">1</span>, sti-&gt;avctx-&gt;sample_rate &#125;,</span><br><span class="line">                                     st-&gt;time_base,</span><br><span class="line">                                     AV_ROUND_DOWN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out_pkt-&gt;stream_index = st-&gt;index;</span><br><span class="line">        out_pkt-&gt;pts          = sti-&gt;parser-&gt;pts;</span><br><span class="line">        out_pkt-&gt;dts          = sti-&gt;parser-&gt;dts;</span><br><span class="line">        out_pkt-&gt;pos          = sti-&gt;parser-&gt;pos;</span><br><span class="line">        out_pkt-&gt;flags       |= pkt-&gt;flags &amp; (AV_PKT_FLAG_DISCARD | AV_PKT_FLAG_CORRUPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;need_parsing == AVSTREAM_PARSE_FULL_RAW)</span><br><span class="line">            &lt;u&gt;out_pkt-&gt;pos&lt;/u&gt; = sti-&gt;parser-&gt;frame_offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;parser-&gt;key_frame == <span class="number">1</span> ||</span><br><span class="line">            (sti-&gt;parser-&gt;key_frame == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">             sti-&gt;parser-&gt;pict_type == AV_PICTURE_TYPE_I))</span><br><span class="line">            out_pkt-&gt;flags |= AV_PKT_FLAG_KEY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;parser-&gt;key_frame == <span class="number">-1</span> &amp;&amp; sti-&gt;parser-&gt;pict_type ==AV_PICTURE_TYPE_NONE &amp;&amp; (pkt-&gt;flags&amp;AV_PKT_FLAG_KEY))</span><br><span class="line">            out_pkt-&gt;flags |= AV_PKT_FLAG_KEY;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">compute_pkt_fields</span>(s, st, sti-&gt;parser, out_pkt, next_dts, next_pts);</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">avpriv_packet_list_put</span>(&amp;si-&gt;parse_queue,</span><br><span class="line">                                     out_pkt, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* end of the stream =&gt; close and free the parser */</span></span><br><span class="line">    <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">        <span class="built_in">av_parser_close</span>(sti-&gt;parser);</span><br><span class="line">        sti-&gt;parser = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">av_packet_unref</span>(out_pkt);</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="try-decode-frame"><a href="#try-decode-frame" class="headerlink" title="try_decode_frame"></a>try_decode_frame</h4><p>尝试对 packet 进行解码，说实话我也不知道这样做是为什么。但是经过调试之后发现经过 try_decode_frame 后 h264 解码器会设置 avctx-&gt;pix_fmt，而这个参数恰好是 has_codec_parameters 函数需要检查的，所以可能有些参数直到解码之后才能确定，这里尝试解码可能就是为了获得这些参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* returns 1 or 0 if or if not decoded data was returned, or a negative error */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">try_decode_frame</span><span class="params">(AVFormatContext *s, AVStream *st,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> AVPacket *avpkt, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">    AVCodecContext *<span class="type">const</span> avctx = sti-&gt;avctx;</span><br><span class="line">    <span class="type">const</span> AVCodec *codec;</span><br><span class="line">    <span class="type">int</span> got_picture = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    AVFrame *frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">    AVSubtitle subtitle;</span><br><span class="line">    AVPacket pkt = *avpkt;</span><br><span class="line">    <span class="type">int</span> do_skip_frame = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVDiscard</span> skip_frame;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">avcodec_is_open</span>(avctx) &amp;&amp;</span><br><span class="line">        sti-&gt;info-&gt;found_decoder &lt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (st-&gt;codecpar-&gt;codec_id != -sti-&gt;info-&gt;found_decoder || !st-&gt;codecpar-&gt;codec_id)) &#123;</span><br><span class="line">        AVDictionary *thread_opt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        codec = <span class="built_in">find_probe_decoder</span>(s, st, st-&gt;codecpar-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!codec) &#123;</span><br><span class="line">            sti-&gt;info-&gt;found_decoder = -st-&gt;codecpar-&gt;codec_id;</span><br><span class="line">            ret                     = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">avcodec_open2</span>(avctx, codec, options ? options : &amp;thread_opt);</span><br><span class="line">        <span class="keyword">if</span> (!options)</span><br><span class="line">            <span class="built_in">av_dict_free</span>(&amp;thread_opt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sti-&gt;info-&gt;found_decoder = -avctx-&gt;codec_id;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        sti-&gt;info-&gt;found_decoder = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!sti-&gt;info-&gt;found_decoder)</span><br><span class="line">        sti-&gt;info-&gt;found_decoder = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sti-&gt;info-&gt;found_decoder &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avpriv_codec_get_cap_skip_frame_fill_param</span>(avctx-&gt;codec)) &#123;</span><br><span class="line">        do_skip_frame = <span class="number">1</span>;</span><br><span class="line">        skip_frame = avctx-&gt;skip_frame;</span><br><span class="line">        avctx-&gt;skip_frame = AVDISCARD_ALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pkt.size &gt; <span class="number">0</span> || (!pkt.data &amp;&amp; got_picture)) &amp;&amp;</span><br><span class="line">           ret &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (!<span class="built_in">has_codec_parameters</span>(st, <span class="literal">NULL</span>) || !<span class="built_in">has_decode_delay_been_guessed</span>(st) ||</span><br><span class="line">            (!sti-&gt;codec_info_nb_frames &amp;&amp;</span><br><span class="line">             (avctx-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_CHANNEL_CONF)))) &#123;</span><br><span class="line">        got_picture = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||</span><br><span class="line">            avctx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            ret = <span class="built_in">avcodec_send_packet</span>(avctx, &amp;pkt);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != <span class="built_in">AVERROR</span>(EAGAIN) &amp;&amp; ret != AVERROR_EOF)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">                pkt.size = <span class="number">0</span>;</span><br><span class="line">            ret = <span class="built_in">avcodec_receive_frame</span>(avctx, frame);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">                got_picture = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF)</span><br><span class="line">                ret = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line">            ret = <span class="built_in">avcodec_decode_subtitle2</span>(avctx, &amp;subtitle,</span><br><span class="line">                                           &amp;got_picture, &amp;pkt);</span><br><span class="line">            <span class="keyword">if</span> (got_picture)</span><br><span class="line">                <span class="built_in">avsubtitle_free</span>(&amp;subtitle);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">                pkt.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (got_picture)</span><br><span class="line">                sti-&gt;nb_decoded_frames++;</span><br><span class="line">            ret       = got_picture;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span> (do_skip_frame) &#123;</span><br><span class="line">        avctx-&gt;skip_frame = skip_frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="part-3"><a href="#part-3" class="headerlink" title="part 3"></a>part 3</h3><p>第三部分则是一些收尾工作。</p>
<p>前面都是对 AVStream 和 AVCodecContext 上的参数做一些调整，在最后面把 AVCodecContext 的参数拷贝回 AVStream，结合前面，可以得到整个流程：</p>
<ul>
<li>首先 read_head 创建 AVStream，并往 AVStream 中设置部分信息</li>
<li>然后把 AVStream 的信息拷贝到 AVCodecContext</li>
<li>然后尝试解码，解码过程可能更新 AVCodecContext，最后再把更新过的 AVCodecContext 拷贝回 AVStream</li>
</ul>
<p>在最后又把 AVCodecContext 给关掉了，所以后面还要自己再重新创建 AVCodecContext</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (eof_reached) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flush_codecs) &#123;</span><br><span class="line">        AVPacket *empty_pkt = si-&gt;pkt;</span><br><span class="line">        <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">av_packet_unref</span>(empty_pkt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">            AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">            FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* flush the decoders */</span></span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;info-&gt;found_decoder == <span class="number">1</span>) &#123;</span><br><span class="line">                err = <span class="built_in">try_decode_frame</span>(ic, st, empty_pkt,</span><br><span class="line">                                        (options &amp;&amp; i &lt; orig_nb_streams)</span><br><span class="line">                                        ? &amp;options[i] : <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(ic, AV_LOG_INFO,</span><br><span class="line">                        <span class="string">&quot;decoding for stream %d failed\n&quot;</span>, st-&gt;index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ff_rfps_calculate</span>(ic);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        AVCodecContext *<span class="type">const</span> avctx = sti-&gt;avctx;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            <span class="keyword">if</span> (avctx-&gt;codec_id == AV_CODEC_ID_RAWVIDEO &amp;&amp; !avctx-&gt;codec_tag &amp;&amp; !avctx-&gt;bits_per_coded_sample) &#123;</span><br><span class="line">                <span class="type">uint32_t</span> tag= <span class="built_in">avcodec_pix_fmt_to_codec_tag</span>(avctx-&gt;pix_fmt);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">avpriv_pix_fmt_find</span>(PIX_FMT_LIST_RAW, tag) == avctx-&gt;pix_fmt)</span><br><span class="line">                    avctx-&gt;codec_tag= tag;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* estimate average framerate if not set by demuxer */</span></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!st-&gt;r_frame_rate.num) &#123;</span><br><span class="line">                <span class="keyword">if</span> (    avctx-&gt;time_base.den * (<span class="type">int64_t</span>) st-&gt;time_base.num</span><br><span class="line">                    &lt;= avctx-&gt;time_base.num * (<span class="type">uint64_t</span>)avctx-&gt;ticks_per_frame * st-&gt;time_base.den) &#123;</span><br><span class="line">                    <span class="built_in">av_reduce</span>(&amp;st-&gt;r_frame_rate.num, &amp;st-&gt;r_frame_rate.den,</span><br><span class="line">                              avctx-&gt;time_base.den, (<span class="type">int64_t</span>)avctx-&gt;time_base.num * avctx-&gt;ticks_per_frame, INT_MAX);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    st-&gt;r_frame_rate.num = st-&gt;time_base.den;</span><br><span class="line">                    st-&gt;r_frame_rate.den = st-&gt;time_base.num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;display_aspect_ratio.num &amp;&amp; sti-&gt;display_aspect_ratio.den) &#123;</span><br><span class="line">                AVRational hw_ratio = &#123; avctx-&gt;height, avctx-&gt;width &#125;;</span><br><span class="line">                st-&gt;sample_aspect_ratio = <span class="built_in">av_mul_q</span>(sti-&gt;display_aspect_ratio,</span><br><span class="line">                                                   hw_ratio);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!avctx-&gt;bits_per_coded_sample)</span><br><span class="line">                avctx-&gt;bits_per_coded_sample =</span><br><span class="line">                    <span class="built_in">av_get_bits_per_sample</span>(avctx-&gt;codec_id);</span><br><span class="line">            <span class="comment">// set stream disposition based on audio service type</span></span><br><span class="line">            <span class="keyword">switch</span> (avctx-&gt;audio_service_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> AV_AUDIO_SERVICE_TYPE_EFFECTS:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_CLEAN_EFFECTS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_VISUAL_IMPAIRED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_HEARING_IMPAIRED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AV_AUDIO_SERVICE_TYPE_COMMENTARY:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_COMMENT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AV_AUDIO_SERVICE_TYPE_KARAOKE:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_KARAOKE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (probesize)</span><br><span class="line">        <span class="built_in">estimate_timings</span>(ic, old_offset);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_opt_set_int</span>(ic, <span class="string">&quot;skip_clear&quot;</span>, <span class="number">0</span>, AV_OPT_SEARCH_CHILDREN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span> &amp;&amp; ic-&gt;nb_streams)</span><br><span class="line">        <span class="comment">/* We could not have all the codec parameters before EOF. */</span></span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *errmsg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* if no packet was ever seen, update context now for has_codec_parameters */</span></span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;avctx_inited) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">                st-&gt;codecpar-&gt;format == AV_SAMPLE_FMT_NONE)</span><br><span class="line">                st-&gt;codecpar-&gt;format = sti-&gt;avctx-&gt;sample_fmt;</span><br><span class="line">            ret = <span class="built_in">avcodec_parameters_to_context</span>(sti-&gt;avctx, st-&gt;codecpar);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> find_stream_info_err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">has_codec_parameters</span>(st, &amp;errmsg)) &#123;</span><br><span class="line">            <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">            <span class="built_in">avcodec_string</span>(buf, <span class="built_in">sizeof</span>(buf), sti-&gt;avctx, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">av_log</span>(ic, AV_LOG_WARNING,</span><br><span class="line">                   <span class="string">&quot;Could not find codec parameters for stream %d (%s): %s\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;Consider increasing the value for the &#x27;analyzeduration&#x27; (%&quot;</span>PRId64<span class="string">&quot;) and &#x27;probesize&#x27; (%&quot;</span>PRId64<span class="string">&quot;) options\n&quot;</span>,</span><br><span class="line">                   i, buf, errmsg, ic-&gt;max_analyze_duration, ic-&gt;probesize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">compute_chapters_end</span>(ic);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> find_stream_info_err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update the stream parameters from the internal codec contexts */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;avctx_inited) &#123;</span><br><span class="line">            ret = <span class="built_in">avcodec_parameters_from_context</span>(st-&gt;codecpar, sti-&gt;avctx);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> find_stream_info_err;</span><br><span class="line">            ret = <span class="built_in">add_coded_side_data</span>(st, sti-&gt;avctx);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> find_stream_info_err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sti-&gt;avctx_inited = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">find_stream_info_err:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;info) &#123;</span><br><span class="line">            <span class="built_in">av_freep</span>(&amp;sti-&gt;info-&gt;duration_error);</span><br><span class="line">            <span class="built_in">av_freep</span>(&amp;sti-&gt;info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">avcodec_close</span>(sti-&gt;avctx);</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> avcodec_close() frees AVOption settable fields which includes ch_layout,</span></span><br><span class="line">        <span class="comment">//        so we need to restore it.</span></span><br><span class="line">        <span class="built_in">av_channel_layout_copy</span>(&amp;sti-&gt;avctx-&gt;ch_layout, &amp;st-&gt;codecpar-&gt;ch_layout);</span><br><span class="line">        <span class="built_in">av_bsf_free</span>(&amp;sti-&gt;extract_extradata.bsf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ic-&gt;pb) &#123;</span><br><span class="line">        FFIOContext *<span class="type">const</span> ctx = <span class="built_in">ffiocontext</span>(ic-&gt;pb);</span><br><span class="line">        <span class="built_in">av_log</span>(ic, AV_LOG_DEBUG, <span class="string">&quot;After avformat_find_stream_info() pos: %&quot;</span>PRId64<span class="string">&quot; bytes read:%&quot;</span>PRId64<span class="string">&quot; seeks:%d frames:%d\n&quot;</span>,</span><br><span class="line">               <span class="built_in">avio_tell</span>(ic-&gt;pb), ctx-&gt;bytes_read, ctx-&gt;seek_count, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">unref_then_goto_end:</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(pkt1);</span><br><span class="line">    <span class="keyword">goto</span> find_stream_info_err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/05/10/ffmpeg-%E4%B9%8B-demuxer-decoder-%E7%9B%B8%E5%85%B3-api-%E4%B8%80/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
              2023-05-10 21:32:20
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="分类"></i>
                    
                    <span class="span--category">
                      <a href="/categories/ffmpeg/" title="ffmpeg">
                        <b>#</b> ffmpeg
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/05/10/ffmpeg-%E4%B9%8B-demuxer-decoder-%E7%9B%B8%E5%85%B3-api-%E4%B8%89/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#avformat-find-stream-info"><span class="toc-text">avformat_find_stream_info</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#part-1"><span class="toc-text">part 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#has-codec-parameters"><span class="toc-text">has_codec_parameters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find-probe-decoder"><span class="toc-text">find_probe_decoder</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-2"><span class="toc-text">part 2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#read-frame-internal"><span class="toc-text">read_frame_internal</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ff-read-packet"><span class="toc-text">ff_read_packet</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#probe-codec"><span class="toc-text">probe_codec</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#force-codec-ids"><span class="toc-text">force_codec_ids</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#parse-packet"><span class="toc-text">parse_packet</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-decode-frame"><span class="toc-text">try_decode_frame</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-3"><span class="toc-text">part 3</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'fg49dbpe7aWEpf8yQgZnaNlc-gzGzoHsz',
        appKey: 'zT8ZAY6u1L6753gMkaDp8hgW',
        placeholder: '说点什么吧',
        avatar: 'retro',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" href="https://github.com/Zeroneplus">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a href="https://zeroneplus.github.io/">Copyright © 2023 ZeronePlus</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        

      </div>
    </div>
  
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body>
</html>
