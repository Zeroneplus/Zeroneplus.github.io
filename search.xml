<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ffmpeg之YUV像素格式</title>
      <link href="/2023/04/26/ffmpeg%E4%B9%8BYUV%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F/"/>
      <url>/2023/04/26/ffmpeg%E4%B9%8BYUV%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍几种 YUV 像素格式。像素格式规定了图像的色彩特性，比如使用哪种颜色空间（yuv、rgb），有几个颜色分量（3 个、4 个或其他），色彩位深（8 比特、10 比特等），此外像素格式要规定每个色彩分量的存储方式（是 planar 平面 还是 packed 交错）。</p><h2 id="yuv420p"><a href="#yuv420p" class="headerlink" title="yuv420p"></a>yuv420p</h2><p>这种像素格式是最常见的格式。yuv 是指 yuv 色彩空间，420 表示采样格式，每 4 个 y 共用一个 u 和一个 v，p 表示 planar，也就是 3 个分量分平面存储。</p><p>根据 u 和 v 分量的存储顺序，yuv420p 又可以分为 YV12 和 YU12，YV12 的存储顺序是先存储 y，然后存储 v，然后存储 u，而 YU12 的存储顺序是先存储 y，然后存储 u，然后存储 v，我见过有的资料也称 YU12 为 I420。</p><p>如果每个 y u v 分量都是 8 比特位深，也就是一字节，那么对于一个 4x4 大小的图像，YV12 的存储布局如下</p><p><img src="/images/ffmpeg%E4%B9%8BYUV%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F/RPJPbvdetossyixRUkucVIP9nUb.png"></p><p>图来自 <a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv420.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv420.html</a></p><p>注意上图 cr 分量在 cb 的前面，cb、cr 的含义等同于 U、V，所以它是 YV12。</p><p>从上图可以看到，不同的平面之间紧凑排列，没有额外的间距。但如果对 Y 分量的行设定了对齐参数，比如让 Y 一行的实际存储空间所占据的字节数对齐到 16，则此时 Y 的一行末尾可能会有多余的 padding 字节用于对齐，此时 U 和 V 分量的一行也要有对齐字节，他们的 padding 字节是 Y 的 padding 字节的一半。也即不论是否发生对齐，都要满足 <code>Y一行占据的字节数=U一行占据的字节数+V一行占据的字节数</code> 这个条件。</p><p>我们看看 ffmpeg 中 yuv420p 格式的 AVPixFmtDescriptor 结构，这个结构之前有篇文章介绍了它的字段的含义，这里不再赘述，可以发现这里其实是 YU12 格式，因为 U 在前面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = &#123;</span><br><span class="line">    [AV_PIX_FMT_YUV420P] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;yuv420p&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">1</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        .flags = AV_PIX_FMT_FLAG_PLANAR,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="YUYV-和-UYVY"><a href="#YUYV-和-UYVY" class="headerlink" title="YUYV 和 UYVY"></a>YUYV 和 UYVY</h2><p>这两种格式属于交错格式，也就是所有分量在一个平面中保存，他们的采样方式是 422，也就是每两个 Y 共用一个 U 和 V。对于一个 4x4 的图像，YUYV 格式存储布局如下：</p><p><img src="/images/ffmpeg%E4%B9%8BYUV%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F/Ps83b0Jvhofjv7xf3YQcGlihnef.png"></p><p>图来自 <a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuyv.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuyv.html</a></p><p>它的存储布局就像它的名字一样，按 Y U Y V 这样的存储顺序，这样恰好就是两个 Y 共用一个 U 和 V。类似的如果是 UYVY，那么就是 U Y V Y 这样的存储顺序。</p><p>类似的还有 YVYU、VYUY 存储格式，原理和上面一样，就是分量存储顺序变了一下。</p><p>ffmpeg 中 yuyv 格式的描述符如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = &#123;</span><br><span class="line">...</span><br><span class="line">    [AV_PIX_FMT_YUYV422] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;yuyv422&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">0</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="yuv422p"><a href="#yuv422p" class="headerlink" title="yuv422p"></a>yuv422p</h2><p>从这个格式的名字就知道，它是 422 采样，也就是两个 Y 共用一个 U 和 V，和上面 YUYV 一样，但是他多了一个 p，表示不是交错存储，而是分别存储每个分量。这里就不多介绍，直接看例子，对于一个 4x4 的图像，yuv422p 存储顺序如下：</p><p><img src="/images/ffmpeg%E4%B9%8BYUV%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F/GYobbbRRWoYLhmxrLDGcMsMynxf.png"></p><p>图来自 <a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv422p.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv422p.html</a></p><p>yuv422p 和 yuv420p 一样，如果 Y 的行宽进行了对齐处理，那么 U、V 也要有 padding byte，依然要求 <code>Y一行占据的字节数=U一行占据的字节数+V一行占据的字节数</code></p><p>yuv422p 的描述符如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    [AV_PIX_FMT_YUV422P] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;yuv422p&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">0</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        .flags = AV_PIX_FMT_FLAG_PLANAR,</span><br><span class="line">    &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="yuv420sp"><a href="#yuv420sp" class="headerlink" title="yuv420sp"></a>yuv420sp</h2><p>这种格式和 yuv420p 的区别是：yuv420sp 用两个平面来存储分量，即让 Y 分量一个平面，让 UV 分量共用一个平面。根据 UV 平面的存储顺序，又可以区分为 NV12 和 NV21 两种格式，NV12 的存储布局如下</p><p><img src="/images/ffmpeg%E4%B9%8BYUV%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F/GTHob863YoWak6xt29lcmI2gnQc.png"></p><p>图来自 <a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-nv12.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-nv12.html</a></p><p>所以 NV12 的 UV 平面是按照 U V U V 这样的存储顺序，而且可以发现，UV 平面的宽度和 Y 平面是一样的，此时如果 Y 平面的行宽有对齐要求，那么 UV 平面的 padding 字节和 Y 平面一样，就不再是 YV12&#x2F;YU12 时的一半了。</p><p>NV21 和 NV12 的区别是 UV 平面按照 V U V U 这样的顺序进行存储。</p><p>NV21 和 NV12 描述符如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[AV_PIX_FMT_NV12] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;nv12&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">1</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        .flags = AV_PIX_FMT_FLAG_PLANAR,</span><br><span class="line">    &#125;,</span><br><span class="line">    [AV_PIX_FMT_NV21] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;nv21&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">1</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        .flags = AV_PIX_FMT_FLAG_PLANAR,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>关于 yuv 像素格式就介绍到这里，像素格式本身并不复杂，就是各种名字眼花缭乱，同一种存储格式可能有不同的叫法，重点是要弄清楚不同格式它的存储方式是什么，这样遇到某个没见过的格式时看他的存储方式也能弄清楚它的含义是什么。</p><p>参考资料：</p><p><a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv420.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv420.html</a></p><p><a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuyv.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuyv.html</a></p><p><a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv422p.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv422p.html</a></p><p><a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-nv12.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-nv12.html</a></p><p><a href="https://blog.csdn.net/teachermei/article/details/127650824">https://blog.csdn.net/teachermei/article/details/127650824</a></p><p><a href="https://blog.csdn.net/yu540135101/article/details/107121769">https://blog.csdn.net/yu540135101/article/details/107121769</a></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> 媒体格式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 gdb 进行调试（初级）</title>
      <link href="/2023/04/26/%E4%BD%BF%E7%94%A8-gdb-%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/"/>
      <url>/2023/04/26/%E4%BD%BF%E7%94%A8-gdb-%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近使用了 gdb 对程序进行调试，使用体验非常好，有种相见恨晚的感觉。其实之前就知道这个工具，但是它是命令行工具没有图形界面，心里有种畏惧感所以一直没有使用。</p><p>使用 gdb 调试比之前加 log 调试要舒服太多了，后面进行调试时要以 gdb 调试为主，加 log 为辅助手段。这篇文章就简要记录一下目前用到的 gdb 调试方法，后面用到更高级的调试方法会继续更新。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>要想使用 gdb 进行调试，程序编译时必须带 <code>-g</code> 选项，比如 <code>gcc main.c -o main -g</code></p><p>启动调试，可以直接 <code>gdb exefile</code>，也可以先进入 gdb 然后在 gdb 命令行内执行 <code>file exefile</code> 来加载可执行文件，如果可执行文件是可调试的，那么会出现 <code>Reading symbols from xxx...done.</code></p><p>通过 run 命令开始执行程序，run 的简写为 r。如果没有设断点，run 之后会一直执行到程序结束。如果程序有命令行参数，则可在 run 的后面指定</p><p>除了 run 还可以通过 start 指令让程序开始运行，但是 start 会停在程序的 main 函数的最开始</p><p>设置断点通过 break 指令，简写为 b。设置断点可以是文件名加行号的方式，如 <code>b filename.c:122</code>，这适合工程很大，源文件很多的情况。还可以设置条件断点，让程序只有在一定条件下才会停下：<code>b filename.c:122 condition</code>，这个我没有使用过，就不细说。</p><p>查看断点是通过 <code>info breakpoints</code>，删除断点通过 <code>delete breakpoint_num</code>，<code>breakpoint_num</code> 是 <code>info breakpoints</code> 时打印出的 <code>Num</code></p><p>info 指令有很多子选项，比如 <code>info locals</code> 可以查看当前函数中的局部变量，<code>info frame</code> 查看当前函数调用栈，更多功能可以在 gdb 命令行中输入 info 查看</p><p>查看断点附近源码，通过 <code>list</code> 命令，简写为 <code>l</code>，这个功能我也很少用，基本上都是对着源码调试</p><p>查看当前函数调用栈通过 backtrace 指令，简写为 bt，这个指令也非常有用，可以方便的查看当前函数的调用层次，对于复杂的工程通过 bt 可以很快确定函数调用逻辑</p><p>单步调试通过 next 命令，简写为 n，每一个 next 会执行当前上下文&#x2F;函数单元内的一条语句，比如某个语句是函数调用，那么 next 会执行这个函数，而不会进入到函数里面，再比如某个 <code>if (statement)</code> 的 <code>statement</code> 是复杂的语句，那么 next 会执行整个 <code>statement</code>。还可以在 next 后面加数字，比如 <code>n 2</code>，表示往后执行两条语句再停下。next 在分析复杂函数的执行流程时很有用，通过 next 可以清晰的看到程序的每个 if 分支走了哪里。</p><p>单步调试的另一个指令是 step，这个指令比 next 要更细一些，他遇到函数时会进入函数，要想从函数中返回，即跳过后面的语句，可以通过 finish 指令，finish 会从当前函数调用点返回，并在下一条语句处停住</p><p>continue 指令是让程序执行到下个断点，简写为 c</p><p>skip 指令可以指定某个函数在 step 时不会进入，比如 <code>skip function hello</code>，那么在 step 时遇到 hello 函数将不会进入</p><p>查看变量通过 print 指令，简写为 p，比如 <code>p var</code>，如果 var 是 char 类型指针，那么 p 会把字符串内容打印出来。如果 var 是 int 类型指针，那么可以对他解引用然后打印 <code>p *var</code></p><p>除了查看变量，还可以设置变量，通过 set 指令，但是目前我还没有使用过这个变量，这里略过，等用到了再介绍</p><p>最后要退出调试可以通过 quit 指令，简写为 q</p><h2 id="value-optimized-out"><a href="#value-optimized-out" class="headerlink" title="value optimized out"></a>value optimized out</h2><p>使用 gdb 调试时，打印变量时可能会出现 <code>$30 = &lt;value optimized out&gt;</code> 的提示，这是因为编译器在编译时开了优化 <code>gcc -O3</code>，把变量优化掉了。</p><p>此时可以关闭优化使用 <code>gcc -O0</code> 重新编译，也可以使用加 log 方法进行辅助。新版本的 gcc 有个优化选项 <code>gcc -Og</code>，这个优化选项的意思是在不影响 debug 的前提下尽可能去做优化（但是这个选项可能还是会出现 <code>value optimized out</code>，此时使用 <code>gcc -O0</code>）。除了上面的思路，还可以给变量加 volatile 限定，编译器不会对被这个限定符修饰的变量做优化，但是其他变量的优化还是会做的。</p><p>除了优化导致 <code>value optimized out</code>，还可能由于变量覆盖导致 <code>value optimized out</code>，对于变量被覆盖时如何查看变量请参见 <a href="https://stackoverflow.com/questions/5497855/what-does-value-optimized-out-mean-in-gdb">What does <value optimized out> mean in gdb?</a> 。</p><p>参考资料：</p><p><a href="https://blog.csdn.net/chen1415886044/article/details/105094688">https://blog.csdn.net/chen1415886044/article/details/105094688</a></p><p><a href="https://stackoverflow.com/questions/5497855/what-does-value-optimized-out-mean-in-gdb">What does <value optimized out> mean in gdb?</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>auto和decltype</title>
      <link href="/2023/04/26/auto%E5%92%8Cdecltype/"/>
      <url>/2023/04/26/auto%E5%92%8Cdecltype/</url>
      
        <content type="html"><![CDATA[<p>auto 和 decltype 是 C++ 的类型推导工具，利用好这两个工具能方便平时的编码工作。这篇博客总结一下自己对于 auto 和 decltype 的理解。</p><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>auto 推导出现在变量定义中，通过赋值语句右边的值的类型来推断左边要定义的变量的类型。</p><p>广义上变量定义包括显式的变量定义语句和函数的参数传递，所以模板函数的模板参数推断和变量定义语句中的 auto 推导的原理是一致的，下面介绍的关于 auto 推导的原理也适用于模板函数的模板参数推断。</p><p>先看不带任何修饰的 auto 推导。当 auto 不带任何修饰时，会把右边的变量类型经过退化（decay）后得到的类型作为 auto 的类型，退化操作包括：</p><ul><li>去掉引用</li><li>去掉顶层 const</li><li>数组自动转换为指针、函数名自动转换为指针</li></ul><p>看下面几个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i , &amp;j = i;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> k, &amp;l = k;</span><br><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> b = j; <span class="comment">// 去掉引用                 auto为int</span></span><br><span class="line"><span class="keyword">auto</span> b = k; <span class="comment">// 去掉顶层const            auto为int</span></span><br><span class="line"><span class="keyword">auto</span> b = l; <span class="comment">// 去掉引用、去掉顶层const    auto为int</span></span><br><span class="line"><span class="keyword">auto</span> b = a; <span class="comment">// 数组自动转换为指针         auto为char*</span></span><br></pre></td></tr></table></figure><p>第一条操作：去掉引用。这个很好理解，因为如果右边是引用，那么应当将右边变量视为被他引用的变量，这是引用的语义，引用是变量的别名。右边是引用并不意味着左边要定义的变量也是引用，将左边推断为引用显然是不合理的</p><p>第二条操作：去掉顶层 const。由于 auto 没有加任何修饰符，那么此时不会把左边推断为引用，所以是值传递，既然是值传递，那么右边是否是顶层 const 对左边也没有影响，同样右边是 const 并不意味着左边也是 const</p><p>第三条操作：假设右边是一个数组，如果 auto 推断时不进行数组转换为指针，那么左边推断得到的类型也是数组，就出现了数组赋值给数组的操作。这个操作在原有的 C++ 赋值规则中是不允许的，所以要进行转换，语言的设计要满足一致性，新引入的规则不应该和已有的规则矛盾。函数名自动转换为指针也类似。</p><p>再看带修饰的 auto 推导。先看不带&amp;的情况，此时和上面不带任何修饰的 auto 推导没有本质区别，给 auto 加非引用修饰只是表示我们能确定左边类型的部分信息，看下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> * i = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">auto</span> t = i; <span class="comment">// auto是int const *</span></span><br><span class="line"><span class="keyword">auto</span> * s = i; <span class="comment">// auto是int const</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> * k = i; <span class="comment">// auto是int</span></span><br></pre></td></tr></table></figure><p>所以此时还是会对右边类型进行退化处理，然后将退化后的类型“减去”左边的已知部分得到 auto。此时 auto 就像一个<strong>占位符</strong>一样。</p><p>带修饰的 auto 推导和不带修饰的 auto 推导还是有一点区别：带修饰的 auto 推导可以显式的添加 const 来把变量声明为顶层 const，但是不带修饰的 auto 由于类型退化不可能推断得到顶层 const；此外带修饰的 const 还可以让左边类型比右边类型更严格，比如加上额外的 const 修饰</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> i = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> *<span class="type">const</span> k = i; <span class="comment">// 左边类型比右边更严格</span></span><br></pre></td></tr></table></figure><p>最后分析带&amp;的 auto 推导。给 auto 加上&amp;修饰后，表示左边想要定义一个引用，那么此时还需要对右边类型做退化吗？</p><p>首先，引用要去掉，因为始终应该把右边的引用视为他绑定的对象，也就是右边的类型应该追溯到真正对象的类型，这一点在所有 auto 推导中都是一样的</p><p>那剩余两个操作，去掉 const 和自动转换是否要执行呢？显然是不可以的，因为此时定义的是引用，而引用的语义是变量的别名，做了自动转换后引用指向的是转换后的类型，显然是错误的。看下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> i = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp; t = i; <span class="comment">// auto是int *const，不能去掉const</span></span><br><span class="line">             <span class="comment">// 如果去掉const， 那么t是int *&amp;，一个非const绑定到const，非法</span></span><br></pre></td></tr></table></figure><p>所以带&amp;的 auto 推导不会执行退化的后两步，而是把右边类型去除引用后加上左边修饰的引用组成一个引用类型。</p><p>再看几个例子加深一下印象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> b = a; <span class="comment">// b 是int*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; c = a; <span class="comment">// auto是int[3]，b是 int(&amp;)[3]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> d = f; <span class="comment">// auto是函数指针 int(*)()</span></span><br><span class="line"><span class="keyword">auto</span>&amp; e = f; <span class="comment">// auto是函数类型，e是函数引用</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i; <span class="comment">// j是int类型</span></span><br><span class="line"><span class="keyword">auto</span>&amp; k = i; <span class="comment">// k是int const&amp;类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* <span class="type">const</span> p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">auto</span> q = p; <span class="comment">// q是int const*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; r = p; <span class="comment">// q是int const* const &amp;</span></span><br></pre></td></tr></table></figure><p>最后来看看 auto &amp;&amp;。auto &amp;&amp;被称为万能引用，他和模板函数中 T&amp;&amp;是一样的，可以接受左值或者右值参数，看下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; a = <span class="number">1</span>; <span class="comment">// 接受右值 auto是int，a是int&amp;&amp;类型</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; c = b; <span class="comment">// 接受左值，auto是int&amp;，根据引用折叠，c是int&amp;类型</span></span><br></pre></td></tr></table></figure><p>auto&amp;&amp;推断时</p><ul><li>如果右边是左值，先按照 auto&amp;进行推断，推断得到 auto 后，在 auto 右边加一个&amp;组合成新的 auto，然后将这个新 auto 和&amp;&amp;组合，所以实际的类型是 auto&amp; &amp;&amp;，这里的 auto 是按照常规的 auto&amp;进行推断得到的，而&amp; &amp;&amp;最终会折叠为&amp;，所以当右边是左值时 audo&amp;&amp;等价于 auto&amp;</li><li>如果右边是右值（包括纯右值和将亡值），先按照常规的 auto&amp;进行推断，推断得到 auto 之后不做处理，直接和&amp;&amp;组合，所以最后的类型是 auto &amp;&amp;</li></ul><p>auto&amp;&amp;推断时，右边类型也不会做退化的后两步，因为也是引用推断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> &amp;&amp; j = i; <span class="comment">// auto是 int const&amp;, j经过折叠是int const&amp;</span></span><br></pre></td></tr></table></figure><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>decltype 是另一种类型推导工具，他对表达式、变量进行推导，把表达式结果的类型、变量的类型作为自己的结果。</p><p>如果 decltype 中只有单个变量，那么 decltype 推断得到的类型就是该变量在源码定义时的类型，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) k = i; <span class="comment">// k是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) k = i; <span class="comment">// k是int const类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* <span class="type">const</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) k = i; <span class="comment">// k是int const* const类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) k = i; <span class="comment">// k是int &amp;&amp;类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) k = i; <span class="comment">// k是int &amp;类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> A a;</span><br><span class="line"><span class="keyword">decltype</span>(a.i) k = i; <span class="comment">// k是int类型，不是const int</span></span><br></pre></td></tr></table></figure><p>注意‘单个变量’包含 <code>a-&gt;b, a.b</code> 这种形式</p><p>所有其他的情况，decltype 推断规则如下：假设 decltype 中的表达式的类型为 T</p><ul><li>如果 decltype 中的表达式结果是左值，那么 decltype 推断得到的类型是 T&amp;</li><li>如果 decltype 中的表达式结果是将亡值，那么 decltype 推断得到的类型是 T&amp;&amp;</li><li>如果 decltype 中的表达式结果是纯右值，那么 decltype 推断得到的类型是 T</li></ul><p>左值、将亡值、纯右值的概念可以参见另一篇文章。</p><p>我们通过具体例子分析上面的规则。</p><p>第一条规则。<code>++p</code> 返回的是引用，即 <code>int *&amp;</code>，是左值，所以 decltype 推断是 <code>int *&amp; &amp;</code>，折叠得到 <code>int *&amp;</code>。<code>p[0]</code> 返回的也是引用，即 <code>int&amp;</code>，decltype 推断是 <code>int &amp; &amp;</code>，折叠得到 <code>int &amp;</code>。<code>f2()</code> 返回的也是引用，即 <code>int&amp;</code>，是左值，decltype 推断是 <code>int &amp; &amp;</code>，折叠得到 <code>int &amp;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="keyword">decltype</span>(++p) <span class="comment">// int *&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(p[<span class="number">0</span>]) <span class="comment">// int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f2</span>()) <span class="comment">// int&amp;</span></span><br></pre></td></tr></table></figure><p>第二条规则。<code>f1()</code> 返回将亡值，所以 decltype 推断得到 <code>int&amp;&amp; &amp;&amp;</code>，折叠得到 <code>int&amp;&amp;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f1</span>()) <span class="comment">/// int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>第三条规则。<code>i+0</code> 返回纯右值，是 int 类型，所以 decltype 推断得到 int</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i+<span class="number">0</span>)  <span class="comment">// int</span></span><br></pre></td></tr></table></figure><p>在 decltype 中最让人迷惑的是括号对 decltype 推断的影响。</p><p>括号运算符本身不对括号内表达式结果的属性做任何修改，就好像没有括号一样，如果括号内表达式是左值、将亡值、纯右值，那么括号表达式的结果也是左值、将亡值、纯右值，但是有了括号之后就是表达式了，不能再使用之前单个变量的推导规则（哪怕括号内只有一个变量）。</p><p>还是通过具体例子分析括号对 decltype 推断的影响。</p><p>下面的例子中，对单个变量加了括号，此时 decltype 内部表达式的类型还是 <code>int</code> <code>int&amp;</code> <code>int&amp;&amp;</code>，但是加了括号之后需要按表达式的规则进行推断，由于他们都是左值（括号不会改变内部表达式结果的值属性），所以要加&amp;，即 <code>int&amp;</code> <code>int&amp; &amp;</code> <code>int&amp;&amp; &amp;</code>，经过折叠就是 <code>int&amp;</code> <code>int&amp;</code> <code>int&amp;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp; j = i;</span><br><span class="line"><span class="type">int</span>&amp;&amp; k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>((i))  <span class="comment">// int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>((j))  <span class="comment">// int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>((k))  <span class="comment">// int&amp;</span></span><br></pre></td></tr></table></figure><p>下面例子则展示了括号对 <code>a.b</code> 推断的影响，此时要把 a 的类型考虑在内，即 <code>a.i</code> 得到 <code>int const&amp;</code> 类型，因为 a 是 const，而 <code>.</code> 运算符返回引用，最后 decltype 是 <code>int const&amp; &amp;</code>，折叠得到 <code>int const&amp;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> A a;</span><br><span class="line"><span class="keyword">decltype</span>((a.i)) k = i; <span class="comment">// k是int const&amp;类型</span></span><br></pre></td></tr></table></figure><p>下面的例子中，f1()返回将亡值，括号之后还是将亡值，decltype 推断时会加&amp;&amp;，即 <code>int&amp;&amp; &amp;&amp;</code>，折叠后就是 <code>int&amp;&amp;</code>，f2()返回左值引用，括号之后还是左值引用，decltype 推断时会加&amp;，即 <code>int&amp; &amp;</code>，折叠后就是 <code>int&amp;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>((<span class="built_in">f1</span>())) <span class="comment">// int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>((<span class="built_in">f2</span>())) <span class="comment">// int&amp;</span></span><br></pre></td></tr></table></figure><p>括号遇到纯右值的情况比较简单，就好像没有括号一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((<span class="number">1</span>+i)) <span class="comment">// int</span></span><br><span class="line"><span class="keyword">decltype</span>((<span class="number">1</span>))   <span class="comment">// int</span></span><br></pre></td></tr></table></figure><p>最后注意 decltype 推断时不需要像 auto 一样做退化处理，上面分析时是没有对表达式结果的类型做退化处理的。</p><p>参考资料：</p><p><a href="https://magodo.github.io/cpp-auto-decltype/">https://magodo.github.io/cpp-auto-decltype/</a></p><p><a href="http://thbecker.net/articles/auto_and_decltype/section_01.html">http://thbecker.net/articles/auto_and_decltype&#x2F;section_01.html</a></p><p><a href="https://learn.microsoft.com/en-us/cpp/cpp/decltype-cpp?view=msvc-170">https://learn.microsoft.com/en-us/cpp/cpp/decltype-cpp?view=msvc-170</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++新特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg AVFrame buffer的分配与对齐</title>
      <link href="/2023/04/23/ffmpeg-AVFrame-buffer%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%AF%B9%E9%BD%90/"/>
      <url>/2023/04/23/ffmpeg-AVFrame-buffer%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<p>之前有篇文章介绍了 AVFrame 的一些基本方法，最近遇到了需要确认 AVFrame 中数据的 stride 是否对齐的问题，于是又回过头去把 AVFrame 内存分配过程研究了一下，这篇文章就介绍一下 AVFrame buffer 的分配与对齐。</p><p>在通过 <code>AVFrame *av_frame_alloc(void)</code> 函数分配 AVFrame 之后，需要通过 av_frame_get_buffer 函数分配用于存储 YUV 或者 RGB 格式图像的内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_frame_get_buffer</span><span class="params">(AVFrame *frame, <span class="type">int</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;format &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;width &gt; <span class="number">0</span> &amp;&amp; frame-&gt;height &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_video_buffer</span>(frame, align);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (frame-&gt;nb_samples &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             (<span class="built_in">av_channel_layout_check</span>(&amp;frame-&gt;ch_layout)</span><br><span class="line">...</span><br><span class="line">             ))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_audio_buffer</span>(frame, align);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_frame_get_buffer 函数内部调用 get_video_buffer 函数，下面就以 get_video_buffer 函数为研究对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_video_buffer</span><span class="params">(AVFrame *frame, <span class="type">int</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVPixFmtDescriptor *desc = <span class="built_in">av_pix_fmt_desc_get</span>(frame-&gt;format);</span><br><span class="line">    <span class="type">int</span> ret, i, padded_height, total_size;</span><br><span class="line">    <span class="type">int</span> plane_padding = <span class="built_in">FFMAX</span>(<span class="number">16</span> + <span class="number">16</span><span class="comment">/*STRIDE_ALIGN*/</span>, align);</span><br><span class="line">    <span class="type">ptrdiff_t</span> linesizes[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> sizes[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!desc)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_check_size</span>(frame-&gt;width, frame-&gt;height, <span class="number">0</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;linesize[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (align &lt;= <span class="number">0</span>)</span><br><span class="line">            align = <span class="number">32</span>; <span class="comment">/* STRIDE_ALIGN. Should be av_cpu_max_align() */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=align; i+=i) &#123;</span><br><span class="line">            ret = <span class="built_in">av_image_fill_linesizes</span>(frame-&gt;linesize, frame-&gt;format,</span><br><span class="line">                                          <span class="built_in">FFALIGN</span>(frame-&gt;width, i));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(frame-&gt;linesize[<span class="number">0</span>] &amp; (align<span class="number">-1</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span> &amp;&amp; frame-&gt;linesize[i]; i++)</span><br><span class="line">            frame-&gt;linesize[i] = <span class="built_in">FFALIGN</span>(frame-&gt;linesize[i], align);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        linesizes[i] = frame-&gt;linesize[i];</span><br><span class="line"></span><br><span class="line">    padded_height = <span class="built_in">FFALIGN</span>(frame-&gt;height, <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_fill_plane_sizes</span>(sizes, frame-&gt;format,</span><br><span class="line">                                         padded_height, linesizes)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    total_size = <span class="number">4</span>*plane_padding;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sizes[i] &gt; INT_MAX - total_size)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        total_size += sizes[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame-&gt;buf[<span class="number">0</span>] = <span class="built_in">av_buffer_alloc</span>(total_size);</span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_fill_pointers</span>(frame-&gt;data, frame-&gt;format, padded_height,</span><br><span class="line">                                      frame-&gt;buf[<span class="number">0</span>]-&gt;data, frame-&gt;linesize)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;data[i])</span><br><span class="line">            frame-&gt;data[i] += i * plane_padding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame-&gt;extended_data = frame-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AVPixFmtDescriptor"><a href="#AVPixFmtDescriptor" class="headerlink" title="AVPixFmtDescriptor"></a>AVPixFmtDescriptor</h2><p>上面函数的第一步是查找 AVPixFmtDescriptor，AVPixFmtDescriptor 中有格式的存储信息，这些信息配合宽度高度可以计算需要多大的存储空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVPixFmtDescriptor</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">uint8_t</span> nb_components;  <span class="comment">///&lt; The number of components each pixel has, (1-4)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Amount to shift the luma width right to find the chroma width.</span></span><br><span class="line"><span class="comment">     * For YV12 this is 1 for example.</span></span><br><span class="line"><span class="comment">     * chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w)</span></span><br><span class="line"><span class="comment">     * The note above is needed to ensure rounding up.</span></span><br><span class="line"><span class="comment">     * This value only refers to the chroma components.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint8_t</span> log2_chroma_w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Amount to shift the luma height right to find the chroma height.</span></span><br><span class="line"><span class="comment">     * For YV12 this is 1 for example.</span></span><br><span class="line"><span class="comment">     * chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h)</span></span><br><span class="line"><span class="comment">     * The note above is needed to ensure rounding up.</span></span><br><span class="line"><span class="comment">     * This value only refers to the chroma components.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint8_t</span> log2_chroma_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Combination of AV_PIX_FMT_FLAG_... flags.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint64_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Parameters that describe how pixels are packed.</span></span><br><span class="line"><span class="comment">     * If the format has 1 or 2 components, then luma is 0.</span></span><br><span class="line"><span class="comment">     * If the format has 3 or 4 components:</span></span><br><span class="line"><span class="comment">     *   if the RGB flag is set then 0 is red, 1 is green and 2 is blue;</span></span><br><span class="line"><span class="comment">     *   otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If present, the Alpha channel is always the last component.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVComponentDescriptor comp[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alternative comma-separated names.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *alias;</span><br><span class="line">&#125; AVPixFmtDescriptor;</span><br></pre></td></tr></table></figure><ul><li><code>nb_components</code> 当前格式有多少个分量</li><li><code>log2_chroma_w</code> 色度分量的宽度 &#x3D; 亮度分量的宽度 &gt;&gt; log2_chroma_w，比如 yuv420p 格式，U、V 分量的宽度是 Y 分量的宽度的一半，那这个值就是 1</li><li><code>log2_chroma_h</code> 色度分量的高度 &#x3D; 亮度分量的高度 &gt;&gt; log2_chroma_w，和上面一样，比如 YUV420 格式，U、V 分量的宽度是 Y 分量的宽度的一半，那这个值就是 1</li><li><code>AVComponentDescriptor</code> 是对每个不同分量的存储信息的描述</li></ul><p>AVComponentDescriptor 结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVComponentDescriptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Which of the 4 planes contains the component.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> plane;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of elements between 2 horizontally consecutive pixels.</span></span><br><span class="line"><span class="comment">     * Elements are bits for bitstream formats, bytes otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of elements before the component of the first pixel.</span></span><br><span class="line"><span class="comment">     * Elements are bits for bitstream formats, bytes otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of least significant bits that must be shifted away</span></span><br><span class="line"><span class="comment">     * to get the value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of bits in the component.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">&#125; AVComponentDescriptor;</span><br></pre></td></tr></table></figure><ul><li><code>plane</code> 当前分量在那个平面上，比如 yuv420p 就分三个平面来存储不同的分量，那么 plane 分别是 0 1 2，而 yuyv422 是把三个分量在一个平面上存储，那么 plane 分别是 0 0 0</li><li><code>step</code> 水平方向相邻两个像素点之间距离的字节数（如果是比特流类型则是比特数），注意他指的是相同分量的像素点，对于 yuv420p 这种分平面的格式来说，step 是 1 1 1，对 yuyv422 这种交错存储在一个平面的格式，step 是 2 4 4，因为他的存储格式是先保存一个像素点的 YUV 再保存下一个像素点的 YUV，比如 y u y v y u y v …，可以看到 y 之间相差两字节，u 和 v 都是相差 4 字节</li><li><code>offset</code> 分量的第一个像素离起始地址的偏移，以上面的 yuyv422 交错存储格式，y 的 offset 是 0，u 的 offset 是 1，v 的 offset 是 3</li><li><code>shift</code> 这个参数一般用在非 8 比特的格式</li><li><code>depth</code> 像素的位深，比如 8 比特、10 比特</li></ul><p>具体看看 yuv420p 和 yuyv422 的 AVPixFmtDescriptor</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = &#123;</span><br><span class="line">    [AV_PIX_FMT_YUV420P] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;yuv420p&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">1</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        .flags = AV_PIX_FMT_FLAG_PLANAR,</span><br><span class="line">    &#125;,</span><br><span class="line">    [AV_PIX_FMT_YUYV422] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;yuyv422&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">0</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>了解了具体格式后再看剩下的代码。</p><p>av_image_check_size 函数就是检查宽高是否合理，不再赘述。</p><p>av_image_fill_linesizes 函数则是计算每个平面的 linesize，linesize 就是行宽，很多编码器都要求输入 frame 的 linesize 对齐到 16 或者 32，经过对齐之后的 linesize 一般不等于图像的宽度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_image_fill_linesizes</span><span class="params">(<span class="type">int</span> linesizes[<span class="number">4</span>], <span class="keyword">enum</span> AVPixelFormat pix_fmt, <span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line">    <span class="type">const</span> AVPixFmtDescriptor *desc = <span class="built_in">av_pix_fmt_desc_get</span>(pix_fmt);</span><br><span class="line">    <span class="type">int</span> max_step     [<span class="number">4</span>];       <span class="comment">/* max pixel step for each plane */</span></span><br><span class="line">    <span class="type">int</span> max_step_comp[<span class="number">4</span>];       <span class="comment">/* the component for each plane which has the max pixel step */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(linesizes, <span class="number">0</span>, <span class="number">4</span>*<span class="built_in">sizeof</span>(linesizes[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!desc || desc-&gt;flags &amp; AV_PIX_FMT_FLAG_HWACCEL)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_image_fill_max_pixsteps</span>(max_step, max_step_comp, desc);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = <span class="built_in">image_get_linesize</span>(width, i, max_step[i], max_step_comp[i], desc)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        linesizes[i] = ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_image_fill_linesizes 先通过 av_image_fill_max_pixsteps 获取相邻像素间的 step，其实就是上面 AVComponentDescriptor 中的 step</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_image_fill_max_pixsteps</span><span class="params">(<span class="type">int</span> max_pixsteps[<span class="number">4</span>], <span class="type">int</span> max_pixstep_comps[<span class="number">4</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> AVPixFmtDescriptor *pixdesc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">memset</span>(max_pixsteps, <span class="number">0</span>, <span class="number">4</span>*<span class="built_in">sizeof</span>(max_pixsteps[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span> (max_pixstep_comps)</span><br><span class="line">        <span class="built_in">memset</span>(max_pixstep_comps, <span class="number">0</span>, <span class="number">4</span>*<span class="built_in">sizeof</span>(max_pixstep_comps[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">const</span> AVComponentDescriptor *comp = &amp;(pixdesc-&gt;comp[i]);</span><br><span class="line">        <span class="keyword">if</span> (comp-&gt;step &gt; max_pixsteps[comp-&gt;plane]) &#123;</span><br><span class="line">            max_pixsteps[comp-&gt;plane] = comp-&gt;step;</span><br><span class="line">            <span class="keyword">if</span> (max_pixstep_comps)</span><br><span class="line">                max_pixstep_comps[comp-&gt;plane] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过 image_get_linesize 计算未对齐时的 linesize</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">image_get_linesize</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> plane,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">int</span> max_step, <span class="type">int</span> max_step_comp,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> AVPixFmtDescriptor *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s, shifted_w, linesize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!desc)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (width &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    s = (max_step_comp == <span class="number">1</span> || max_step_comp == <span class="number">2</span>) ? desc-&gt;log2_chroma_w : <span class="number">0</span>;</span><br><span class="line">    shifted_w = ((width + (<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>)) &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (shifted_w &amp;&amp; max_step &gt; INT_MAX / shifted_w)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    linesize = max_step * shifted_w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc-&gt;flags &amp; AV_PIX_FMT_FLAG_BITSTREAM)</span><br><span class="line">        linesize = (linesize + <span class="number">7</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> linesize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面计算 linesize 对于不同分量不同平面，比如 yuv420p 格式比较好理解，但是对于所有分量同一平面的交错格式，比如 yuyv422，可能不是那么好理解，一起算算看：</p><p>在 av_image_fill_max_pixsteps 之后，max_step 为 4 0 0 0，max_step_comp 为 2 0 0 0，因为 yuyv422 只有一个平面，所以函数中只会更新 max_pixsteps[0]和 max_pixstep_comps[0]。读者可以自己验证一下。</p><p>在 image_get_linesize 中，由于只有一个平面，所以只有 linesizes[0]非 0，对第 0 个平面，输入参数 max_step 为 4，max_step_comp 为 2，那么 s 为 log2_chroma_w，也就是 1，shifted_w 就是 width&#x2F;2，最后 linesize 就是 2*width，刚好就是 yuyv422 存储一行需要的字节数。看来这种计算方法确实是经过精心设计的。</p><p>注意上面函数传给 av_image_fill_linesizes 的 width 是 <code>FFALIGN(frame-&gt;width, i)</code>，也就是会把 <code>frame-&gt;width</code> 对齐到 1 或 2 或 4…或 align 的整数倍</p><p>看下面这个循环，会在 <code>!(frame-&gt;linesize[0] &amp; (align-1))</code> 时退出，而这个条件其实是 frame-&gt;linesize[0]整除 align，也就是会在 1 或 2 或 4…或 align 这些对齐参数中，找到最小的让 frame-&gt;linesize[0]整除 align 的对齐参数。这样做是为了节约空间，让对齐得到宽度尽可能和 frame-&gt;width 接近</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=align; i+=i) &#123;</span><br><span class="line">            ret = <span class="built_in">av_image_fill_linesizes</span>(frame-&gt;linesize, frame-&gt;format,</span><br><span class="line">                                          <span class="built_in">FFALIGN</span>(frame-&gt;width, i));</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">if</span> (!(frame-&gt;linesize[<span class="number">0</span>] &amp; (align<span class="number">-1</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通过 av_image_fill_linesizes 计算 linesize 后，会进行下面的对齐操作，这一步把 linesize 进行对齐，而上面是把 frame-&gt;width 进行对齐</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span> &amp;&amp; frame-&gt;linesize[i]; i++)</span><br><span class="line">            frame-&gt;linesize[i] = <span class="built_in">FFALIGN</span>(frame-&gt;linesize[i], align);</span><br></pre></td></tr></table></figure><p>除了对宽度进行对齐，还会对高度进行对齐</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">padded_height = <span class="built_in">FFALIGN</span>(frame-&gt;height, <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_fill_plane_sizes</span>(sizes, frame-&gt;format,</span><br><span class="line">                                         padded_height, linesizes)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure><p>padded_height 就是把高度对齐到 32，av_image_fill_plane_sizes 则是计算每个平面需要的 size</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_image_fill_plane_sizes</span><span class="params">(<span class="type">size_t</span> sizes[<span class="number">4</span>], <span class="keyword">enum</span> AVPixelFormat pix_fmt,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height, <span class="type">const</span> <span class="type">ptrdiff_t</span> linesizes[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, has_plane[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> AVPixFmtDescriptor *desc = <span class="built_in">av_pix_fmt_desc_get</span>(pix_fmt);</span><br><span class="line">    <span class="built_in">memset</span>(sizes    , <span class="number">0</span>, <span class="built_in">sizeof</span>(sizes[<span class="number">0</span>])*<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    sizes[<span class="number">0</span>] = linesizes[<span class="number">0</span>] * (<span class="type">size_t</span>)height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc-&gt;flags &amp; AV_PIX_FMT_FLAG_PAL) &#123;</span><br><span class="line">        sizes[<span class="number">1</span>] = <span class="number">256</span> * <span class="number">4</span>; <span class="comment">/* palette is stored here as 256 32 bits words */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        has_plane[desc-&gt;comp[i].plane] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">4</span> &amp;&amp; has_plane[i]; i++) &#123;</span><br><span class="line">        <span class="type">int</span> h, s = (i == <span class="number">1</span> || i == <span class="number">2</span>) ? desc-&gt;log2_chroma_h : <span class="number">0</span>;</span><br><span class="line">        h = (height + (<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>) &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (linesizes[i] &gt; SIZE_MAX / h)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        sizes[i] = (<span class="type">size_t</span>)h * linesizes[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_image_fill_plane_sizes 就是把 linesizes 和 height 相乘计算 plane size，同样对于 yuv420p 这种高度也是降采样的格式需要考虑 log2_chroma_h 参数</p><p>平面之间还会有一个 plane_padding 大小的间距，这个可能是避免平面之间连续，但是具体作用我也不清楚。计算总的 size 是将每个平面的 size 和 plane_padding 加起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total_size = <span class="number">4</span>*plane_padding;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sizes[i] &gt; INT_MAX - total_size)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        total_size += sizes[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>计算完总 size 后会分配一整块大的 buffer，然后通过 av_image_fill_pointers 函数将不同平面的 data 指针指向这个大 buffer 的不同部分。av_image_fill_pointers 让 data[0]指向 buffer 起始地址，后续的 buffer 则依次加上 plane size 递增</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_image_fill_pointers</span><span class="params">(<span class="type">uint8_t</span> *data[<span class="number">4</span>], <span class="keyword">enum</span> AVPixelFormat pix_fmt, <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">uint8_t</span> *ptr, <span class="type">const</span> <span class="type">int</span> linesizes[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line">    <span class="type">ptrdiff_t</span> linesizes1[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> sizes[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        linesizes1[i] = linesizes[i];</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_image_fill_plane_sizes</span>(sizes, pix_fmt, height, linesizes1);</span><br><span class="line"></span><br><span class="line">    data[<span class="number">0</span>] = ptr;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">4</span> &amp;&amp; sizes[i]; i++)</span><br><span class="line">        data[i] = data[i - <span class="number">1</span>] + sizes[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后对 data 指针的进行调整，加上之前说的 plane_padding</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;data[i])</span><br><span class="line">            frame-&gt;data[i] += i * plane_padding;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里就把 buffer 对齐介绍完了，可以看到 ffmpeg 在分配 buffer 的时候会把宽度、linesize、高度进行对齐，同时 plane 之间还会有一个 padding 间距。</p><p>最后再看看这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_image_get_buffer_size</span><span class="params">(<span class="keyword">enum</span> AVPixelFormat pix_fmt,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret, i;</span><br><span class="line">    <span class="type">int</span> linesize[<span class="number">4</span>];</span><br><span class="line">    <span class="type">ptrdiff_t</span> aligned_linesize[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> sizes[<span class="number">4</span>];</span><br><span class="line">    <span class="type">const</span> AVPixFmtDescriptor *desc = <span class="built_in">av_pix_fmt_desc_get</span>(pix_fmt);</span><br><span class="line">    <span class="keyword">if</span> (!desc)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_image_check_size</span>(width, height, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_image_fill_linesizes</span>(linesize, pix_fmt, width);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        aligned_linesize[i] = <span class="built_in">FFALIGN</span>(linesize[i], align);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_image_fill_plane_sizes</span>(sizes, pix_fmt, height, aligned_linesize);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sizes[i] &gt; INT_MAX - ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        ret += sizes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是计算 buffer size，基本流程和上面 get_video_buffer 函数是一样的，都有 av_image_check_size、av_image_fill_linesizes、对齐 linesize、av_image_fill_plane_sizes 步骤，但是 get_video_buffer 的对齐比 av_image_get_buffer_size 更严格，比 av_image_get_buffer_size 多了宽度对齐、高度对齐、plane padding。</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>move和forward</title>
      <link href="/2023/04/22/move%E5%92%8Cforward/"/>
      <url>/2023/04/22/move%E5%92%8Cforward/</url>
      
        <content type="html"><![CDATA[<p>之前的文章介绍了右值引用和将亡值，这篇博客谈一谈从右值引用引申出的移动和转发。</p><p>之前说过，左值引用和右值引用本质都是指针，所以可以用 static_cast 将他们进行互相转换。但是一般很少直接用 static_cast 进行转换，而是使用语义性更强的 move&#x2F;forward 获得输入的左值&#x2F;右值参数的左值引用&#x2F;将亡值。</p><p>move 的例子如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;j = i;</span><br><span class="line"><span class="type">int</span> &amp;&amp;k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">move</span>(i);</span><br><span class="line">std::<span class="built_in">move</span>(j);</span><br><span class="line">std::<span class="built_in">move</span>(k);</span><br><span class="line">std::<span class="built_in">move</span>(<span class="number">0</span>); <span class="comment">// 上面move返回的都是将亡值</span></span><br></pre></td></tr></table></figure><p>move 函数会返回输入的左值、右值参数的将亡值，move 函数实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE <span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type _Up;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Up&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入参数是模板参数的右值引用，也就是万能引用，表明 move 可以接受左值或者右值参数。万能引用经过模板参数推导后会发生引用折叠，最后 <code>__t</code> 一定是左值或者右值引用之一，以上面的代码为例</p><ul><li>输入为 i、j、k，那么 <code>_Tp</code> 推断 int &amp;，<code>__t</code> 最后折叠为 int &amp;类型</li><li>输入为 0，那么 <code>_Tp</code> 推断 int，<code>__t</code> 最后是 int &amp;&amp;类型</li></ul><p>在知道 <code>_Tp</code> 如何推断之后，就可以很轻松的理解上面的代码了。先看返回值，<code>typename remove_reference&lt;_Tp&gt;::type&amp;&amp;</code> 表示将 <code>_Tp</code> 去除引用后的类型加上右值引用，则返回值一定是右值引用，这和 move 的语义相符，就是返回将亡值。函数体中就是用 static_cast 将输入的不管是左值还是右值引用都强制转换为 <code>typename remove_reference&lt;_Tp&gt;::type&amp;&amp;</code>，也就是右值引用。</p><p>所以 move 的作用就是获得输入参数的将亡值，仅此而已。</p><p>无论输入参数是左值还是右值，move 都返回将亡值，如果现在需要根据输入参数的类型返回不同类型的引用，比如输入左值，返回左值引用，输入右值，返回右值引用，那么 move 将无能为力，所以引入了 forward。forward 例子如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;j = i;</span><br><span class="line"><span class="type">int</span> &amp;&amp;k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">std::forward&lt;<span class="type">int</span>&amp;&gt;(i); <span class="comment">// 返回左值引用</span></span><br><span class="line"></span><br><span class="line">std::forward&lt;<span class="type">int</span>&gt;(<span class="number">0</span>); <span class="comment">// 返回右值引用</span></span><br></pre></td></tr></table></figure><p>forward 实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span></span><br><span class="line"><span class="function">_Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span></span><br><span class="line"><span class="function">_Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!is_lvalue_reference&lt;_Tp&gt;::value,</span><br><span class="line">                  <span class="string">&quot;can not forward an rvalue as an lvalue&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forwad 和 move 不一样，move 可以通过输入参数推断模板类型，但是 forward 必须指定模板参数，因为 foward 的参数是 <code>typename remove_reference&lt;_Tp&gt;::type</code>，无法通过输入参数进行模板参数推断。</p><p>在指定模板参数后，就有了两个版本的 forwad，一个参数是左值引用，另一个是右值引用，根据函数匹配原则，输入参数是左值，优先选择左值引用版本，输入参数是右值，优先是使用右值引用版本。</p><p>forwad 函数内部也是用 static_cast 对输入参数进行强制转换，但是 <code>static_cast&lt;_Tp&amp;&amp;&gt;</code> 进行转换的目标参数是 <code>_Tp&amp;&amp;</code>，根据引用折叠，要想得到左值引用，<code>_Tp</code> 必须形如 int&amp;，想要得到右值，<code>_Tp</code> 必须是 int 或者 int&amp;&amp;。这也是为什么上面例子中左值引用是 <code>std::forward&lt;int&amp;&gt;(i);</code> 右值引用是 <code>std::forward&lt;int&gt;(0);</code></p><p>返回值和上面 <code>static_cast&lt;_Tp&amp;&amp;&gt;</code> 一样都是 <code>_Tp&amp;&amp;</code>。</p><p>所以使用 forwad 一定要正确配置模板参数，比如使用 <code>std::forward&lt;int&gt;(i);</code> 返回的将是右值引用，而 <code>std::forward&lt;int&amp;&gt;(0);</code> 虽然可以返回左值，但是上面 static_assert 会报错。</p><p>forward 常常和模板一起使用，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gg</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据万能引用模板参数推断原则，如果输入参数是左值，那么 T 形如 int&amp;，如果输入右值，则 T 形如 int（不论输入是纯右值还是将亡值）。上面模板函数在使用 forwad 时传的模板参数 T，恰好和 forward 对模板参数的要求一致：要转发得到左值，T 必须形如 int&amp;，要转发得到右值引用，T 必须是 int 或者 int&amp;&amp;。</p><p>从上面的分析可以发现，move 和 foward 都是获得输入参数的引用，move 只能得到将亡值，forwad 则会根据输入参数类型返回左值引用或者将亡值，他们内部都是通过 static_cast 实现的。</p><p>本来还计划介绍 <code>forward as tuple</code>，但想了想，还是等 tuple 分析完以后再来介绍会好一些。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++新特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>左值、右值、左值引用、右值引用</title>
      <link href="/2023/04/22/%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>/2023/04/22/%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章想不自量力的分析 C++ 中的左值、右值、左值引用、右值引用，为后面分析其他新特性做铺垫。</p></blockquote><p>左值和右值是表达式的结果的属性，表达式就是“运算符 + 运算对象”，表达式加上末尾的分号就是语句，最简单的表达式是变量，下面例子都是表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span></span><br><span class="line">i</span><br><span class="line">i+<span class="number">1</span></span><br><span class="line">++i</span><br></pre></td></tr></table></figure><p>可以这样理解左值和右值：左值是指表达式的结果能被操纵、能被取地址，右值是指表达式的结果虽然存在，也可以使用，但是我们没有办法取地址。</p><p>区分左值、右值最容易的方法是：左值通常有名字，在程序里可以取地址；右值通常是某次计算的临时结果，虽然仿佛有一个变量来存储这个结果，但是该变量对程序员不可见，无法取地址。</p><p>但是注意要以能否取地址为判定准则，而不是以是否有名字来区分左右值，看以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i; <span class="comment">// i是左值</span></span><br><span class="line">i = <span class="number">1</span>; <span class="comment">// i是左值，1是右值</span></span><br><span class="line"><span class="type">int</span> j = i+<span class="number">1</span>; <span class="comment">// j是左值，i+1的结果是一个临时值，是右值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A&amp; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&amp;<span class="built_in">f</span>(); <span class="comment">// f()返回左值 虽然f()的返回值没有名字</span></span><br></pre></td></tr></table></figure><p>还要注意，不能用下面的方法来区分左值右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A&amp; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">A <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>().<span class="built_in">hello</span>();</span><br><span class="line"><span class="built_in">g</span>().<span class="built_in">hello</span>(); <span class="comment">// 不能以这种方式来区分，因为左值右值都可以“使用”，像这样访问对象的成员函数是使用</span></span><br></pre></td></tr></table></figure><p>C++11 在原来的左值右值基础上做了扩展，原来的左值右值现在分成左值 lvalue、将亡值 xvalue、纯右值 prvalue。</p><p>纯右值和之前的右值概念是一致的，字面量、某些运算符计算得到的临时结果、返回非引用类型的函数是纯右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">1</span>; <span class="comment">// 等号右边是纯右值</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>; <span class="comment">// 等号右边是纯右值</span></span><br><span class="line">j = j + i; <span class="comment">// j + i 返回一个临时的运算结果，是纯右值</span></span><br><span class="line">j-- <span class="comment">// 纯右值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 纯右值</span></span><br><span class="line">&amp;a <span class="comment">// 纯右值</span></span><br><span class="line">a==b <span class="comment">// 纯右值</span></span><br><span class="line">a&gt;=b <span class="comment">// 纯右值</span></span><br><span class="line">a&lt;b <span class="comment">// 纯右值</span></span><br><span class="line">a&amp;&amp;b <span class="comment">// 纯右值</span></span><br><span class="line">a||b <span class="comment">// 纯右值</span></span><br><span class="line">~a <span class="comment">// 纯右值</span></span><br><span class="line">a+b <span class="comment">// 纯右值</span></span><br></pre></td></tr></table></figure><p>左值和之前左值的概念类似，都是指能被程序员操纵、使用的值，比如变量名、函数名、变量的左值&#x2F;右值引用，某些返回左值引用的运算符，返回左值引用的函数，如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, *p = &amp;i; <span class="comment">// i p都是左值</span></span><br><span class="line"><span class="type">int</span>&amp; j = i; <span class="comment">// j也是左值</span></span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">// *p 也是左值，解引用返回指向变量的左值引用</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">2</span>; <span class="comment">// 索引也返回左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; m = <span class="number">1</span>; <span class="comment">// m也是左值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">f</span>() <span class="comment">// 返回左值引用的函数的结果也是左值</span></span><br></pre></td></tr></table></figure><p><code>int i</code> <code>int&amp;j</code> 容易理解，某些返回左值引用的运算符需要注意，比如解引用、前缀 ++、前缀–、数组索引、+&#x3D;、-&#x3D;。</p><p>但是右值引用 <code>int&amp;&amp; m</code>，为什么也把他算到左值里面？</p><p>这是因为当我们定义一个右值引用后，我们就可以显式的使用这个引用了，就好像操作的是被绑定的变量，所以把他也当作左值，比如下面可以对 m 取地址，<strong>能进行取地址操作是左值的核心属性</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; m = <span class="number">1</span>;</span><br><span class="line">&amp;m</span><br></pre></td></tr></table></figure><p>将亡值和新引入的右值引用相关，哪些情况下会得到将亡值？返回右值引用的函数、转换为右值引用的转换函数，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">f</span><span class="params">(<span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(i) <span class="comment">// 将亡值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp;j = i;</span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(j) <span class="comment">// 将亡值</span></span><br></pre></td></tr></table></figure><p>可以看到，当右值引用出现在变量定义和函数返回值时，有不同的含义，当右值引用出现在函数返回值时，是将亡值，而当右值引用出现在变量定义时，是左值。</p><p>为什么要让函数返回右值引用是将亡值？为了支持新的移动语义。</p><p>当 C++ 中发生拷贝构造时，会把传入的引用指向的对象中的资源拷贝一份：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line"><span class="built_in">E</span>(<span class="type">const</span> E&amp;); <span class="comment">// 发生拷贝时会new一块buf，然后memcpy传入的对象中的buf</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *buf; <span class="comment">// 动态分配的内存，析构时释放</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果用户想提高效率，不想发生拷贝，而希望构造函数直接接管传入对象中分配的内存，那么需要一个标记提示函数 “输入参数指向的对象可以被安全的接管”，此时构造函数可以直接将输入对象的 buf 指针赋给自己，因为输入对象是可被安全接管的。我们称可以被安全接管的对象为将亡值。</p><p>首先可以确定这个 “标记” 一定是引用，只有引用传递才能保证函数访问到的是需要被接管的对象，传值会发生拷贝，这和我们上面节省拷贝的初衷不符。原有的左值引用是否可以呢？不可以，左值引用已经有了自己的语义，无法实现这一功能，所以就诞生了右值引用。</p><p>既然确定了这个“标记”是一个引用，接下来就要思考如何让一个变量标记为“可以被安全的接管”。可以像定义变量一样，定义一个右值引用的变量，然后将这个变量视为“将亡”，这其实也是可以的，但是为什么最后没有使用这种方式，个人猜测原因之一是这种显式定义的变量给人一种可以使用的感觉，可能有程序员会不小心在后面的代码中使用这个变量，所以最后使用函数返回右值引用作为“将亡”的标记。</p><p>在决定了函数返回右值引用作为“将亡”之后，还要考虑引入新的右值引用对原有语言规则的影响，比如能否在定义变量时使用右值引用，这样定义后又该怎么解释这个右值引用。出于语言一致性的考虑，C++ 允许在变量定义中使用右值引用，但此时的右值引用就像左值引用一样（毕竟右值引用也是一种引用），所以它也是左值。当我们定义一个右值引用的变量时，可以对他取地址，但是无法对函数返回右值引用取地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* q =&amp;i; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;<span class="built_in">hello</span>(); <span class="comment">// error. Cannot take the address of an rvalue of type &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure><p>既然允许在变量定义中定义右值引用，还要考虑右值引用能绑定到什么类型的值上，出于种种考虑，标准规定右值引用只能绑定到纯右值或者将亡值上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; m = <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; j = m; <span class="comment">// error. Rvalue reference to type &#x27;int&#x27; cannot bind to lvalue of type &#x27;int&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; p = <span class="built_in">hello</span>(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>C++ 标准中，左值和将亡值称为泛左值，纯右值和将亡值称为右值。将亡值是函数返回右值引用，而右值引用广义上来说也是引用，可以视为左值；将亡值无法取地址，这符合右值的特点，也可以视为右值。所以将亡值就是标记一个引用为临时值。</p><p><img src="/images/%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/%5Bignore%5D-l-x-r-value.png"></p><p>再谈一谈左值右值引用的转换。可以通过 static_cast 将一个左值引用转成右值引用，反之亦然。可以这样理解这种转换，左值&#x2F;右值引用都是对对象的引用，底层都是指针，只是在上层有不同的解释。当我们把一个左值引用通过 move 或者 static_cast 转换成一个将亡值的时候，表示将这个对象标记为将亡，并要求后续代码不能再使用这个对象，然后如果某个函数有接受右值引用参数的重载，就可以通过将亡值把对象移动出去。看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="comment">// 实现了移动构造</span></span><br><span class="line"><span class="type">void</span> *buff;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">ff</span><span class="params">(A b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    A a;</span><br><span class="line">    </span><br><span class="line">    A c = <span class="built_in">ff</span>(std::<span class="built_in">move</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中 A 对象有两块内存，一块是栈内存，一块是堆内存。当给 ff 函数传将亡值时，由于形参是值，实参是右值引用，所以发生移动构造，此时会在 ff 的参数栈上构造一个 A 对象，但是 a 的堆内存是直接转移到 b 的，真正拷贝的是栈内存的那一部分；ff 函数返回结果类似，也是进行了栈内存拷贝，其实 ff 内部可以直接返回 b，不需要 move，因为有返回值优化；最后在通过 ff 返回值构造 c 时，由于 ff 返回一个临时值，所以也调用移动构造函数，再拷贝一次栈内存，堆内存转移，但是通常编译器会把这次对象构造优化掉，直接把 ff 返回值当作 c。</p><p>参考：</p><p><a href="https://www.cnblogs.com/zpcdbky/p/5275959.html">https://www.cnblogs.com/zpcdbky/p/5275959.html</a></p><p><a href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/</a></p><p><a href="http://irootlee.com/juicer_pointer_reference/">http://irootlee.com/juicer_pointer_reference&#x2F;</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++新特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言的变长参数函数</title>
      <link href="/2023/04/06/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0/"/>
      <url>/2023/04/06/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>之前在研究 gobject 的时候，遇到了很多 C 语言的变长参数函数，这篇博客分析一下 C 语言的变长参数函数。</p><p>我们都用过 printf 函数，给定一个格式字符串，然后可以根据这个字符串输入不定长度的参数，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %s %d\n&quot;</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">2</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>他的实现类似下面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mini_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_start</span>(ap, fmt);</span><br><span class="line">    ret = <span class="built_in">vprintf</span>(fmt, &amp;ap);</span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, va_list* ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* val_s;</span><br><span class="line">    <span class="type">int64_t</span> val_i64;</span><br><span class="line">    <span class="type">int32_t</span> val_i32;</span><br><span class="line">    <span class="type">int16_t</span> val_i16;</span><br><span class="line">    <span class="type">int8_t</span> val_i8, c;</span><br><span class="line">    <span class="type">double</span> val_dbl;</span><br><span class="line">    <span class="type">float</span> val_flt;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = *fmt++)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            val_dbl = <span class="built_in">va_arg</span>(*ap, <span class="type">double</span>);</span><br><span class="line">            ret = <span class="built_in">printf_double</span>(val_dbl); <span class="comment">// 交给特定类型的函数去做</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            val_s = <span class="built_in">va_arg</span>(*ap, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">            ret = <span class="built_in">printf_string</span>(val_s); <span class="comment">// 交给特定类型的函数去做</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子的核心是以下几步</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">va_list ap;</span><br><span class="line"><span class="built_in">va_start</span>(ap, fmt);</span><br><span class="line"><span class="built_in">va_end</span>(ap);</span><br><span class="line"><span class="type">double</span> val_dbl = <span class="built_in">va_arg</span>(ap, <span class="type">double</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* val_s = <span class="built_in">va_arg</span>(ap, <span class="type">const</span> <span class="type">char</span>*);</span><br></pre></td></tr></table></figure><ul><li><code>va_list ap;</code> 表示声明一个 char <em>类型的变量 ap，<code>va_list</code> 就是 char</em>类型</li><li><code>va_start(ap, fmt);</code> 表示把 ap 指针的值指向 fmt 变量的下一个变量的地址值，可以这样理解：<code>ap=&amp;fmt+sizeof(fmt)</code></li><li><code>va_end(ap);</code> 表示把 ap 赋值为空，做清理工作</li><li><code>double val_dbl = va_arg(ap, double);</code> 表示把 ap 指针指向的内存解释为 double 类型，同时返回该值，然后将 ap 指针移动到当前变量的下一个变量。</li><li><code>const char* val_s = va_arg(ap, const char*);</code> 和上面一样，把 ap 指针指向的内存解释为 const char*类型，同时返回该值，然后将 ap 指针移动到当前变量的下一个变量。</li></ul><p>从上面分析可知，使用变长参数需要两个条件：变长参数连续保存，变长参数的类型和数目要通过某种方式传递给函数。只有这样才能正确解释当前 ap 指针指向的内存，以及移动 ap 到下一个变长参数的地址。</p><p>正确理解变长参数需要知道函数调用约定的知识，这里以 CDECL 为例（<a href="https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions">https://en.wikibooks.org/wiki/X86_Disassembly&#x2F;Calling_Conventions</a>），CDECL 函数调用约定：</p><ul><li>参数从右向左入栈，返回值通过 eax 寄存器返回</li><li>函数调用者清理栈空间</li></ul><p>这个调用方式的好处是支持变长参数，因为栈空间是由函数调用者清理，调用者肯定知道他传了多少参数，缺点是被调用者无法检查传给自己的参数是否合法（比如参数数目是否正确）</p><p>下图展示了 CDECL 下如何从栈中取变长参数</p><p>变长参数有两种常见的使用方式，一种是像 printf 一样，输入一个格式字符串，变长参数的类型通过该格式字符串得到。第二种是固定变长参数的类型为一种，比如下面的函数要求变长参数类型都为指针类型，对这种情况，往往还需要一个参数标识变长参数结尾，下面函数以 NULL 指针标志变长参数结尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>* s, ...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">void</span>* pre = s;</span><br><span class="line">    <span class="type">void</span>* node = <span class="literal">NULL</span>;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">va_start</span>(ap, s);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        node = <span class="built_in">va_arg</span>(ap, <span class="type">void</span>*);</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">do_something</span>(pre, node);</span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 f 时最后一个参数必须为 NULL 指针，比如 <code>f(&amp;a,&amp;b,&amp;c,NULL)</code>。</p><p>总结：使用 C 语言变长参数函数的核心是能正确从栈中取得每一个参数。</p><p>参考资料：</p><p><a href="https://www.cnblogs.com/chinazhangjie/archive/2012/08/18/2645475.html">https://www.cnblogs.com/chinazhangjie/archive/2012/08/18/2645475.html</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>delete[]和delete</title>
      <link href="/2023/04/02/delete-%E5%92%8Cdelete/"/>
      <url>/2023/04/02/delete-%E5%92%8Cdelete/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近看到这个帖子上介绍的 C++ delete[]的实现 <a href="https://zhuanlan.zhihu.com/p/74897601">https://zhuanlan.zhihu.com/p/74897601</a>，这篇博客记录一下自己的验证。</p></blockquote><p>当 C++ delete 一个数组时，不仅仅是简单的释放内存，还需要对数组中的每一个对象都调用析构函数，所以需要知道数组元素的个数，那么数组个数信息到底保存在哪里呢？上面帖子中最高赞同的答案是：C++ new 一个数组时，会在数组的最开始额外分配一块小内存（比如 4 或 8 字节）用于记录数组个数，下面对这个结论进行验证。</p><p>cpp 文件如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        i++;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    i++;</span><br><span class="line">    i = <span class="number">45</span>;</span><br><span class="line">    A* a = <span class="keyword">new</span> A[i];</span><br><span class="line">    <span class="keyword">delete</span>[] a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面文件编译后用 gdb 进行调试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b <span class="number">18</span> </span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11ef</span>: file m2.cpp, line <span class="number">18.</span> </span><br><span class="line">(gdb) r</span><br><span class="line">...</span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at m2.cpp:<span class="number">18</span> </span><br><span class="line"><span class="number">18</span>          <span class="keyword">delete</span>[] a;  </span><br><span class="line">(gdb) p a </span><br><span class="line">$<span class="number">1</span> = (A *) <span class="number">0x55555556aeb8</span> </span><br><span class="line">(gdb) x/<span class="number">8</span>db <span class="number">0x55555556aeb8</span><span class="number">-8</span> </span><br><span class="line"><span class="number">0x55555556aeb0</span>: <span class="number">45</span>      <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在 18 行打了个断点，然后查看 a 变量的值，a 变量存储了新创建的数组的地址，接着查看这个地址向前移动 8 后的内存，可以看到，确实出现了数组个数信息，当把数组长度调整时，45 也会随之改变。所以上面的结论是对的，当 new 一个数组时，会在头部额外分配一块内存记录数组个数。</p><p>接着又进行了以下实验，这次把析构函数注释掉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">/* ~A()&#123;</span></span><br><span class="line"><span class="comment">        i++;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    i++;</span><br><span class="line">    i = <span class="number">45</span></span><br><span class="line">    A* a = <span class="keyword">new</span> A[i];</span><br><span class="line">    <span class="keyword">delete</span> a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上面文件然后用 gdb 调试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ m2.cpp -o main -g</span><br><span class="line">gdb main</span><br><span class="line"></span><br><span class="line">info breakpoints</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b <span class="number">18</span> </span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11b7</span>: file m2.cpp, line <span class="number">18.</span> </span><br><span class="line">(gdb) r</span><br><span class="line">...</span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at m2.cpp:<span class="number">18</span> </span><br><span class="line"><span class="number">18</span>          <span class="keyword">delete</span>[] a;  </span><br><span class="line">(gdb) p a </span><br><span class="line">$<span class="number">1</span> = (A *) <span class="number">0x55555556aeb0</span> </span><br><span class="line">(gdb) x/<span class="number">8</span>db <span class="number">0x55555556aeb0</span><span class="number">-8</span> </span><br><span class="line"><span class="number">0x55555556aea8</span>: <span class="number">-63</span>      <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span> </span><br><span class="line">(gdb) exit</span><br></pre></td></tr></table></figure><p>这次在数组头部往前 8 字节的地方没有出现数组个数信息，经测试-63 处的内存每次调试都会得到不同的值。<strong>所以编译器只会在必要的时候保存数组长度信息</strong>，当析构函数是编译器合成并且是 trivial 的（也就是没有做什么具体工作），那么析构时没有必要调用析构函数，因此也就不需要数组长度信息了。</p><p>参考资料：</p><p>深度探索 C++ 对象模型</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++对象模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg filter之AVFilterLink</title>
      <link href="/2023/03/28/ffmpeg-filter%E4%B9%8BAVFilterLink/"/>
      <url>/2023/03/28/ffmpeg-filter%E4%B9%8BAVFilterLink/</url>
      
        <content type="html"><![CDATA[<p>这篇博客介绍一下 AVFilterLink 中部分重要的字段。</p><p>AVFilterLink 用于管理 filter 之间的连接状态，filter 之间的数据流通，比如下游向上游申请数据，上游向下游传输数据，都需要通过 AVFilterLink 实现。</p><p>AVFilterLink 部分关键字段如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AVFilterLink</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lists of supported formats / etc. supported by the input filter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVFilterFormatsConfig incfg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lists of supported formats / etc. supported by the output filter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVFilterFormatsConfig outcfg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * True if a frame is currently wanted on the output of this link.</span></span><br><span class="line"><span class="comment">     * Set when ff_request_frame() is called by the output,</span></span><br><span class="line"><span class="comment">     * cleared when a frame is filtered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> frame_wanted_out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If set, the source filter can not generate a frame as is.</span></span><br><span class="line"><span class="comment">     * The goal is to avoid repeatedly calling the request_frame() method on</span></span><br><span class="line"><span class="comment">     * the same link.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> frame_blocked_in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link input status.</span></span><br><span class="line"><span class="comment">     * If not zero, all attempts of filter_frame will fail with the</span></span><br><span class="line"><span class="comment">     * corresponding code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> status_in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link output status.</span></span><br><span class="line"><span class="comment">     * If not zero, all attempts of request_frame will fail with the</span></span><br><span class="line"><span class="comment">     * corresponding code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> status_out;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/ffmpeg-avfilterlink/filter.jpg"></p><ul><li><p>incfg&#x2F;outcfg  是当前 link 的输入端支持的 format 和输出端支持的 format，注意这里的输入输出是相对 link 而言的，如上图，incfg 来自 src filter，因为 src filter 是 link 的输入，outcfg 来自 sink filter，因为 sink filter 是 link 的输出，而这条 link 在 src filter 中被视为 output link，在 sink filter 中被视为 input link，这里容易弄混。</p></li><li><p>frame_wanted_out  当下游 filter 向自己的 input link 请求 frame 时，如果此时 link 的 fifo 中没有数据，那么就会设置 frame_wanted_out 为 1，表示 link 的 ouput 想要数据；当上游往下游送数据时（可能是下游的申请导致的），会把 frame_wanted_out 变为 0</p></li><li><p>frame_blocked_in  当 filter 需要向上传递 request_frame 请求时，会把当前想要传递 request_frame 请求的 output link 的 frame_blocked_in 设为 1，当下次再向上传递该 output link 的 request_frame 请求时会检查他的 frame_blocked_in，如果 frame_blocked_in 为 1 则跳过这次传递 request_frame 请求过程。</p><ul><li>frame_blocked_in 不太好理解，我最开始以为是：当下游 filter 往自己的 input link 请求 frame 时，会设置 input link 的 frame_blocked_in 为 1，而上游向下游送数据时会把 frame_blocked_in 赋为 0。这个理解只对了一半：上游向下游送数据时会把 frame_blocked_in 赋为 0，而下游向上游请求 frame 时不设置 frame_blocked_in 为 1，而是在上游 filter 激活时发现自己无法满足下游的 request_frame 请求（比如没有 frame），从而向自己的 input link 发起 request_frame 时会设置下游 output link 的 frame_blocked_in 为 1</li><li>但是据我观察，很多 filter 没有在自己的 activate function 中检查这个变量。目前官方的默认激活函数 ff_filter_activate_default 检查了 frame_blocked_in 来避免重复的 request_frame 请求。</li></ul></li><li><p>status_in  表示当前 link 的输入端的状态，0 为正常，大于 0 为异常，这里输入端的概念和 incfg 是一样的</p></li><li><p>status_out  表示当前 link 的输出端的状态，0 为正常，大于 0 为异常，这里输出端的概念和 outcfg 是一样的</p></li></ul><p>参考资料：</p><p><a href="https://www.cnblogs.com/TaigaCon/p/10111326.html">https://www.cnblogs.com/TaigaCon/p/10111326.html</a></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg filter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg filter之dump排错</title>
      <link href="/2023/03/25/ffmpeg-filter%E4%B9%8Bdump%E6%8E%92%E9%94%99/"/>
      <url>/2023/03/25/ffmpeg-filter%E4%B9%8Bdump%E6%8E%92%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>最近在使用 ffmpeg filter 的时候，发现了 dump 这个工具，这个工具用起来很方便，能够快速查看整个 filtergraph 的状态，对于排错很有帮助，特此写篇博客介绍一下这个工具。</p><p>dump 的输出类似下面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Axxx -&gt; Bxxx   f:1|1 fmt:fltp sr:8000   cl:1 channels       st:1 wn:1 cnt:496      cur:4|512      ex:N/A</span><br><span class="line">Cxxx -&gt; Dxxx   f:0|0 fmt:?    sr:0      cl:0 channels       st:0 wn:0 cnt:0        cur:0|0        ex:hello world </span><br><span class="line">Dxxx -&gt; NULL                                                                                      ex:st: 0</span><br><span class="line">Exxx -&gt; Fxxx   f:1|1 fmt:yuv420p wh:   640|480    ra:   1|1    st:1 wn:1 cnt:355      cur:0|0        ex:N/A</span><br><span class="line">Fxxx -&gt; Gxxx   f:0|0 fmt:?    wh:     0|0      ra:   0|0    st:0 wn:0 cnt:0        cur:0|0        ex:hello </span><br><span class="line">Gxxx -&gt; NULL                                                                                                   ex:N/A</span><br><span class="line">Fxxx -&gt; Bxxx   f:1|1 fmt:yuv420p wh:   640|480    ra:   1|1    st:1 wn:1 cnt:355      cur:0|0        ex:world </span><br><span class="line">Fxxx -&gt; Hxxx   f:0|0 fmt:?    wh:     0|0      ra:   0|0    st:0 wn:0 cnt:0        cur:0|0        ex:world</span><br></pre></td></tr></table></figure><p>其中每一行代表一个 link，’-&gt;’左边是 link 的输入 filter，右边是输出 filter，’-&gt;’右边为 NULL 代表 filter 左边是 sink filter。其他字段，比如 <code>f fmt sr</code> 等都表示 link 上的数据，这里先不解释具体含义，到下面代码部分结合代码一起介绍。</p><p>dump 最终会作用到 avfilter_graph_dump_ext，所以我们从这个函数开始。该函数会调用 graph_filter_dump 对每一个 filter 进行 dump</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">avfilter_graph_dump_ext</span><span class="params">(AVFilterGraph *graph, <span class="type">const</span> <span class="type">char</span> *options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext *cur;</span><br><span class="line">    AVBPrint buf;</span><br><span class="line">    <span class="type">char</span> *dump = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_bprint_init</span>(&amp;buf, <span class="number">0</span>, AV_BPRINT_SIZE_UNLIMITED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">        cur = graph-&gt;filters[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;nb_inputs || cur-&gt;nb_inputs &gt; <span class="number">1</span> || cur-&gt;nb_outputs &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">graph_filter_dump</span>(&amp;buf, cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_bprint_finalize</span>(&amp;buf, &amp;dump);</span><br><span class="line">    <span class="keyword">return</span> dump;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>graph_filter_dump 会对当前 filter 的每一条 output link 进行 dump，先打印 “A -&gt; B” 信息，然后调用 graph_link_dump 打印 link 上的信息，graph_link_dump 函数对理解上面 dump 的输出至关重要。在 dump 完 link 后会通过 avfilter_process_command 函数执行每个 filter 自己定义的 dump 动作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">graph_filter_dump</span><span class="params">(AVBPrint *buf, AVFilterContext *cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        AVFilterLink *link = <span class="literal">NULL</span>;</span><br><span class="line">        AVFilterContext *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;nb_outputs) &#123;</span><br><span class="line">            link = cur-&gt;outputs[i];</span><br><span class="line">            next = link-&gt;dst;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;%-24s -&gt; %-24s&quot;</span>, cur-&gt;name, next ? next-&gt;name : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">        <span class="built_in">graph_link_dump</span>(buf, cur, link);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">avfilter_process_command</span>(cur, <span class="string">&quot;dump&quot;</span>, <span class="literal">NULL</span>, tmp, <span class="built_in">sizeof</span>(tmp), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;ex:%s\n&quot;</span>, tmp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;ex:N/A\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next &amp;&amp; !(next-&gt;nb_inputs &gt; <span class="number">1</span> || next-&gt;nb_outputs &gt; <span class="number">1</span>))</span><br><span class="line">            <span class="built_in">graph_filter_dump</span>(buf, next);</span><br><span class="line">    &#125; <span class="keyword">while</span> (++i &lt; cur-&gt;nb_outputs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看 graph_link_dump 函数，他会将 link 上信息打印出来。从下面代码中可以知道：</p><ul><li><code>f:0|0</code> 表示 link 的 input format 和 output format 是否非空，0 为空，1 为非空</li><li>fmt 代表 link-&gt;format，wh 代表 link-&gt;w 和 link-&gt;h，ra 代表 link-&gt;sample_aspect_ratio，sr 代表 link-&gt;sample_rate，cl 代表 channel layout。wh 和 ra 是针对视频，sr 和 cl 是针对音频</li><li>st 代表 link 的 status_in，但是注意，代码中得到 st 是!ff_outlink_get_status(link)，而 link 中 status_in 为 0 表示正常，大于 0 表示异常，所以这里 st 为 0 表示异常，1 表示正常</li><li>wn 代表 link 的 frame_wanted_out，如果 frame_wanted_out 大于 0，表示下游向上游请求数据</li><li>cnt 代表 link 的 link-&gt;frame_count_in，表示有多少数据流入了当前 link</li><li><code>cur:0|0</code> 代表 link 上的 fifo 中有多少数据，左边代表视频，右边代表音频，通常 <code>|</code> 两边只能有一个大于 0，因为 link 只能有一种数据，但是我也见过两边都大于 0 的情况。这个字段很有用，因为如果见到 cur 不断增长，那么表明当前 link 的下游没有取数据，那么就很有可能是下游 filter 发生了问题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">graph_link_dump</span><span class="params">(AVBPrint *buf, AVFilterContext *cur, AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *format;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!link) &#123;</span><br><span class="line">        <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;%79s&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;f:%d|%d &quot;</span>, !!link-&gt;incfg.formats, !!link-&gt;outcfg.formats);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (link-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            format = <span class="built_in">av_x_if_null</span>(<span class="built_in">av_get_pix_fmt_name</span>(link-&gt;format), <span class="string">&quot;?&quot;</span>);</span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;fmt:%-4s wh:%6d|%-6d ra:%4d|%-4d &quot;</span>,</span><br><span class="line">                       format, link-&gt;w, link-&gt;h,</span><br><span class="line">                       link-&gt;sample_aspect_ratio.num,</span><br><span class="line">                       link-&gt;sample_aspect_ratio.den);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            <span class="built_in">av_channel_layout_describe</span>(&amp;link-&gt;ch_layout, tmp, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">            format = <span class="built_in">av_x_if_null</span>(<span class="built_in">av_get_sample_fmt_name</span>(link-&gt;format), <span class="string">&quot;?&quot;</span>);</span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;fmt:%-4s sr:%-6d cl:%-16s &quot;</span>,</span><br><span class="line">                       format, link-&gt;sample_rate, tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;?&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;st:%d wn:%d cnt:%-8lld cur:%d|%-8d &quot;</span>, !<span class="built_in">ff_outlink_get_status</span>(link),</span><br><span class="line">               <span class="built_in">ff_outlink_frame_wanted</span>(link), link-&gt;frame_count_in,</span><br><span class="line">               <span class="built_in">ff_inlink_queued_frames</span>(link), <span class="built_in">ff_inlink_queued_samples</span>(link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_outlink_get_status</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> link-&gt;status_in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ff_inlink_queued_frames</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ff_framequeue_queued_frames</span>(&amp;link-&gt;fifo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the number of queued frames.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">ff_framequeue_queued_frames</span><span class="params">(<span class="type">const</span> FFFrameQueue *fq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fq-&gt;queued;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the number of queued samples.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint64_t</span> <span class="title">ff_framequeue_queued_samples</span><span class="params">(<span class="type">const</span> FFFrameQueue *fq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fq-&gt;total_samples_head - fq-&gt;total_samples_tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲到这里，dump 输出的含义基本上就讲完了，最后还剩下一个 <code>ex</code>。ex 是在 graph_link_dump 之后执行的，其逻辑是如果 filter 在自己的 process_command 函数中定义了如何相应 dump 指令，则将 process_command 函数返回结果打印，否则打印 N&#x2F;A。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">graph_filter_dump</span><span class="params">(AVBPrint *buf, AVFilterContext *cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;%-24s -&gt; %-24s&quot;</span>, cur-&gt;name, next ? next-&gt;name : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">        <span class="built_in">graph_link_dump</span>(buf, cur, link);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">avfilter_process_command</span>(cur, <span class="string">&quot;dump&quot;</span>, <span class="literal">NULL</span>, tmp, <span class="built_in">sizeof</span>(tmp), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;ex:%s\n&quot;</span>, tmp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;ex:N/A\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">while</span> (++i &lt; cur-&gt;nb_outputs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg filter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg filter之状态变化与数据流转</title>
      <link href="/2023/03/21/ffmpeg-filter%E4%B9%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC/"/>
      <url>/2023/03/21/ffmpeg-filter%E4%B9%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>这篇博客介绍一下 filter 的状态变化与数据流转过程，是 filter 系列的最后一篇，后续可能还会写一些小文章介绍一些之前略过的细节内容。</p><p>filter 有两种方法实现滤波函数，第一种方法是在 filter 的 input AVFilterPad 上实现 filter_frame 函数，这种方法通常配合默认 activate 函数使用，一般用于简单的一个输入，一个输出的场景，第二个方法是实现 filter 的 activate 函数，在 activate 函数中执行 frame 的传输，这个方法一般用于复杂一些的，多个输入输出的 filter。</p><p>对于上面第二种方法，一个典型的 sink filter 的 activate 函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">activate</span><span class="params">(AVFilterContext *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">0</span>， pts;</span><br><span class="line">    AVFilterLink *link;</span><br><span class="line">    AVFrame *frame;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ctx-&gt;nb_inputs; i++) &#123;</span><br><span class="line"></span><br><span class="line">        link = ctx-&gt;inputs[i];</span><br><span class="line">        <span class="built_in">ff_inlink_acknowledge_status</span>(link, &amp;ret, &amp;pts);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">ff_inlink_consume_frame</span>(link, &amp;frame);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process with frame</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ff_inlink_request_frame</span>(link);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本流程是：</p><ul><li>更新 inlink 的状态，比如上游把 status_in 设为 1 后，下游要相应的更新 status_out</li><li>如果 inlink 的状态没问题，就尝试从 inlink 的 fifo 中取数据</li><li>取到数据后对数据进行处理</li><li>最后再向 inlink 发送 request_frame 请求</li></ul><p>看看上面用到的状态调整函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_inlink_acknowledge_status</span><span class="params">(AVFilterLink *link, <span class="type">int</span> *rstatus, <span class="type">int64_t</span> *rpts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *rpts = link-&gt;current_pts;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ff_framequeue_queued_frames</span>(&amp;link-&gt;fifo))</span><br><span class="line">        <span class="keyword">return</span> *rstatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;status_out)</span><br><span class="line">        <span class="keyword">return</span> *rstatus = link-&gt;status_out;</span><br><span class="line">    <span class="keyword">if</span> (!link-&gt;status_in)</span><br><span class="line">        <span class="keyword">return</span> *rstatus = <span class="number">0</span>;</span><br><span class="line">    *rstatus = link-&gt;status_out = link-&gt;status_in;</span><br><span class="line">    <span class="built_in">ff_update_link_current_pts</span>(link, link-&gt;status_in_pts);</span><br><span class="line">    *rpts = link-&gt;current_pts;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_inlink_acknowledge_status 主要工作是把 status_in 的状态传递到 status_out。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_inlink_consume_frame</span><span class="params">(AVFilterLink *link, AVFrame **rframe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFrame *frame;</span><br><span class="line"></span><br><span class="line">    *rframe = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ff_inlink_check_available_frame</span>(link))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (link-&gt;fifo.samples_skipped) &#123;</span><br><span class="line">        frame = <span class="built_in">ff_framequeue_peek</span>(&amp;link-&gt;fifo, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ff_inlink_consume_samples</span>(link, frame-&gt;nb_samples, frame-&gt;nb_samples, rframe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame = <span class="built_in">ff_framequeue_take</span>(&amp;link-&gt;fifo);</span><br><span class="line">    <span class="built_in">consume_update</span>(link, frame);</span><br><span class="line">    *rframe = frame;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_inlink_check_available_frame</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ff_framequeue_queued_frames</span>(&amp;link-&gt;fifo) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">consume_update</span><span class="params">(AVFilterLink *link, <span class="type">const</span> AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ff_update_link_current_pts</span>(link, frame-&gt;pts);</span><br><span class="line">    <span class="built_in">ff_inlink_process_commands</span>(link, frame);</span><br><span class="line">    link-&gt;dst-&gt;is_disabled = !<span class="built_in">ff_inlink_evaluate_timeline_at_frame</span>(link, frame);</span><br><span class="line">    link-&gt;frame_count_out++;</span><br><span class="line">    link-&gt;sample_count_out += frame-&gt;nb_samples;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_inlink_consume_frame 就是从 inlink 中取一个 frame。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_inlink_request_frame</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_assert1</span>(!link-&gt;status_in);</span><br><span class="line">    <span class="built_in">av_assert1</span>(!link-&gt;status_out);</span><br><span class="line">    link-&gt;frame_wanted_out = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ff_filter_set_ready</span>(link-&gt;src, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_inlink_request_frame 就是把 inlink 的 frame_wanted_out 设为 1，然后激活上游 filter，让上游 filter 去处理下游的 request_frame 请求。</p><p>上面的例子展示的是 sink filter 的 activate 函数，从该函数中可以看到下游向上游请求数据的过程，但是没有上游收到下游 request_frame 请求，然后往下游 filter_frame 的过程。接下来我们看一个既有输入又有输出的 filter 的 activate 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">activate</span><span class="params">(AVFilterContext *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ctx-&gt;nb_inputs; i++) &#123;</span><br><span class="line">        AVFrame *frame = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> rpts;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ff_inlink_acknowledge_status</span>(ctx-&gt;inputs[i], &amp;status, &amp;rpts);</span><br><span class="line">        <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">            ret = <span class="built_in">ff_inlink_consume_frame</span>(ctx-&gt;inputs[i], &amp;frame);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ctx-&gt;nb_outputs; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ff_outlink_get_status</span>(ctx-&gt;outputs[j]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status) &#123;</span><br><span class="line">                <span class="comment">// 在某些条件下，根据inlink状态设置outlink的状态</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="comment">/* some condition */</span>)</span><br><span class="line">                    <span class="built_in">ff_outlink_set_status</span>(ctx-&gt;outputs[j], AVERROR_EOF, AV_NOPTS_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frame) &#123;</span><br><span class="line">                <span class="comment">// 进行滤波处理并将frame传给下游</span></span><br><span class="line">                ...</span><br><span class="line">                ret = <span class="built_in">ff_filter_frame</span>(ctx-&gt;outputs[j], frame);</span><br><span class="line">                <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在满足一定条件后向上游申请数据</span></span><br><span class="line">        <span class="comment">// 或者发送eof给上游</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* some condition */</span>)</span><br><span class="line">            <span class="built_in">ff_inlink_request_frame</span>(ctx-&gt;inputs[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* some condition */</span>)</span><br><span class="line">            <span class="built_in">ff_inlink_set_status</span>(ctx-&gt;inputs[i], AVERROR_EOF);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数的流程和 sink filter 类似，但是多了往下游传输 frame 的过程：</p><ul><li>对每个 inlink，先检查并传递该 link 上的 status</li><li>如果这个 inlink 异常，则需要把异常传递给和该 inlink 有关联的下游 outlink</li><li>如果这个 inlink 正常，从 inlink 上取 frame，进行处理，并传给下游 outlink</li><li>最后还要决定是继续往 inlink 中请求数据，还是设置 AVERROR_EOF 来断开 inlink</li></ul><p>可以发现，激活函数中做了这几件事：检查 inlink 的状态；从上往下传递异常 或者 从上往下传输 frame；从下往上传递异常 或者 从下往上传递 request frame 请求。</p><p>接下来也看看相关函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_outlink_get_status</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> link-&gt;status_in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_outlink_get_status 就是取得 outlink 的状态，outlink 是相对 src filter 而言的，所以 ff_outlink_get_status 就是取得 link 的 input 状态 status_in</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">ff_outlink_set_status</span><span class="params">(AVFilterLink *link, <span class="type">int</span> status, <span class="type">int64_t</span> pts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ff_avfilter_link_set_in_status</span>(link, status, pts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_avfilter_link_set_in_status</span><span class="params">(AVFilterLink *link, <span class="type">int</span> status, <span class="type">int64_t</span> pts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;status_in == status)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">av_assert0</span>(!link-&gt;status_in);</span><br><span class="line">    link-&gt;status_in = status;</span><br><span class="line">    link-&gt;status_in_pts = pts;</span><br><span class="line">    link-&gt;frame_wanted_out = <span class="number">0</span>;</span><br><span class="line">    link-&gt;frame_blocked_in = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ff_frame_pool_uninit</span>((FFFramePool**)&amp;link-&gt;frame_pool);</span><br><span class="line">    <span class="built_in">filter_unblock</span>(link-&gt;dst);</span><br><span class="line">    <span class="comment">/* Fast forward EOF and other error status, with priority 300;</span></span><br><span class="line"><span class="comment">     * otherwise, reconfig may occur ahead of time, resulting in link format not being cleared,</span></span><br><span class="line"><span class="comment">     * then getting error reconfig result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">ff_filter_set_ready</span>(link-&gt;dst, status ? <span class="number">300</span> : <span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">filter_unblock</span><span class="params">(AVFilterContext *filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter-&gt;nb_outputs; i++)</span><br><span class="line">        filter-&gt;outputs[i]-&gt;frame_blocked_in = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_outlink_set_status 就是设置 outlink 的状态，同样 outlink 是相对 src filter 而言的，所以这里也是设置 status_in。</p><p>除了 outlink 可以 get&#x2F;set status，inlink 也可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_inlink_set_status</span><span class="params">(AVFilterLink *link, <span class="type">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;status_out)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    link-&gt;frame_wanted_out = <span class="number">0</span>;</span><br><span class="line">    link-&gt;frame_blocked_in = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ff_avfilter_link_set_out_status</span>(link, status, AV_NOPTS_VALUE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ff_framequeue_queued_frames</span>(&amp;link-&gt;fifo)) &#123;</span><br><span class="line">           AVFrame *frame = <span class="built_in">ff_framequeue_take</span>(&amp;link-&gt;fifo);</span><br><span class="line">           <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!link-&gt;status_in)</span><br><span class="line">        link-&gt;status_in = status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_avfilter_link_set_out_status</span><span class="params">(AVFilterLink *link, <span class="type">int</span> status, <span class="type">int64_t</span> pts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_assert0</span>(!link-&gt;frame_wanted_out);</span><br><span class="line">    <span class="built_in">av_assert0</span>(!link-&gt;status_out);</span><br><span class="line">    link-&gt;status_out = status;</span><br><span class="line">    <span class="keyword">if</span> (pts != AV_NOPTS_VALUE)</span><br><span class="line">        <span class="built_in">ff_update_link_current_pts</span>(link, pts);</span><br><span class="line">    <span class="built_in">ff_frame_pool_uninit</span>((FFFramePool**)&amp;link-&gt;frame_pool);</span><br><span class="line">    <span class="built_in">filter_unblock</span>(link-&gt;dst);</span><br><span class="line">    <span class="built_in">ff_filter_set_ready</span>(link-&gt;src, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_inlink_set_status 中除了设置 status_out，还会设置 status_in，这和 ff_outlink_set_status 不一样</p><p>注意没有 ff_inlink_get_status，但是有 ff_inlink_acknowledge_status，这个函数是把 link 上的 status_in 传递到 status_out，然后返回 status_out。</p><p>可以看到 status_in 和 status_out 的设置有特殊的规定：可以单独设置 status_in；不能单独设置 status_out，设置 status_out 时会一起设置 status_in；可以单独取得 status_in；当取得 status_out 时一定会检查 status_in 并尝试改变 status_out。</p><p>注意到上面还出现了一个新的函数 ff_filter_frame，用于从上游往下游送数据，该函数主要是把 frame 添加到 filter 的 output link 的 fifo 中，该函数会清除 frame_blocked_in 和 frame_wanted_out，最后还会激活下游 filter，而之前的 ff_inlink_request_frame 会激活上游的 filter。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_filter_frame</span><span class="params">(AVFilterLink *link, AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!link-&gt;incfg.formats) &#123;</span><br><span class="line">        <span class="built_in">link_uninit_dump_pcm</span>(link, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Consistency checks */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    link-&gt;frame_blocked_in = link-&gt;frame_wanted_out = <span class="number">0</span>;</span><br><span class="line">    link-&gt;frame_count_in++;</span><br><span class="line">    link-&gt;sample_count_in += frame-&gt;nb_samples;</span><br><span class="line">    <span class="built_in">filter_unblock</span>(link-&gt;dst);</span><br><span class="line">    ret = <span class="built_in">ff_framequeue_add</span>(&amp;link-&gt;fifo, frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ff_filter_set_ready</span>(link-&gt;dst, <span class="number">300</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    <span class="keyword">return</span> AVERROR_PATCHWELCOME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面的两个激活函数，filter 的整体的运转逻辑就不难理解了：</p><p><img src="/images/filter%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96/filter-request.jpg"></p><p>数据请求总是由下游 sink 发起，会逐步把 request 请求往 src 传递，这是一个拉的过程；当传递到某个有数据的 filter 时，就开始往下游推数据。关键点是每次 request_frame 时会激活上游 filter，每次 filter_frame 时会激活下游 filter。</p><p>介绍完自定义 activate 函数中的数据流转逻辑，再来看看默认激活函数配合 pad 上 filter_frame 和 request_frame 函数的数据流转过程</p><p><img src="/images/filter%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96/pad.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ff_filter_activate_default</span><span class="params">(AVFilterContext *filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter-&gt;nb_inputs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">samples_ready</span>(filter-&gt;inputs[i], filter-&gt;inputs[i]-&gt;min_samples)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ff_filter_frame_to_filter</span>(filter-&gt;inputs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter-&gt;nb_inputs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter-&gt;inputs[i]-&gt;status_in &amp;&amp; !filter-&gt;inputs[i]-&gt;status_out) &#123;</span><br><span class="line">            <span class="built_in">av_assert1</span>(!<span class="built_in">ff_framequeue_queued_frames</span>(&amp;filter-&gt;inputs[i]-&gt;fifo));</span><br><span class="line">            <span class="keyword">return</span> forward_status_change(filter, filter-&gt;inputs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter-&gt;nb_outputs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter-&gt;outputs[i]-&gt;frame_wanted_out &amp;&amp;</span><br><span class="line">            !filter-&gt;outputs[i]-&gt;frame_blocked_in) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ff_request_frame_to_filter</span>(filter-&gt;outputs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FFERROR_NOT_READY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_filter_activate_default 会优先从自己的 inlink 上取数据并将数据传递给下游，通过 ff_filter_frame_to_filter 函数实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ff_filter_frame_to_filter</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFrame *frame = <span class="literal">NULL</span>;</span><br><span class="line">    AVFilterContext *dst = link-&gt;dst;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert1</span>(<span class="built_in">ff_framequeue_queued_frames</span>(&amp;link-&gt;fifo));</span><br><span class="line">    ret = link-&gt;min_samples ?</span><br><span class="line">          <span class="built_in">ff_inlink_consume_samples</span>(link, link-&gt;min_samples, link-&gt;max_samples, &amp;frame) :</span><br><span class="line">          <span class="built_in">ff_inlink_consume_frame</span>(link, &amp;frame);</span><br><span class="line">    <span class="built_in">av_assert1</span>(ret);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_assert1</span>(!frame);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* The filter will soon have received a new frame, that may allow it to</span></span><br><span class="line"><span class="comment">       produce one or more: unblock its outputs. */</span></span><br><span class="line">    <span class="built_in">filter_unblock</span>(dst);</span><br><span class="line">    <span class="comment">/* AVFilterPad.filter_frame() expect frame_count_out to have the value</span></span><br><span class="line"><span class="comment">       before the frame; ff_filter_frame_framed() will re-increment it. */</span></span><br><span class="line">    link-&gt;frame_count_out--;</span><br><span class="line">    ret = <span class="built_in">ff_filter_frame_framed</span>(link, frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != link-&gt;status_out) &#123;</span><br><span class="line">        <span class="built_in">ff_avfilter_link_set_out_status</span>(link, ret, AV_NOPTS_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Run once again, to see if several frames were available, or if</span></span><br><span class="line"><span class="comment">           the input status has also changed, or any other reason. */</span></span><br><span class="line">        <span class="built_in">ff_filter_set_ready</span>(dst, <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ff_filter_frame_framed</span><span class="params">(AVFilterLink *link, AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*filter_frame)(AVFilterLink *, AVFrame *);</span><br><span class="line">    AVFilterContext *dstctx = link-&gt;dst;</span><br><span class="line">    AVFilterPad *dst = link-&gt;dstpad;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(filter_frame = dst-&gt;filter_frame))</span><br><span class="line">        filter_frame = default_filter_frame;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dst-&gt;flags &amp; AVFILTERPAD_FLAG_NEEDS_WRITABLE) &#123;</span><br><span class="line">        ret = <span class="built_in">ff_inlink_make_frame_writable</span>(link, &amp;frame);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ff_inlink_process_commands</span>(link, frame);</span><br><span class="line">    dstctx-&gt;is_disabled = !<span class="built_in">ff_inlink_evaluate_timeline_at_frame</span>(link, frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dstctx-&gt;is_disabled &amp;&amp;</span><br><span class="line">        (dstctx-&gt;filter-&gt;flags &amp; AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC))</span><br><span class="line">        filter_frame = default_filter_frame;</span><br><span class="line">    ret = <span class="built_in">filter_frame</span>(link, frame);</span><br><span class="line">    link-&gt;frame_count_out++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">default_filter_frame</span><span class="params">(AVFilterLink *link, AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ff_filter_frame</span>(link-&gt;dst-&gt;outputs[<span class="number">0</span>], frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pad 的默认 filter_frame 函数是 ff_filter_frame，就是不作滤波处理，直接传递到 output link 的 fifo 上。</p><p>其次优先执行 input link 的状态调整：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">forward_status_change</span><span class="params">(AVFilterContext *filter, AVFilterLink *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> out = <span class="number">0</span>, progress = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert0</span>(!in-&gt;status_out);</span><br><span class="line">    <span class="keyword">if</span> (!filter-&gt;nb_outputs) &#123;</span><br><span class="line">        <span class="comment">/* not necessary with the current API and sinks */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!in-&gt;status_out) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!filter-&gt;outputs[out]-&gt;status_in) &#123;</span><br><span class="line">            progress++;</span><br><span class="line">            ret = <span class="built_in">ff_request_frame_to_filter</span>(filter-&gt;outputs[out]);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++out == filter-&gt;nb_outputs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!progress) &#123;</span><br><span class="line">                <span class="comment">/* Every output already closed: input no longer interesting</span></span><br><span class="line"><span class="comment">                   (example: overlay in shortest mode, other input closed). */</span></span><br><span class="line">                <span class="built_in">ff_avfilter_link_set_out_status</span>(in, in-&gt;status_in, in-&gt;status_in_pts);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            progress = <span class="number">0</span>;</span><br><span class="line">            out = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ff_filter_set_ready</span>(filter, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数比较有趣，他没有直接调用 ff_inlink_acknowledge_status 来改变 inlink 的 status_out，而是让 output link 发送 request 请求，在 request 过程中会检查 inlink 的 status_in 并更新 status_out：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ff_request_frame_to_filter</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FF_TPRINTF_START</span>(<span class="literal">NULL</span>, request_frame_to_filter); <span class="built_in">ff_tlog_link</span>(<span class="literal">NULL</span>, link, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* Assume the filter is blocked, let the method clear it if not */</span></span><br><span class="line">    link-&gt;frame_blocked_in = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;srcpad-&gt;request_frame)</span><br><span class="line">        ret = link-&gt;srcpad-&gt;<span class="built_in">request_frame</span>(link);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (link-&gt;src-&gt;inputs[<span class="number">0</span>])</span><br><span class="line">        ret = <span class="built_in">ff_request_frame</span>(link-&gt;src-&gt;inputs[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="built_in">AVERROR</span>(EAGAIN) &amp;&amp; ret != link-&gt;status_in)</span><br><span class="line">            <span class="built_in">ff_avfilter_link_set_in_status</span>(link, ret, <span class="built_in">guess_status_pts</span>(link-&gt;src, ret, link-&gt;time_base));</span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR_EOF)</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_request_frame</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!link-&gt;outcfg.formats)</span><br><span class="line">        <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert1</span>(!link-&gt;dst-&gt;filter-&gt;activate);</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;status_out)</span><br><span class="line">        <span class="keyword">return</span> link-&gt;status_out;</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;status_in) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ff_framequeue_queued_frames</span>(&amp;link-&gt;fifo)) &#123;</span><br><span class="line">            <span class="built_in">av_assert1</span>(!link-&gt;frame_wanted_out);</span><br><span class="line">            <span class="built_in">av_assert1</span>(link-&gt;dst-&gt;ready &gt;= <span class="number">300</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Acknowledge status change. Filters using ff_request_frame() will</span></span><br><span class="line"><span class="comment">               handle the change automatically. Filters can also check the</span></span><br><span class="line"><span class="comment">               status directly but none do yet. */</span></span><br><span class="line">            <span class="built_in">ff_avfilter_link_set_out_status</span>(link, link-&gt;status_in, link-&gt;status_in_pts);</span><br><span class="line">            <span class="keyword">return</span> link-&gt;status_out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    link-&gt;frame_wanted_out = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ff_filter_set_ready</span>(link-&gt;src, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_request_frame_to_filter 在让 outlink 发送 request 请求的同时还把 inlink 的状态传递给了 outlink。</p><p>如果上面两步都没有执行，那么 ff_filter_activate_default 最后会尝试执行 ff_request_frame_to_filter 往上游传递 request_frame 请求。在传递 request_frame 请求时会检查 outlink 的 frame_wanted_out 和 frame_blocked_in，frame_wanted_out 比较好理解，而 frame_blocked_in 则是 ff_request_frame_to_filter 函数内设置的，也就是说避免 ff_request_frame_to_filter 对同一个 link 多次执行。</p><p>经过对比可以发现，默认激活函数做的事情也是那么几件：从上往下送数据，从上往下传递状态，从下往上传递 request 请求。默认激活函数通常和 pad 的 request_frame 和 filter_frame 配合使用。</p><p>最后再总结一下 pad 的 request_frame 和 filter_frame 函数：request_frame 只出现在 output pad，用于把 outlink 上的 request 请求传递给 inlink；filter_frame 只出现在 input pad，用于把 inlink 上的 frame 传递到 outlink 的 fifo。</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg filter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg filter之格式协商（format negotiation）</title>
      <link href="/2023/03/19/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86%EF%BC%88format-negotiation%EF%BC%89/"/>
      <url>/2023/03/19/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86%EF%BC%88format-negotiation%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这篇博客接着上一篇介绍一下 filter 的格式协商。</p><p>从个人的学习经验来看，格式协商算是 filter 中最不容易理解的一部分了，但反过来说，理解了格式协商那么 filter 就基本上摸清楚了。</p><p>还是以上篇博客中的例子为研究对象，但是这次把目光聚焦在 avfilter_graph_config 函数上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> AVFilter *buffersrc  = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;buffer&quot;</span>);</span><br><span class="line"><span class="type">const</span> AVFilter *buffersink = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;buffersink&quot;</span>);</span><br><span class="line"><span class="type">const</span> AVFilter *myfilter   = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;myfilter&quot;</span>);</span><br><span class="line"></span><br><span class="line">AVFilterGraph *filter_graph = <span class="built_in">avfilter_graph_alloc</span>();</span><br><span class="line"></span><br><span class="line">AVFilterContext *in_video_filter = <span class="literal">NULL</span>;</span><br><span class="line">AVFilterContext *out_video_filter = <span class="literal">NULL</span>;</span><br><span class="line">AVFilterContext *my_video_filter = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">avfilter_graph_create_filter</span>(&amp;in_video_filter, buffersrc, <span class="string">&quot;in&quot;</span>, args, <span class="literal">NULL</span>, filter_graph);</span><br><span class="line"><span class="built_in">avfilter_graph_create_filter</span>(&amp;out_video_filter, buffersink, <span class="string">&quot;out&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, filter_graph);</span><br><span class="line"><span class="built_in">avfilter_graph_create_filter</span>(&amp;my_video_filter, myfilter, <span class="string">&quot;myfilter&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, filter_graph);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avfilter_link</span>(in_video_filter, <span class="number">0</span>, my_video_filter, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">avfilter_link</span>(my_video_filter, <span class="number">0</span>, out_video_filter, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avfilter_graph_config</span>(filter_graph, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>为了简单起见，假设我们得到的 filtergraph 如下（下面的 filtergraph 涉及到多路连接，需要使用支持多路连接的 filter，这里省略了创建该 filtergraph 的过程，读者可以自己尝试）：</p><p><img src="/images/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86/graph.jpg"></p><h1 id="avfilter-graph-config"><a href="#avfilter-graph-config" class="headerlink" title="avfilter_graph_config"></a>avfilter_graph_config</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avfilter_graph_config</span><span class="params">(AVFilterGraph *graphctx, <span class="type">void</span> *log_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">graph_check_validity</span>(graphctx, log_ctx)))</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">graph_config_formats</span>(graphctx, log_ctx)))</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">graph_config_links</span>(graphctx, log_ctx)))</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">graph_check_links</span>(graphctx, log_ctx)))</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">graph_config_pointers</span>(graphctx, log_ctx)))</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 avfilter_graph_config 函数分成了几个小函数。下面逐一分析每个小函数。</p><h2 id="graph-check-validity"><a href="#graph-check-validity" class="headerlink" title="graph_check_validity"></a>graph_check_validity</h2><p>graph_check_validity 就是检查所有 input 和 output pad 是否都已经连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">graph_check_validity</span><span class="params">(AVFilterGraph *graph, <span class="type">void</span> *log_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext *filt;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">        <span class="type">const</span> AVFilterPad *pad;</span><br><span class="line">        filt = graph-&gt;filters[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filt-&gt;nb_inputs; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!filt-&gt;inputs[j] || !filt-&gt;inputs[j]-&gt;src) &#123;</span><br><span class="line">                pad = &amp;filt-&gt;input_pads[j];</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filt-&gt;nb_outputs; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!filt-&gt;outputs[j] || !filt-&gt;outputs[j]-&gt;dst) &#123;</span><br><span class="line">                pad = &amp;filt-&gt;output_pads[j];</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="graph-config-formats"><a href="#graph-config-formats" class="headerlink" title="graph_config_formats"></a>graph_config_formats</h2><p>graph_config_formats 中进行了格式协商，是 avfilter_graph_config 的核心</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">graph_config_formats</span><span class="params">(AVFilterGraph *graph, <span class="type">void</span> *log_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find supported formats from sub-filters, and merge along links */</span></span><br><span class="line">    <span class="keyword">while</span> ((ret = <span class="built_in">query_formats</span>(graph, log_ctx)) == <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">        <span class="built_in">av_log</span>(graph, AV_LOG_DEBUG, <span class="string">&quot;query_formats not finished\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Once everything is merged, it&#x27;s possible that we&#x27;ll still have</span></span><br><span class="line"><span class="comment">     * multiple valid media format choices. We try to minimize the amount</span></span><br><span class="line"><span class="comment">     * of format conversion inside filters */</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">reduce_formats</span>(graph)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for audio filters, ensure the best format, sample rate and channel layout</span></span><br><span class="line"><span class="comment">     * is selected */</span></span><br><span class="line">    <span class="built_in">swap_sample_fmts</span>(graph);</span><br><span class="line">    <span class="built_in">swap_samplerates</span>(graph);</span><br><span class="line">    <span class="built_in">swap_channel_layouts</span>(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">pick_formats</span>(graph)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>graph_config_formats 中最重要的三步</p><ul><li>1.query_formats()</li><li>2.reduce_formats()</li><li>3.pick_formats()</li></ul><h3 id="query-formats"><a href="#query-formats" class="headerlink" title="query_formats"></a>query_formats</h3><p>query_formats 主要的工作是</p><ul><li><p>查询 filter 上每个 input&#x2F;output 支持的 format</p><ul><li><p>如果每个 input&#x2F;output 上都有 format，就不继续 query</p></li><li><p>否则进行 query</p><ul><li>在 query 之前，如果没有定义 sanitize 方法，就尝试把 agreed format 复制到没有 format 的 input&#x2F;output 上，如果上一步复制 format 后所有 input&#x2F;output 都有了 format，那么跳过下面的 query 过程。这一步是为了优化，避免冗余的查询。对于运行前后过程中 format 会发生变化（比如有时候为空，有时候有值）的 filter，这里需要注意。</li><li>执行 query，填充 link 上的 format</li><li>如果没有 sanitize 方法，填充 query 后还没有 format 的 input&#x2F;output</li></ul></li></ul></li><li><p>执行 sanitize 方法断开无效的 link</p></li><li><p>对每一个 link 上的 input&#x2F;output format 进行合并，如果无法合并，尝试插入 scale、resample filter 进行格式转换</p></li></ul><h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>查询 format 可以简单的认为就是调用 filter 的 query_format 来给 filter 的每个 input&#x2F;output 上的 format 赋值，但实际查询时会作优化处理，比如：</p><ul><li>如果 filter 的每个输入输出都有格式，那么就不调用 query_format；</li><li>如果 filter 没有定义 sanitize 方法，会尝试 ref_agreed_format 用协商好的 format 填充其他为空的 format，以及把 link 上为空的 input&#x2F;output format 自动填充</li></ul><p>经过查询之后，filter 的 input&#x2F;output 就有 format 了，如下图所示</p><p><img src="/images/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86/negation.jpg"></p><p>上图显示了两种可能的查询结果，通常来说经过查询后 filter 的每一个 input&#x2F;output 都会有 format，但是有些 filter 有动态输入输出的需求，会<strong>特意</strong>在某些情况下让 query_format 函数不设置某个 input&#x2F;output 的 format，让其保持为空。将 format 保持为空是为了让后续的 sanitize 过程能剔除这条 link，具体过程留到下面 sanitize 中再介绍。</p><h4 id="sanitize-formats"><a href="#sanitize-formats" class="headerlink" title="sanitize_formats"></a>sanitize_formats</h4><p>sanitize_formats 会把一端有 format、一端没有 format 的 link 的 input&#x2F;output format 都清空，如果一个 link 的 input&#x2F;output format 都为空，那么这个 link 就是断开的。</p><p>对一个 filter 的所有 link 都剔除一遍后，会执行 filter 自定义的 sanitize 方法（如果定义），给 filter 一个调整输入输出的机会，如果 filter 没有定义 sanitize 方法，会执行默认的 sanitize 方法：如果 filter 的 input&#x2F;output 有一端的 format 全部为空，则释放所有 input&#x2F;output 的 format。</p><p>此外 sanitize 过程会反复执行，比如先剔除了一个 filter 的 output link，然后再通过该 filter 的 sanitize 函数改变他的 input link，接着这个 input link 又会影响到他连接的另一个 filter，这个过程会不断执行，直到整个 graph 不再发生变化。</p><p>sanitize 过程可以用下图来表示</p><p><img src="/images/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86/sanitize.jpg"></p><p>第一幅图是 query 之后的初始 format；第二幅图是剔除了一端有 format，一端没有 format 的 link；第三幅图是 filter 默认的 sanitize 函数的作用：如果有一端全部为空，则释放所有的 format；第四幅图还是剔除了一端有 format，一端没有 format 的 link，但是这个是因为 filter 默认的 sanitize 函数剔除了 link 上某端的 format 而重新引起的。第四幅图就是最后的稳定状态，可以看到在稳定状态下只有最上面的链路是连通的，其他的都是断开的。</p><p>下面是 sanitize_formats 的具体代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">sanitize_formats</span><span class="params">(AVFilterGraph *graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext *f;</span><br><span class="line">    <span class="type">bool</span> changed = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">unsigned</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">        f = graph-&gt;filters[i];</span><br><span class="line">        <span class="comment">// 对每个filter，先剔除一端有format，一端没有format的input link</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; f-&gt;nb_inputs; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!f-&gt;inputs[j]-&gt;outcfg.formats &amp;&amp; f-&gt;inputs[j]-&gt;incfg.formats) &#123;</span><br><span class="line">                <span class="built_in">ff_avfilter_link_unref_formats</span>(f-&gt;inputs[j]);</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后剔除一端有format，一端没有format的output link</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; f-&gt;nb_outputs; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!f-&gt;outputs[j]-&gt;incfg.formats &amp;&amp; f-&gt;outputs[j]-&gt;outcfg.formats) &#123;</span><br><span class="line">                <span class="built_in">ff_avfilter_link_unref_formats</span>(f-&gt;outputs[j]);</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用filter的sanitize_formats方法或者默认的sanitize_formats方法</span></span><br><span class="line">        <span class="keyword">if</span> (f-&gt;filter-&gt;sanitize_formats) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f-&gt;filter-&gt;<span class="built_in">sanitize_formats</span>(f) == <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (formats_useless(f)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; f-&gt;nb_inputs; j++)</span><br><span class="line">                <span class="built_in">ff_avfilter_link_unref_formats</span>(f-&gt;inputs[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; f-&gt;nb_outputs; j++)</span><br><span class="line">                <span class="built_in">ff_avfilter_link_unref_formats</span>(f-&gt;outputs[j]);</span><br><span class="line"></span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果filter有一端全部没有format，那么整个filter是无用的</span></span><br><span class="line"><span class="comment">// 所以可以把输入、输出format全部置为空</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">formats_useless</span><span class="params">(AVFilterContext *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> in, out;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;nb_inputs == <span class="number">0</span> || f-&gt;nb_outputs == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    in = out = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;nb_inputs; i++)</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;inputs[i]-&gt;outcfg.formats) &#123;</span><br><span class="line">            in = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;nb_outputs; i++)</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;outputs[i]-&gt;incfg.formats) &#123;</span><br><span class="line">            out = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> in ^ out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_avfilter_link_unref_formats</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ff_formats_unref</span>(&amp;link-&gt;incfg.formats);</span><br><span class="line">    <span class="built_in">ff_formats_unref</span>(&amp;link-&gt;outcfg.formats);</span><br><span class="line">    <span class="built_in">ff_formats_unref</span>(&amp;link-&gt;incfg.samplerates);</span><br><span class="line">    <span class="built_in">ff_formats_unref</span>(&amp;link-&gt;outcfg.samplerates);</span><br><span class="line">    <span class="built_in">ff_channel_layouts_unref</span>(&amp;link-&gt;incfg.channel_layouts);</span><br><span class="line">    <span class="built_in">ff_channel_layouts_unref</span>(&amp;link-&gt;outcfg.channel_layouts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>sanitize 之后是对同一个 link 上的 input&#x2F;output format 进行 merge，merge 的思路是：如果 input&#x2F;output format 有一个共有的 format，就把这个 format 移到最前面，并且让 input&#x2F;output format 都指向同一个 format</p><p>如果无法合并，则尝试插入 scale 或者 resample filter 进行格式转换</p><p><img src="/images/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86/merge.jpg"></p><p>下面是 merge 的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">merge_pix_fmts</span><span class="params">(<span class="type">void</span> *a, <span class="type">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge_formats_internal</span>(a, b, AVMEDIA_TYPE_VIDEO, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">merge_formats_internal</span><span class="params">(AVFilterFormats *a, AVFilterFormats *b,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">enum</span> AVMediaType type, <span class="type">int</span> check)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> alpha1=<span class="number">0</span>, alpha2=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chroma1=<span class="number">0</span>, chroma2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert2</span>(check || (a-&gt;refcount &amp;&amp; b-&gt;refcount));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MERGE_FORMATS</span>(a, b, formats, nb_formats, AVFilterFormats, check, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把a和b共有的format添加到a中，然后让b的所有引用都指向a并且销毁b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add all formats common to a and b to a, add b&#x27;s refs to a and destroy b.</span></span><br><span class="line"><span class="comment"> * If check is set, nothing is modified and it is only checked whether</span></span><br><span class="line"><span class="comment"> * the formats are compatible.</span></span><br><span class="line"><span class="comment"> * If empty_allowed is set and one of a,b-&gt;nb is zero, the lists are</span></span><br><span class="line"><span class="comment"> * merged; otherwise, 0 (for nonmergeability) is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MERGE_FORMATS(a, b, fmts, nb, type, check, empty_allowed)          \</span></span><br><span class="line"><span class="meta">do &#123;                                                                       \</span></span><br><span class="line"><span class="meta">    int i, j, k = 0, skip = 0;                                             \</span></span><br><span class="line"><span class="meta">                                                                           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (empty_allowed) &#123;                                                   \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!a-&gt;nb || !b-&gt;nb) &#123;                                            \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (check)                                                     \</span></span><br><span class="line"><span class="meta">                return 1;                                                  \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (!a-&gt;nb)                                                    \</span></span><br><span class="line"><span class="meta">                FFSWAP(type *, a, b);                                      \</span></span><br><span class="line"><span class="meta">            skip = 1;                                                      \</span></span><br><span class="line"><span class="meta">        &#125;                                                                  \</span></span><br><span class="line"><span class="meta">    &#125;                                                                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!skip) &#123;                                                           \</span></span><br><span class="line"><span class="meta">        for (i = 0; i <span class="string">&lt; a-&gt;</span>nb; i++)                                        \</span></span><br><span class="line"><span class="meta">            for (j = 0; j <span class="string">&lt; b-&gt;</span>nb; j++)                                    \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (a-&gt;fmts[i] == b-&gt;fmts[j]) &#123;                            \</span></span><br><span class="line"><span class="meta">                    <span class="keyword">if</span> (check)                                             \</span></span><br><span class="line"><span class="meta">                        return 1;                                          \</span></span><br><span class="line"><span class="meta">                    a-&gt;fmts[k++] = a-&gt;fmts[i];                             \</span></span><br><span class="line"><span class="meta">                    break;                                                 \</span></span><br><span class="line"><span class="meta">                &#125;                                                          \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* Check that there was at least one common format.                \</span></span></span><br><span class="line"><span class="comment"><span class="meta">         * Notice that both a and b are unchanged if not. */</span>               \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!k)                                                            \</span></span><br><span class="line"><span class="meta">            return 0;                                                      \</span></span><br><span class="line"><span class="meta">        av_assert2(!check);                                                \</span></span><br><span class="line"><span class="meta">        a-&gt;nb = k;                                                         \</span></span><br><span class="line"><span class="meta">    &#125;                                                                      \</span></span><br><span class="line"><span class="meta">                                                                           \</span></span><br><span class="line"><span class="meta">    MERGE_REF(a, b, fmts, type, return AVERROR(ENOMEM););                  \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add all refs from a to ret and destroy a.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MERGE_REF(ret, a, fmts, type, fail_statement)                      \</span></span><br><span class="line"><span class="meta">do &#123;                                                                       \</span></span><br><span class="line"><span class="meta">    type ***tmp;                                                           \</span></span><br><span class="line"><span class="meta">    int i;                                                                 \</span></span><br><span class="line"><span class="meta">                                                                           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!(tmp = av_realloc_array(ret-&gt;refs, ret-&gt;refcount + a-&gt;refcount,   \</span></span><br><span class="line"><span class="meta">                                 sizeof(*tmp))))                           \</span></span><br><span class="line"><span class="meta">        &#123; fail_statement &#125;                                                 \</span></span><br><span class="line"><span class="meta">    ret-&gt;refs = tmp;                                                       \</span></span><br><span class="line"><span class="meta">                                                                           \</span></span><br><span class="line"><span class="meta">    for (i = 0; i <span class="string">&lt; a-&gt;</span>refcount; i ++) &#123;                                   \</span></span><br><span class="line"><span class="meta">        ret-&gt;refs[ret-&gt;refcount] = a-&gt;refs[i];                             \</span></span><br><span class="line"><span class="meta">        *ret-&gt;refs[ret-&gt;refcount++] = ret;                                 \</span></span><br><span class="line"><span class="meta">    &#125;                                                                      \</span></span><br><span class="line"><span class="meta">                                                                           \</span></span><br><span class="line"><span class="meta">    av_freep(&amp;a-&gt;refs);                                                    \</span></span><br><span class="line"><span class="meta">    av_freep(&amp;a-&gt;fmts);                                                    \</span></span><br><span class="line"><span class="meta">    av_freep(&amp;a);                                                          \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><h3 id="reduce-formats"><a href="#reduce-formats" class="headerlink" title="reduce_formats"></a>reduce_formats</h3><p>reduce_formats 主要是对同一个 filter 的输入输出格式进行优化，减小在同一个 filter 内的格式转换次数，如下所示</p><p><img src="/images/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86/reduce_formats.jpg"></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">reduce_formats</span><span class="params">(AVFilterGraph *graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, reduced, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        reduced = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">reduce_formats_on_filter</span>(graph-&gt;filters[i])) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            reduced |= ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (reduced);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">reduce_formats_on_filter</span><span class="params">(AVFilterContext *filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">REDUCE_FORMATS</span>(<span class="type">int</span>,      AVFilterFormats,        formats,         formats,</span><br><span class="line">                   nb_formats, ff_add_format);</span><br><span class="line">    <span class="built_in">REDUCE_FORMATS</span>(<span class="type">int</span>,      AVFilterFormats,        samplerates,     formats,</span><br><span class="line">                   nb_formats, ff_add_format);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reduce channel layouts */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDUCE_FORMATS(fmt_type, list_type, list, var, nb, add_format) \</span></span><br><span class="line"><span class="meta">do &#123;                                                                   \</span></span><br><span class="line"><span class="meta">    for (i = 0; i <span class="string">&lt; filter-&gt;</span>nb_inputs; i++) &#123;                          \</span></span><br><span class="line"><span class="meta">        AVFilterLink *link = filter-&gt;inputs[i];                        \</span></span><br><span class="line"><span class="meta">        fmt_type fmt;                                                  \</span></span><br><span class="line"><span class="meta">                                                                       \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!link-&gt;outcfg.list || link-&gt;outcfg.list-&gt;nb != 1)          \</span></span><br><span class="line"><span class="meta">            continue;                                                  \</span></span><br><span class="line"><span class="meta">        fmt = link-&gt;outcfg.list-&gt;var[0];                               \</span></span><br><span class="line"><span class="meta">                                                                       \</span></span><br><span class="line"><span class="meta">        for (j = 0; j <span class="string">&lt; filter-&gt;</span>nb_outputs; j++) &#123;                     \</span></span><br><span class="line"><span class="meta">            AVFilterLink *out_link = filter-&gt;outputs[j];               \</span></span><br><span class="line"><span class="meta">            list_type *fmts;                                           \</span></span><br><span class="line"><span class="meta">                                                                       \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (link-&gt;type != out_link-&gt;type ||                        \</span></span><br><span class="line"><span class="meta">                out_link-&gt;incfg.list-&gt;nb == 1)                         \</span></span><br><span class="line"><span class="meta">                continue;                                              \</span></span><br><span class="line"><span class="meta">            fmts = out_link-&gt;incfg.list;                               \</span></span><br><span class="line"><span class="meta">                                                                       \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (!out_link-&gt;incfg.list-&gt;nb) &#123;                           \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> ((ret = add_format(&amp;out_link-&gt;incfg.list, fmt)) &lt; 0)\</span></span><br><span class="line"><span class="meta">                    return ret;                                        \</span></span><br><span class="line"><span class="meta">                ret = 1;                                               \</span></span><br><span class="line"><span class="meta">                break;                                                 \</span></span><br><span class="line"><span class="meta">            &#125;                                                          \</span></span><br><span class="line"><span class="meta">                                                                       \</span></span><br><span class="line"><span class="meta">            for (k = 0; k <span class="string">&lt; out_link-&gt;</span>incfg.list-&gt;nb; k++)             \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (fmts-&gt;var[k] == fmt) &#123;                             \</span></span><br><span class="line"><span class="meta">                    fmts-&gt;var[0]  = fmt;                               \</span></span><br><span class="line"><span class="meta">                    fmts-&gt;nb = 1;                                      \</span></span><br><span class="line"><span class="meta">                    ret = 1;                                           \</span></span><br><span class="line"><span class="meta">                    break;                                             \</span></span><br><span class="line"><span class="meta">                &#125;                                                      \</span></span><br><span class="line"><span class="meta">        &#125;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                  \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><h3 id="pick-formats"><a href="#pick-formats" class="headerlink" title="pick_formats"></a>pick_formats</h3><p>pick_formats 主要是将每个 link 上的格式固定下来</p><p>如果 link 上的 input format 或者 output format 的 number 只有一个，那么就使用那个格式作为最终格式，否则会借助<code>inputs[0]</code>的格式来决定输出 link 该选择哪个格式最优</p><p><img src="/images/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86/pick_formats.jpg"></p><p>下面是具体代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pick_formats</span><span class="params">(AVFilterGraph *graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, ret;</span><br><span class="line">    <span class="type">int</span> change;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        change = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">            AVFilterContext *filter = graph-&gt;filters[i];</span><br><span class="line">            <span class="keyword">if</span> (filter-&gt;nb_inputs)&#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filter-&gt;nb_inputs; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (filter-&gt;inputs[j]-&gt;incfg.formats &amp;&amp; filter-&gt;inputs[j]-&gt;incfg.formats-&gt;nb_formats == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((ret = <span class="built_in">pick_format</span>(filter-&gt;inputs[j], <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> ret;</span><br><span class="line">                        change = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (filter-&gt;nb_outputs)&#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filter-&gt;nb_outputs; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (filter-&gt;outputs[j]-&gt;incfg.formats &amp;&amp; filter-&gt;outputs[j]-&gt;incfg.formats-&gt;nb_formats == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((ret = <span class="built_in">pick_format</span>(filter-&gt;outputs[j], <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> ret;</span><br><span class="line">                        change = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (filter-&gt;nb_inputs &amp;&amp; filter-&gt;nb_outputs &amp;&amp; filter-&gt;inputs[<span class="number">0</span>]-&gt;format&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filter-&gt;nb_outputs; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (filter-&gt;outputs[j]-&gt;format&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((ret = <span class="built_in">pick_format</span>(filter-&gt;outputs[j], filter-&gt;inputs[<span class="number">0</span>])) &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> ret;</span><br><span class="line">                        change = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(change);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">        AVFilterContext *filter = graph-&gt;filters[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filter-&gt;nb_inputs; j++)</span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">pick_format</span>(filter-&gt;inputs[j], <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filter-&gt;nb_outputs; j++)</span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">pick_format</span>(filter-&gt;outputs[j], <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pick_format</span><span class="params">(AVFilterLink *link, AVFilterLink *ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!link || !link-&gt;incfg.formats)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (link-&gt;type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ref &amp;&amp; ref-&gt;type == AVMEDIA_TYPE_VIDEO)&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">FIXME:</span> This should check for AV_PIX_FMT_FLAG_ALPHA after PAL8 pixel format without alpha is implemented</span></span><br><span class="line">            <span class="type">int</span> has_alpha= <span class="built_in">av_pix_fmt_desc_get</span>(ref-&gt;format)-&gt;nb_components % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">enum</span> <span class="title class_">AVPixelFormat</span> best= AV_PIX_FMT_NONE;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; link-&gt;incfg.formats-&gt;nb_formats; i++) &#123;</span><br><span class="line">                <span class="keyword">enum</span> <span class="title class_">AVPixelFormat</span> p = link-&gt;incfg.formats-&gt;formats[i];</span><br><span class="line">                best= <span class="built_in">av_find_best_pix_fmt_of_2</span>(best, p, ref-&gt;format, has_alpha, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">av_log</span>(link-&gt;src,AV_LOG_DEBUG, <span class="string">&quot;picking %s out of %d ref:%s alpha:%d\n&quot;</span>,</span><br><span class="line">                   <span class="built_in">av_get_pix_fmt_name</span>(best), link-&gt;incfg.formats-&gt;nb_formats,</span><br><span class="line">                   <span class="built_in">av_get_pix_fmt_name</span>(ref-&gt;format), has_alpha);</span><br><span class="line">            link-&gt;incfg.formats-&gt;formats[<span class="number">0</span>] = best;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (link-&gt;type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ref &amp;&amp; ref-&gt;type == AVMEDIA_TYPE_AUDIO)&#123;</span><br><span class="line">            <span class="keyword">enum</span> AVSampleFormat best= AV_SAMPLE_FMT_NONE;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; link-&gt;incfg.formats-&gt;nb_formats; i++) &#123;</span><br><span class="line">                <span class="keyword">enum</span> <span class="title class_">AVSampleFormat</span> p = link-&gt;incfg.formats-&gt;formats[i];</span><br><span class="line">                best = <span class="built_in">find_best_sample_fmt_of_2</span>(best, p, ref-&gt;format);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">av_log</span>(link-&gt;src,AV_LOG_DEBUG, <span class="string">&quot;picking %s out of %d ref:%s\n&quot;</span>,</span><br><span class="line">                   <span class="built_in">av_get_sample_fmt_name</span>(best), link-&gt;incfg.formats-&gt;nb_formats,</span><br><span class="line">                   <span class="built_in">av_get_sample_fmt_name</span>(ref-&gt;format));</span><br><span class="line">            link-&gt;incfg.formats-&gt;formats[<span class="number">0</span>] = best;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    link-&gt;incfg.formats-&gt;nb_formats = <span class="number">1</span>;</span><br><span class="line">    link-&gt;format = link-&gt;incfg.formats-&gt;formats[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (link-&gt;type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="graph-config-links"><a href="#graph-config-links" class="headerlink" title="graph_config_links"></a>graph_config_links</h2><p>这一步是配置 link，graph_config_links 函数会调用 src&#x2F;sink pad 上的 config props 函数传递 width、height 等信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">graph_config_links</span><span class="params">(AVFilterGraph *graph, <span class="type">void</span> *log_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext *filt;</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">        filt = graph-&gt;filters[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!filt-&gt;nb_outputs) &#123; <span class="comment">// 从sink filter开始从后向前</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">avfilter_config_links</span>(filt)))</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avfilter_config_links</span><span class="params">(AVFilterContext *filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*config_link)(AVFilterLink *);</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter-&gt;nb_inputs; i ++) &#123;</span><br><span class="line">        AVFilterLink *link = filter-&gt;inputs[i];</span><br><span class="line">        AVFilterLink *inlink;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!link || !link-&gt;incfg.formats || !link-&gt;outcfg.formats)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!link-&gt;src || !link-&gt;dst) &#123;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inlink = link-&gt;src-&gt;nb_inputs ? link-&gt;src-&gt;inputs[<span class="number">0</span>] : <span class="literal">NULL</span>;</span><br><span class="line">        link-&gt;current_pts =</span><br><span class="line">        link-&gt;current_pts_us = AV_NOPTS_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (link-&gt;init_state) &#123;</span><br><span class="line">        <span class="keyword">case</span> AVLINK_INIT:</span><br><span class="line">            <span class="comment">/* For part graph re-negotiation.</span></span><br><span class="line"><span class="comment">               For example: output-filter link has config_props(),</span></span><br><span class="line"><span class="comment">               but the input-filter still need config_props(). */</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">avfilter_config_links</span>(link-&gt;src)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> AVLINK_STARTINIT:</span><br><span class="line">            <span class="built_in">av_log</span>(filter, AV_LOG_INFO, <span class="string">&quot;circular filter chain detected\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> AVLINK_UNINIT:</span><br><span class="line">            link-&gt;init_state = AVLINK_STARTINIT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">avfilter_config_links</span>(link-&gt;src)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(config_link = link-&gt;srcpad-&gt;config_props)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (link-&gt;src-&gt;nb_inputs != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(link-&gt;src, AV_LOG_ERROR, <span class="string">&quot;Source filters and filters &quot;</span></span><br><span class="line">                                                    <span class="string">&quot;with more than one input &quot;</span></span><br><span class="line">                                                    <span class="string">&quot;must set config_props() &quot;</span></span><br><span class="line">                                                    <span class="string">&quot;callbacks on all outputs\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((ret = <span class="built_in">config_link</span>(link)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(link-&gt;src, AV_LOG_ERROR,</span><br><span class="line">                       <span class="string">&quot;Failed to configure output pad on %s\n&quot;</span>,</span><br><span class="line">                       link-&gt;src-&gt;name);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (link-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">                <span class="keyword">if</span> (!link-&gt;time_base.num &amp;&amp; !link-&gt;time_base.den)</span><br><span class="line">                    link-&gt;time_base = inlink ? inlink-&gt;time_base : AV_TIME_BASE_Q;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!link-&gt;sample_aspect_ratio.num &amp;&amp; !link-&gt;sample_aspect_ratio.den)</span><br><span class="line">                    link-&gt;sample_aspect_ratio = inlink ?</span><br><span class="line">                        inlink-&gt;sample_aspect_ratio : (AVRational)&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (inlink) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!link-&gt;frame_rate.num &amp;&amp; !link-&gt;frame_rate.den)</span><br><span class="line">                        link-&gt;frame_rate = inlink-&gt;frame_rate;</span><br><span class="line">                    <span class="keyword">if</span> (!link-&gt;w)</span><br><span class="line">                        link-&gt;w = inlink-&gt;w;</span><br><span class="line">                    <span class="keyword">if</span> (!link-&gt;h)</span><br><span class="line">                        link-&gt;h = inlink-&gt;h;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!link-&gt;w || !link-&gt;h) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(link-&gt;src, AV_LOG_ERROR,</span><br><span class="line">                           <span class="string">&quot;Video source filters must set their output link&#x27;s &quot;</span></span><br><span class="line">                           <span class="string">&quot;width and height\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">                <span class="keyword">if</span> (inlink) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!link-&gt;time_base.num &amp;&amp; !link-&gt;time_base.den)</span><br><span class="line">                        link-&gt;time_base = inlink-&gt;time_base;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!link-&gt;time_base.num &amp;&amp; !link-&gt;time_base.den)</span><br><span class="line">                    link-&gt;time_base = (AVRational) &#123;<span class="number">1</span>, link-&gt;sample_rate&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (link-&gt;src-&gt;nb_inputs &amp;&amp; link-&gt;src-&gt;inputs[<span class="number">0</span>]-&gt;hw_frames_ctx &amp;&amp;</span><br><span class="line">                !(link-&gt;src-&gt;filter-&gt;flags_internal &amp; FF_FILTER_FLAG_HWFRAME_AWARE)) &#123;</span><br><span class="line">                <span class="built_in">av_assert0</span>(!link-&gt;hw_frames_ctx &amp;&amp;</span><br><span class="line">                           <span class="string">&quot;should not be set by non-hwframe-aware filter&quot;</span>);</span><br><span class="line">                link-&gt;hw_frames_ctx = <span class="built_in">av_buffer_ref</span>(link-&gt;src-&gt;inputs[<span class="number">0</span>]-&gt;hw_frames_ctx);</span><br><span class="line">                <span class="keyword">if</span> (!link-&gt;hw_frames_ctx)</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((config_link = link-&gt;dstpad-&gt;config_props))</span><br><span class="line">                <span class="keyword">if</span> ((ret = <span class="built_in">config_link</span>(link)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(link-&gt;dst, AV_LOG_ERROR,</span><br><span class="line">                           <span class="string">&quot;Failed to configure input pad on %s\n&quot;</span>,</span><br><span class="line">                           link-&gt;dst-&gt;name);</span><br><span class="line">                    <span class="keyword">return</span> ret;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            link-&gt;init_state = AVLINK_INIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>graph_config_links 会从 sink filter 开始向前递归，然后从 src filter 开始配置 link，是一个 dfs 过程。</p><p>graph_check_links 和 graph_config_pointers 都比较简单，这里就不再仔细介绍。</p><p>参考资料：</p><p><a href="https://www.cnblogs.com/TaigaCon/p/10111326.html">https://www.cnblogs.com/TaigaCon/p/10111326.html</a></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg filter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg filter之创建filter与filtergraph</title>
      <link href="/2023/03/16/ffmpeg-filter%E4%B9%8B%E5%88%9B%E5%BB%BAfilter%E4%B8%8Efiltergraph/"/>
      <url>/2023/03/16/ffmpeg-filter%E4%B9%8B%E5%88%9B%E5%BB%BAfilter%E4%B8%8Efiltergraph/</url>
      
        <content type="html"><![CDATA[<p>这篇博客介绍一下 ffmpeg 中 filter 和 filtergraph 的使用，为后续介绍具体原理作铺垫。</p><p>下面是一个 filter 和 filtergraph 的简单示例：</p><ul><li>先从 filtergraph 中创建 3 个 filter 的实例</li><li>将 filter 实例连接起来</li><li>配置整个 filtergraph，然后就可以使用该 filtergraph 对数据进行处理</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> AVFilter *buffersrc  = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;buffer&quot;</span>);</span><br><span class="line"><span class="type">const</span> AVFilter *buffersink = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;buffersink&quot;</span>);</span><br><span class="line"><span class="type">const</span> AVFilter *myfilter   = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;myfilter&quot;</span>);</span><br><span class="line"></span><br><span class="line">AVFilterGraph *filter_graph = <span class="built_in">avfilter_graph_alloc</span>();</span><br><span class="line"></span><br><span class="line">AVFilterContext *in_video_filter = <span class="literal">NULL</span>;</span><br><span class="line">AVFilterContext *out_video_filter = <span class="literal">NULL</span>;</span><br><span class="line">AVFilterContext *my_video_filter = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">avfilter_graph_create_filter</span>(&amp;in_video_filter, buffersrc, <span class="string">&quot;in&quot;</span>, args, <span class="literal">NULL</span>, filter_graph);</span><br><span class="line"><span class="built_in">avfilter_graph_create_filter</span>(&amp;out_video_filter, buffersink, <span class="string">&quot;out&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, filter_graph);</span><br><span class="line"><span class="built_in">avfilter_graph_create_filter</span>(&amp;my_video_filter, myfilter, <span class="string">&quot;myfilter&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, filter_graph);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avfilter_link</span>(in_video_filter, <span class="number">0</span>, my_video_filter, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">avfilter_link</span>(my_video_filter, <span class="number">0</span>, out_video_filter, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avfilter_graph_config</span>(filter_graph, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>上面代码的逻辑比较好理解，这里不作过多介绍。下面直接分析相关 api 的代码实现</p><h1 id="avfilter-get-by-name"><a href="#avfilter-get-by-name" class="headerlink" title="avfilter_get_by_name"></a>avfilter_get_by_name</h1><p>avfilter_get_by_name 就是通过 name 字符串得到 AVFilter 的指针，AVFilter 相当于一个描述符，指明了将要创建的 AVFilterContext 的特性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVFilter *<span class="title">avfilter_get_by_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVFilter *f = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span> *opaque = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!name)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((f = <span class="built_in">av_filter_iterate</span>(&amp;opaque)))</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(f-&gt;name, name))</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="avfilter-graph-alloc"><a href="#avfilter-graph-alloc" class="headerlink" title="avfilter_graph_alloc"></a>avfilter_graph_alloc</h1><p>avfilter_graph_alloc 则是创建 AVFilterGraph 实例，该实例管理所有的 AVFilterContext</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVFilterGraph *<span class="title">avfilter_graph_alloc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterGraph *ret = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*ret));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret-&gt;internal = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*ret-&gt;internal));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret-&gt;av_class = &amp;filtergraph_class;</span><br><span class="line">    <span class="built_in">av_opt_set_defaults</span>(ret);</span><br><span class="line">    <span class="built_in">ff_framequeue_global_init</span>(&amp;ret-&gt;internal-&gt;frame_queues);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_framequeue_global_init</span><span class="params">(FFFrameQueueGlobal *fqg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="avfilter-graph-create-filter"><a href="#avfilter-graph-create-filter" class="headerlink" title="avfilter_graph_create_filter"></a>avfilter_graph_create_filter</h1><p>这个函数是在 AVFilterGraph 实例内创建 AVFilterContext，具体来说就是先创建 AVFilterContext，然后将 AVFilterContext 添加到 AVFilterGraph 中，当然用户也可以手动进行这两个过程，但是 avfilter_graph_create_filter 在把 AVFilterContext 添加到 AVFilterGraph 时会自动处理 AVFilterGraph 中的 AVFilterContext 指针数组，不建议用户直接使用底层接口。</p><p>avfilter_graph_create_filter 中还会执行 AVFilterContext 的初始化，也就是会调用 AVFilter 中定义的 init&#x2F;init_dict 函数初始化 AVFilterContext。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avfilter_graph_create_filter</span><span class="params">(AVFilterContext **filt_ctx, <span class="type">const</span> AVFilter *filt,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *args, <span class="type">void</span> *opaque,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 AVFilterGraph *graph_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    *filt_ctx = <span class="built_in">avfilter_graph_alloc_filter</span>(graph_ctx, filt, name);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">avfilter_init_str</span>(*filt_ctx, args);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVFilterContext *<span class="title">avfilter_graph_alloc_filter</span><span class="params">(AVFilterGraph *graph,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> AVFilter *filter,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext **filters, *s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (graph-&gt;thread_type &amp;&amp; !graph-&gt;internal-&gt;thread_execute) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph-&gt;execute) &#123;</span><br><span class="line">            graph-&gt;internal-&gt;thread_execute = graph-&gt;execute;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> ret = <span class="built_in">ff_graph_thread_init</span>(graph);</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filters = <span class="built_in">av_realloc_array</span>(graph-&gt;filters, graph-&gt;nb_filters + <span class="number">1</span>, <span class="built_in">sizeof</span>(*filters));</span><br><span class="line">...</span><br><span class="line">    graph-&gt;filters = filters;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">ff_filter_alloc</span>(filter, name);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    graph-&gt;filters[graph-&gt;nb_filters++] = s;</span><br><span class="line"></span><br><span class="line">    s-&gt;graph = graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVFilterContext *<span class="title">ff_filter_alloc</span><span class="params">(<span class="type">const</span> AVFilter *filter, <span class="type">const</span> <span class="type">char</span> *inst_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext *ret;</span><br><span class="line">    <span class="type">int</span> preinited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filter)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(AVFilterContext));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret-&gt;av_class = &amp;avfilter_class;</span><br><span class="line">    ret-&gt;filter   = filter;</span><br><span class="line">    ret-&gt;name     = inst_name ? <span class="built_in">av_strdup</span>(inst_name) : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (filter-&gt;priv_size) &#123;</span><br><span class="line">        ret-&gt;priv     = <span class="built_in">av_mallocz</span>(filter-&gt;priv_size);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (filter-&gt;preinit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter-&gt;<span class="built_in">preinit</span>(ret) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        preinited = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_opt_set_defaults</span>(ret);</span><br><span class="line">    <span class="keyword">if</span> (filter-&gt;priv_class) &#123;</span><br><span class="line">        *(<span class="type">const</span> AVClass**)ret-&gt;priv = filter-&gt;priv_class;</span><br><span class="line">        <span class="built_in">av_opt_set_defaults</span>(ret-&gt;priv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret-&gt;internal = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*ret-&gt;internal));</span><br><span class="line">...</span><br><span class="line">    ret-&gt;internal-&gt;execute = default_execute;</span><br><span class="line"></span><br><span class="line">    ret-&gt;nb_inputs  = filter-&gt;nb_inputs;</span><br><span class="line">    <span class="keyword">if</span> (ret-&gt;nb_inputs ) &#123;</span><br><span class="line">        ret-&gt;input_pads   = <span class="built_in">av_memdup</span>(filter-&gt;inputs,  ret-&gt;nb_inputs  * <span class="built_in">sizeof</span>(*filter-&gt;inputs));</span><br><span class="line">...</span><br><span class="line">        ret-&gt;inputs      = <span class="built_in">av_calloc</span>(ret-&gt;nb_inputs, <span class="built_in">sizeof</span>(*ret-&gt;inputs));</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret-&gt;nb_outputs = filter-&gt;nb_outputs;</span><br><span class="line">    <span class="keyword">if</span> (ret-&gt;nb_outputs) &#123;</span><br><span class="line">        ret-&gt;output_pads  = <span class="built_in">av_memdup</span>(filter-&gt;outputs, ret-&gt;nb_outputs * <span class="built_in">sizeof</span>(*filter-&gt;outputs));</span><br><span class="line">...</span><br><span class="line">        ret-&gt;outputs     = <span class="built_in">av_calloc</span>(ret-&gt;nb_outputs, <span class="built_in">sizeof</span>(*ret-&gt;outputs));</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avfilter_init_str</span><span class="params">(AVFilterContext *filter, <span class="type">const</span> <span class="type">char</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVDictionary *options = <span class="literal">NULL</span>;</span><br><span class="line">    AVDictionaryEntry *e;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args &amp;&amp; *args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!filter-&gt;filter-&gt;priv_class) &#123;</span><br><span class="line">            <span class="built_in">av_log</span>(filter, AV_LOG_ERROR, <span class="string">&quot;This filter does not take any &quot;</span></span><br><span class="line">                   <span class="string">&quot;options, but options were provided: %s.\n&quot;</span>, args);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">process_options</span>(filter, &amp;options, args);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">avfilter_init_dict</span>(filter, &amp;options);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((e = <span class="built_in">av_dict_get</span>(options, <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span>, AV_DICT_IGNORE_SUFFIX))) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(filter, AV_LOG_ERROR, <span class="string">&quot;No such option: %s.\n&quot;</span>, e-&gt;key);</span><br><span class="line">        ret = AVERROR_OPTION_NOT_FOUND;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avfilter_init_dict</span><span class="params">(AVFilterContext *ctx, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_opt_set_dict</span>(ctx, options);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;filter-&gt;flags &amp; AVFILTER_FLAG_SLICE_THREADS &amp;&amp;</span><br><span class="line">        ctx-&gt;thread_type &amp; ctx-&gt;graph-&gt;thread_type &amp; AVFILTER_THREAD_SLICE &amp;&amp;</span><br><span class="line">        ctx-&gt;graph-&gt;internal-&gt;thread_execute) &#123;</span><br><span class="line">        ctx-&gt;thread_type       = AVFILTER_THREAD_SLICE;</span><br><span class="line">        ctx-&gt;internal-&gt;execute = ctx-&gt;graph-&gt;internal-&gt;thread_execute;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx-&gt;thread_type = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;filter-&gt;priv_class) &#123;</span><br><span class="line">        ret = <span class="built_in">av_opt_set_dict2</span>(ctx-&gt;priv, options, AV_OPT_SEARCH_CHILDREN);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">av_log</span>(ctx, AV_LOG_ERROR, <span class="string">&quot;Error applying options to the filter.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;filter-&gt;init)</span><br><span class="line">        ret = ctx-&gt;filter-&gt;<span class="built_in">init</span>(ctx);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;filter-&gt;init_dict)</span><br><span class="line">        ret = ctx-&gt;filter-&gt;<span class="built_in">init_dict</span>(ctx, options);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;enable_str) &#123;</span><br><span class="line">        ret = <span class="built_in">set_enable_expr</span>(ctx, ctx-&gt;enable_str);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="avfilter-link"><a href="#avfilter-link" class="headerlink" title="avfilter_link"></a>avfilter_link</h1><p>avfilter_link 函数将两个 filter 的 src、sink 端连接起来，他会创建一个 AVFilterLink 的实例管理该连接。该 AVFilterLink 实例中有很多重要的字段，这些数据控制了这条连接的通断状态和数据缓存，后面会单独写一篇文章介绍 AVFilterLink 上的字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avfilter_link</span><span class="params">(AVFilterContext *src, <span class="type">unsigned</span> srcpad,</span></span></span><br><span class="line"><span class="params"><span class="function">                  AVFilterContext *dst, <span class="type">unsigned</span> dstpad)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterLink *link;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert0</span>(src-&gt;graph);</span><br><span class="line">    <span class="built_in">av_assert0</span>(dst-&gt;graph);</span><br><span class="line">    <span class="built_in">av_assert0</span>(src-&gt;graph == dst-&gt;graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (src-&gt;nb_outputs &lt;= srcpad || dst-&gt;nb_inputs &lt;= dstpad ||</span><br><span class="line">        src-&gt;outputs[srcpad]      || dst-&gt;inputs[dstpad])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (src-&gt;output_pads[srcpad].type != dst-&gt;input_pads[dstpad].type) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(src, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;Media type mismatch between the &#x27;%s&#x27; filter output pad %d (%s) and the &#x27;%s&#x27; filter input pad %d (%s)\n&quot;</span>,</span><br><span class="line">               src-&gt;name, srcpad, (<span class="type">char</span> *)<span class="built_in">av_x_if_null</span>(<span class="built_in">av_get_media_type_string</span>(src-&gt;output_pads[srcpad].type), <span class="string">&quot;?&quot;</span>),</span><br><span class="line">               dst-&gt;name, dstpad, (<span class="type">char</span> *)<span class="built_in">av_x_if_null</span>(<span class="built_in">av_get_media_type_string</span>(dst-&gt; input_pads[dstpad].type), <span class="string">&quot;?&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    link = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*link));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    src-&gt;outputs[srcpad] = dst-&gt;inputs[dstpad] = link;</span><br><span class="line"></span><br><span class="line">    &lt;u&gt;link-&gt;src     = src;&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;link-&gt;dst     = dst;&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;link-&gt;srcpad  = &amp;src-&gt;output_pads[srcpad];&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;link-&gt;dstpad  = &amp;dst-&gt;input_pads[dstpad];&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;link-&gt;type    = src-&gt;output_pads[srcpad].type;&lt;/u&gt;</span><br><span class="line">    <span class="built_in">av_assert0</span>(AV_PIX_FMT_NONE == <span class="number">-1</span> &amp;&amp; AV_SAMPLE_FMT_NONE == <span class="number">-1</span>);</span><br><span class="line">    &lt;u&gt;link-&gt;format  = <span class="number">-1</span>;&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;link-&gt;status_in  = AVERROR_EOF;&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;link-&gt;status_out = AVERROR_EOF;&lt;/u&gt;</span><br><span class="line">    <span class="built_in">ff_framequeue_init</span>(&amp;link-&gt;fifo, &amp;src-&gt;graph-&gt;internal-&gt;frame_queues);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_framequeue_init</span><span class="params">(FFFrameQueue *fq, FFFrameQueueGlobal *fqg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fq-&gt;queue = &amp;fq-&gt;first_bucket;</span><br><span class="line">    fq-&gt;allocated = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面介绍了通过 api 直接构建 filtergraph 的方法，除了这种方法以外还可以通过配置文件来构建 filtergraph，其内部也是使用的上面的 api，只是多了一层解析配置文件、根据配置自动创建并连接 filter 的包装，读者可以参考其他资料，这里不再赘述。下篇博客针对 avfilter_graph_config 函数介绍一下 filter 的格式协商。</p><p>参考资料：</p><p><a href="https://www.cnblogs.com/TaigaCon/p/10067871.html">https://www.cnblogs.com/TaigaCon/p/10067871.html</a></p><p><a href="http://beyoung.xyz/2018/03/24/2018-3-24-FFmpeg%E4%B8%ADAVFilter%E6%A8%A1%E5%9D%97%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/">http://beyoung.xyz/2018/03/24/2018-3-24-FFmpeg%E4%B8%ADAVFilter%E6%A8%A1%E5%9D%97%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</a></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg filter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg之AVFrame和AVPacket</title>
      <link href="/2023/03/13/ffmpeg%E4%B9%8BAVFrame%E5%92%8CAVPacket/"/>
      <url>/2023/03/13/ffmpeg%E4%B9%8BAVFrame%E5%92%8CAVPacket/</url>
      
        <content type="html"><![CDATA[<p>AVFrame 和 AVPacket 是 ffmpeg 中对 buffer 进行管理的结构，AVFrame 用于管理解码好的数据，比如 yuv、rgb 格式的图像，AVPacket 用于管理编码完成后的数据，比如 h264 码流。</p><p>先介绍 AVFrame，他的结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVFrame</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_NUM_DATA_POINTERS 8</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">All pointers in data and extended_data must point into one of the</span></span><br><span class="line"><span class="comment">AVBufferRef in buf or extended_buf.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Some filters and swscale can read</span></span><br><span class="line"><span class="comment">up to 16 bytes beyond the planes, if these filters are to be used,</span></span><br><span class="line"><span class="comment">then 16 extra bytes must be allocated.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">In case of video, the data[] pointers can point to the</span></span><br><span class="line"><span class="comment">end of image data in order to reverse line order, when used in</span></span><br><span class="line"><span class="comment">combination with negative values in the linesize[] array.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">uint8_t</span> *data[AV_NUM_DATA_POINTERS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">For video, a positive or negative value, which is typically indicating</span></span><br><span class="line"><span class="comment">the size in bytes of each picture line,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">int</span> linesize[AV_NUM_DATA_POINTERS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// extended_data指向所有的data，他里面包含了data的内容，也就是说extended_data数组的前面部分就是data的内容</span></span><br><span class="line">    <span class="type">uint8_t</span> **extended_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AVBuffer references backing the data for this frame. All the pointers in</span></span><br><span class="line"><span class="comment">data and extended_data must point inside one of the buffers in buf or extended_buf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    AVBufferRef *buf[AV_NUM_DATA_POINTERS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Note that this is different from AVFrame.extended_data, which always</span></span><br><span class="line"><span class="comment">contains all the pointers. This array only contains the extra pointers,</span></span><br><span class="line"><span class="comment">which cannot fit into AVFrame.buf.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    AVBufferRef **extended_buf;</span><br><span class="line">    <span class="type">int</span>        nb_extended_buf;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>data 是一个指针数组，里面的每一项指向一个内存地址。</li><li>linesize 用于图像，表示这个图像一行的宽度。由于对齐的要求，linesize 通常大于图像的尺寸宽度。</li><li>extended_data 看名字就知道是对 data 数组的扩展，一般用在音频数据中，如果音频数据的 layout 有多个 plane，那么 AV_NUM_DATA_POINTERS 大小的 data 数组可能不够用，此时需要新分配更大的数组来保存这些指针。需要注意，extended_data 是包含 data 数组中的指针的，不是说新分配的指针才保存在 extended_data 中，而是 extended_data 会先把 data 的内容拷贝过来，然后再存储新的 buffer 指针。如果 data 数组够用，那么 extended_data 就指向 data 数组。</li><li>buf 是一个指针数组，每一项指向一个 AVBufferRef，他和 buffer 的引用计数有关，后面介绍引用计数时会具体分析这个成员。</li><li>extended_buf 是一个指针的指针，也可以当成指针数组，看名字就知道 extended_buf 是 buf 的扩展，但是和 extended_data 相较于 data 不一样，extended_buf 数组的前面部分不是 buf，就是新分配的 AVBufferRef*，也就是不用先把 buf 拷贝到 extended_buf，这和 extended_data 不一样。</li><li>nb_extended_buf 是 extended_buf 的辅助信息，指明 extended_buf 数组有多少个元素。为什么 extended_data 没有类似的辅助信息？先留一个疑问，下面再讲。</li></ul><p>了解了 AVFrame 的结构后，再看一下相关的方法。</p><p>要使用 AVFrame，需要先分配 AVFrame 这个结构体本身。下面的 av_frame_alloc 仅仅只分配了 AVFrame，同时作了一些初始化工作。可以看到 extended_data 最开始就是指向 data。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this only allocates the AVFrame itself, not the data buffers.</span></span><br><span class="line"><span class="comment">// The resulting struct must be freed using av_frame_free().</span></span><br><span class="line"><span class="comment">// allocated once and then reused multiple times to hold different data</span></span><br><span class="line"><span class="function">AVFrame *<span class="title">av_frame_alloc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFrame *frame = <span class="built_in">av_malloc</span>(<span class="built_in">sizeof</span>(*frame));</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">get_frame_defaults</span>(frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_frame_defaults</span><span class="params">(AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这一步把width、height等都归0了</span></span><br><span class="line">    <span class="built_in">memset</span>(frame, <span class="number">0</span>, <span class="built_in">sizeof</span>(*frame));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    frame-&gt;pts                   =</span><br><span class="line">    frame-&gt;pkt_dts               = AV_NOPTS_VALUE;</span><br><span class="line">    frame-&gt;best_effort_timestamp = AV_NOPTS_VALUE;</span><br><span class="line">    frame-&gt;pkt_duration        = <span class="number">0</span>;</span><br><span class="line">    frame-&gt;pkt_pos             = <span class="number">-1</span>;</span><br><span class="line">    frame-&gt;pkt_size            = <span class="number">-1</span>;</span><br><span class="line">    frame-&gt;time_base           = (AVRational)&#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    frame-&gt;key_frame           = <span class="number">1</span>;</span><br><span class="line">    frame-&gt;sample_aspect_ratio = (AVRational)&#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    frame-&gt;format              = <span class="number">-1</span>; <span class="comment">/* unknown */</span></span><br><span class="line">    frame-&gt;extended_data       = frame-&gt;data;</span><br><span class="line">    frame-&gt;color_primaries     = AVCOL_PRI_UNSPECIFIED;</span><br><span class="line">    frame-&gt;color_trc           = AVCOL_TRC_UNSPECIFIED;</span><br><span class="line">    frame-&gt;colorspace          = AVCOL_SPC_UNSPECIFIED;</span><br><span class="line">    frame-&gt;color_range         = AVCOL_RANGE_UNSPECIFIED;</span><br><span class="line">    frame-&gt;chroma_location     = AVCHROMA_LOC_UNSPECIFIED;</span><br><span class="line">    frame-&gt;flags               = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_frame_alloc 之后，AVFrame 内部还没有真正可以用来存储数据的内存，需要通过 av_frame_get_buffer 或者其他方式申请内存。使用 av_frame_get_buffer 时，必须指定 format，width&#x2F;height（对视频），nb_samples&#x2F;ch_layout（对音频）。</p><blockquote><p>The following fields must be set on frame before calling this function:<br/> - format (pixel format for video, sample format for audio)<br/> - width and height for video<br/> - nb_samples and ch_layout for audio</p></blockquote><p>此外输入的 AVFrame 必须是“fresh”的，“fresh”是指新 av_frame_alloc 或者 av_frame_unref 后。</p><p>如果 AVFrame 不是“fresh”的，则可能发生内存泄漏：在 get_video_buffer 函数里面是直接对 frame-&gt;data、frame-&gt;buf 赋值，没有内存释放动作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_frame_get_buffer</span><span class="params">(AVFrame *frame, <span class="type">int</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;format &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"><span class="function">FF_DISABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(frame-&gt;width &gt; <span class="number">0</span> &amp;&amp; frame-&gt;height &gt; <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="title">get_video_buffer</span><span class="params">(frame, align)</span></span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (frame-&gt;nb_samples &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             (<span class="built_in">av_channel_layout_check</span>(&amp;frame-&gt;ch_layout)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_OLD_CHANNEL_LAYOUT</span></span><br><span class="line">              || frame-&gt;channel_layout || frame-&gt;channels &gt; <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             ))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_audio_buffer</span>(frame, align);</span><br><span class="line"><span class="function">FF_ENABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">AVERROR</span><span class="params">(EINVAL)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_video_buffer</span><span class="params">(AVFrame *frame, <span class="type">int</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVPixFmtDescriptor *desc = <span class="built_in">av_pix_fmt_desc_get</span>(frame-&gt;format);</span><br><span class="line">    <span class="type">int</span> ret, i, padded_height, total_size;</span><br><span class="line">    <span class="type">int</span> plane_padding = <span class="built_in">FFMAX</span>(<span class="number">16</span> + <span class="number">16</span><span class="comment">/*STRIDE_ALIGN*/</span>, align);</span><br><span class="line">    <span class="type">ptrdiff_t</span> linesizes[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> sizes[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!desc)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_check_size</span>(frame-&gt;width, frame-&gt;height, <span class="number">0</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;linesize[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (align &lt;= <span class="number">0</span>)</span><br><span class="line">            align = <span class="number">32</span>; <span class="comment">/* STRIDE_ALIGN. Should be av_cpu_max_align() */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=align; i+=i) &#123;</span><br><span class="line">            ret = <span class="built_in">av_image_fill_linesizes</span>(frame-&gt;linesize, frame-&gt;format,</span><br><span class="line">                                          <span class="built_in">FFALIGN</span>(frame-&gt;width, i));</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">if</span> (!(frame-&gt;linesize[<span class="number">0</span>] &amp; (align<span class="number">-1</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span> &amp;&amp; frame-&gt;linesize[i]; i++)</span><br><span class="line">            frame-&gt;linesize[i] = <span class="built_in">FFALIGN</span>(frame-&gt;linesize[i], align);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        linesizes[i] = frame-&gt;linesize[i];</span><br><span class="line"></span><br><span class="line">    padded_height = <span class="built_in">FFALIGN</span>(frame-&gt;height, <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_fill_plane_sizes</span>(sizes, frame-&gt;format,</span><br><span class="line">                                         padded_height, linesizes)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    total_size = <span class="number">4</span>*plane_padding;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sizes[i] &gt; INT_MAX - total_size)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        total_size += sizes[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame-&gt;buf[<span class="number">0</span>] = <span class="built_in">av_buffer_alloc</span>(total_size);</span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_fill_pointers</span>(frame-&gt;data, frame-&gt;format, padded_height,</span><br><span class="line">                                      frame-&gt;buf[<span class="number">0</span>]-&gt;data, frame-&gt;linesize)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;data[i])</span><br><span class="line">            frame-&gt;data[i] += i * plane_padding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame-&gt;extended_data = frame-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 get_video_buffer 里面还可以看到，先分配一大块内存到 buf[0]，然后把 data 指针指向这块大 buf 的不同部分。</p><p>再看一下 AVFrame 的引用计数特性。在上面 get_video_buffer 中，是通过 av_buffer_alloc 函数来真正进行内存分配工作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVBufferRef *<span class="title">av_buffer_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">uint8_t</span>    *data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    data = <span class="built_in">av_malloc</span>(size);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_buffer_create</span>(data, size, av_buffer_default_free, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVBufferRef *<span class="title">av_buffer_create</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> (*free)(<span class="type">void</span> *opaque, <span class="type">uint8_t</span> *data),</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *opaque, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *ret;</span><br><span class="line">    AVBuffer *buf = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*buf));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">buffer_create</span>(buf, data, size, free, opaque, flags);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> AVBufferRef *<span class="title">buffer_create</span><span class="params">(AVBuffer *buf, <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">void</span> (*free)(<span class="type">void</span> *opaque, <span class="type">uint8_t</span> *data),</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">void</span> *opaque, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *ref = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    buf-&gt;data     = data;</span><br><span class="line">    buf-&gt;size     = size;</span><br><span class="line">    buf-&gt;free     = free ? free : av_buffer_default_free;</span><br><span class="line">    buf-&gt;opaque   = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">atomic_init</span>(&amp;buf-&gt;refcount, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    buf-&gt;flags = flags;</span><br><span class="line"></span><br><span class="line">    ref = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*ref));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ref-&gt;buffer = buf;</span><br><span class="line">    ref-&gt;data   = data;</span><br><span class="line">    ref-&gt;size   = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先分配真正存储数据的内存，然后创建一个 AVBufferRef 的实例，AVBufferRef 实例中有指向 AVBuffer 的指针，而 AVBuffer 里面有引用计数、释放时调用的 free 函数地址等信息。通过在不同 AVFrame 共享 AVBuffer 指针来实现引用计数。</p><p>从上面可以看到，AVFrame 的 data 数组只是存放内存地址，真正管理内存的是 buf 指向的 AVBufferRef，下面的 ref、unref 操作都是操作的 AVBufferRef</p><p>如果我们不想用引用计数，该怎么办呢？很简单，我们可以直接给 AVFrame 的 data 赋值，赋一个自己申请的内存，同时让 buf 数组为空，这样的 AVFrame 就不是引用计数的。但是这样的 AVFrame 在 ref 时会进行 copy 操作，而且使用带引用计数的 AVFrame 是未来的趋势。</p><p>再看看 AVFrame 的其他操作。</p><p>先看 ref 操作，ref 操作同样要求 dst 是 fresh 的。ref 操作主要做了：</p><ul><li>把 src 的属性，比如 width、height 等拷贝到 dest</li><li>如果 src 不是引用计数，则会把 src 的 data 拷贝到 dst</li><li>否则增加引用计数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_frame_ref</span><span class="params">(AVFrame *dst, <span class="type">const</span> AVFrame *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert1</span>(dst-&gt;width == <span class="number">0</span> &amp;&amp; dst-&gt;height == <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">av_assert1</span>(dst-&gt;ch_layout.nb_channels == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               dst-&gt;ch_layout.order == AV_CHANNEL_ORDER_UNSPEC);</span><br><span class="line"></span><br><span class="line">    dst-&gt;format         = src-&gt;format;</span><br><span class="line">    dst-&gt;width          = src-&gt;width;</span><br><span class="line">    dst-&gt;height         = src-&gt;height;</span><br><span class="line">    dst-&gt;nb_samples     = src-&gt;nb_samples;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里面会处理side data</span></span><br><span class="line">    ret = <span class="built_in">frame_copy_props</span>(dst, src, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* duplicate the frame data if it&#x27;s not refcounted */</span></span><br><span class="line">    <span class="keyword">if</span> (!src-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        ret = <span class="built_in">av_frame_get_buffer</span>(dst, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">        ret = <span class="built_in">av_frame_copy</span>(dst, src);</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ref the buffers */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">FF_ARRAY_ELEMS</span>(src-&gt;buf); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!src-&gt;buf[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dst-&gt;buf[i] = <span class="built_in">av_buffer_ref</span>(src-&gt;buf[i]);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (src-&gt;extended_buf) &#123;</span><br><span class="line">        dst-&gt;extended_buf = <span class="built_in">av_calloc</span>(src-&gt;nb_extended_buf,</span><br><span class="line">                                      <span class="built_in">sizeof</span>(*dst-&gt;extended_buf));</span><br><span class="line">...</span><br><span class="line">        dst-&gt;nb_extended_buf = src-&gt;nb_extended_buf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; src-&gt;nb_extended_buf; i++) &#123;</span><br><span class="line">            dst-&gt;extended_buf[i] = <span class="built_in">av_buffer_ref</span>(src-&gt;extended_buf[i]);</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* duplicate extended data */</span></span><br><span class="line">    <span class="keyword">if</span> (src-&gt;extended_data != src-&gt;data) &#123;</span><br><span class="line">        <span class="type">int</span> ch = dst-&gt;ch_layout.nb_channels;</span><br><span class="line">...</span><br><span class="line">        dst-&gt;extended_data = <span class="built_in">av_malloc_array</span>(<span class="built_in">sizeof</span>(*dst-&gt;extended_data), ch);</span><br><span class="line">...</span><br><span class="line">        <span class="built_in">memcpy</span>(dst-&gt;extended_data, src-&gt;extended_data, <span class="built_in">sizeof</span>(*src-&gt;extended_data) * ch);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        dst-&gt;extended_data = dst-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;data,     src-&gt;data,     <span class="built_in">sizeof</span>(src-&gt;data));</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;linesize, src-&gt;linesize, <span class="built_in">sizeof</span>(src-&gt;linesize));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVBufferRef *<span class="title">av_buffer_ref</span><span class="params">(<span class="type">const</span> AVBufferRef *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *ret = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*ret));</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    *ret = *buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">atomic_fetch_add_explicit</span>(&amp;buf-&gt;buffer-&gt;refcount, <span class="number">1</span>, memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以解答为什么 extended_data 不需要指明数组元素的个数：上面在分配 extended_data 时，数组长度是以 ch_layout.nb_channels 来算的，所以 extended_data 一般用在 audio 数据中。</p><p>再看一下 unref 操作。unref 主要作了：</p><ul><li>释放所有 buf、data</li><li>恢复 AVFrame 中的字段为默认值</li></ul><p>可以认为 unref 之后和新 alloc 得到的 AVFrame 的状态是一样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_frame_unref</span><span class="params">(AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清扫 side_data，暂时不管</span></span><br><span class="line">    <span class="built_in">wipe_side_data</span>(frame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 和 extended_buf都要被释放</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">FF_ARRAY_ELEMS</span>(frame-&gt;buf); i++)</span><br><span class="line">        <span class="built_in">av_buffer_unref</span>(&amp;frame-&gt;buf[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; frame-&gt;nb_extended_buf; i++)</span><br><span class="line">        <span class="built_in">av_buffer_unref</span>(&amp;frame-&gt;extended_buf[i]);</span><br><span class="line">    <span class="built_in">av_freep</span>(&amp;frame-&gt;extended_buf);</span><br><span class="line">    <span class="built_in">av_dict_free</span>(&amp;frame-&gt;metadata);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_buffer_unref</span>(&amp;frame-&gt;hw_frames_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_buffer_unref</span>(&amp;frame-&gt;opaque_ref);</span><br><span class="line">    <span class="built_in">av_buffer_unref</span>(&amp;frame-&gt;private_ref);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;extended_data != frame-&gt;data)</span><br><span class="line">        <span class="built_in">av_freep</span>(&amp;frame-&gt;extended_data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_channel_layout_uninit</span>(&amp;frame-&gt;ch_layout);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_frame_defaults</span>(frame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_buffer_unref</span><span class="params">(AVBufferRef **buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!buf || !*buf)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">buffer_replace</span>(buf, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">buffer_replace</span><span class="params">(AVBufferRef **dst, AVBufferRef **src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBuffer *b;</span><br><span class="line"></span><br><span class="line">    b = (*dst)-&gt;buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (src) &#123;</span><br><span class="line">        **dst = **src;</span><br><span class="line">        <span class="built_in">av_freep</span>(src);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">av_freep</span>(dst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">atomic_fetch_sub_explicit</span>(&amp;b-&gt;refcount, <span class="number">1</span>, memory_order_acq_rel) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* b-&gt;free below might already free the structure containing *b,</span></span><br><span class="line"><span class="comment">         * so we have to read the flag now to avoid use-after-free. */</span></span><br><span class="line">        <span class="type">int</span> free_avbuffer = !(b-&gt;flags_internal &amp; BUFFER_FLAG_NO_FREE);</span><br><span class="line">        b-&gt;<span class="built_in">free</span>(b-&gt;opaque, b-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (free_avbuffer)</span><br><span class="line">            <span class="built_in">av_free</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动 move 操作。和 C++ 中的移动语义类似，把内存从一个 AVFrame 转移到另一个 frame，dst 同样要求是 fresh 的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_frame_move_ref</span><span class="params">(AVFrame *dst, AVFrame *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_assert1</span>(dst-&gt;width == <span class="number">0</span> &amp;&amp; dst-&gt;height == <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">av_assert1</span>(dst-&gt;ch_layout.nb_channels == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               dst-&gt;ch_layout.order == AV_CHANNEL_ORDER_UNSPEC);</span><br><span class="line"></span><br><span class="line">    *dst = *src;</span><br><span class="line">    <span class="keyword">if</span> (src-&gt;extended_data == src-&gt;data)</span><br><span class="line">        dst-&gt;extended_data = dst-&gt;data;</span><br><span class="line">    <span class="built_in">get_frame_defaults</span>(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clone 操作。相当于 av_frame_alloc()+av_frame_ref()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVFrame *<span class="title">av_frame_clone</span><span class="params">(<span class="type">const</span> AVFrame *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFrame *ret = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">av_frame_ref</span>(ret, src) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">av_frame_free</span>(&amp;ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 操作。他和 unref 的区别是，unref 会释放 get_video_buffer 分配的内存，但是 av_frame_alloc 得到的 AVFrame 本身不会释放，而 free 会先 unref，然后释放 AVFrame 本身：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_frame_free</span><span class="params">(AVFrame **frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">av_frame_unref</span>(*frame);</span><br><span class="line">    <span class="built_in">av_freep</span>(frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy 操作。和 clone 操作有很大区别。copy 是把 src 的 buffer 拷贝到 dest，dest 和 src 必须都是相同维度（宽&#x2F;高），而且都已经 av_frame_get_buffer 分配了 buffer，copy 仅仅只是把 av_frame_get_buffer 分配的 buffer 内容进行拷贝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_frame_copy</span><span class="params">(AVFrame *dst, <span class="type">const</span> AVFrame *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dst-&gt;format != src-&gt;format || dst-&gt;format &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"><span class="function">FF_DISABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(dst-&gt;width &gt; <span class="number">0</span> &amp;&amp; dst-&gt;height &gt; <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="title">frame_copy_video</span><span class="params">(dst, src)</span></span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dst-&gt;nb_samples &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             (<span class="built_in">av_channel_layout_check</span>(&amp;dst-&gt;ch_layout)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_OLD_CHANNEL_LAYOUT</span></span><br><span class="line">              || dst-&gt;channels &gt; <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">frame_copy_audio</span>(dst, src);</span><br><span class="line"><span class="function">FF_ENABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">AVERROR</span><span class="params">(EINVAL)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断当前 AVFrame 是否可写，只有 AVFrame 非引用计数，或者当 frame 的引用计数为 1 时，也就是只有自己拥有时才能写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_frame_is_writable</span><span class="params">(AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* assume non-refcounted frames are not writable */</span></span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;buf[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">FF_ARRAY_ELEMS</span>(frame-&gt;buf); i++)</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;buf[i])</span><br><span class="line">            ret &amp;= !!<span class="built_in">av_buffer_is_writable</span>(frame-&gt;buf[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; frame-&gt;nb_extended_buf; i++)</span><br><span class="line">        ret &amp;= !!<span class="built_in">av_buffer_is_writable</span>(frame-&gt;extended_buf[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让当前 AVFrame 可写。如果 AVFrame 是引用计数的并且计数不为 1，就拷贝一份当前 AVFrame 的内存到新的 AVFrame 中，同时 unref 老的 AVFrame，在把新的 AVFrame 赋值给老的 AVFrame 作为返回，这样使得当前 AVFrame 可写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_frame_make_writable</span><span class="params">(AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFrame tmp;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;buf[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">av_frame_is_writable</span>(frame))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tmp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">    tmp.format         = frame-&gt;format;</span><br><span class="line">    tmp.width          = frame-&gt;width;</span><br><span class="line">    tmp.height         = frame-&gt;height;</span><br><span class="line">...</span><br><span class="line">    tmp.nb_samples     = frame-&gt;nb_samples;</span><br><span class="line">    ret = <span class="built_in">av_channel_layout_copy</span>(&amp;tmp.ch_layout, &amp;frame-&gt;ch_layout);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;hw_frames_ctx)</span><br><span class="line">        ret = <span class="built_in">av_hwframe_get_buffer</span>(frame-&gt;hw_frames_ctx, &amp;tmp, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = <span class="built_in">av_frame_get_buffer</span>(&amp;tmp, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_frame_copy</span>(&amp;tmp, frame);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_frame_copy_props</span>(&amp;tmp, frame);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line"></span><br><span class="line">    *frame = tmp;</span><br><span class="line">    <span class="keyword">if</span> (tmp.data == tmp.extended_data)</span><br><span class="line">        frame-&gt;extended_data = frame-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面介绍了部分 AVFrame 相关的函数及其实现，包括 alloc、get_buffer、ref、unref、free，可以看到，大部分方法还是围绕引用计数这个点来做文章，其他没有介绍到的方法大体也离不开这一点，抓住引用计数这个点就能正确理解 AVFrame。</p><p>接下来再分析一下 AVPacket，AVPacket 原理和 AVFrame 基本一样，比 AVFrame 可能还要简单一些，有了上面 AVFrame 的基础理解起来也不难。</p><p>AVPacket 存储的是等待 decode 的数据</p><blockquote><p>This structure stores compressed data. It is typically exported by demuxers and then passed as input to decoders, or received as output from encoders and then passed to muxers.<br/>For video, it should typically contain one compressed frame. For audio it may contain several compressed frames. Encoders are allowed to output empty packets, with no compressed data, containing only side data (e.g. to update some stream parameters at the end of encoding).</p></blockquote><p>AVPacket 的结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVPacket</span> &#123;</span><br><span class="line">    AVBufferRef *buf;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> pts;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> dts;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>   size;</span><br><span class="line">    <span class="type">int</span>   stream_index;</span><br><span class="line"></span><br><span class="line">    AVRational time_base;</span><br><span class="line">...</span><br><span class="line">&#125; AVPacket;</span><br></pre></td></tr></table></figure><p>AVPacket 只有一个 data 指针，而不是 data 数组，他也有 AVBufferRef 指针，也支持引用计数。</p><p>创建 AVPacket，也是通过 alloc 方法：将字段初始化为默认值，并不分配真正存储数据的内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVPacket *<span class="title">av_packet_alloc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVPacket *pkt = <span class="built_in">av_malloc</span>(<span class="built_in">sizeof</span>(AVPacket));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_packet_defaults</span>(pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pkt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_packet_defaults</span><span class="params">(AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pkt, <span class="number">0</span>, <span class="built_in">sizeof</span>(*pkt));</span><br><span class="line"></span><br><span class="line">    pkt-&gt;pts             = AV_NOPTS_VALUE;</span><br><span class="line">    pkt-&gt;dts             = AV_NOPTS_VALUE;</span><br><span class="line">    pkt-&gt;pos             = <span class="number">-1</span>;</span><br><span class="line">    pkt-&gt;time_base       = <span class="built_in">av_make_q</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ref 操作：dest 必须 fresh 的，比如新 alloc 或者 unref 之后</p><ul><li>如果 src 不是 refcouted，将 src 的 buffer 拷贝到 dest，否则拷贝引用</li><li>其他字段比如 sidedata 会从 src 拷贝内存到 dest，因为 side data 不是 ref counted 的，他在 ref 时总是拷贝，unref 时会释放</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_packet_ref</span><span class="params">(AVPacket *dst, <span class="type">const</span> AVPacket *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    dst-&gt;buf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_packet_copy_props</span>(dst, src);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!src-&gt;buf) &#123; <span class="comment">// 非引用计数</span></span><br><span class="line">        ret = <span class="built_in">packet_alloc</span>(&amp;dst-&gt;buf, src-&gt;size);</span><br><span class="line">...</span><br><span class="line">        <span class="built_in">av_assert1</span>(!src-&gt;size || src-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (src-&gt;size)</span><br><span class="line">            <span class="built_in">memcpy</span>(dst-&gt;buf-&gt;data, src-&gt;data, src-&gt;size);</span><br><span class="line"></span><br><span class="line">        dst-&gt;data = dst-&gt;buf-&gt;data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dst-&gt;buf = <span class="built_in">av_buffer_ref</span>(src-&gt;buf);</span><br><span class="line">...</span><br><span class="line">        dst-&gt;data = src-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dst-&gt;size = src-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(dst);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请 AVPacket 内部 payload 的内存，pkt 必须 fresh</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_new_packet</span><span class="params">(AVPacket *pkt, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *buf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">packet_alloc</span>(&amp;buf, size);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_packet_defaults</span>(pkt);</span><br><span class="line">    pkt-&gt;buf      = buf;</span><br><span class="line">    pkt-&gt;data     = buf-&gt;data;</span><br><span class="line">    pkt-&gt;size     = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">packet_alloc</span><span class="params">(AVBufferRef **buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span> || size &gt;= INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_buffer_realloc</span>(buf, size + AV_INPUT_BUFFER_PADDING_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>((*buf)-&gt;data + size, <span class="number">0</span>, AV_INPUT_BUFFER_PADDING_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_buffer_realloc</span><span class="params">(AVBufferRef **pbuf, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *buf = *pbuf;</span><br><span class="line">    <span class="type">uint8_t</span> *tmp;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!buf) &#123;</span><br><span class="line">        <span class="comment">/* allocate a new buffer with av_realloc(), so it will be reallocatable</span></span><br><span class="line"><span class="comment">         * later */</span></span><br><span class="line">        <span class="type">uint8_t</span> *data = <span class="built_in">av_realloc</span>(<span class="literal">NULL</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (!data)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line"></span><br><span class="line">        buf = <span class="built_in">av_buffer_create</span>(data, size, av_buffer_default_free, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!buf) &#123;</span><br><span class="line">            <span class="built_in">av_freep</span>(&amp;data);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buf-&gt;buffer-&gt;flags_internal |= BUFFER_FLAG_REALLOCATABLE;</span><br><span class="line">        *pbuf = buf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf-&gt;size == size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(buf-&gt;buffer-&gt;flags_internal &amp; BUFFER_FLAG_REALLOCATABLE) ||</span><br><span class="line">        !<span class="built_in">av_buffer_is_writable</span>(buf) || buf-&gt;data != buf-&gt;buffer-&gt;data) &#123;</span><br><span class="line">        <span class="comment">/* cannot realloc, allocate a new reallocable buffer and copy data */</span></span><br><span class="line">        AVBufferRef *<span class="keyword">new</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">av_buffer_realloc</span>(&amp;<span class="keyword">new</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="keyword">new</span>-&gt;data, buf-&gt;data, <span class="built_in">FFMIN</span>(size, buf-&gt;size));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">buffer_replace</span>(pbuf, &amp;<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="built_in">av_realloc</span>(buf-&gt;buffer-&gt;data, size);</span><br><span class="line">    <span class="keyword">if</span> (!tmp)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line"></span><br><span class="line">    buf-&gt;buffer-&gt;data = buf-&gt;data = tmp;</span><br><span class="line">    buf-&gt;buffer-&gt;size = buf-&gt;size = size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unref 操作：如果 AVPacket 不是 refcounted，释放 data 指向的内存，否则释放 buf 这个 AVBufferRef，同时将字段恢复成 alloc 时的默认值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_unref</span><span class="params">(AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_packet_free_side_data</span>(pkt);</span><br><span class="line">    <span class="built_in">av_buffer_unref</span>(&amp;pkt-&gt;opaque_ref);</span><br><span class="line">    <span class="built_in">av_buffer_unref</span>(&amp;pkt-&gt;buf);</span><br><span class="line">    <span class="built_in">get_packet_defaults</span>(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动操作：将 src 的内容移动到 dest，dest 必须是 fresh 的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_move_ref</span><span class="params">(AVPacket *dst, AVPacket *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *dst = *src;</span><br><span class="line">    <span class="built_in">get_packet_defaults</span>(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 操作：释放 AVPacket 本身，此外如果是 refcounted，还会先进行 unref 操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_free</span><span class="params">(AVPacket **pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pkt || !*pkt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_packet_unref</span>(*pkt);</span><br><span class="line">    <span class="built_in">av_freep</span>(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他操作就不再列举，AVPacket 原理和 AVFrame 基本一致，操作也是相通的。</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg之AVDictionary</title>
      <link href="/2023/03/10/ffmpeg%E4%B9%8BAVDictionary/"/>
      <url>/2023/03/10/ffmpeg%E4%B9%8BAVDictionary/</url>
      
        <content type="html"><![CDATA[<p>这篇博客接着之前的  ffmpeg 之 AVOption 和 AVClass  介绍一下 AVDictionary。</p><p>AVDictionary 从字面上看就是字典的意思，所以他的功能也不难猜到，就是一次性操作多个 AVOption。</p><p>先看一下 AVDictionary 的 struct 结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AVDictionary</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    AVDictionaryEntry *elems;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVDictionaryEntry</span> &#123;</span><br><span class="line">    <span class="type">char</span> *key;</span><br><span class="line">    <span class="type">char</span> *value;</span><br><span class="line">&#125; AVDictionaryEntry;</span><br></pre></td></tr></table></figure><p>AVDictionary 用于一次性 set 多个属性，有 av_opt_set_dict 这个专门的函数，他的第一个参数是 struct 实例，它必须支持 AVOption，第二个参数是指向 AVDictionary 的指针的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_opt_set_dict</span><span class="params">(<span class="type">void</span> *obj, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">av_opt_set_dict2</span>(obj, options, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_opt_set_dict 内部调用了 av_opt_set_dict2。</p><p>av_opt_set_dict2 中通过 av_dict_get 遍历每个 AVDictionaryEntry，然后也是通过 av_opt_set 设置属性到 struct 实例中，如果在 av_opt_set 时没找到相应的 key，该 AVDictionaryEntry 会被插入到一个新的 AVDictionary 中，最后把输入的 AVDictionary 的指针变为新的 AVDictionary，原来的 AVDictionary 会被释放，此时 options 指向的 AVDictionary*指向的就是包含未被设置的 AVDictionaryEntry 的 AVDictionary 了。</p><p>也就是说 av_opt_set_dict2 会把设置成功的 AVDictionaryEntry 给去掉，将未被设置的 AVDictionaryEntry 保留下来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_opt_set_dict2</span><span class="params">(<span class="type">void</span> *obj, AVDictionary **options, <span class="type">int</span> search_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVDictionaryEntry *t = <span class="literal">NULL</span>;</span><br><span class="line">    AVDictionary    *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!options)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((t = <span class="built_in">av_dict_get</span>(*options, <span class="string">&quot;&quot;</span>, t, AV_DICT_IGNORE_SUFFIX))) &#123;</span><br><span class="line">        ret = <span class="built_in">av_opt_set</span>(obj, t-&gt;key, t-&gt;value, search_flags);</span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR_OPTION_NOT_FOUND)</span><br><span class="line">            ret = <span class="built_in">av_dict_set</span>(&amp;tmp, t-&gt;key, t-&gt;value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">av_log</span>(obj, AV_LOG_ERROR, <span class="string">&quot;Error setting option %s to value %s.\n&quot;</span>, t-&gt;key, t-&gt;value);</span><br><span class="line">            <span class="built_in">av_dict_free</span>(&amp;tmp);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">av_dict_free</span>(options);</span><br><span class="line">    *options = tmp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg之AVOption和AVClass</title>
      <link href="/2023/03/07/ffmpeg%E4%B9%8BAVOption%E5%92%8CAVClass/"/>
      <url>/2023/03/07/ffmpeg%E4%B9%8BAVOption%E5%92%8CAVClass/</url>
      
        <content type="html"><![CDATA[<p>这篇博客介绍一下 ffmpeg 中的 AVOption 和 AVClass。</p><p>和 gstreamer 一样，ffmpeg 也提供了对 struct 实例的 get、set 方法，但是 ffmpeg 没有提供一套面向对象的编程机制，所以他的 get、set 方法看起来有些怪怪的。</p><p>ffmpeg 中要让一个 struct 支持 get、set，那么这个 struct 的第一个成员必须是一个指向 AVClass 的指针，其指向的 AVClass 中必须有 AVOption 数组，该数组最后一个元素必须是 NULL，而 AVOption 中描述了属性的信息，比如属性的名字、默认值、存储的位置。</p><p>看一个官方的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">test_struct</span> &#123;</span><br><span class="line">    <span class="type">const</span> AVClass *<span class="keyword">class</span>;</span><br><span class="line">    <span class="type">int</span>      int_opt;</span><br><span class="line">    <span class="type">char</span>    *str_opt;</span><br><span class="line">    <span class="type">uint8_t</span> *bin_opt;</span><br><span class="line">    <span class="type">int</span>      bin_len;</span><br><span class="line">&#125; test_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AVOption test_options[] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;test_int&quot;</span>, <span class="string">&quot;This is a test option of int type.&quot;</span>, <span class="built_in">offsetof</span>(test_struct, int_opt),</span><br><span class="line">    AV_OPT_TYPE_INT, &#123; .i64 = <span class="number">-1</span> &#125;, INT_MIN, INT_MAX &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;test_str&quot;</span>, <span class="string">&quot;This is a test option of string type.&quot;</span>, <span class="built_in">offsetof</span>(test_struct, str_opt),</span><br><span class="line">    AV_OPT_TYPE_STRING &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;test_bin&quot;</span>, <span class="string">&quot;This is a test option of binary type.&quot;</span>, <span class="built_in">offsetof</span>(test_struct, bin_opt),</span><br><span class="line">    AV_OPT_TYPE_BINARY &#125;,</span><br><span class="line">  &#123; <span class="literal">NULL</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AVClass test_class = &#123;</span><br><span class="line">    .class_name = <span class="string">&quot;test class&quot;</span>,</span><br><span class="line">    .item_name  = av_default_item_name,</span><br><span class="line">    .option     = test_options,</span><br><span class="line">    .version    = LIBAVUTIL_VERSION_INT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">test_struct *<span class="title">alloc_test_struct</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test_struct *ret = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*ret));</span><br><span class="line">    ret-&gt;<span class="keyword">class</span> = &amp;test_class;</span><br><span class="line">    <span class="built_in">av_opt_set_defaults</span>(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free_test_struct</span><span class="params">(test_struct **foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_opt_free</span>(*foo);</span><br><span class="line">    <span class="built_in">av_freep</span>(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中想要描述的是 test_struct，他的第一个成员是指向 test_class 的指针，而 test_class 中有 test_options 这个数组首地址，该数组的每一项都描述了一个属性，get、set 时会使用 AVOption 中的信息。</p><p>AVOption 结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVOption</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * short English help text</span></span><br><span class="line"><span class="comment">     * @todo What about other languages?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *help;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The offset relative to the context structure where the option</span></span><br><span class="line"><span class="comment">     * value is stored. It should be 0 for named constants.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVOptionType</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * the default value for scalar options</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int64_t</span> i64;</span><br><span class="line">        <span class="type">double</span> dbl;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *str;</span><br><span class="line">        <span class="comment">/* TODO those are unused now */</span></span><br><span class="line">        AVRational q;</span><br><span class="line">    &#125; default_val;</span><br><span class="line">    <span class="type">double</span> min;                 <span class="comment">///&lt; minimum valid value for the option</span></span><br><span class="line">    <span class="type">double</span> max;                 <span class="comment">///&lt; maximum valid value for the option</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_OPT_FLAG_ENCODING_PARAM  1   <span class="comment">///&lt; a generic parameter which can be set by the user for muxing or encoding</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_OPT_FLAG_DECODING_PARAM  2   <span class="comment">///&lt; a generic parameter which can be set by the user for demuxing or decoding</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_OPT_FLAG_AUDIO_PARAM     8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_OPT_FLAG_VIDEO_PARAM     16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_OPT_FLAG_SUBTITLE_PARAM  32</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The logical unit to which the option belongs. Non-constant</span></span><br><span class="line"><span class="comment">     * options and corresponding named constants share the same</span></span><br><span class="line"><span class="comment">     * unit. May be NULL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *unit;</span><br><span class="line">&#125; AVOption;</span><br></pre></td></tr></table></figure><p>每一个字段上面都有注释，就不一一解释了。</p><p>看一下 offset 字段，他指的是被管理的属性存在 struct 的哪里，结合上面的例子就知道 offset 是被管理的字段在 struct 中的偏移。</p><p>default_val 字段，表示默认值，是一个 union，不同类型共用这一个 union。当 AVOption 的类型指定后 default_val 需要与之对应。</p><p>一般来说，每个 AVOption 必须有非空的 name 字段、type 字段、默认值字段，对于数字类型，最大值、最小值字段同样不能为空。offset 字段也是必须的，他指明了被设置的属性保存到 struct 的哪里。其他字段就不是必须的了，但 flag 字段通常会被设置。</p><p>AVClass 结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Describe the class of an AVClass context structure. That is an</span></span><br><span class="line"><span class="comment"> * arbitrary struct of which the first field is a pointer to an</span></span><br><span class="line"><span class="comment"> * AVClass struct (e.g. AVCodecContext, AVFormatContext etc.).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVClass</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of the class; usually it is the same name as the</span></span><br><span class="line"><span class="comment">     * context structure type to which the AVClass is associated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* class_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A pointer to a function which returns the name of a context</span></span><br><span class="line"><span class="comment">     * instance ctx associated with the class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* (*item_name)(<span class="type">void</span>* ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * a pointer to the first option specified in the class if any or NULL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @see av_set_default_options()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">AVOption</span> *option;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LIBAVUTIL_VERSION with which this structure was created.</span></span><br><span class="line"><span class="comment">     * This is used to allow fields to be added without requiring major</span></span><br><span class="line"><span class="comment">     * version bumps everywhere.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> version;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callback to return the supported/allowed ranges.</span></span><br><span class="line"><span class="comment">     * available since version (52.12)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">int</span> (*query_ranges)(<span class="keyword">struct</span> AVOptionRanges **, <span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *key, <span class="type">int</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return next AVOptions-enabled child or NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span>* (*child_next)(<span class="type">void</span> *obj, <span class="type">void</span> *prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Iterate over the AVClasses corresponding to potential AVOptions-enabled</span></span><br><span class="line"><span class="comment">     * children.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param iter pointer to opaque iteration state. The caller must initialize</span></span><br><span class="line"><span class="comment">     *             *iter to NULL before the first call.</span></span><br><span class="line"><span class="comment">     * @return AVClass for the next AVOptions-enabled child or NULL if there are</span></span><br><span class="line"><span class="comment">     *         no more such children.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @note The difference between child_next and this is that child_next</span></span><br><span class="line"><span class="comment">     *       iterates over _already existing_ objects, while child_class_iterate</span></span><br><span class="line"><span class="comment">     *       iterates over _all possible_ children.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">AVClass</span>* (*child_class_iterate)(<span class="type">void</span> **iter);</span><br><span class="line">&#125; AVClass;</span><br></pre></td></tr></table></figure><p>目前看来 AVClass 最重要的就是 option 这个数组，他里面的 AVOption 指明了如何对被管理的 struct 进行 get、set 操作，其他的字段一般用得很少，保持默认值就行，但是 child_next 和 child_class_iterate 在 get、set 中也有用处，这个后面再介绍。</p><p>接下来分析一下 av_opt_set 的代码。</p><p>av_opt_set 用于设置属性，第一个参数是 struct 的实例，第二个参数是属性名，需要和 AVOption 中的 name 对应，第三个参数是属性值，注意是一个字符串，如果是数字类型在 set 时会把字符串转换为数字类型，第四个是搜索属性，如果想搜索嵌套属性时需要设置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_opt_set</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *val, <span class="type">int</span> search_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">av_opt_set2</span>(obj, name, val, <span class="number">0</span>, search_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_opt_set 内部调用 av_opt_set2 函数，av_opt_set2 先通过 name 查找 AVOption，找到之后获得 AVOption 中的 offset 信息，然后把输入的 val 根据类型进行转换（比如字符串转 int），最后把值设置到 struct 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_opt_set2</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *val, <span class="type">int</span> opt_flags, <span class="type">int</span> search_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span> *dst, *target_obj;</span><br><span class="line">    <span class="type">const</span> AVOption *o = <span class="built_in">av_opt_find2</span>(obj, name, <span class="literal">NULL</span>, opt_flags, search_flags, &amp;target_obj);</span><br><span class="line">    <span class="keyword">if</span> (!o || !target_obj)</span><br><span class="line">        <span class="keyword">return</span> AVERROR_OPTION_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!val &amp;&amp; (o-&gt;type != AV_OPT_TYPE_STRING &amp;&amp;</span><br><span class="line">                 o-&gt;type != AV_OPT_TYPE_PIXEL_FMT &amp;&amp; o-&gt;type != AV_OPT_TYPE_SAMPLE_FMT &amp;&amp;</span><br><span class="line">                 o-&gt;type != AV_OPT_TYPE_IMAGE_SIZE &amp;&amp;</span><br><span class="line">                 o-&gt;type != AV_OPT_TYPE_DURATION &amp;&amp; o-&gt;type != AV_OPT_TYPE_COLOR &amp;&amp;</span><br><span class="line">                 o-&gt;type != AV_OPT_TYPE_BOOL))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;flags &amp; AV_OPT_FLAG_READONLY)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;flags &amp; AV_OPT_FLAG_DEPRECATED)</span><br><span class="line">        <span class="built_in">av_log</span>(obj, AV_LOG_WARNING, <span class="string">&quot;The \&quot;%s\&quot; option is deprecated: %s\n&quot;</span>, name, o-&gt;help);</span><br><span class="line"></span><br><span class="line">    dst = ((<span class="type">uint8_t</span> *)target_obj) + o-&gt;offset;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_BOOL:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set_string_bool</span>(obj, o, val, dst);</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_STRING:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set_string</span>(obj, o, val, dst);</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_BINARY:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set_string_binary</span>(obj, o, val, dst);</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_FLAGS:</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_INT:</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_INT64:</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_UINT64:</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_FLOAT:</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_DOUBLE:</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_RATIONAL:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set_string_number</span>(obj, target_obj, o, val, dst);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">av_log</span>(obj, AV_LOG_ERROR, <span class="string">&quot;Invalid option type.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一下查找 AVOption，是通过 av_opt_find2 函数进行查找，av_opt_find2 会根据 search_flags 选择是否查找嵌套的 AVOption，这个留到后面再说，先看只在当前 struct 中进行查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVOption *<span class="title">av_opt_find2</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">int</span> opt_flags, <span class="type">int</span> search_flags, <span class="type">void</span> **target_obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVClass  *c;</span><br><span class="line">    <span class="type">const</span> AVOption *o = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    c= *(AVClass**)obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (search_flags &amp; AV_OPT_SEARCH_CHILDREN) &#123;</span><br><span class="line">        <span class="comment">// 嵌套查找，先不管</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (o = <span class="built_in">av_opt_next</span>(obj, o)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(o-&gt;name, name) &amp;&amp; (o-&gt;flags &amp; opt_flags) == opt_flags &amp;&amp;</span><br><span class="line">            ((!unit &amp;&amp; o-&gt;type != AV_OPT_TYPE_CONST) ||</span><br><span class="line">             (unit  &amp;&amp; o-&gt;type == AV_OPT_TYPE_CONST &amp;&amp; o-&gt;unit &amp;&amp; !<span class="built_in">strcmp</span>(o-&gt;unit, unit)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target_obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(search_flags &amp; AV_OPT_SEARCH_FAKE_OBJ))</span><br><span class="line">                    *target_obj = obj;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    *target_obj = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_opt_find2 通过 av_opt_next 逐个的遍历当前 struct 的 AVClass 中的 AVOption 数组，把每一项的 name 和输入的 name 进行比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVOption *<span class="title">av_opt_next</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *obj, <span class="type">const</span> AVOption *last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVClass *<span class="keyword">class</span>;</span><br><span class="line">    <span class="keyword">if</span> (!obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">class</span> = *(<span class="type">const</span> AVClass**)obj;</span><br><span class="line">    <span class="keyword">if</span> (!last &amp;&amp; <span class="keyword">class</span> &amp;&amp; <span class="keyword">class</span>-&gt;option &amp;&amp; <span class="keyword">class</span>-&gt;option[<span class="number">0</span>].name)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">class</span>-&gt;option;</span><br><span class="line">    <span class="keyword">if</span> (last &amp;&amp; last[<span class="number">1</span>].name)</span><br><span class="line">        <span class="keyword">return</span> ++last;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到 AVOption 后把偏移 offset 信息取出来，然后进行属性设置操作。</p><p>看一个 string 类型的设置操作，可以看到，会把输入的字符串复制一份出来，所以这部分内存后面还需要释放。当调用 av_opt_free 时，这部分动态分配的内存会被释放，如果 struct 有 string 类型的属性，析构时需要调用 av_opt_free 函数。（注意 binary 类型也会进行动态内存分配）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">set_string</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> AVOption *o, <span class="type">const</span> <span class="type">char</span> *val, <span class="type">uint8_t</span> **dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_freep</span>(dst);</span><br><span class="line">    *dst = <span class="built_in">av_strdup</span>(val);</span><br><span class="line">    <span class="keyword">return</span> *dst ? <span class="number">0</span> : <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个 bool 类型的设置操作，他会对输入的字符串进行分析，如果是 true,y,yes 之类的会将字段设置为 true，反之如果是 false,n,no 之类的则会设为 false</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">set_string_bool</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> AVOption *o, <span class="type">const</span> <span class="type">char</span> *val, <span class="type">int</span> *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!val)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(val, <span class="string">&quot;auto&quot;</span>)) &#123;</span><br><span class="line">        n = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">av_match_name</span>(val, <span class="string">&quot;true,y,yes,enable,enabled,on&quot;</span>)) &#123;</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">av_match_name</span>(val, <span class="string">&quot;false,n,no,disable,disabled,off&quot;</span>)) &#123;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> *end = <span class="literal">NULL</span>;</span><br><span class="line">        n = <span class="built_in">strtol</span>(val, &amp;end, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (val + <span class="built_in">strlen</span>(val) != end)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; o-&gt;min || n &gt; o-&gt;max)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    *dst = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">av_log</span>(obj, AV_LOG_ERROR, <span class="string">&quot;Unable to parse option value \&quot;%s\&quot; as boolean\n&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数字类型的设置函数就不看了，基本原理就是把用字符串表示的数字转成 AVOption 中的类型，然后进行设置，同时数字类型还会检查输入值是否在最大最小值范围内。</p><p>再看一下 av_opt_set_defaults。这个函数就是把 struct 中的字段赋值为 AVOption 中的默认值，基本过程和 av_opt_set 一致。从下面可以看到，调用 av_opt_next 遍历每一个 AVOption，取偏移信息，然后把默认值设到字段中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_opt_set_defaults</span><span class="params">(<span class="type">void</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_opt_set_defaults2</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_opt_set_defaults2</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> mask, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVOption *opt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = <span class="built_in">av_opt_next</span>(s, opt))) &#123;</span><br><span class="line">        <span class="type">void</span> *dst = ((<span class="type">uint8_t</span>*)s) + opt-&gt;offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((opt-&gt;flags &amp; mask) != flags)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opt-&gt;flags &amp; AV_OPT_FLAG_READONLY)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (opt-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_CONST:</span><br><span class="line">                <span class="comment">/* Nothing to be done here */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_BOOL:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_FLAGS:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_INT:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_INT64:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_UINT64:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_DURATION:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_PIXEL_FMT:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_SAMPLE_FMT:</span><br><span class="line">                <span class="built_in">write_number</span>(s, opt, dst, <span class="number">1</span>, <span class="number">1</span>, opt-&gt;default_val.i64);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_DOUBLE:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_FLOAT: &#123;</span><br><span class="line">                <span class="type">double</span> val;</span><br><span class="line">                val = opt-&gt;default_val.dbl;</span><br><span class="line">                <span class="built_in">write_number</span>(s, opt, dst, val, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_STRING:</span><br><span class="line">                <span class="comment">// 发生字符串拷贝</span></span><br><span class="line">                <span class="built_in">set_string</span>(s, opt, opt-&gt;default_val.str, dst);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">av_log</span>(s, AV_LOG_DEBUG, <span class="string">&quot;AVOption type %d of option %s not implemented yet\n&quot;</span>,</span><br><span class="line">                   opt-&gt;type, opt-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了上面的 set 过程，av_opt_get 就很简单了。</p><p>同样先用 av_opt_find2 查找 AVOption，找到之后取偏移信息，通过偏移信息就可以从 struct 中访问到字段，由于输出是 char 字符串，所以对某些类型，比如 bool、数字类型需要转成字符串，这里同样涉及到动态分配的内存，out_val 指向的指针需要自己在外面手动释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_opt_get</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> search_flags, <span class="type">uint8_t</span> **out_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> *dst, *target_obj;</span><br><span class="line">    <span class="type">const</span> AVOption *o = <span class="built_in">av_opt_find2</span>(obj, name, <span class="literal">NULL</span>, <span class="number">0</span>, search_flags, &amp;target_obj);</span><br><span class="line">    <span class="type">uint8_t</span> *bin, buf[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> len, i, ret;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!o || !target_obj || (o-&gt;offset&lt;=<span class="number">0</span> &amp;&amp; o-&gt;type != AV_OPT_TYPE_CONST))</span><br><span class="line">        <span class="keyword">return</span> AVERROR_OPTION_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;flags &amp; AV_OPT_FLAG_DEPRECATED)</span><br><span class="line">        <span class="built_in">av_log</span>(obj, AV_LOG_WARNING, <span class="string">&quot;The \&quot;%s\&quot; option is deprecated: %s\n&quot;</span>, name, o-&gt;help);</span><br><span class="line"></span><br><span class="line">    dst = (<span class="type">uint8_t</span> *)target_obj + o-&gt;offset;</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;type) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_INT:</span><br><span class="line">        ret = <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%d&quot;</span>, *(<span class="type">int</span> *)dst);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_INT64:</span><br><span class="line">        ret = <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%&quot;</span>PRId64, *(<span class="type">int64_t</span> *)dst);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_UINT64:</span><br><span class="line">        ret = <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%&quot;</span>PRIu64, *(<span class="type">uint64_t</span> *)dst);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_FLOAT:</span><br><span class="line">        ret = <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%f&quot;</span>, *(<span class="type">float</span> *)dst);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_DOUBLE:</span><br><span class="line">        ret = <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%f&quot;</span>, *(<span class="type">double</span> *)dst);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_STRING:</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">uint8_t</span> **)dst) &#123;</span><br><span class="line">            *out_val = <span class="built_in">av_strdup</span>(*(<span class="type">uint8_t</span> **)dst); <span class="comment">// 外面需要自己释放</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (search_flags &amp; AV_OPT_ALLOW_NULL) &#123;</span><br><span class="line">            *out_val = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *out_val = <span class="built_in">av_strdup</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *out_val ? <span class="number">0</span> : <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_BINARY:</span><br><span class="line">        <span class="keyword">if</span> (!*(<span class="type">uint8_t</span> **)dst &amp;&amp; (search_flags &amp; AV_OPT_ALLOW_NULL)) &#123;</span><br><span class="line">            *out_val = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = *(<span class="type">int</span> *)(((<span class="type">uint8_t</span> *)dst) + <span class="built_in">sizeof</span>(<span class="type">uint8_t</span> *));</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">uint64_t</span>)len * <span class="number">2</span> + <span class="number">1</span> &gt; INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        <span class="keyword">if</span> (!(*out_val = <span class="built_in">av_malloc</span>(len * <span class="number">2</span> + <span class="number">1</span>))) <span class="comment">// 外面需要自己释放</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="keyword">if</span> (!len) &#123;</span><br><span class="line">            *out_val[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bin = *(<span class="type">uint8_t</span> **)dst;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            <span class="built_in">snprintf</span>(*out_val + i * <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;%02X&quot;</span>, bin[i]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">   &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="built_in">sizeof</span>(buf))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    *out_val = <span class="built_in">av_strdup</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> *out_val ? <span class="number">0</span> : <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 binary 要注意，从上面 AV_OPT_TYPE_BINARY 分支可以看到，binary 在 struct 中占据两部分，一个是 binary 的地址，一个是 binary 的长度。</p><p>最后再介绍一下嵌套 AVOption。</p><p>gobject 中支持属性的继承，也就是子类可以使用父类的属性，也可以覆盖父类的属性，这种需求是很常见的。而 ffmpeg 没有实现面向对象的机制，但是他也想支持类似的属性继承功能，于是就提供了嵌套 AVOption 特性。</p><p>嵌套 AVOption 是指当前 struct 支持 AVOption，同时他还有一个成员也支持 AVOption，现在希望 get、set 时能从当前 struct 以及他的成员中进行操作。看一个官方的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">child_struct</span> &#123;</span><br><span class="line">    AVClass *<span class="keyword">class</span>;</span><br><span class="line">    <span class="type">int</span> flags_opt;</span><br><span class="line">&#125; child_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AVOption child_opts[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;test_flags&quot;</span>, <span class="string">&quot;This is a test option of flags type.&quot;</span>,</span><br><span class="line">    <span class="built_in">offsetof</span>(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, &#123; .i64 = <span class="number">0</span> &#125;, INT_MIN, INT_MAX &#125;,</span><br><span class="line">    &#123; <span class="literal">NULL</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AVClass child_class = &#123;</span><br><span class="line">    .class_name = <span class="string">&quot;child class&quot;</span>,</span><br><span class="line">    .item_name  = av_default_item_name,</span><br><span class="line">    .option     = child_opts,</span><br><span class="line">    .version    = LIBAVUTIL_VERSION_INT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">test_struct</span> &#123;</span><br><span class="line">    <span class="type">const</span> AVClass *<span class="keyword">class</span>;</span><br><span class="line">    <span class="type">int</span>      int_opt;</span><br><span class="line">    <span class="type">char</span>    *str_opt;</span><br><span class="line">    <span class="type">uint8_t</span> *bin_opt;</span><br><span class="line">    <span class="type">int</span>      bin_len;</span><br><span class="line">    child_struct *child_struct;</span><br><span class="line">&#125; test_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AVOption test_options[] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;test_int&quot;</span>, <span class="string">&quot;This is a test option of int type.&quot;</span>, <span class="built_in">offsetof</span>(test_struct, int_opt),</span><br><span class="line">    AV_OPT_TYPE_INT, &#123; .i64 = <span class="number">-1</span> &#125;, INT_MIN, INT_MAX &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;test_str&quot;</span>, <span class="string">&quot;This is a test option of string type.&quot;</span>, <span class="built_in">offsetof</span>(test_struct, str_opt),</span><br><span class="line">    AV_OPT_TYPE_STRING &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;test_bin&quot;</span>, <span class="string">&quot;This is a test option of binary type.&quot;</span>, <span class="built_in">offsetof</span>(test_struct, bin_opt),</span><br><span class="line">    AV_OPT_TYPE_BINARY &#125;,</span><br><span class="line">  &#123; <span class="literal">NULL</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">child_next</span><span class="params">(<span class="type">void</span> *obj, <span class="type">void</span> *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test_struct *t = obj;</span><br><span class="line">    <span class="keyword">if</span> (!prev &amp;&amp; t-&gt;child_struct)</span><br><span class="line">        <span class="keyword">return</span> t-&gt;child_struct;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> AVClass* <span class="title">child_class_iterate</span><span class="params">(<span class="type">void</span> **iter)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 只返回一次child_class</span></span><br><span class="line">    <span class="type">const</span> AVClass *c = *iter ? <span class="literal">NULL</span> : &amp;child_class;</span><br><span class="line">    *iter = (<span class="type">void</span>*)(<span class="type">uintptr_t</span>)c;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AVClass test_class = &#123;</span><br><span class="line">    .class_name = <span class="string">&quot;test class&quot;</span>,</span><br><span class="line">    .item_name  = av_default_item_name,</span><br><span class="line">    .option     = test_options,</span><br><span class="line">    .version    = LIBAVUTIL_VERSION_INT,</span><br><span class="line">    .child_next = child_next,</span><br><span class="line">    .child_class_iterate = child_class_iterate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的例子中，有 test_struct 和 child_struct 两个结构，他们都支持 AVOption。test_struct 有一个指针指向 child_struct，可以把 child_struct 视为 test_struct 的子结构。</p><p>要让 test_struct 支持嵌套 AVOption（也就是 set、get test_struct 时可以设置到 child_struct），只需要在 test_struct 的 AVClass 中实现 child_next、child_class_iterate 两个函数。child_next 是对真实存在的子 struct 进行遍历，child_class_iterate 是对所有可能存在的子 struct 进行遍历。这样说可能不太好理解，看一下 AVCodecContext 中的 child_next 和 child_class_iterate 函数：</p><p>先通过 avcodec_alloc_context3 来创建 AVCodecContext 实例，AVCodecContext 实例中的 AVClass 是 av_codec_context_class 这个 struct。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVCodecContext *<span class="title">avcodec_alloc_context3</span><span class="params">(<span class="type">const</span> AVCodec *codec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecContext *avctx= <span class="built_in">av_malloc</span>(<span class="built_in">sizeof</span>(AVCodecContext));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!avctx)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">init_context_defaults</span>(avctx, codec) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_free</span>(avctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> avctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">init_context_defaults</span><span class="params">(AVCodecContext *s, <span class="type">const</span> AVCodec *codec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FFCodec *<span class="type">const</span> codec2 = <span class="built_in">ffcodec</span>(codec);</span><br><span class="line">    <span class="type">int</span> flags=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in">sizeof</span>(AVCodecContext));</span><br><span class="line"></span><br><span class="line">    s-&gt;av_class = &amp;av_codec_context_class;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_codec_context_class 的 child_next、child_class_iterate 分别是 codec_child_next、codec_child_class_iterate。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> AVClass av_codec_context_class = &#123;</span><br><span class="line">    .class_name              = <span class="string">&quot;AVCodecContext&quot;</span>,</span><br><span class="line">    .item_name               = context_to_name,</span><br><span class="line">    .option                  = avcodec_options,</span><br><span class="line">    .version                 = LIBAVUTIL_VERSION_INT,</span><br><span class="line">    .log_level_offset_offset = <span class="built_in">offsetof</span>(AVCodecContext, log_level_offset),</span><br><span class="line">    .child_next              = codec_child_next,</span><br><span class="line">    .child_class_iterate     = codec_child_class_iterate,</span><br><span class="line">    .category                = AV_CLASS_CATEGORY_ENCODER,</span><br><span class="line">    .get_category            = get_category,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到 codec_child_next 就是返回 AVCodecContext 中的 priv_data 指针，而 priv_data 指向的是每个 codec 自定义的一个也支持 get、set 操作的 struct 的实例，该实例在创建 AVCodecContext 通常也会被创建，他是当前 AVCodecContext 中必然真实存在的一个实例。</p><p>而 codec_child_class_iterate 是通过 av_codec_iterate 对每个 AVCodec 实例进行遍历，返回每个 AVCodec 实例中的 priv_class（也是一个 AVClass），codec_child_class_iterate 返回的 AVClass 肯定不能进行 get、set 操作，因为该 AVClass 对应的 struct 都不知道有没有创建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">codec_child_next</span><span class="params">(<span class="type">void</span> *obj, <span class="type">void</span> *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecContext *s = obj;</span><br><span class="line">    <span class="keyword">if</span> (!prev &amp;&amp; s-&gt;codec &amp;&amp; s-&gt;codec-&gt;priv_class &amp;&amp; s-&gt;priv_data)</span><br><span class="line">        <span class="keyword">return</span> s-&gt;priv_data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> AVClass *<span class="title">codec_child_class_iterate</span><span class="params">(<span class="type">void</span> **iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVCodec *c;</span><br><span class="line">    <span class="comment">/* find next codec with priv options */</span></span><br><span class="line">    <span class="keyword">while</span> (c = <span class="built_in">av_codec_iterate</span>(iter))</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;priv_class)</span><br><span class="line">            <span class="keyword">return</span> c-&gt;priv_class;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到之前 av_opt_find2 中略过的 search_flags 相关部分。</p><p>av_opt_find2 在查找 AVOption 时，会根据 search_flags 决定调用 child_next 还是 child_class_iterate 来遍历子 struct，如果 AV_OPT_SEARCH_CHILDREN 为 true 而 AV_OPT_SEARCH_FAKE_OBJ 为 false 则会使用 child_next。</p><p>可以看到下面的搜索过程其实是一个深度优先搜索，所以子 struct 可以覆盖父 struct 的属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVOption *<span class="title">av_opt_find2</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">int</span> opt_flags, <span class="type">int</span> search_flags, <span class="type">void</span> **target_obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVClass  *c;</span><br><span class="line">    <span class="type">const</span> AVOption *o = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    c= *(AVClass**)obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (search_flags &amp; AV_OPT_SEARCH_CHILDREN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (search_flags &amp; AV_OPT_SEARCH_FAKE_OBJ) &#123;</span><br><span class="line">            <span class="type">void</span> *iter = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="type">const</span> AVClass *child;</span><br><span class="line">            <span class="keyword">while</span> (child = <span class="built_in">av_opt_child_class_iterate</span>(c, &amp;iter))</span><br><span class="line">                <span class="keyword">if</span> (o = <span class="built_in">av_opt_find2</span>(&amp;child, name, unit, opt_flags, search_flags, <span class="literal">NULL</span>))</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">void</span> *child = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">while</span> (child = <span class="built_in">av_opt_child_next</span>(obj, child))</span><br><span class="line">                <span class="keyword">if</span> (o = <span class="built_in">av_opt_find2</span>(child, name, unit, opt_flags, search_flags, target_obj))</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (o = <span class="built_in">av_opt_next</span>(obj, o)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(o-&gt;name, name) &amp;&amp; (o-&gt;flags &amp; opt_flags) == opt_flags &amp;&amp;</span><br><span class="line">            ((!unit &amp;&amp; o-&gt;type != AV_OPT_TYPE_CONST) ||</span><br><span class="line">             (unit  &amp;&amp; o-&gt;type == AV_OPT_TYPE_CONST &amp;&amp; o-&gt;unit &amp;&amp; !<span class="built_in">strcmp</span>(o-&gt;unit, unit)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target_obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(search_flags &amp; AV_OPT_SEARCH_FAKE_OBJ))</span><br><span class="line">                    *target_obj = obj;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    *target_obj = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">av_opt_child_next</span><span class="params">(<span class="type">void</span> *obj, <span class="type">void</span> *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVClass *c = *(AVClass **)obj;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;child_next)</span><br><span class="line">        <span class="keyword">return</span> c-&gt;<span class="built_in">child_next</span>(obj, prev);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> AVClass *<span class="title">av_opt_child_class_iterate</span><span class="params">(<span class="type">const</span> AVClass *parent, <span class="type">void</span> **iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;child_class_iterate)</span><br><span class="line">        <span class="keyword">return</span> parent-&gt;<span class="built_in">child_class_iterate</span>(iter);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44268323">https://blog.csdn.net/leixiaohua1020/article/details/44268323</a></p><p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44279329">https://blog.csdn.net/leixiaohua1020/article/details/44279329</a></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>declval是什么</title>
      <link href="/2023/03/04/declval%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2023/03/04/declval%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>C++ 中，我想 decltype 大家应该都知道，那么 declval 又是什么呢？</p><p>declval 定义在<utility>中，他可能的实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> always_false = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::add_rvalue_reference&lt;T&gt;::<span class="function">type <span class="title">declval</span><span class="params">()</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(always_false&lt;T&gt;, <span class="string">&quot;declval not allowed in an evaluated context&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，declval 就是为输入类型增加了右值引用，然后返回。</p><p>declval 是一个模板函数，通常要配合 decltype 使用，在 decltype 中，用 declval 去“定义”某个类型的变量，然后用这个变量来组成表达式，这里定义打引号是因为 declval 定义的变量不能访问他的值，只能进行类型计算，举个例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">hello</span><span class="params">(<span class="type">const</span> B&amp;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ff</span><span class="params">(B&amp; b)</span> -&gt; <span class="title">decltype</span><span class="params">(declval&lt;A&gt;().hello(declval&lt;B&gt;()))</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子只做演示，实际不可能写这种代码。上面的例子跳过了 A 和 B 的构造函数，直接定义他们的变量，并且访问他们的成员函数。</p><p>个人觉得 declval 最让人困惑的一点是：为什么 declval 返回一个右值引用类型就可以访问到该类型的成员函数和成员变量？</p><p>我的理解是 declval 的关键在于<strong>借助函数返回值返回一个虚拟的变量</strong>：C++ 的函数总被视为返回一个变量，但是在 decltype 类型计算中并不关心返回的变量是否真正存在，只是在编译的时候计算、推导类型。值的一提，C++ 很多其他特性其实都借助了函数返回值这一点，比如 move、forward。</p><p>看一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">hello</span><span class="params">(<span class="type">const</span> B&amp;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> AA = A&amp;&amp;;</span><br><span class="line"><span class="keyword">using</span> BB = B&amp;&amp;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ff</span><span class="params">(B&amp; b)</span> -&gt; <span class="title">decltype</span><span class="params">(AA.hello(BB))</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子编译不过，虽然他看上去和上面的例子做的工作一样，但是违反了 C++ 的语义，我们不能从类型去访问成员函数，所以需要借助函数返回值来迂回实现。</p><p>为什么返回右值引用，左值引用可以吗？</p><p>个人觉得是可以的，只要把引用想象成对一个虚拟变量的引用，不管左值还是右值引用，都可以访问成员变量和成员函数。但 declval 设计成返回右值引用应该有其他方面的考虑。</p><p>参考资料：</p><p><a href="https://en.cppreference.com/w/cpp/utility/declval">https://en.cppreference.com/w/cpp/utility/declval</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++新特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>decltype(auto)用法</title>
      <link href="/2023/03/04/decltype-auto-%E7%94%A8%E6%B3%95/"/>
      <url>/2023/03/04/decltype-auto-%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中，经常使用 decltype 和 auto 进行类型推导，auto 用于表达式左边，根据赋值语句（广义包括函数返回、普通赋值）右边进行类型推断，decltype 则是对表达式、变量进行推断得到类型。那么 decltype(auto)又是什么呢？</p><p>decltype(auto)一般用于函数的返回值，先看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; </span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">( T&amp; t )</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">value</span>() ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; </span><br><span class="line"><span class="function"><span class="keyword">auto</span>&amp; <span class="title">bar</span><span class="params">( T&amp; t )</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">value</span>() ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 auto 不会主动推断为引用类型，哪怕赋值语句右边是引用类型，他也会推断为引用的值类型，除非我们主动在 auto 后面加引用。上面的第一个例子返回值永远是值类型，第二个则返回引用类型。</p><p>decltype(auto)会根据函数的 return 表达式的类型来推断自己的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; </span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">bar</span><span class="params">( T&amp; t )</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">value</span>() ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数可以等价于下面的尾置返回推断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; </span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bar</span><span class="params">( T&amp; t )</span> -&gt; <span class="title">decltype</span><span class="params">(t.value())</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">value</span>() ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 decltype(auto)把返回值表达式进行 decltype 推断得到自己的类型，比如下面例子，ff 返回值永远是右值引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">ff</span><span class="params">(F&amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和尾置返回相比，decltype(auto)更灵活，他能推断的表达式可以和输入参数无关，尾置返回通常从和输入参数相关的表达式进行推断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">B b;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">ff</span><span class="params">(F&amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，ff 函数返回一个全局变量的右值，完全和输入参数无关。尾置返回通常不能这么灵活，他通常根据输入参数进行类型推断。但是对于上面的例子，我们使用尾置返回 +declval 也可以实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">B b;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ff</span><span class="params">(F&amp;s)</span> -&gt; <span class="title">decltype</span><span class="params">(std::move(declval&lt;B&gt;()))</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，decltype(auto)就相当于对 return 表达式进行了 decltype 推断。最后看一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">ff</span><span class="params">(F&amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; k = <span class="built_in">ff</span>(j);</span><br><span class="line">    <span class="type">int</span>&amp; m = <span class="built_in">ff</span>(j); <span class="comment">// error: cannot bind non-const lvalue reference of type ‘int&amp;’ to</span></span><br><span class="line">                    <span class="comment">// an rvalue of type ‘std::remove_reference&lt;int&amp;&gt;::type’ &#123;aka ‘int’&#125;</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://cplusplus.com/forum/general/188645/">https://cplusplus.com/forum/general/188645/</a></p><p><a href="https://en.cppreference.com/w/cpp/language/function">https://en.cppreference.com/w/cpp/language/function</a> Return type deduction 一节</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++新特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++标准库智能指针之shared_ptr和weak_ptr</title>
      <link href="/2023/03/01/C-%E6%A0%87%E5%87%86%E5%BA%93%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E4%B9%8Bshared-ptr%E5%92%8Cweak-ptr/"/>
      <url>/2023/03/01/C-%E6%A0%87%E5%87%86%E5%BA%93%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E4%B9%8Bshared-ptr%E5%92%8Cweak-ptr/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/C-%E6%A0%87%E5%87%86%E5%BA%93%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E4%B9%8Bshared-ptr%E5%92%8Cweak-ptr/shared_ptr.jpg" alt="shared_ptr和weak_ptr"></p><p>shared_ptr通过引用计数来管理指向的内存，当引用计数为0时，释放指向的内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> shared_ptr</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    element_type*      __ptr_;</span><br><span class="line">    __shared_weak_count* __cntrl_;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">            __cntrl_-&gt;__release_shared();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>shared_ptr内部只有两个指针，__ptr_就是我们管理的指针，__cntrl_和引用计数有关</p><h2 id="接受裸指针的构造函数"><a href="#接受裸指针的构造函数" class="headerlink" title="接受裸指针的构造函数"></a>接受裸指针的构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(_Yp* __p,</span><br><span class="line">                            <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)</span><br><span class="line">    : __ptr_(__p)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;_Yp&gt; __hold(__p);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;</span><br><span class="line">    <span class="keyword">typedef</span> __shared_ptr_pointer&lt;_Yp*, default_delete&lt;_Yp&gt;, _AllocT &gt; _CntrlBlk;</span><br><span class="line">    __cntrl_ = <span class="keyword">new</span> _CntrlBlk(__p, <span class="built_in">default_delete</span>&lt;_Yp&gt;(), _AllocT());</span><br><span class="line">    __hold.<span class="built_in">release</span>();</span><br><span class="line">    __enable_weak_this(__p, __p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个构造函数生效的前提是is_convertible&lt;_Yp*, element_type*&gt;这个条件要满足，也就是说，_Yp*不一定要是element_type*类型，可以是他的子类</p><p>__shared_ptr_default_allocator定义如下，对于非函数，上面的_AllocT就是allocator&lt;_Yp&gt;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>, <span class="type">bool</span> = is_function&lt;_Yp&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> __shared_ptr_default_allocator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> allocator&lt;_Yp&gt; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>allocator类还没有仔细看过，不做深入讨论</p><p>__cntrl_是__shared_weak_count的指针，而__shared_ptr_pointer是__shared_weak_count的子类，__shared_weak_count又是__shared_count的子类</p><p>__shared_count如下，他有一个__ shared_owners_，代表共享引用计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TYPE_VIS</span> __shared_count</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">long</span> __shared_owners_;</span><br><span class="line">    <span class="keyword">virtual</span> ~__shared_count() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared() _NOEXCEPT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> __shared_count(<span class="type">long</span> __refs = <span class="number">0</span>) _NOEXCEPT</span><br><span class="line">        : __shared_owners_(__refs) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __add_shared() _NOEXCEPT &#123;</span><br><span class="line">      __libcpp_atomic_refcount_increment(__shared_owners_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> __release_shared() _NOEXCEPT &#123;</span><br><span class="line">      <span class="keyword">if</span> (__libcpp_atomic_refcount_decrement(__shared_owners_) == <span class="number">-1</span>) &#123;</span><br><span class="line">        __on_zero_shared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __libcpp_relaxed_load(&amp;__shared_owners_) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>增加和减少引用计数都是在这个类里。引用计数最开始创建时为0，也就是说引用计数是从0开始的，真正的引用计数需要在__shared_owners_基础上加1。</p><p>当释放引用计数时 __release_shared() ，如果当前已经没有引用计数了，就会调用__on_zero_shared()（这个函数的作用是释放真正被管理的内存），并返回true或者false给调用者，调用__release_shared()的是__shared_count的子类__shared_weak_count里的__release_shared()方法。__on_zero_shared()是虚函数，留给子类实现</p><p>__shared_weak_count继承__shared_count，有一个__shared_weak_owners_，这就是弱引用计数。__add_shared()增加引用计数就是调用父类__shared_count的__add_shared()，__add_weak()就是增加__shared_weak_owners_</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TYPE_VIS</span> __shared_weak_count</span><br><span class="line">    : <span class="keyword">private</span> __shared_count</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> __shared_weak_owners_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> __shared_weak_count(<span class="type">long</span> __refs = <span class="number">0</span>) _NOEXCEPT</span><br><span class="line">        : __shared_count(__refs), <span class="comment">// 父类</span></span><br><span class="line">          __shared_weak_owners_(__refs) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~__shared_weak_count() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __add_shared() _NOEXCEPT &#123;</span><br><span class="line">      __shared_count::__add_shared();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __add_weak() _NOEXCEPT &#123;</span><br><span class="line">      __libcpp_atomic_refcount_increment(__shared_weak_owners_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __release_shared() _NOEXCEPT &#123;</span><br><span class="line">      <span class="keyword">if</span> (__shared_count::__release_shared())</span><br><span class="line">        __release_weak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __release_weak() _NOEXCEPT &#123;</span><br><span class="line">        <span class="keyword">if</span> (__libcpp_atomic_load(&amp;__shared_weak_owners_, _AO_Acquire) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            __on_zero_shared_weak();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__libcpp_atomic_refcount_decrement(__shared_weak_owners_) == <span class="number">-1</span>)</span><br><span class="line">            __on_zero_shared_weak();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __shared_count::<span class="built_in">use_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">__shared_weak_count* <span class="title">lock</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        <span class="type">long</span> object_owners = __libcpp_atomic_load(&amp;__shared_owners_);</span><br><span class="line">        <span class="keyword">while</span> (object_owners != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (__libcpp_atomic_compare_exchange(&amp;__shared_owners_,</span><br><span class="line">                                                 &amp;object_owners,</span><br><span class="line">                                                 object_owners+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared_weak() _NOEXCEPT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++标准库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++标准库智能指针之unique_ptr</title>
      <link href="/2023/03/01/C-%E6%A0%87%E5%87%86%E5%BA%93%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E4%B9%8Bunique-ptr/"/>
      <url>/2023/03/01/C-%E6%A0%87%E5%87%86%E5%BA%93%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E4%B9%8Bunique-ptr/</url>
      
        <content type="html"><![CDATA[<p>这篇文章分析一下C++标准库智能指针中的unique_ptr</p><h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><p>unique_ptr是一种独占型的智能指针，无法拷贝，但是可以移动。先看一下unique_ptr的使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个裸指针作为构造函数参数</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放指针指向的内存</span></span><br><span class="line">b.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放指针指针指向的内存，同时接管另一片内存</span></span><br><span class="line">b.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得unique_ptr内部的指针值</span></span><br><span class="line"><span class="keyword">auto</span> pp = b.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放指针，但不释放内存</span></span><br><span class="line"><span class="keyword">auto</span> p = b.<span class="built_in">release</span>();</span><br><span class="line"><span class="comment">// 手动释放内存</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">cc</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; dd = std::<span class="built_in">move</span>(cc);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>unique_ptr原理相对简单，就是使用了RAII机制来包装一个裸指针，他的定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span> = default_delete&lt;_Tp&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> _LIBCPP_TEMPLATE_VIS unique_ptr &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Dp deleter_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __pointer_type&lt;_Tp, deleter_type&gt;::type pointer;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  __compressed_pair&lt;pointer, deleter_type&gt; __ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>unique_ptr内部只有 __compressed_pair&lt;pointer, deleter_type&gt;  __ptr _; 这一个数据成员。</p><p>pointer类型：如果_Dp是default_delete类型，那么pointer推导出来就是_Tp*，而deleter_type通常是一个空的类型（default_delete就是空的），__compressed_pair会针对此进行空间优化，__ptr_的大小通常就是pointer的大小。</p><h2 id="接受裸指针参数的构造函数"><a href="#接受裸指针参数的构造函数" class="headerlink" title="接受裸指针参数的构造函数"></a>接受裸指针参数的构造函数</h2><p>先看一下unique_ptr的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">          <span class="keyword">class</span> = _EnableIfDeleterDefaultConstructible&lt;_Dummy&gt; &gt;</span><br><span class="line"><span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer __p) _NOEXCEPT : __ptr_(__p) &#123;&#125;</span><br></pre></td></tr></table></figure><p>就是用指针参数__p来构造__ptr_</p><p>_EnableIfDeleterDefaultConstructible则是检查删除器是否可以默认构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy, <span class="keyword">class</span> <span class="title class_">_Deleter</span> = <span class="keyword">typename</span> __dependent_type&lt;</span><br><span class="line">                         __identity&lt;deleter_type&gt;, _Dummy&gt;::type&gt;</span><br><span class="line"><span class="keyword">using</span> _EnableIfDeleterDefaultConstructible =</span><br><span class="line">  <span class="keyword">typename</span> enable_if&lt;is_default_constructible&lt;_Deleter&gt;::value &amp;&amp;</span><br><span class="line">                     !is_pointer&lt;_Deleter&gt;::value&gt;::type;</span><br></pre></td></tr></table></figure><p>__identity如下，__identity<deleter_type>内部定义了deleter_type为type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__identity</span> &#123; <span class="keyword">typedef</span> _Tp type; &#125;;</span><br></pre></td></tr></table></figure><p>__dependent_type如下，所以上面__dependent_type&lt;__identity<deleter_type>, _Dummy&gt;::type就是deleter_type，因为他继承了__identity里面的type类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="type">bool</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__dependent_type</span> : <span class="keyword">public</span> _Tp &#123;&#125;;</span><br></pre></td></tr></table></figure><p>所以上面_EnableIfDeleterDefaultConstructible这个trait检查的就是下面两个条件要满足</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_default_constructible&lt;deleter_type&gt;::value</span><br><span class="line">!is_pointer&lt;deleter_type&gt;::value</span><br></pre></td></tr></table></figure><p>第一个条件要求deleter_type能够默认构造<br>第二个条件要求deleter_type不是指针类型</p><h2 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function"><span class="title">unique_ptr</span><span class="params">(unique_ptr&amp;&amp; __u)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">    : __ptr_(__u.release(), _VSTD::forward&lt;deleter_type&gt;(__u.get_deleter())) &#123;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>, <span class="keyword">class</span> <span class="title class_">_Ep</span>,</span><br><span class="line">    <span class="keyword">class</span> = _EnableIfMoveConvertible&lt;unique_ptr&lt;_Up, _Ep&gt;, _Up&gt;,</span><br><span class="line">    <span class="keyword">class</span> = _EnableIfDeleterConvertible&lt;_Ep&gt;</span><br><span class="line">&gt;</span><br><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) _NOEXCEPT</span><br><span class="line">    : __ptr_(__u.<span class="built_in">release</span>(), _VSTD::forward&lt;_Ep&gt;(__u.<span class="built_in">get_deleter</span>())) &#123;&#125;</span><br></pre></td></tr></table></figure><p>移动构造的参数可以是和当前unique_ptr相同的类型，也可以是不同类型，此时两者要满足能够互相转换的条件，比如子类的unique_ptr移动到父类unique_ptr</p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数内部调用reset()，reset()就是将__ptr_的第一个元素（也就是指针）取出，然后调用第二个元素（也就是删除器），把第一个元素作为参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">unique_ptr</span>() &#123; <span class="built_in">reset</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> _NOEXCEPT </span>&#123;</span><br><span class="line">pointer __tmp = __ptr_.<span class="built_in">first</span>();</span><br><span class="line">__ptr_.<span class="built_in">first</span>() = __p;</span><br><span class="line"><span class="keyword">if</span> (__tmp)</span><br><span class="line">  __ptr_.<span class="built_in">second</span>()(__tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">release</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    pointer <span class="type">__t</span> = __ptr_.<span class="built_in">first</span>();</span><br><span class="line">    __ptr_.<span class="built_in">first</span>() = <span class="built_in">pointer</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="type">__t</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅是取出__ptr_的第一个元素，然后将之置为空指针</p><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __ptr_.<span class="built_in">first</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出__ptr_的第一个元素</p><h2 id="make-unique"><a href="#make-unique" class="headerlink" title="make_unique"></a>make_unique</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> __unique_if&lt;_Tp&gt;::<span class="function">__unique_single</span></span><br><span class="line"><span class="function"><span class="title">make_unique</span><span class="params">(_Args&amp;&amp;... __args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;_Tp&gt;(<span class="keyword">new</span> _Tp(_VSTD::forward&lt;_Args&gt;(__args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部就是调用unique_ptr&lt;_Tp&gt;的构造函数，使用了默认删除器。__unique_if是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unique_if</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> unique_ptr&lt;_Tp&gt; __unique_single;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果_Tp是非数组类型，__unique_if&lt;_Tp&gt;::__unique_single 就是unique_ptr&lt;_Tp&gt;</p><h2 id="default-delete"><a href="#default-delete" class="headerlink" title="default_delete"></a>default_delete</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_CXX03_LANG</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> _NOEXCEPT </span>= <span class="keyword">default</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>&gt;</span><br><span class="line">  <span class="built_in">default_delete</span>(<span class="type">const</span> default_delete&lt;_Up&gt;&amp;,</span><br><span class="line">                 <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Up*, _Tp*&gt;::value&gt;::type* =</span><br><span class="line">                     <span class="number">0</span>) _NOEXCEPT &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp* __ptr)</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">delete</span> __ptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>default_delete确实是一个空类型。他是一个重载了operator()调用运算符的类</p><p>上面分析了日常工作中unique_ptr常见的成员函数，下篇继续分析智能指针中的shared_ptr和weak_ptr。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++标准库 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
