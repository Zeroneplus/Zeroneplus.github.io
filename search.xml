<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ffmpeg 之 matroska encoder</title>
      <link href="/2023/12/05/ffmpeg-%E4%B9%8B-matroska-encoder/"/>
      <url>/2023/12/05/ffmpeg-%E4%B9%8B-matroska-encoder/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个录像功能优化的任务，需要分析 mkv 格式和 mp4 格式的优缺点，于是阅读了 ffmpeg matroska encoder 代码以及 mkv 格式的官方 spec。特此记录一下 mkv 格式的学习心得。</p><p>mkv 文件可以理解为一个二进制格式的 xml 文件，常规的 xml 文件如下，通过 <code>&lt; /&gt;</code> 来标识元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Cluster</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Timestamp</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">Timestamp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BlockGroup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="comment">&lt;!-- References a Block 40 Track Ticks before this one --&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ReferenceBlock</span>&gt;</span>-40<span class="tag">&lt;/<span class="name">ReferenceBlock</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Block</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">BlockGroup</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Cluster</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而 mkv 使用 ebml（Extensible Binary Meta Language）格式来存储数据。ebml 中每个元素都有三个部分：element id（全局唯一，用于标识元素类型）、element data length（element data 的长度）、element data。element id 和 element data length 都使用变长整数来存储，变长整数是普通整数的压缩，变长整数分为 3 部分，前缀 0、分隔符（1 比特的 1）、数据。前缀 0 和分隔符用于确定当前变长整数的字节数（前缀 0 的个数 +1），举几个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">二进制整数                                 对应的变长整数                             字节数</span><br><span class="line">0000 0110                                1000 0110                                1</span><br><span class="line">0000 0110 0000 0110                      0100 0110 0000 0110                      2</span><br><span class="line">0000 0110 0000 0110 0000 0110 0000 0110  0001 0110 0000 0110 0000 0110 0000 0110  4</span><br></pre></td></tr></table></figure><p>所以对于变长整数来说，1byte 最多可以使用 7bit，2byte 最多可以使用 14bit，3byte 最多可以使用 21bit，以此类推。变长整数和 h264 格式中的指数哥伦布编码类似，但是变长整数要求 byte-aligned。更多关于 ebml 的内容请参考 <a href="https://datatracker.ietf.org/doc/rfc8794/">https://datatracker.ietf.org/doc/rfc8794/</a>。</p><p>把上面 ebml 理解之后，mkv 格式就简单了。mkv 和 mp4 有很多相似的地方，理解的时候可以把 mp4 中的概念迁移到 mkv 中：mkv 的 element 类似 mp4 中的 box，element id、element data length 类似 mp4 box 的 type field、size field；mkv 也存在元素的嵌套，父元素可以包含若干子元素。</p><p>这篇文章不打算介绍 mkv spec 相关内容，这些内容如果你理解 mp4 格式，很快就能触类旁通。这篇文章想结合 matroskaenc.c 来分析 mkv 格式某些不容易理解的地方。</p><h1 id="codec-相关的-extra-data-如何存储"><a href="#codec-相关的-extra-data-如何存储" class="headerlink" title="codec 相关的 extra data 如何存储"></a>codec 相关的 extra data 如何存储</h1><p>和 mp4 类似，mkv 中有一个 codecpriv element，位于 track-&gt;trackentry 下，用于存储 codec 相关的 extra data</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mkv_write_track</span><span class="params">(AVFormatContext *s, MatroskaMuxContext *mkv,</span></span></span><br><span class="line"><span class="params"><span class="function">                           AVStream *st, mkv_track *track, AVIOContext *pb,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">int</span> is_default)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IS_WEBM</span>(mkv) || par-&gt;codec_id != AV_CODEC_ID_WEBVTT) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> *codecpriv;</span><br><span class="line">        <span class="type">int</span> codecpriv_size, max_payload_size;</span><br><span class="line">        track-&gt;codecpriv_offset = <span class="built_in">avio_tell</span>(pb);</span><br><span class="line">        ret = <span class="built_in">mkv_assemble_codecprivate</span>(s, mkv-&gt;tmp_bc, par,</span><br><span class="line">                                        par-&gt;extradata, par-&gt;extradata_size,</span><br><span class="line">                                        native_id, qt_id,</span><br><span class="line">                                        &amp;codecpriv, &amp;codecpriv_size, &amp;max_payload_size);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        <span class="built_in">mkv_put_codecprivate</span>(pb, max_payload_size, codecpriv, codecpriv_size);</span><br><span class="line">        track-&gt;codecpriv_size = max_payload_size;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mkv_assemble_codecprivate</span><span class="params">(AVFormatContext *s, AVIOContext *dyn_cp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     AVCodecParameters *par,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> <span class="type">uint8_t</span> *extradata, <span class="type">int</span> extradata_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">int</span> native_id, <span class="type">int</span> qt_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">uint8_t</span> **codecpriv, <span class="type">int</span> *codecpriv_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">unsigned</span> *max_payload_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MatroskaMuxContext av_unused *<span class="type">const</span> mkv = s-&gt;priv_data;</span><br><span class="line">    <span class="type">unsigned</span> size_to_reserve = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (native_id) &#123;</span><br><span class="line">        ret = <span class="built_in">mkv_assemble_native_codecprivate</span>(s, dyn_cp, par,</span><br><span class="line">                                               extradata, extradata_size,</span><br><span class="line">                                               &amp;size_to_reserve);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_MATROSKA_MUXER</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (par-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (par-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *codecpriv_size = <span class="built_in">avio_get_dyn_buf</span>(dyn_cp, codecpriv);</span><br><span class="line">    <span class="keyword">if</span> (dyn_cp-&gt;error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dyn_cp-&gt;error;</span><br><span class="line">    *max_payload_size = *codecpriv_size + size_to_reserve;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mkv_assemble_native_codecprivate 里面也是调用 ff_isom_write_avcc 来得到 h264 格式的 extradata</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mkv_assemble_native_codecprivate</span><span class="params">(AVFormatContext *s, AVIOContext *dyn_cp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> AVCodecParameters *par,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> <span class="type">uint8_t</span> *extradata,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int</span> extradata_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">unsigned</span> *size_to_reserve)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (par-&gt;codec_id) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_MATROSKA_MUXER</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> AV_CODEC_ID_H264:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ff_isom_write_avcc</span>(dyn_cp, extradata,</span><br><span class="line">                                  extradata_size);</span><br><span class="line">    <span class="keyword">case</span> AV_CODEC_ID_HEVC:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ff_isom_write_hvcc</span>(dyn_cp, extradata,</span><br><span class="line">                                  extradata_size, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> AV_CODEC_ID_AAC:</span><br><span class="line">        <span class="keyword">if</span> (extradata_size)</span><br><span class="line">            <span class="built_in">avio_write</span>(dyn_cp, extradata, extradata_size);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *size_to_reserve = MAX_PCE_SIZE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="mkv-格式是如何存储-sample-数据的"><a href="#mkv-格式是如何存储-sample-数据的" class="headerlink" title="mkv 格式是如何存储 sample 数据的"></a>mkv 格式是如何存储 sample 数据的</h1><p>数据存在 cluster element 中，mkv 格式原生支持切片，默认情况下 5s 或者 5MB 分一个小片</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mkv_write_header</span><span class="params">(AVFormatContext *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or</span></span><br><span class="line">    <span class="comment">// after 4k and on a keyframe</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_SEEKABLE</span>(pb, mkv)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mkv-&gt;cluster_time_limit &lt; <span class="number">0</span>)</span><br><span class="line">            mkv-&gt;cluster_time_limit = <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">if</span> (mkv-&gt;cluster_size_limit &lt; <span class="number">0</span>)</span><br><span class="line">            mkv-&gt;cluster_size_limit = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mkv-&gt;cluster_time_limit &lt; <span class="number">0</span>)</span><br><span class="line">            mkv-&gt;cluster_time_limit = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (mkv-&gt;cluster_size_limit &lt; <span class="number">0</span>)</span><br><span class="line">            mkv-&gt;cluster_size_limit = <span class="number">32</span> * <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在写 pkt 的时候，会检查当前积攒的 buffer 是否已经足够（大于 5s 或者 5MB），如果是，就将当前积攒的数据作为一个 cluster 写入到文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mkv_write_packet</span><span class="params">(AVFormatContext *s, <span class="type">const</span> AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MatroskaMuxContext *mkv = s-&gt;priv_data;</span><br><span class="line">    <span class="type">int</span> codec_type          = s-&gt;streams[pkt-&gt;stream_index]-&gt;codecpar-&gt;codec_type;</span><br><span class="line">    <span class="type">int</span> keyframe            = !!(pkt-&gt;flags &amp; AV_PKT_FLAG_KEY);</span><br><span class="line">    <span class="type">int</span> cluster_size;</span><br><span class="line">    <span class="type">int64_t</span> cluster_time;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> start_new_cluster;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (mkv-&gt;cluster_pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mkv-&gt;tracks[pkt-&gt;stream_index].write_dts)</span><br><span class="line">            cluster_time = pkt-&gt;dts - mkv-&gt;cluster_pts;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cluster_time = pkt-&gt;pts - mkv-&gt;cluster_pts;</span><br><span class="line">        cluster_time += mkv-&gt;tracks[pkt-&gt;stream_index].ts_offset;</span><br><span class="line"></span><br><span class="line">        cluster_size  = <span class="built_in">avio_tell</span>(mkv-&gt;cluster_bc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mkv-&gt;is_dash &amp;&amp; codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            <span class="comment">// WebM DASH specification states that the first block of</span></span><br><span class="line">            <span class="comment">// every Cluster has to be a key frame. So for DASH video,</span></span><br><span class="line">            <span class="comment">// we only create a Cluster on seeing key frames.</span></span><br><span class="line">            start_new_cluster = keyframe;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mkv-&gt;is_dash &amp;&amp; codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">                   cluster_time &gt; mkv-&gt;cluster_time_limit) &#123;</span><br><span class="line">            <span class="comment">// For DASH audio, we create a Cluster based on cluster_time_limit.</span></span><br><span class="line">            start_new_cluster = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mkv-&gt;is_dash &amp;&amp;</span><br><span class="line">                   (cluster_size &gt; mkv-&gt;cluster_size_limit ||</span><br><span class="line">                    cluster_time &gt; mkv-&gt;cluster_time_limit ||</span><br><span class="line">                    (codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp; keyframe &amp;&amp;</span><br><span class="line">                     cluster_size &gt; <span class="number">4</span> * <span class="number">1024</span>))) &#123;</span><br><span class="line">            start_new_cluster = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            start_new_cluster = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start_new_cluster) &#123;</span><br><span class="line">            ret = <span class="built_in">mkv_end_cluster</span>(s);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mkv_end_cluster</span><span class="params">(AVFormatContext *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MatroskaMuxContext *mkv = s-&gt;priv_data;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mkv-&gt;have_video) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++)</span><br><span class="line">            mkv-&gt;tracks[i].has_cue = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mkv-&gt;cluster_pos = <span class="number">-1</span>;</span><br><span class="line">    ret = <span class="built_in">end_ebml_master_crc32</span>(s-&gt;pb, &amp;mkv-&gt;cluster_bc, mkv,</span><br><span class="line">                                MATROSKA_ID_CLUSTER, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">avio_write_marker</span>(s-&gt;pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_FLUSH_POINT);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果数据还不够，就把 sample 数据缓存，写到 block element 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mkv_write_packet_internal</span><span class="params">(AVFormatContext *s, <span class="type">const</span> AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MatroskaMuxContext *mkv = s-&gt;priv_data;</span><br><span class="line">    AVIOContext *pb;</span><br><span class="line">    AVCodecParameters *par  = s-&gt;streams[pkt-&gt;stream_index]-&gt;codecpar;</span><br><span class="line">    mkv_track *track        = &amp;mkv-&gt;tracks[pkt-&gt;stream_index];</span><br><span class="line">    <span class="type">int</span> is_sub              = par-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE;</span><br><span class="line">    <span class="comment">/* All subtitle blocks are considered to be keyframes. */</span></span><br><span class="line">    <span class="type">int</span> keyframe            = is_sub || !!(pkt-&gt;flags &amp; AV_PKT_FLAG_KEY);</span><br><span class="line">    <span class="type">int64_t</span> duration        = <span class="built_in">FFMAX</span>(pkt-&gt;duration, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int64_t</span> write_duration  = is_sub ? duration : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int64_t</span> ts = track-&gt;write_dts ? pkt-&gt;dts : pkt-&gt;pts;</span><br><span class="line">    <span class="type">int64_t</span> relative_packet_pos;</span><br><span class="line">...</span><br><span class="line">    ts += track-&gt;ts_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mkv-&gt;cluster_pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">int64_t</span> cluster_time = ts - mkv-&gt;cluster_pts;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">int16_t</span>)cluster_time != cluster_time) &#123;</span><br><span class="line">            ret = <span class="built_in">mkv_end_cluster</span>(s);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="built_in">av_log</span>(s, AV_LOG_WARNING, <span class="string">&quot;Starting new cluster due to timestamp\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mkv-&gt;cluster_pos == <span class="number">-1</span>) &#123;</span><br><span class="line">        ret = <span class="built_in">start_ebml_master_crc32</span>(&amp;mkv-&gt;cluster_bc, mkv);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        mkv-&gt;cluster_bc-&gt;direct = <span class="number">1</span>;</span><br><span class="line">        mkv-&gt;cluster_pos = <span class="built_in">avio_tell</span>(s-&gt;pb);</span><br><span class="line">        <span class="built_in">put_ebml_uint</span>(mkv-&gt;cluster_bc, MATROSKA_ID_CLUSTERTIMECODE, <span class="built_in">FFMAX</span>(<span class="number">0</span>, ts));</span><br><span class="line">        mkv-&gt;cluster_pts = <span class="built_in">FFMAX</span>(<span class="number">0</span>, ts);</span><br><span class="line">        <span class="built_in">av_log</span>(s, AV_LOG_DEBUG,</span><br><span class="line">               <span class="string">&quot;Starting new cluster with timestamp &quot;</span></span><br><span class="line">               <span class="string">&quot;%&quot;</span> PRId64 <span class="string">&quot; at offset %&quot;</span> PRId64 <span class="string">&quot; bytes\n&quot;</span>,</span><br><span class="line">               mkv-&gt;cluster_pts, mkv-&gt;cluster_pos);</span><br><span class="line">    &#125;</span><br><span class="line">    pb = mkv-&gt;cluster_bc;</span><br><span class="line"></span><br><span class="line">    relative_packet_pos = <span class="built_in">avio_tell</span>(pb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The WebM spec requires WebVTT to be muxed in BlockGroups;</span></span><br><span class="line"><span class="comment">     * so we force it even for packets without duration. */</span></span><br><span class="line">    ret = <span class="built_in">mkv_write_block</span>(s, mkv, pb, par, track, pkt,</span><br><span class="line">                          keyframe, ts, write_duration,</span><br><span class="line">                          par-&gt;codec_id == AV_CODEC_ID_WEBVTT,</span><br><span class="line">                          relative_packet_pos);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (keyframe &amp;&amp; <span class="built_in">IS_SEEKABLE</span>(s-&gt;pb, mkv) &amp;&amp;</span><br><span class="line">        (par-&gt;codec_type == AVMEDIA_TYPE_VIDEO    ||</span><br><span class="line">         par-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE ||</span><br><span class="line">         !mkv-&gt;have_video &amp;&amp; !track-&gt;has_cue)) &#123;</span><br><span class="line">        ret = <span class="built_in">mkv_add_cuepoint</span>(mkv, pkt-&gt;stream_index, ts,</span><br><span class="line">                               mkv-&gt;cluster_pos, relative_packet_pos,</span><br><span class="line">                               write_duration);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        track-&gt;has_cue = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track-&gt;last_timestamp = ts;</span><br><span class="line">    mkv-&gt;duration   = <span class="built_in">FFMAX</span>(mkv-&gt;duration,   ts + duration);</span><br><span class="line">    track-&gt;duration = <span class="built_in">FFMAX</span>(track-&gt;duration, ts + duration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mkv_write_block</span><span class="params">(<span class="type">void</span> *logctx, MatroskaMuxContext *mkv,</span></span></span><br><span class="line"><span class="params"><span class="function">                           AVIOContext *pb, <span class="type">const</span> AVCodecParameters *par,</span></span></span><br><span class="line"><span class="params"><span class="function">                           mkv_track *track, <span class="type">const</span> AVPacket *pkt,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">int</span> keyframe, <span class="type">int64_t</span> ts, <span class="type">uint64_t</span> duration,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">int</span> force_blockgroup, <span class="type">int64_t</span> relative_packet_pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *side_data;</span><br><span class="line">    <span class="type">size_t</span> side_data_size;</span><br><span class="line">    <span class="type">uint64_t</span> additional_id;</span><br><span class="line">    <span class="type">int64_t</span> discard_padding = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> track_number = track-&gt;track_num;</span><br><span class="line">    <span class="built_in">EBML_WRITER</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    mkv-&gt;cur_block.track  = track;</span><br><span class="line">    mkv-&gt;cur_block.pkt    = pkt;</span><br><span class="line">    mkv-&gt;cur_block.rel_ts = ts - mkv-&gt;cluster_pts;</span><br><span class="line">    mkv-&gt;cur_block.flags  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open a BlockGroup with a Block now; it will later be converted</span></span><br><span class="line"><span class="comment">     * to a SimpleBlock if possible. */</span></span><br><span class="line">    <span class="built_in">ebml_writer_open_master</span>(&amp;writer, MATROSKA_ID_BLOCKGROUP);</span><br><span class="line">    <span class="built_in">ebml_writer_add_block</span>(&amp;writer, mkv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (duration)</span><br><span class="line">        <span class="built_in">ebml_writer_add_uint</span>(&amp;writer, MATROSKA_ID_BLOCKDURATION, duration);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_log</span>(logctx, AV_LOG_DEBUG,</span><br><span class="line">           <span class="string">&quot;Writing block of size %d with pts %&quot;</span> PRId64 <span class="string">&quot;, dts %&quot;</span> PRId64 <span class="string">&quot;, &quot;</span></span><br><span class="line">           <span class="string">&quot;duration %&quot;</span> PRId64 <span class="string">&quot; at relative offset %&quot;</span> PRId64 <span class="string">&quot; in cluster &quot;</span></span><br><span class="line">           <span class="string">&quot;at offset %&quot;</span> PRId64 <span class="string">&quot;. TrackNumber %u, keyframe %d\n&quot;</span>,</span><br><span class="line">           pkt-&gt;size, pkt-&gt;pts, pkt-&gt;dts, pkt-&gt;duration, relative_packet_pos,</span><br><span class="line">           mkv-&gt;cluster_pos, track_number, keyframe != <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!force_blockgroup &amp;&amp; writer.nb_elements == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* Nothing except the BlockGroup + Block. Can use a SimpleBlock. */</span></span><br><span class="line">        writer.elements++;    <span class="comment">// Skip the BlockGroup.</span></span><br><span class="line">        writer.nb_elements--;</span><br><span class="line">        <span class="built_in">av_assert2</span>(writer.elements[<span class="number">0</span>].id == MATROSKA_ID_BLOCK);</span><br><span class="line">        writer.elements[<span class="number">0</span>].id = MATROSKA_ID_SIMPLEBLOCK;</span><br><span class="line">        <span class="keyword">if</span> (keyframe)</span><br><span class="line">            mkv-&gt;cur_block.flags |= <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!keyframe)</span><br><span class="line">        <span class="built_in">ebml_writer_add_sint</span>(&amp;writer, MATROSKA_ID_BLOCKREFERENCE,</span><br><span class="line">                             track-&gt;last_timestamp - ts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ebml_writer_write</span>(&amp;writer, pb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ebml_writer_write_block</span><span class="params">(<span class="type">const</span> EbmlElement *elem, AVIOContext *pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MatroskaMuxContext *<span class="type">const</span> mkv = elem-&gt;priv.mkv;</span><br><span class="line">    BlockContext *<span class="type">const</span> block = &amp;mkv-&gt;cur_block;</span><br><span class="line">    mkv_track *<span class="type">const</span> track = block-&gt;track;</span><br><span class="line">    <span class="type">const</span> AVPacket *<span class="type">const</span> pkt = block-&gt;pkt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put_ebml_num</span>(pb, track-&gt;track_num, track-&gt;track_num_size);</span><br><span class="line">    <span class="built_in">avio_wb16</span>(pb, block-&gt;rel_ts);</span><br><span class="line">    <span class="built_in">avio_w8</span>(pb, block-&gt;flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (track-&gt;reformat) &#123;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        track-&gt;<span class="built_in">reformat</span>(mkv, pb, pkt, &amp;size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint8_t</span> *data = pkt-&gt;data;</span><br><span class="line">        <span class="type">unsigned</span> offset = track-&gt;offset &lt;= pkt-&gt;size ? track-&gt;offset : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">avio_write</span>(pb, data + offset, pkt-&gt;size - offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码有以下几点要注意</p><ul><li><p>每个 cluster element 的头部有一个 <code>CLUSTERTIMECODE</code>，这个时间再加上 block 里的时间才是 block 中 sample 的 pts，block 里的时间用 2byte 来表示，所以当 block 里的时间大于 int16_t 能表示的极限时就需要分片</p></li><li><p>mkv 格式只存储 pts，不存储 dts（某些 pts&#x3D;dts 的场景中会使用 dts），所以 mkv 支持 variable fps，因为两个 sample 之间的 duration 由他们的 pts 来决定</p></li><li><p>mkv 也存在关键帧索引的概念，关键帧索引存储在 cues element 中，mkv 只会在以下条件下存储当前 sample 的索引信息：<code>当前sample是关键帧 &amp;&amp; (当前sample是video/subtitle || 当前是audio且整个文件没有video且当前sample是当前cluster的第一个sample)</code>。这就避免了对每一个 audio sample 都保存一个关键帧索引。</p><ul><li>下面存储 cuepoint 时，cluster_pos 参数代表当前 cluster 在整个文件的起始位置，而 <code>entries[idx].cluster_pos</code> 是 <code>cluster_pos - mkv-&gt;segment_offset</code>，所以 <code>entries[idx].cluster_pos</code> 就是当前 cluster 相对 segment element 的偏移值；<code>entries[idx].pts</code> 则是当前关键帧的绝对时间；<code>entries[idx].relative_pos</code> 则是当前关键帧存储位置相对当前 cluster 的偏移</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mkv_add_cuepoint</span><span class="params">(MatroskaMuxContext *mkv, <span class="type">int</span> stream, <span class="type">int64_t</span> ts,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">int64_t</span> cluster_pos, <span class="type">int64_t</span> relative_pos, <span class="type">int64_t</span> duration)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mkv_cues *cues = &amp;mkv-&gt;cues;</span><br><span class="line">    mkv_cuepoint *entries = cues-&gt;entries;</span><br><span class="line">    <span class="type">unsigned</span> idx = cues-&gt;num_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ts &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    entries = <span class="built_in">av_realloc_array</span>(entries, cues-&gt;num_entries + <span class="number">1</span>, <span class="built_in">sizeof</span>(mkv_cuepoint));</span><br><span class="line">    <span class="keyword">if</span> (!entries)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">    cues-&gt;entries = entries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure the cues entries are sorted by pts. */</span></span><br><span class="line">    <span class="keyword">while</span> (idx &gt; <span class="number">0</span> &amp;&amp; entries[idx - <span class="number">1</span>].pts &gt; ts)</span><br><span class="line">        idx--;</span><br><span class="line">    <span class="built_in">memmove</span>(&amp;entries[idx + <span class="number">1</span>], &amp;entries[idx],</span><br><span class="line">            (cues-&gt;num_entries - idx) * <span class="built_in">sizeof</span>(entries[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    entries[idx].pts           = ts;</span><br><span class="line">    entries[idx].stream_idx    = stream;</span><br><span class="line">    entries[idx].cluster_pos   = cluster_pos - mkv-&gt;segment_offset;</span><br><span class="line">    entries[idx].relative_pos  = relative_pos;</span><br><span class="line">    entries[idx].duration      = duration;</span><br><span class="line"></span><br><span class="line">    cues-&gt;num_entries++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后整合所有 cuepoint 代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mkv_assemble_cues</span><span class="params">(AVStream **streams, AVIOContext *dyn_cp, AVIOContext *cuepoint,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> mkv_cues *cues, mkv_track *tracks, <span class="type">int</span> num_tracks,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">uint64_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (mkv_cuepoint *entry = cues-&gt;entries, *end = entry + cues-&gt;num_entries;</span><br><span class="line">         entry &lt; end;) &#123;</span><br><span class="line">        <span class="type">uint64_t</span> pts = entry-&gt;pts;</span><br><span class="line">        <span class="type">uint8_t</span> *buf;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">put_ebml_uint</span>(cuepoint, MATROSKA_ID_CUETIME, pts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put all the entries from different tracks that have the exact same</span></span><br><span class="line">        <span class="comment">// timestamp into the same CuePoint</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num_tracks; j++)</span><br><span class="line">            tracks[j].has_cue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ebml_master track_positions;</span><br><span class="line">            <span class="type">int</span> idx = entry-&gt;stream_idx;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">av_assert0</span>(idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt; num_tracks);</span><br><span class="line">            <span class="keyword">if</span> (tracks[idx].has_cue &amp;&amp; streams[idx]-&gt;codecpar-&gt;codec_type != AVMEDIA_TYPE_SUBTITLE)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tracks[idx].has_cue = <span class="number">1</span>;</span><br><span class="line">            track_positions = <span class="built_in">start_ebml_master</span>(cuepoint, MATROSKA_ID_CUETRACKPOSITION, MAX_CUETRACKPOS_SIZE);</span><br><span class="line">            <span class="built_in">put_ebml_uint</span>(cuepoint, MATROSKA_ID_CUETRACK           , tracks[idx].track_num);</span><br><span class="line">            <span class="built_in">put_ebml_uint</span>(cuepoint, MATROSKA_ID_CUECLUSTERPOSITION , entry-&gt;cluster_pos + offset);</span><br><span class="line">            <span class="built_in">put_ebml_uint</span>(cuepoint, MATROSKA_ID_CUERELATIVEPOSITION, entry-&gt;relative_pos);</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;duration &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">put_ebml_uint</span>(cuepoint, MATROSKA_ID_CUEDURATION    , entry-&gt;duration);</span><br><span class="line">            <span class="built_in">end_ebml_master</span>(cuepoint, track_positions);</span><br><span class="line">        &#125; <span class="keyword">while</span> (++entry &lt; end &amp;&amp; entry-&gt;pts == pts);</span><br><span class="line">        size = <span class="built_in">avio_get_dyn_buf</span>(cuepoint, &amp;buf);</span><br><span class="line">        <span class="keyword">if</span> (cuepoint-&gt;error &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> cuepoint-&gt;error;</span><br><span class="line">        <span class="built_in">put_ebml_binary</span>(dyn_cp, MATROSKA_ID_POINTENTRY, buf, size);</span><br><span class="line">        <span class="built_in">ffio_reset_dyn_buf</span>(cuepoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会将相同时间的关键帧信息存储在一个 cuepoint 中。在 cuepoint 的头部存储一个 <code>entry-&gt;pts</code>，也就是绝对的 pts，然后存储若干个 <code>CUETRACKPOSITION</code>，每个 <code>CUETRACKPOSITION</code> 包含下述元素</p><ul><li><code>track_num</code> 当前属于哪个 track</li><li><code>CUECLUSTERPOSITION</code> 当前 sample 所处的 cluster 相对于 segment 的位置（offset 可以忽略，他用于 cues 移动到文件头部时调整 cluster_pos，<code>entry-&gt;cluster_pos + offset</code> 本质还是当前 sample 所处的 cluster 相对于 segment 的位置）</li><li><code>CUERELATIVEPOSITION</code> 当前 sample 相对于当前 cluster 的偏移</li></ul><p>有了上面这些信息，给定一个指定的 pts，就可以 seek 到相应的 cluster 中。</p><p>参考资料：</p><p>ffmpeg&#x2F;libavformat&#x2F;matroskaenc.c</p><p><a href="https://www.matroska.org/technical/elements.html">https://www.matroska.org/technical/elements.html</a></p><p><a href="https://datatracker.ietf.org/doc/rfc8794/">https://datatracker.ietf.org/doc/rfc8794/</a></p><p><a href="https://blog.csdn.net/intel1985/article/details/113971488">https://blog.csdn.net/intel1985/article/details/113971488</a></p><p><a href="https://www.cnblogs.com/tocy/category/630599.html?page=2">https://www.cnblogs.com/tocy/category/630599.html?page=2</a></p><p><a href="http://blog.chinaunix.net/uid/20758197/cid-148494-list-3.html">http://blog.chinaunix.net/uid/20758197/cid-148494-list-3.html</a></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> mkv </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fMP4 格式</title>
      <link href="/2023/11/22/fMP4-%E6%A0%BC%E5%BC%8F/"/>
      <url>/2023/11/22/fMP4-%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>这篇文章接着上一篇继续介绍 fmp4 格式。</p><p>传统的 mp4 格式的元数据和 sample 数据分开存储。编码时通常先存储 sample 数据，在编码的最后写入元数据。这样做有以下缺点：</p><ul><li>对于长时间录像，由于元数据最后才写入文件，所以编码过程中，元数据占用的内存会不断增长，对小内存设备来说会出现 out of memory 的情况</li><li>在解析 mp4 文件时，需要读取 moov box 之后才知道如何去获取 sample。而 mp4 编码时通常把 moov box 存在文件的最后（不考虑后期优化 mp4 文件时将 moov box 移动到文件前面），所以首帧速度可能较慢</li></ul><p>而 fmp4 则是基于 mp4 格式改进而来，将一个大的 mp4 文件分成若干个小片段(fragment)，常用于一边生成音视频一边播放&#x2F;传输的场合。</p><h1 id="fmp4-和-mp4-的区别"><a href="#fmp4-和-mp4-的区别" class="headerlink" title="fmp4 和 mp4 的区别"></a>fmp4 和 mp4 的区别</h1><p>fmp4 和 mp4 主要有以下区别</p><ul><li>mp4 格式通常只有一个 moov box 来存储所有 sample 的元数据，解析完 moov box 后就知道所有 sample 的信息；而 fmp4 可以有多个 moof 存储当前音视频数据的不同部分，每读取到一个 moof，就可以知道该小段 sample 的信息</li><li>mp4 格式一般是 moov、mdat 两个 box 相邻，分别存储元数据和 sample 数据；fmp4 则是若干对 moof、mdat 相邻，比如 moof、mdat、moof、mdat、moof、mdat…，每一对 moof、mdat 代表某一小段数据的元数据和 sample 数据</li><li>mp4 格式的元数据（sample 的 pts、dts、size、position）存储在 moov 中 stbl 中的 stts、ctts、stsz、stco、stsc 等 box 中；而 fmp4 的元数据存储在 moof 中的 tfhd&#x2F;trun 等 box 中</li></ul><p>接下来通过 ffmpeg mov muxer 的具体代码来看看 fmp4 格式。</p><p>下面是写 moof box，先计算 moof box 的 size，因为 moof 先于 mdat 写入文件，但 moof 中会写入 sample 的 position，所以需要先算出 moof_size 才能知道每个 sample 的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> mov_write_moof_tag(AVIOContext *pb, MOVMuxContext *mov, <span class="built_in">int</span> tracks,</span><br><span class="line">                              int64_t mdat_size)</span><br><span class="line">&#123;</span><br><span class="line">    AVIOContext *avio_buf;</span><br><span class="line">    <span class="built_in">int</span> ret, moof_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = ffio_open_null_buf(&amp;avio_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    mov_write_moof_tag_internal(avio_buf, mov, tracks, <span class="number">0</span>);</span><br><span class="line">    moof_size = ffio_close_null_buf(avio_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;flags &amp; FF_MOV_FLAG_DASH &amp;&amp;</span><br><span class="line">        !(mov-&gt;flags &amp; (FF_MOV_FLAG_GLOBAL_SIDX | FF_MOV_FLAG_SKIP_SIDX)))</span><br><span class="line">        mov_write_sidx_tags(pb, mov, tracks, moof_size + <span class="number">8</span> + mdat_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;write_prft &gt; MOV_PRFT_NONE &amp;&amp; mov-&gt;write_prft &lt; MOV_PRFT_NB)</span><br><span class="line">        mov_write_prft_tag(pb, mov, tracks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;flags &amp; FF_MOV_FLAG_GLOBAL_SIDX ||</span><br><span class="line">        !(mov-&gt;flags &amp; FF_MOV_FLAG_SKIP_TRAILER) ||</span><br><span class="line">        mov-&gt;ism_lookahead) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = mov_add_tfra_entries(pb, mov, tracks, moof_size + <span class="number">8</span> + mdat_size)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">if</span> (!(mov-&gt;flags &amp; FF_MOV_FLAG_GLOBAL_SIDX) &amp;&amp;</span><br><span class="line">            mov-&gt;flags &amp; FF_MOV_FLAG_SKIP_TRAILER) &#123;</span><br><span class="line">            mov_prune_frag_info(mov, tracks, mov-&gt;ism_lookahead + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mov_write_moof_tag_internal(pb, mov, tracks, moof_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mov_write_moof_tag_internal 中会执行 mov_write_mfhd_tag 写入 mfhd，然后针对每个 track 写一个 traf</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> mov_write_moof_tag_internal(AVIOContext *pb, MOVMuxContext *mov,</span><br><span class="line">                                       <span class="built_in">int</span> tracks, <span class="built_in">int</span> moof_size)</span><br><span class="line">&#123;</span><br><span class="line">    int64_t pos = avio_tell(pb);</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line">    avio_wb32(pb, <span class="number">0</span>); /* size placeholder */</span><br><span class="line">    ffio_wfourcc(pb, <span class="string">&quot;moof&quot;</span>);</span><br><span class="line">    mov-&gt;first_trun = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    mov_write_mfhd_tag(pb, mov);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mov-&gt;nb_streams; i++) &#123;</span><br><span class="line">        MOVTrack *track = &amp;mov-&gt;tracks[i];</span><br><span class="line">        <span class="keyword">if</span> (tracks &gt;= <span class="number">0</span> &amp;&amp; i != tracks)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!track-&gt;entry)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        mov_write_traf_tag(pb, mov, track, pos, moof_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> update_size(pb, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mfhd 中有一个 id 标识当前是第几个 fragment</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> mov_write_mfhd_tag(AVIOContext *pb, MOVMuxContext *mov)</span><br><span class="line">&#123;</span><br><span class="line">    avio_wb32(pb, <span class="number">16</span>);</span><br><span class="line">    ffio_wfourcc(pb, <span class="string">&quot;mfhd&quot;</span>);</span><br><span class="line">    avio_wb32(pb, <span class="number">0</span>);</span><br><span class="line">    avio_wb32(pb, mov-&gt;fragments);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mov_write_traf_tag 中写入 tfhd、tfdt，然后开始写 trun，注意一个 track 中可以有多个 trun，一个 trun 里有多个 sample，下面代码里把存储空间上连续的 sample 写成一个 trun</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> mov_write_traf_tag(AVIOContext *pb, MOVMuxContext *mov,</span><br><span class="line">                              MOVTrack *track, int64_t moof_offset,</span><br><span class="line">                              <span class="built_in">int</span> moof_size)</span><br><span class="line">&#123;</span><br><span class="line">    int64_t pos = avio_tell(pb);</span><br><span class="line">    <span class="built_in">int</span> i, start = <span class="number">0</span>;</span><br><span class="line">    avio_wb32(pb, <span class="number">0</span>); /* size placeholder */</span><br><span class="line">    ffio_wfourcc(pb, <span class="string">&quot;traf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mov_write_tfhd_tag(pb, mov, track, moof_offset);</span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;mode != MODE_ISM)</span><br><span class="line">        mov_write_tfdt_tag(pb, track);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; track-&gt;entry; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (track-&gt;cluster[i].pos != track-&gt;cluster[i - <span class="number">1</span>].pos + track-&gt;cluster[i - <span class="number">1</span>].size) &#123;</span><br><span class="line">            mov_write_trun_tag(pb, mov, track, moof_size, start, i);</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mov_write_trun_tag(pb, mov, track, moof_size, start, track-&gt;entry);</span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;mode == MODE_ISM) &#123;</span><br><span class="line">        mov_write_tfxd_tag(pb, track);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mov-&gt;ism_lookahead) &#123;</span><br><span class="line">            <span class="built_in">int</span> size = <span class="number">16</span> + <span class="number">4</span> + <span class="number">1</span> + <span class="number">16</span> * mov-&gt;ism_lookahead;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (track-&gt;nb_frag_info &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                MOVFragmentInfo *info = &amp;track-&gt;frag_info[track-&gt;nb_frag_info - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (!info-&gt;tfrf_offset)</span><br><span class="line">                    info-&gt;tfrf_offset = avio_tell(pb);</span><br><span class="line">            &#125;</span><br><span class="line">            avio_wb32(pb, <span class="number">8</span> + size);</span><br><span class="line">            ffio_wfourcc(pb, <span class="string">&quot;free&quot;</span>);</span><br><span class="line">            ffio_fill(pb, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> update_size(pb, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tfhd 里面有一些 flag 来标识 sample 的默认信息，比如 MOV_TFHD_DEFAULT_SIZE、MOV_TFHD_DEFAULT_DURATION、MOV_TFHD_DEFAULT_FLAGS。如果这些 flag 存在，那么 tfhd 中会有 default_duration、default_size、default_sample_flags 等字段。</p><p>tfhd 里面还有一个比较特殊的 flag：FF_MOV_FLAG_DEFAULT_BASE_MOOF。出现了这个 flag 那么 MOV_TFHD_BASE_DATA_OFFSET 就不能再出现。FF_MOV_FLAG_DEFAULT_BASE_MOOF 表示 tfhd 中没有 data_offset 字段，data_offset 就是 moof 的地址，如果出现 MOV_TFHD_BASE_DATA_OFFSET，那么 tfhd 中有 data_offset，从下面代码可以看到，当存在 MOV_TFHD_BASE_DATA_OFFSET 时，data_offset 其实也是 moof_offset。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> mov_write_tfhd_tag(AVIOContext *pb, MOVMuxContext *mov,</span><br><span class="line">                              MOVTrack *track, int64_t moof_offset)</span><br><span class="line">&#123;</span><br><span class="line">    int64_t pos = avio_tell(pb);</span><br><span class="line">    uint32_t flags = MOV_TFHD_DEFAULT_SIZE | MOV_TFHD_DEFAULT_DURATION |</span><br><span class="line">                     MOV_TFHD_BASE_DATA_OFFSET;</span><br><span class="line">    <span class="keyword">if</span> (!track-&gt;entry) &#123;</span><br><span class="line">        flags |= MOV_TFHD_DURATION_IS_EMPTY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags |= MOV_TFHD_DEFAULT_FLAGS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;flags &amp; FF_MOV_FLAG_OMIT_TFHD_OFFSET)</span><br><span class="line">        flags &amp;= ~MOV_TFHD_BASE_DATA_OFFSET;</span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;flags &amp; FF_MOV_FLAG_DEFAULT_BASE_MOOF) &#123;</span><br><span class="line">        flags &amp;= ~MOV_TFHD_BASE_DATA_OFFSET;</span><br><span class="line">        flags |= MOV_TFHD_DEFAULT_BASE_IS_MOOF;</span><br><span class="line">    &#125;</span><br><span class="line">    /* CMAF requires <span class="built_in">all</span> values to be explicit <span class="keyword">in</span> tfhd atoms */</span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;flags &amp; FF_MOV_FLAG_CMAF)</span><br><span class="line">        flags |= MOV_TFHD_STSD_ID;</span><br><span class="line">...</span><br><span class="line">    avio_wb32(pb, <span class="number">0</span>); /* size placeholder */</span><br><span class="line">    ffio_wfourcc(pb, <span class="string">&quot;tfhd&quot;</span>);</span><br><span class="line">    avio_w8(pb, <span class="number">0</span>); /* version */</span><br><span class="line">    avio_wb24(pb, flags);</span><br><span class="line"></span><br><span class="line">    avio_wb32(pb, track-&gt;track_id); /* track-<span class="built_in">id</span> */</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOV_TFHD_BASE_DATA_OFFSET)</span><br><span class="line">        avio_wb64(pb, moof_offset);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOV_TFHD_STSD_ID) &#123;</span><br><span class="line">        avio_wb32(pb, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOV_TFHD_DEFAULT_DURATION) &#123;</span><br><span class="line">        track-&gt;default_duration = get_cluster_duration(track, <span class="number">0</span>);</span><br><span class="line">        avio_wb32(pb, track-&gt;default_duration);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOV_TFHD_DEFAULT_SIZE) &#123;</span><br><span class="line">        track-&gt;default_size = track-&gt;entry ? track-&gt;cluster[<span class="number">0</span>].size : <span class="number">1</span>;</span><br><span class="line">        avio_wb32(pb, track-&gt;default_size);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        track-&gt;default_size = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOV_TFHD_DEFAULT_FLAGS) &#123;</span><br><span class="line">        /* <span class="type">Set</span> the default flags based on the second sample, <span class="keyword">if</span> available.</span><br><span class="line">         * If the first sample <span class="keyword">is</span> different, that can be signaled via a separate field. */</span><br><span class="line">        <span class="keyword">if</span> (track-&gt;entry &gt; <span class="number">1</span>)</span><br><span class="line">            track-&gt;default_sample_flags = get_sample_flags(track, &amp;track-&gt;cluster[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            track-&gt;default_sample_flags =</span><br><span class="line">                track-&gt;par-&gt;codec_type == AVMEDIA_TYPE_VIDEO ?</span><br><span class="line">                (MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES | MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC) :</span><br><span class="line">                MOV_FRAG_SAMPLE_FLAG_DEPENDS_NO;</span><br><span class="line">        avio_wb32(pb, track-&gt;default_sample_flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> update_size(pb, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tfdt 里面保存当前 fragment 的起始 dts，该起始 dts 加上 trun 里的 sample duration 可以计算出每个 sample 的 dts</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> mov_write_tfdt_tag(AVIOContext *pb, MOVTrack *track)</span><br><span class="line">&#123;</span><br><span class="line">    int64_t pos = avio_tell(pb);</span><br><span class="line"></span><br><span class="line">    avio_wb32(pb, <span class="number">0</span>); /* size */</span><br><span class="line">    ffio_wfourcc(pb, <span class="string">&quot;tfdt&quot;</span>);</span><br><span class="line">    avio_w8(pb, <span class="number">1</span>); /* version */</span><br><span class="line">    avio_wb24(pb, <span class="number">0</span>);</span><br><span class="line">    avio_wb64(pb, track-&gt;cluster[<span class="number">0</span>].dts - track-&gt;start_dts);</span><br><span class="line">    <span class="keyword">return</span> update_size(pb, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>trun 里面存储每一个 sample 的信息，比如当前 trun 的 data offset、每个 sample 的 duration、size、flag。之前在 tfhd 中有一些 default 的 duration、size、flag 参数，当 trun 里 sample 的 duration、size、flag 不存在时，就使用 tfhd 中的 default 值。</p><p>除了 tfhd 中的 base_offset，trun 还有一个 data_offset，base_offset+data_offset 才是当前 trun 的 offset，用当前 trun 的 offset 加上 sample size 就能算出每个 sample 的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> mov_write_trun_tag(AVIOContext *pb, MOVMuxContext *mov,</span><br><span class="line">                              MOVTrack *track, <span class="built_in">int</span> moof_size,</span><br><span class="line">                              <span class="built_in">int</span> first, <span class="built_in">int</span> end)</span><br><span class="line">&#123;</span><br><span class="line">    int64_t pos = avio_tell(pb);</span><br><span class="line">    uint32_t flags = MOV_TRUN_DATA_OFFSET;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = first; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (get_cluster_duration(track, i) != track-&gt;default_duration)</span><br><span class="line">            flags |= MOV_TRUN_SAMPLE_DURATION;</span><br><span class="line">        <span class="keyword">if</span> (track-&gt;cluster[i].size != track-&gt;default_size)</span><br><span class="line">            flags |= MOV_TRUN_SAMPLE_SIZE;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; first &amp;&amp; get_sample_flags(track, &amp;track-&gt;cluster[i]) != track-&gt;default_sample_flags)</span><br><span class="line">            flags |= MOV_TRUN_SAMPLE_FLAGS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; MOV_TRUN_SAMPLE_FLAGS) &amp;&amp; track-&gt;entry &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         get_sample_flags(track, &amp;track-&gt;cluster[<span class="number">0</span>]) != track-&gt;default_sample_flags)</span><br><span class="line">        flags |= MOV_TRUN_FIRST_SAMPLE_FLAGS;</span><br><span class="line">    <span class="keyword">if</span> (track-&gt;flags &amp; MOV_TRACK_CTTS)</span><br><span class="line">        flags |= MOV_TRUN_SAMPLE_CTS;</span><br><span class="line"></span><br><span class="line">    avio_wb32(pb, <span class="number">0</span>); /* size placeholder */</span><br><span class="line">    ffio_wfourcc(pb, <span class="string">&quot;trun&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;flags &amp; FF_MOV_FLAG_NEGATIVE_CTS_OFFSETS)</span><br><span class="line">        avio_w8(pb, <span class="number">1</span>); /* version */</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        avio_w8(pb, <span class="number">0</span>); /* version */</span><br><span class="line">    avio_wb24(pb, flags);</span><br><span class="line"></span><br><span class="line">    avio_wb32(pb, end - first); /* sample count */</span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;flags &amp; FF_MOV_FLAG_OMIT_TFHD_OFFSET &amp;&amp;</span><br><span class="line">        !(mov-&gt;flags &amp; FF_MOV_FLAG_DEFAULT_BASE_MOOF) &amp;&amp;</span><br><span class="line">        !mov-&gt;first_trun)</span><br><span class="line">        avio_wb32(pb, <span class="number">0</span>); /* Later tracks follow immediately after the previous one */</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        avio_wb32(pb, moof_size + <span class="number">8</span> + track-&gt;data_offset +</span><br><span class="line">                      track-&gt;cluster[first].pos); /* data offset */</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOV_TRUN_FIRST_SAMPLE_FLAGS)</span><br><span class="line">        avio_wb32(pb, get_sample_flags(track, &amp;track-&gt;cluster[first]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = first; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; MOV_TRUN_SAMPLE_DURATION)</span><br><span class="line">            avio_wb32(pb, get_cluster_duration(track, i));</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; MOV_TRUN_SAMPLE_SIZE)</span><br><span class="line">            avio_wb32(pb, track-&gt;cluster[i].size);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; MOV_TRUN_SAMPLE_FLAGS)</span><br><span class="line">            avio_wb32(pb, get_sample_flags(track, &amp;track-&gt;cluster[i]));</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; MOV_TRUN_SAMPLE_CTS)</span><br><span class="line">            avio_wb32(pb, track-&gt;cluster[i].cts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mov-&gt;first_trun = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> update_size(pb, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以发现 fmp4 和 mp4 非常像，特别是 sample 元数据的组织方式，fmp4 只是把 mp4 分成很多个 fragment，然后将这些 fragment 的元数据和 sample 数据相邻存储。</p><h1 id="MSE-和-fmp4"><a href="#MSE-和-fmp4" class="headerlink" title="MSE 和 fmp4"></a>MSE 和 fmp4</h1><p>MSE 标准使得浏览器能原生播放 fmp4 格式的视频，但是 MSE 标准对 fmp4 有以下额外要求：</p><ul><li>moov 中不能有数据（moov 中有数据也不会读取）</li><li>trun 的 base data offset 必须使用 FF_MOV_FLAG_DEFAULT_BASE_MOOF</li></ul><p>ffmpeg mov muxer 中有一个 flag：FF_MOV_FLAG_DASH，存在该 flag 时会自动添加 FF_MOV_FLAG_FRAGMENT、FF_MOV_FLAG_EMPTY_MOOV、FF_MOV_FLAG_DEFAULT_BASE_MOOF。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> mov_init(AVFormatContext *s)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;flags &amp; FF_MOV_FLAG_DASH)</span><br><span class="line">        mov-&gt;flags |= FF_MOV_FLAG_FRAGMENT | FF_MOV_FLAG_EMPTY_MOOV |</span><br><span class="line">                      FF_MOV_FLAG_DEFAULT_BASE_MOOF;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以要想得到 mse compatible 的 fmp4 文件，需使用 FF_MOV_FLAG_DASH。</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> mp4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg mov muxer 之 fmp4</title>
      <link href="/2023/11/07/ffmpeg-mov-muxer-%E4%B9%8B-fmp4/"/>
      <url>/2023/11/07/ffmpeg-mov-muxer-%E4%B9%8B-fmp4/</url>
      
        <content type="html"><![CDATA[<p>最近在使用 ffmpeg mp4 muxer 的时候遇到一个问题，当长时间录像时，由于 mp4 muxer 会在每写入一个 sample 之后，增加一个 entry 来存储这个 sample 的信息（用于 write_trailer 时得到 moov box），随着录像时间越来越长，相关 sample 的元数据信息就会越来越多，对于小内存的设备来说，就会出现 out of memory 的情况。</p><p>后来了解到 mp4 还存在一种 fragment mp4 模式，fmp4 就是把一个大的 mp4 文件分成几个小的部分，每个部分依次存储在一个文件中，每个部分的 moov&#x2F;moof、mdat 邻近存储，可以在写完一定长度的数据之后就写入元信息，从而避免将元信息留到最后来写，这种模式相较 mp4 来说内存压力会小很多，特别是对于小设备且长期录像的场合。</p><p>从 mov muxer 的 option 中发现，存在一些和 fragment 相关的选项，比如 frag_duration，设定了这个选项之后，mov muxer 就会按照 frag_duration 的大小来进行分片，比如下面就设定分片时长为 5s（5000000 对应的 timescale 是 1000000）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -hide_banner -f lavfi -i testsrc=size=<span class="number">640</span>x480:rate=<span class="number">30</span> -f mp4 -frag_duration <span class="number">5000000</span> -t <span class="number">20</span> z.mp4</span><br></pre></td></tr></table></figure><p>生成的 mp4 文件通过工具查看确实出现了一个 moov 和 3 个 moof。</p><p>下篇文章介绍一下 fmp4 和 mp4 格式的区别。</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> mp4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg mov muxer 之 negative_cts_offsets flag</title>
      <link href="/2023/10/25/ffmpeg-mov-muxer-%E4%B9%8B-negative-cts-offsets-flag/"/>
      <url>/2023/10/25/ffmpeg-mov-muxer-%E4%B9%8B-negative-cts-offsets-flag/</url>
      
        <content type="html"><![CDATA[<p>最近因为要使用 fmp4 格式进行录像，所以研究了一下 ffmpeg mov muxer。这篇文章记录一下 ffmpeg mov muxer 的 negative_cts_offsets flag 的作用。</p><p>当使用 mp4 存储 h264 文件时，由于解码顺序和显示顺序不同，所以需要 stts 和 ctts box 来分别存储 dts 以及 cts。当没有设置 negative_cts_offsets flag 时，cts 只能是正数，所以 dts+cts 计算得到的 pts 一定是比 0 大的，此时就需要 edit box 来将 pts 移动到 0 开始。但如果设置了 negative_cts_offsets flag，那么 cts 允许为负数，此时 dts+cts 就允许 pts 从 0 开始，那么就不再需要 edit box 来偏移 pts 了。所以如果设置了 negative_cts_offsets flag，那么还可以加上-use_editlist 0 来关闭 edit box。</p><p>在理解这个 flag 的过程中有一个比较坑的地方：从编码器编码出来的 h264 pkt 的 pts 是从 0 开始，而 dts 是从负数开始的，比如下面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -hide_banner -f lavfi -i testsrc=size=640x480:rate=<span class="number">30</span> -f mp4 -t <span class="number">1</span> -vframes <span class="number">5</span> z.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面命令中编码器输出的pkt的pts和dts</span></span><br><span class="line">mov <span class="built_in">input</span> pkt: pts <span class="number">0</span>, dts -<span class="number">1024</span></span><br><span class="line">mov <span class="built_in">input</span> pkt: pts <span class="number">2048</span>, dts -<span class="number">512</span></span><br><span class="line">mov <span class="built_in">input</span> pkt: pts <span class="number">1024</span>, dts <span class="number">0</span></span><br><span class="line">mov <span class="built_in">input</span> pkt: pts <span class="number">512</span>, dts <span class="number">512</span></span><br><span class="line">mov <span class="built_in">input</span> pkt: pts <span class="number">1536</span>, dts <span class="number">1024</span></span><br></pre></td></tr></table></figure><p>这一点对理解 ffmpeg mov muxer 的代码很关键。</p><p>还有一点，就是 AVFormatContext.avoid_negative_ts 这个变量对 pkt 的 pts 和 dts 的影响。这个变量用于控制在将 pkt 送给 muxer 之前是否需要修改 pts 和 dts，比如下面 mov_init 中，如果 use_editlist 为 false，avoid_negative_ts 为默认值，并且没有设置 negative_cts_offsets flag，那么就会将 avoid_negative_ts 设置为 AVFMT_AVOID_NEG_TS_MAKE_ZERO</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> mov_init(AVFormatContext *s)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!mov-&gt;use_editlist &amp;&amp; s-&gt;avoid_negative_ts == AVFMT_AVOID_NEG_TS_AUTO &amp;&amp;</span><br><span class="line">        !(mov-&gt;flags &amp; FF_MOV_FLAG_NEGATIVE_CTS_OFFSETS))</span><br><span class="line">        s-&gt;avoid_negative_ts = AVFMT_AVOID_NEG_TS_MAKE_ZERO;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>avoid_negative_ts 设置为 AVFMT_AVOID_NEG_TS_MAKE_ZERO 之后，ffmpeg 内部在把 pkt 送给 muxer 之前会处理当前 pkt 的 dts&#x2F;pts 为负数的情况，具体逻辑在 handle_avoid_negative_ts 函数中，就是把所有的 pts&#x2F;dts 加一个值，让他们 &gt;&#x3D;0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -hide_banner -f lavfi -i testsrc=size=640x480:rate=<span class="number">30</span> -f mp4 -t <span class="number">1</span> -vframes <span class="number">5</span> -use_editlist <span class="number">0</span> z.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的pts/dts就经过了调整，都加上了一个数</span></span><br><span class="line">mov <span class="built_in">input</span> pkt: pts <span class="number">1024</span>, dts <span class="number">0</span></span><br><span class="line">mov <span class="built_in">input</span> pkt: pts <span class="number">3072</span>, dts <span class="number">512</span></span><br><span class="line">mov <span class="built_in">input</span> pkt: pts <span class="number">2048</span>, dts <span class="number">1024</span></span><br><span class="line">mov <span class="built_in">input</span> pkt: pts <span class="number">1536</span>, dts <span class="number">1536</span></span><br><span class="line">mov <span class="built_in">input</span> pkt: pts <span class="number">2560</span>, dts <span class="number">2048</span></span><br></pre></td></tr></table></figure><p>接下来再看 mov muxer 相关代码，在 mov_write_single_packet 中，如果设置了 NEGATIVE_CTS_OFFSETS，那么会计算一个 dts_shift，并将 dts 整体偏移 dts_shift，以第一组数据为例子，dts_shift 就是 1024，经过偏移后的 dts 从 0 开始，就不再是负数了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> mov_write_single_packet(AVFormatContext *s, AVPacket *pkt)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (mov-&gt;flags &amp; FF_MOV_FLAG_NEGATIVE_CTS_OFFSETS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (trk-&gt;dts_shift == AV_NOPTS_VALUE)</span><br><span class="line">            trk-&gt;dts_shift = pkt-&gt;pts - pkt-&gt;dts;</span><br><span class="line">        pkt-&gt;dts += trk-&gt;dts_shift;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后计算 cts 时则是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    trk-&gt;cluster[trk-&gt;entry].cts   = pkt-&gt;pts - pkt-&gt;dts;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上可知，是否设置 NEGATIVE_CTS_OFFSETS flag 最关键的区别是：设置 NEGATIVE_CTS_OFFSETS 之后，整个 dts 会往正向移动一个 dts shift。</p><p>为什么编码器输出的 pkt 的 dts 是从负数开始？因为老版本的 ctts 只允许为正值，所以 dts 整体往负向移动了一段时间，来保证 pts-dts 为正值，但是新版本的 ctts 允许为负值之后，此时原先编码器中将 dts 整体往负向移动的操作就不再需要了，所以此时需要将 dts 再往正向移动。</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> mp4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么不同底层对象的 function 之间可以相互赋值、构造？</title>
      <link href="/2023/10/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84-function-%E4%B9%8B%E9%97%B4%E5%8F%AF%E4%BB%A5%E7%9B%B8%E4%BA%92%E8%B5%8B%E5%80%BC%E3%80%81%E6%9E%84%E9%80%A0%EF%BC%9F/"/>
      <url>/2023/10/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%BA%95%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84-function-%E4%B9%8B%E9%97%B4%E5%8F%AF%E4%BB%A5%E7%9B%B8%E4%BA%92%E8%B5%8B%E5%80%BC%E3%80%81%E6%9E%84%E9%80%A0%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>最近在复习 std::function 时，遇到一个疑问：为什么不同底层对象的 function 之间可以赋值、构造，当 function 的底层对象发生变化之后（比如通过拷贝赋值函数），为什么 function 能正确知道新的底层对象该如何调用？</p><p>这是因为 function 内部存储底层对象时，是用指针存储的，该指针是如下类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__base&lt;_Rp(_ArgTypes...)&gt;*</span><br></pre></td></tr></table></figure><p>但是指针真正指向的是派生类，该派生类中存有底层对象的类型信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__func</span>&lt;_Fp, _Alloc, _Rp(_ArgTypes...)&gt;</span><br><span class="line">    : <span class="keyword">public</span>  __base&lt;_Rp(_ArgTypes...)&gt;</span><br></pre></td></tr></table></figure><p>而在__base&lt;_Rp(_ArgTypes…)&gt; 中有一系列的虚函数，比如 operator()()、destroy()、__clone()，通过这些虚函数，function 不需要知道底层类型就可以正确的调用 operator()()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__base</span>&lt;_Rp(_ArgTypes...)&gt;</span><br><span class="line">&#123;</span><br><span class="line">    __base(<span class="type">const</span> __base&amp;);</span><br><span class="line">    __base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __base&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY __base() &#123;&#125;</span><br><span class="line">    _LIBCPP_HIDE_FROM_ABI_VIRTUAL <span class="keyword">virtual</span> ~__base() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> __base* __clone() <span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __clone(__base*) <span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> _NOEXCEPT </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">destroy_deallocate</span><span class="params">()</span> _NOEXCEPT </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> _Rp <span class="title">operator</span><span class="params">()</span><span class="params">(_ArgTypes&amp;&amp; ...)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_HAS_NO_RTTI</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">void</span>* <span class="title">target</span><span class="params">(<span class="type">const</span> type_info&amp;)</span> <span class="type">const</span> _NOEXCEPT </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::type_info&amp; <span class="title">target_type</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>= <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _LIBCPP_HAS_NO_RTTI</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++标准库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>引用的 const</title>
      <link href="/2023/10/05/%E5%BC%95%E7%94%A8%E7%9A%84-const/"/>
      <url>/2023/10/05/%E5%BC%95%E7%94%A8%E7%9A%84-const/</url>
      
        <content type="html"><![CDATA[<p>最近在回顾 compressed_pair 的代码，发现了自己之前忽略的一个问题，如果 compressed_pair 的模板参数是引用类型，下面的 get()函数对于 const 和非 const 版本来说，分别返回什么类型？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="type">int</span> _Idx&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__compressed_pair_elem</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> _ParamT = _Tp;</span><br><span class="line">  <span class="keyword">using</span> reference = _Tp&amp;;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="type">const</span> _Tp&amp;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>&gt;</span><br><span class="line">  <span class="keyword">explicit</span> __compressed_pair_elem(_Up&amp;&amp; __u) : __value_(std::forward&lt;_Up&gt;(__u)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  reference __get() &#123; <span class="keyword">return</span> __value_; &#125;</span><br><span class="line">  const_reference __get() <span class="type">const</span> &#123; <span class="keyword">return</span> __value_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  _Tp __value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">__compressed_pair_elem&lt;<span class="type">int</span> &amp;&amp;, <span class="number">0</span>&gt;<span class="built_in">a</span>(<span class="number">0</span>);</span><br><span class="line">__compressed_pair_elem&lt;<span class="type">int</span> &amp;&amp;, <span class="number">1</span>&gt;<span class="function"><span class="type">const</span> <span class="title">b</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(a.__get()) c = x;</span><br><span class="line"><span class="keyword">decltype</span>(b.__get()) d = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是都是返回 int&amp;类型，<strong>当 const 作用在引用上时，const 会被忽略</strong>，因为引用本身就是顶层 const，下面的代码中 t 是 int&amp;类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> h = <span class="type">int</span> &amp;;</span><br><span class="line"><span class="keyword">using</span> t = h <span class="type">const</span>;</span><br></pre></td></tr></table></figure><p>上面第二个 using 是把 h 作为一个引用类型去解释，所以 const 会作用到引用上而不会作用到 int 上</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mp4 的 edit box</title>
      <link href="/2023/09/27/mp4-%E7%9A%84-edit-box/"/>
      <url>/2023/09/27/mp4-%E7%9A%84-edit-box/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍一下 mp4 的 edit box，edit box 的作用就是对 track 上的媒体数据进行重新排列。</p><p>EditListBox 在规范中定义如下，每个 edit list 有 segment_duration、media_time、media_rate_integer、media_rate_fraction 这几个字段，media_rate_integer 和 media_rate_fraction 可以认为就是 media_rate 的两个部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">aligned</span>(<span class="number">8</span>) <span class="function"><span class="keyword">class</span> EditListBox extends <span class="title">FullBox</span><span class="params">(‘elst’, version, <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">32</span>)</span> entry_count</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i &lt;= entry_count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (version==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function"><span class="type">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">64</span>)</span> segment_duration</span>;</span><br><span class="line">            <span class="built_in">int</span>(<span class="number">64</span>) media_time;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// version==0</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="built_in">int</span>(<span class="number">32</span>) segment_duration;</span><br><span class="line">            <span class="built_in">int</span>(<span class="number">32</span>) media_time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span>(<span class="number">16</span>) media_rate_integer;</span><br><span class="line">        <span class="built_in">int</span>(<span class="number">16</span>) media_rate_fraction = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 edit list 代表原有 track 上的一段媒体数据：media_time 代表该段数据的起始时间，segment_duration 代表该段数据的长度（这里不管这两个字段的 timescale 是什么，规范中有说明），media_rate 代表该段数据的播放时长（目前只有 0 和 1 两种值，0 代表特殊的 dwell 场景）。</p><p>上面说的可能不是特别好理解，举个例子具体分析一下：假设现在有一段媒体数据，起始时间是 10，时长是 50，下面是不同 edit list 对该文件的作用</p><p><img src="/images/mp4-edit-list/mp4-edit-list.jpg" alt="mp4-edit-ox"></p><p>从上面可以看到，edit list 的作用就是从原始的媒体数据中取若干段数据下来，然后组合得到新的 track（可以认为就是一个剪辑、重新拼接过程，有了 edit list，当用户想做剪辑时可以直接在 mp4 格式层面执行，不需要重新解码、编码）。还有一点要注意，edit list 操作得到的 track 的时间要重新计算：第一段数据的起始时间从 0 开始，根据自己的 duration 累加得到后续数据的起始时间。</p><p>参考资料：</p><p>mp4 文件 elst 研究 <a href="https://blog.jianchihu.net/mp4-elst-box.html">https://blog.jianchihu.net/mp4-elst-box.html</a></p><p>Standardized “Skip Intro” in MP4 video files? <a href="https://stackoverflow.com/questions/61979789/standardized-skip-intro-in-mp4-video-files">https://stackoverflow.com/questions/61979789/standardized-skip-intro-in-mp4-video-files</a></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> mp4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg mov demuxer 如何读取 extradata</title>
      <link href="/2023/09/19/ffmpeg-mov-demuxer-%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96-extradata/"/>
      <url>/2023/09/19/ffmpeg-mov-demuxer-%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96-extradata/</url>
      
        <content type="html"><![CDATA[<p>这篇文章记录一下 ffmpeg mov demuxer 读取 extradata，也就是读取 sps&#x2F;pps 的过程。</p><p>sps&#x2F;pps 存储在 stsd box 中，mov_read_stsd 函数如下，根据 entries 可以确定 stsd 中有多少个条目，分别读取每一个条目</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mov_read_stsd</span><span class="params">(MOVContext *c, AVIOContext *pb, MOVAtom atom)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVStream *st;</span><br><span class="line">    MOVStreamContext *sc;</span><br><span class="line">    <span class="type">int</span> ret, entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;fc-&gt;nb_streams &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams - <span class="number">1</span>];</span><br><span class="line">    sc = st-&gt;priv_data;</span><br><span class="line"></span><br><span class="line">    sc-&gt;stsd_version = <span class="built_in">avio_r8</span>(pb);</span><br><span class="line">    <span class="built_in">avio_rb24</span>(pb); <span class="comment">/* flags */</span></span><br><span class="line">    entries = <span class="built_in">avio_rb32</span>(pb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Each entry contains a size (4 bytes) and format (4 bytes). */</span></span><br><span class="line">    <span class="keyword">if</span> (entries &lt;= <span class="number">0</span> || entries &gt; atom.size / <span class="number">8</span> || entries &gt; <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(c-&gt;fc, AV_LOG_ERROR, <span class="string">&quot;invalid STSD entries %d\n&quot;</span>, entries);</span><br><span class="line">        <span class="keyword">return</span> AVERROR_INVALIDDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sc-&gt;extradata) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(c-&gt;fc, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;Duplicate stsd found in this track.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> AVERROR_INVALIDDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prepare space for hosting multiple extradata. */</span></span><br><span class="line">    sc-&gt;extradata = <span class="built_in">av_calloc</span>(entries, <span class="built_in">sizeof</span>(*sc-&gt;extradata));</span><br><span class="line">    <span class="keyword">if</span> (!sc-&gt;extradata)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line"></span><br><span class="line">    sc-&gt;extradata_size = <span class="built_in">av_calloc</span>(entries, <span class="built_in">sizeof</span>(*sc-&gt;extradata_size));</span><br><span class="line">    <span class="keyword">if</span> (!sc-&gt;extradata_size) &#123;</span><br><span class="line">        ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">ff_mov_read_stsd_entries</span>(c, pb, entries);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore back the primary extradata. */</span></span><br><span class="line">    <span class="built_in">av_freep</span>(&amp;st-&gt;codecpar-&gt;extradata);</span><br><span class="line">    st-&gt;codecpar-&gt;extradata_size = sc-&gt;extradata_size[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (sc-&gt;extradata_size[<span class="number">0</span>]) &#123;</span><br><span class="line">        st-&gt;codecpar-&gt;extradata = <span class="built_in">av_mallocz</span>(sc-&gt;extradata_size[<span class="number">0</span>] + AV_INPUT_BUFFER_PADDING_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (!st-&gt;codecpar-&gt;extradata)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="built_in">memcpy</span>(st-&gt;codecpar-&gt;extradata, sc-&gt;extradata[<span class="number">0</span>], sc-&gt;extradata_size[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mov_finalize_stsd_codec</span>(c, pb, st, sc);</span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span> (sc-&gt;extradata) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sc-&gt;stsd_count; j++)</span><br><span class="line">            <span class="built_in">av_freep</span>(&amp;sc-&gt;extradata[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_freep</span>(&amp;sc-&gt;extradata);</span><br><span class="line">    <span class="built_in">av_freep</span>(&amp;sc-&gt;extradata_size);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_mov_read_stsd_entries 函数如下，对每个 entries，需要读取 box type（也就是 format）、dref_id（表明当前 entry 使用哪个 data reference），注意下面把 format 赋给了 codec_tag</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_mov_read_stsd_entries</span><span class="params">(MOVContext *c, AVIOContext *pb, <span class="type">int</span> entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVStream *st;</span><br><span class="line">    MOVStreamContext *sc;</span><br><span class="line">    <span class="type">int</span> pseudo_stream_id;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert0</span> (c-&gt;fc-&gt;nb_streams &gt;= <span class="number">1</span>);</span><br><span class="line">    st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams<span class="number">-1</span>];</span><br><span class="line">    sc = st-&gt;priv_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pseudo_stream_id = <span class="number">0</span>;</span><br><span class="line">         pseudo_stream_id &lt; entries &amp;&amp; !pb-&gt;eof_reached;</span><br><span class="line">         pseudo_stream_id++) &#123;</span><br><span class="line">        <span class="comment">//Parsing Sample description table</span></span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">AVCodecID</span> id;</span><br><span class="line">        <span class="type">int</span> ret, dref_id = <span class="number">1</span>;</span><br><span class="line">        MOVAtom a = &#123; <span class="built_in">AV_RL32</span>(<span class="string">&quot;stsd&quot;</span>) &#125;;</span><br><span class="line">        <span class="type">int64_t</span> start_pos = <span class="built_in">avio_tell</span>(pb);</span><br><span class="line">        <span class="type">int64_t</span> size    = <span class="built_in">avio_rb32</span>(pb); <span class="comment">/* size */</span></span><br><span class="line">        <span class="type">uint32_t</span> format = <span class="built_in">avio_rl32</span>(pb); <span class="comment">/* data format */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="built_in">avio_rb32</span>(pb); <span class="comment">/* reserved */</span></span><br><span class="line">            <span class="built_in">avio_rb16</span>(pb); <span class="comment">/* reserved */</span></span><br><span class="line">            dref_id = <span class="built_in">avio_rb16</span>(pb);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="built_in">av_log</span>(c-&gt;fc, AV_LOG_ERROR,</span><br><span class="line">                   <span class="string">&quot;invalid size %&quot;</span>PRId64<span class="string">&quot; in stsd\n&quot;</span>, size);</span><br><span class="line">            <span class="keyword">return</span> AVERROR_INVALIDDATA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">mov_skip_multiple_stsd</span>(c, pb, st-&gt;codecpar-&gt;codec_tag, format,</span><br><span class="line">                                   size - (<span class="built_in">avio_tell</span>(pb) - start_pos))) &#123;</span><br><span class="line">            sc-&gt;stsd_count++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sc-&gt;pseudo_stream_id = st-&gt;codecpar-&gt;codec_tag ? <span class="number">-1</span> : pseudo_stream_id;</span><br><span class="line">        sc-&gt;dref_id= dref_id;</span><br><span class="line">        sc-&gt;format = format;</span><br><span class="line"></span><br><span class="line">        id = <span class="built_in">mov_codec_id</span>(st, format);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">av_log</span>(c-&gt;fc, AV_LOG_TRACE,</span><br><span class="line">               <span class="string">&quot;size=%&quot;</span>PRId64<span class="string">&quot; 4CC=%s codec_type=%d\n&quot;</span>, size,</span><br><span class="line">               <span class="built_in">av_fourcc2str</span>(format), st-&gt;codecpar-&gt;codec_type);</span><br><span class="line"></span><br><span class="line">        st-&gt;codecpar-&gt;codec_id = id;</span><br><span class="line">        <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type==AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            <span class="built_in">mov_parse_stsd_video</span>(c, pb, st, sc);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type==AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type==AVMEDIA_TYPE_SUBTITLE)&#123;</span><br><span class="line">...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* this will read extra atoms at the end (wave, alac, damr, avcC, hvcC, SMI ...) */</span></span><br><span class="line">        a.size = size - (<span class="built_in">avio_tell</span>(pb) - start_pos);</span><br><span class="line">        <span class="keyword">if</span> (a.size &gt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">mov_read_default</span>(c, pb, a)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.size &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">avio_skip</span>(pb, a.size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sc-&gt;extradata &amp;&amp; st-&gt;codecpar-&gt;extradata) &#123;</span><br><span class="line">            <span class="type">int</span> extra_size = st-&gt;codecpar-&gt;extradata_size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move the current stream extradata to the stream context one. */</span></span><br><span class="line">            sc-&gt;extradata_size[pseudo_stream_id] = extra_size;</span><br><span class="line">            sc-&gt;extradata[pseudo_stream_id] = st-&gt;codecpar-&gt;extradata;</span><br><span class="line">            st-&gt;codecpar-&gt;extradata      = <span class="literal">NULL</span>;</span><br><span class="line">            st-&gt;codecpar-&gt;extradata_size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sc-&gt;stsd_count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看 mov_parse_stsd_video 函数，这个函数读取 isom 中定义的一些通用的 stsd 信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mov_parse_stsd_video</span><span class="params">(MOVContext *c, AVIOContext *pb,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 AVStream *st, MOVStreamContext *sc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> codec_name[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int64_t</span> stsd_start;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="type">uint32_t</span> id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The first 16 bytes of the video sample description are already</span></span><br><span class="line"><span class="comment">     * read in ff_mov_read_stsd_entries() */</span></span><br><span class="line">    stsd_start = <span class="built_in">avio_tell</span>(pb) - <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">avio_rb16</span>(pb); <span class="comment">/* version */</span></span><br><span class="line">    <span class="built_in">avio_rb16</span>(pb); <span class="comment">/* revision level */</span></span><br><span class="line">    id = <span class="built_in">avio_rl32</span>(pb); <span class="comment">/* vendor */</span></span><br><span class="line">    <span class="built_in">av_dict_set</span>(&amp;st-&gt;metadata, <span class="string">&quot;vendor_id&quot;</span>, <span class="built_in">av_fourcc2str</span>(id), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">avio_rb32</span>(pb); <span class="comment">/* temporal quality */</span></span><br><span class="line">    <span class="built_in">avio_rb32</span>(pb); <span class="comment">/* spatial quality */</span></span><br><span class="line"></span><br><span class="line">    st-&gt;codecpar-&gt;width  = <span class="built_in">avio_rb16</span>(pb); <span class="comment">/* width */</span></span><br><span class="line">    st-&gt;codecpar-&gt;height = <span class="built_in">avio_rb16</span>(pb); <span class="comment">/* height */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">avio_rb32</span>(pb); <span class="comment">/* horiz resolution */</span></span><br><span class="line">    <span class="built_in">avio_rb32</span>(pb); <span class="comment">/* vert resolution */</span></span><br><span class="line">    <span class="built_in">avio_rb32</span>(pb); <span class="comment">/* data size, always 0 */</span></span><br><span class="line">    <span class="built_in">avio_rb16</span>(pb); <span class="comment">/* frames per samples */</span></span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">avio_r8</span>(pb); <span class="comment">/* codec name, pascal string */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">31</span>)</span><br><span class="line">        len = <span class="number">31</span>;</span><br><span class="line">    <span class="built_in">mov_read_mac_string</span>(c, pb, len, codec_name, <span class="built_in">sizeof</span>(codec_name));</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">31</span>)</span><br><span class="line">        <span class="built_in">avio_skip</span>(pb, <span class="number">31</span> - len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (codec_name[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">av_dict_set</span>(&amp;st-&gt;metadata, <span class="string">&quot;encoder&quot;</span>, codec_name, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* codec_tag YV12 triggers an UV swap in rawdec.c */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(codec_name, <span class="string">&quot;Planar Y&#x27;CbCr 8-bit 4:2:0&quot;</span>, <span class="number">25</span>)) &#123;</span><br><span class="line">        st-&gt;codecpar-&gt;codec_tag = <span class="built_in">MKTAG</span>(<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        st-&gt;codecpar-&gt;width &amp;= ~<span class="number">1</span>;</span><br><span class="line">        st-&gt;codecpar-&gt;height &amp;= ~<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Flash Media Server uses tag H.263 with Sorenson Spark */</span></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_tag == <span class="built_in">MKTAG</span>(<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;3&#x27;</span>) &amp;&amp;</span><br><span class="line">        !<span class="built_in">strncmp</span>(codec_name, <span class="string">&quot;Sorenson H263&quot;</span>, <span class="number">13</span>))</span><br><span class="line">        st-&gt;codecpar-&gt;codec_id = AV_CODEC_ID_FLV1;</span><br><span class="line"></span><br><span class="line">    st-&gt;codecpar-&gt;bits_per_coded_sample = <span class="built_in">avio_rb16</span>(pb); <span class="comment">/* depth */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">avio_seek</span>(pb, stsd_start, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ff_get_qtpalette</span>(st-&gt;codecpar-&gt;codec_id, pb, sc-&gt;palette)) &#123;</span><br><span class="line">        st-&gt;codecpar-&gt;bits_per_coded_sample &amp;= <span class="number">0x1F</span>;</span><br><span class="line">        sc-&gt;has_palette = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想读取 sps&#x2F;pps，还需要读取 mp4 标准对 video stsd 的扩展部分，ff_mov_read_stsd_entries 在 mov_parse_stsd_video 之后还会执行 mov_read_default 来继续读取 box。比如 mp4 格式，就是继承标准的 visual stsd entry 并把 format（也就是 box type）改成 avc1，然后在标准的 visual stsd entry 的后面加上 avcc box，继续看 avcc box 的解析过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mov_read_glbl</span><span class="params">(MOVContext *c, AVIOContext *pb, MOVAtom atom)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVStream *st;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;fc-&gt;nb_streams &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uint64_t</span>)atom.size &gt; (<span class="number">1</span>&lt;&lt;<span class="number">30</span>))</span><br><span class="line">        <span class="keyword">return</span> AVERROR_INVALIDDATA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (atom.size &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// Broken files created by legacy versions of libavformat will</span></span><br><span class="line">        <span class="comment">// wrap a whole fiel atom inside of a glbl atom.</span></span><br><span class="line">        <span class="type">unsigned</span> size = <span class="built_in">avio_rb32</span>(pb);</span><br><span class="line">        <span class="type">unsigned</span> type = <span class="built_in">avio_rl32</span>(pb);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">avio_feof</span>(pb))</span><br><span class="line">            <span class="keyword">return</span> AVERROR_INVALIDDATA;</span><br><span class="line">        <span class="built_in">avio_seek</span>(pb, <span class="number">-8</span>, SEEK_CUR);</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="built_in">MKTAG</span>(<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>) &amp;&amp; size == atom.size)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">mov_read_default</span>(c, pb, atom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st-&gt;codecpar-&gt;extradata_size &gt; <span class="number">1</span> &amp;&amp; st-&gt;codecpar-&gt;extradata) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(c-&gt;fc, AV_LOG_WARNING, <span class="string">&quot;ignoring multiple glbl\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">ff_get_extradata</span>(c-&gt;fc, st-&gt;codecpar, pb, atom.size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (atom.type == <span class="built_in">MKTAG</span>(<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;C&#x27;</span>) &amp;&amp; st-&gt;codecpar-&gt;codec_tag == <span class="built_in">MKTAG</span>(<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">        <span class="comment">/* HEVC-based Dolby Vision derived from hvc1.</span></span><br><span class="line"><span class="comment">           Happens to match with an identifier</span></span><br><span class="line"><span class="comment">           previously utilized for DV. Thus, if we have</span></span><br><span class="line"><span class="comment">           the hvcC extradata box available as specified,</span></span><br><span class="line"><span class="comment">           set codec to HEVC */</span></span><br><span class="line">        st-&gt;codecpar-&gt;codec_id = AV_CODEC_ID_HEVC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_get_extradata</span><span class="params">(<span class="type">void</span> *logctx, AVCodecParameters *par, AVIOContext *pb, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">ff_alloc_extradata</span>(par, size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    ret = <span class="built_in">ffio_read_size</span>(pb, par-&gt;extradata, size);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_freep</span>(&amp;par-&gt;extradata);</span><br><span class="line">        par-&gt;extradata_size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">av_log</span>(logctx, AV_LOG_ERROR, <span class="string">&quot;Failed to read extradata of size %d\n&quot;</span>, size);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，就是把整个 avcc box 的内容取出来作为 extradata</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> mp4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg mov demuxer 如何 read pkt</title>
      <link href="/2023/09/05/ffmpeg-mov-demuxer-%E5%A6%82%E4%BD%95-read-pkt/"/>
      <url>/2023/09/05/ffmpeg-mov-demuxer-%E5%A6%82%E4%BD%95-read-pkt/</url>
      
        <content type="html"><![CDATA[<p>这篇文章继续看 ffmpeg mov demuxer 的 read pkt 过程。</p><p>先去查找下一个 sample，通过 mov_find_next_sample，该函数会找 dts 最小的那个 stream 的 sample</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mov_read_packet</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    sample = <span class="built_in">mov_find_next_sample</span>(s, &amp;st);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> AVIndexEntry *<span class="title">mov_find_next_sample</span><span class="params">(AVFormatContext *s, AVStream **st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVIndexEntry *sample = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int64_t</span> best_dts = INT64_MAX;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *avst = s-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> avsti = <span class="built_in">ffstream</span>(avst);</span><br><span class="line">        MOVStreamContext *msc = avst-&gt;priv_data;</span><br><span class="line">        <span class="keyword">if</span> (msc-&gt;pb &amp;&amp; msc-&gt;current_sample &lt; avsti-&gt;nb_index_entries) &#123;</span><br><span class="line">            AVIndexEntry *current_sample = &amp;avsti-&gt;index_entries[msc-&gt;current_sample];</span><br><span class="line">            <span class="type">int64_t</span> dts = <span class="built_in">av_rescale</span>(current_sample-&gt;timestamp, AV_TIME_BASE, msc-&gt;time_scale);</span><br><span class="line">            <span class="built_in">av_log</span>(s, AV_LOG_TRACE, <span class="string">&quot;stream %d, sample %d, dts %&quot;</span>PRId64<span class="string">&quot;\n&quot;</span>, i, msc-&gt;current_sample, dts);</span><br><span class="line">            <span class="keyword">if</span> (!sample || </span><br><span class="line">                (!(s-&gt;pb-&gt;seekable &amp; AVIO_SEEKABLE_NORMAL) &amp;&amp; current_sample-&gt;pos &lt; sample-&gt;pos) ||</span><br><span class="line">                ((s-&gt;pb-&gt;seekable &amp; AVIO_SEEKABLE_NORMAL) &amp;&amp;</span><br><span class="line">                 ((msc-&gt;pb != s-&gt;pb &amp;&amp; dts &lt; best_dts) || </span><br><span class="line">                  (msc-&gt;pb == s-&gt;pb &amp;&amp; dts != AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                    ((<span class="built_in">FFABS</span>(best_dts - dts) &lt;= AV_TIME_BASE &amp;&amp; current_sample-&gt;pos &lt; sample-&gt;pos) ||</span><br><span class="line">                     (<span class="built_in">FFABS</span>(best_dts - dts) &gt; AV_TIME_BASE &amp;&amp; dts &lt; best_dts)</span><br><span class="line">                    )</span><br><span class="line">                  )</span><br><span class="line">                 )</span><br><span class="line">                )</span><br><span class="line">               ) &#123;</span><br><span class="line">                sample = current_sample;</span><br><span class="line">                best_dts = dts;</span><br><span class="line">                *st = avst;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sample;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后更新 sample 对应的 stream 的 current_sample 以及 current_index</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mov_read_packet</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">mov_current_sample_inc</span>(sc);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mov_current_sample_inc</span><span class="params">(MOVStreamContext *sc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sc-&gt;current_sample++;</span><br><span class="line">    sc-&gt;current_index++;</span><br><span class="line">    <span class="keyword">if</span> (sc-&gt;index_ranges &amp;&amp;</span><br><span class="line">        sc-&gt;current_index &gt;= sc-&gt;current_index_range-&gt;end &amp;&amp;</span><br><span class="line">        sc-&gt;current_index_range-&gt;end) &#123;</span><br><span class="line">        sc-&gt;current_index_range++;</span><br><span class="line">        sc-&gt;current_index = sc-&gt;current_index_range-&gt;start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 avio_seek 到 sample-&gt;pos</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int64_t</span> ret64 = <span class="built_in">avio_seek</span>(sc-&gt;pb, sample-&gt;pos, SEEK_SET);</span><br></pre></td></tr></table></figure><p>通过 av_get_packet 读取 pkt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = <span class="built_in">av_get_packet</span>(sc-&gt;pb, pkt, sample-&gt;size);</span><br></pre></td></tr></table></figure><p>更新 pkt 的 dts 等信息，dts 就是来自 sample-&gt;timestamp，pts 则是 dts+ctts</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pkt-&gt;stream_index = sc-&gt;ffindex;</span><br><span class="line">    pkt-&gt;dts = sample-&gt;timestamp;</span><br><span class="line">    <span class="keyword">if</span> (sample-&gt;flags &amp; AVINDEX_DISCARD_FRAME) &#123;</span><br><span class="line">        pkt-&gt;flags |= AV_PKT_FLAG_DISCARD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sc-&gt;ctts_data &amp;&amp; sc-&gt;ctts_index &lt; sc-&gt;ctts_count) &#123;</span><br><span class="line">        pkt-&gt;pts = pkt-&gt;dts + sc-&gt;dts_shift + sc-&gt;ctts_data[sc-&gt;ctts_index].duration;</span><br><span class="line">        <span class="comment">/* update ctts context */</span></span><br><span class="line">        sc-&gt;ctts_sample++;</span><br><span class="line">        <span class="keyword">if</span> (sc-&gt;ctts_index &lt; sc-&gt;ctts_count &amp;&amp;</span><br><span class="line">            sc-&gt;ctts_data[sc-&gt;ctts_index].count == sc-&gt;ctts_sample) &#123;</span><br><span class="line">            sc-&gt;ctts_index++;</span><br><span class="line">            sc-&gt;ctts_sample = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int64_t</span> next_dts = (sc-&gt;current_sample &lt; <span class="built_in">ffstream</span>(st)-&gt;nb_index_entries) ?</span><br><span class="line">            <span class="built_in">ffstream</span>(st)-&gt;index_entries[sc-&gt;current_sample].timestamp : st-&gt;duration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next_dts &gt;= pkt-&gt;dts)</span><br><span class="line">            pkt-&gt;duration = next_dts - pkt-&gt;dts;</span><br><span class="line">        pkt-&gt;pts = pkt-&gt;dts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sc-&gt;sdtp_data &amp;&amp; sc-&gt;current_sample &lt;= sc-&gt;sdtp_count) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> sample_flags = sc-&gt;sdtp_data[sc-&gt;current_sample - <span class="number">1</span>];</span><br><span class="line">        <span class="type">uint8_t</span> sample_is_depended_on = (sample_flags &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3</span>;</span><br><span class="line">        pkt-&gt;flags |= sample_is_depended_on == MOV_SAMPLE_DEPENDENCY_NO ? AV_PKT_FLAG_DISPOSABLE : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pkt-&gt;flags |= sample-&gt;flags &amp; AVINDEX_KEYFRAME ? AV_PKT_FLAG_KEY : <span class="number">0</span>;</span><br><span class="line">    pkt-&gt;pos = sample-&gt;pos;</span><br></pre></td></tr></table></figure><p>最后还会执行 stsd 的切换，比如当前 sample 对应的 chunk 换了一个 stsd 时，需要重新把新的 stsd 的 extradata 放在 pkt 中并传给解码器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sc-&gt;stsc_data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sc-&gt;stsc_data[sc-&gt;stsc_index].id &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            sc-&gt;stsc_data[sc-&gt;stsc_index].id - <span class="number">1</span> &lt; sc-&gt;stsd_count &amp;&amp;</span><br><span class="line">            sc-&gt;stsc_data[sc-&gt;stsc_index].id - <span class="number">1</span> != sc-&gt;last_stsd_index) &#123;</span><br><span class="line">            ret = <span class="built_in">mov_change_extradata</span>(sc, pkt);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the stsc index for the next sample */</span></span><br><span class="line">        sc-&gt;stsc_sample++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">mov_stsc_index_valid</span>(sc-&gt;stsc_index, sc-&gt;stsc_count) &amp;&amp;</span><br><span class="line">            <span class="built_in">mov_get_stsc_samples</span>(sc, sc-&gt;stsc_index) == sc-&gt;stsc_sample) &#123;</span><br><span class="line">            sc-&gt;stsc_index++;</span><br><span class="line">            sc-&gt;stsc_sample = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mov_change_extradata</span><span class="params">(MOVStreamContext *sc, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *side, *extradata;</span><br><span class="line">    <span class="type">int</span> extradata_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save the current index. */</span></span><br><span class="line">    sc-&gt;last_stsd_index = sc-&gt;stsc_data[sc-&gt;stsc_index].id - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the decoder that extradata changed. */</span></span><br><span class="line">    extradata_size = sc-&gt;extradata_size[sc-&gt;last_stsd_index];</span><br><span class="line">    extradata = sc-&gt;extradata[sc-&gt;last_stsd_index];</span><br><span class="line">    <span class="keyword">if</span> (extradata_size &gt; <span class="number">0</span> &amp;&amp; extradata) &#123;</span><br><span class="line">        side = <span class="built_in">av_packet_new_side_data</span>(pkt,</span><br><span class="line">                                       AV_PKT_DATA_NEW_EXTRADATA,</span><br><span class="line">                                       extradata_size);</span><br><span class="line">        <span class="keyword">if</span> (!side)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="built_in">memcpy</span>(side, extradata, extradata_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> mp4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg mov demuxer 如何进行 seek</title>
      <link href="/2023/08/25/ffmpeg-mov-demuxer-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C-seek/"/>
      <url>/2023/08/25/ffmpeg-mov-demuxer-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C-seek/</url>
      
        <content type="html"><![CDATA[<p>接着上一篇继续看 ffmpeg mov demuxer seek 的过程。</p><h1 id="mov-read-seek"><a href="#mov-read-seek" class="headerlink" title="mov_read_seek"></a>mov_read_seek</h1><p>seek 时会调用 mov_read_seek 函数。mov_read_seek 先对想要 seek 的 stream 进行 mov_seek_stream，找到需要 seek 到的 sample idx，然后如果是 seek_individually，就把剩下的 stream 都分别 seek 到 sample idx 对应的 sample 的时间上，如果不是 seek_individually，则把所有 stream 逐个增加 sample，直到抵达 sample idx（该 sample 增加过程和 read pkt 里一样，所以理论上这种方法要更准确一点）。</p><p><code>mc-&gt;seek_individually</code> 默认为 1，所以使用第一种 seek。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mov_read_seek</span><span class="params">(AVFormatContext *s, <span class="type">int</span> stream_index, <span class="type">int64_t</span> sample_time, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MOVContext *mc = s-&gt;priv_data;</span><br><span class="line">    AVStream *st;</span><br><span class="line">    FFStream *sti;</span><br><span class="line">    <span class="type">int</span> sample;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stream_index &gt;= s-&gt;nb_streams)</span><br><span class="line">        <span class="keyword">return</span> AVERROR_INVALIDDATA;</span><br><span class="line"></span><br><span class="line">    st = s-&gt;streams[stream_index];</span><br><span class="line">    sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">    sample = <span class="built_in">mov_seek_stream</span>(s, st, sample_time, flags);</span><br><span class="line">    <span class="keyword">if</span> (sample &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mc-&gt;seek_individually) &#123;</span><br><span class="line">        <span class="comment">/* adjust seek timestamp to found sample timestamp */</span></span><br><span class="line">        <span class="type">int64_t</span> seek_timestamp = sti-&gt;index_entries[sample].timestamp;</span><br><span class="line">        sti-&gt;skip_samples = <span class="built_in">mov_get_skip_samples</span>(st, sample);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">            AVStream *<span class="type">const</span> st  = s-&gt;streams[i];</span><br><span class="line">            FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">            <span class="type">int64_t</span> timestamp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stream_index == i)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            timestamp = <span class="built_in">av_rescale_q</span>(seek_timestamp, s-&gt;streams[stream_index]-&gt;time_base, st-&gt;time_base);</span><br><span class="line">            sample = <span class="built_in">mov_seek_stream</span>(s, st, timestamp, flags);</span><br><span class="line">            <span class="keyword">if</span> (sample &gt;= <span class="number">0</span>)</span><br><span class="line">                sti-&gt;skip_samples = <span class="built_in">mov_get_skip_samples</span>(st, sample);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">            MOVStreamContext *sc;</span><br><span class="line">            st = s-&gt;streams[i];</span><br><span class="line">            sc = st-&gt;priv_data;</span><br><span class="line">            <span class="built_in">mov_current_sample_set</span>(sc, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            MOVStreamContext *sc;</span><br><span class="line">            AVIndexEntry *entry = <span class="built_in">mov_find_next_sample</span>(s, &amp;st);</span><br><span class="line">            <span class="keyword">if</span> (!entry)</span><br><span class="line">                <span class="keyword">return</span> AVERROR_INVALIDDATA;</span><br><span class="line">            sc = st-&gt;priv_data;</span><br><span class="line">            <span class="keyword">if</span> (sc-&gt;ffindex == stream_index &amp;&amp; sc-&gt;current_sample == sample)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">mov_current_sample_inc</span>(sc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mov-seek-stream"><a href="#mov-seek-stream" class="headerlink" title="mov_seek_stream"></a>mov_seek_stream</h2><p>seek 时使用 dts 进行 seek，通过 av_index_search_timestamp 查找需要 seek 到的 sample idx</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mov_seek_stream</span><span class="params">(AVFormatContext *s, AVStream *st, <span class="type">int64_t</span> timestamp, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MOVStreamContext *sc = st-&gt;priv_data;</span><br><span class="line">    FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">    <span class="type">int</span> sample, time_sample, ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here we consider timestamp to be PTS, hence try to offset it so that we</span></span><br><span class="line">    <span class="comment">// can search over the DTS timeline.</span></span><br><span class="line">    timestamp -= (sc-&gt;min_corrected_pts + sc-&gt;dts_shift);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">mov_seek_fragment</span>(s, st, timestamp);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        sample = <span class="built_in">av_index_search_timestamp</span>(st, timestamp, flags);</span><br><span class="line">        <span class="built_in">av_log</span>(s, AV_LOG_TRACE, <span class="string">&quot;stream %d, timestamp %&quot;</span>PRId64<span class="string">&quot;, sample %d\n&quot;</span>, st-&gt;index, timestamp, sample);</span><br><span class="line">        <span class="keyword">if</span> (sample &lt; <span class="number">0</span> &amp;&amp; sti-&gt;nb_index_entries &amp;&amp; timestamp &lt; sti-&gt;index_entries[<span class="number">0</span>].timestamp)</span><br><span class="line">            sample = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sample &lt; <span class="number">0</span>) <span class="comment">/* not sure what to do */</span></span><br><span class="line">            <span class="keyword">return</span> AVERROR_INVALIDDATA;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sample || <span class="built_in">can_seek_to_key_sample</span>(st, sample, timestamp))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        timestamp -= <span class="built_in">FFMAX</span>(sc-&gt;min_sample_duration, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mov_current_sample_set</span>(sc, sample);</span><br><span class="line">    <span class="built_in">av_log</span>(s, AV_LOG_TRACE, <span class="string">&quot;stream %d, found sample %d\n&quot;</span>, st-&gt;index, sc-&gt;current_sample);</span><br><span class="line">    <span class="comment">/* adjust ctts index */</span></span><br><span class="line">    <span class="keyword">if</span> (sc-&gt;ctts_data) &#123;</span><br><span class="line">        time_sample = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sc-&gt;ctts_count; i++) &#123;</span><br><span class="line">            <span class="type">int</span> next = time_sample + sc-&gt;ctts_data[i].count;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; sc-&gt;current_sample) &#123;</span><br><span class="line">                sc-&gt;ctts_index = i;</span><br><span class="line">                sc-&gt;ctts_sample = sc-&gt;current_sample - time_sample;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            time_sample = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* adjust stsd index */</span></span><br><span class="line">    <span class="keyword">if</span> (sc-&gt;chunk_count) &#123;</span><br><span class="line">        time_sample = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sc-&gt;stsc_count; i++) &#123;</span><br><span class="line">            <span class="type">int64_t</span> next = time_sample + <span class="built_in">mov_get_stsc_samples</span>(sc, i);</span><br><span class="line">            <span class="keyword">if</span> (next &gt; sc-&gt;current_sample) &#123;</span><br><span class="line">                sc-&gt;stsc_index = i;</span><br><span class="line">                sc-&gt;stsc_sample = sc-&gt;current_sample - time_sample;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">av_assert0</span>(next == (<span class="type">int</span>)next);</span><br><span class="line">            time_sample = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sample;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="av-index-search-timestamp"><a href="#av-index-search-timestamp" class="headerlink" title="av_index_search_timestamp"></a>av_index_search_timestamp</h3><p>此函数通过二分法进行搜索，搜索时以 dts 作为搜索目标，注意下面搜索会返回 timestamp 对应的最近的<strong>下一个关键帧</strong>的 sample idx</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_index_search_timestamp</span><span class="params">(AVStream *st, <span class="type">int64_t</span> wanted_timestamp, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ff_index_search_timestamp</span>(sti-&gt;index_entries, sti-&gt;nb_index_entries,</span><br><span class="line">                                     wanted_timestamp, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_index_search_timestamp</span><span class="params">(<span class="type">const</span> AVIndexEntry *entries, <span class="type">int</span> nb_entries,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int64_t</span> wanted_timestamp, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, m;</span><br><span class="line">    <span class="type">int64_t</span> timestamp;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">-1</span>;</span><br><span class="line">    b = nb_entries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimize appending index entries at the end.</span></span><br><span class="line">    <span class="keyword">if</span> (b &amp;&amp; entries[b - <span class="number">1</span>].timestamp &lt; wanted_timestamp)</span><br><span class="line">        a = b - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (b - a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        m         = (a + b) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Search for the next non-discarded packet.</span></span><br><span class="line">        <span class="keyword">while</span> ((entries[m].flags &amp; AVINDEX_DISCARD_FRAME) &amp;&amp; m &lt; b &amp;&amp; m &lt; nb_entries - <span class="number">1</span>) &#123;</span><br><span class="line">            m++;</span><br><span class="line">            <span class="keyword">if</span> (m == b &amp;&amp; entries[m].timestamp &gt;= wanted_timestamp) &#123;</span><br><span class="line">                m = b - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timestamp = entries[m].timestamp;</span><br><span class="line">        <span class="keyword">if</span> (timestamp &gt;= wanted_timestamp)</span><br><span class="line">            b = m;</span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt;= wanted_timestamp)</span><br><span class="line">            a = m;</span><br><span class="line">    &#125;</span><br><span class="line">    m = (flags &amp; AVSEEK_FLAG_BACKWARD) ? a : b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AVSEEK_FLAG_ANY))</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; m &lt; nb_entries &amp;&amp;</span><br><span class="line">               !(entries[m].flags &amp; AVINDEX_KEYFRAME))</span><br><span class="line">            m += (flags &amp; AVSEEK_FLAG_BACKWARD) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m == nb_entries)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mov-current-sample-set"><a href="#mov-current-sample-set" class="headerlink" title="mov_current_sample_set"></a>mov_current_sample_set</h3><p>av_index_search_timestamp 找到需要 seek 到的 sample idx 之后，通过 mov_current_sample_set 设置当前的 sample idx 为上一步得到的 sample idx</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mov_current_sample_set</span><span class="params">(MOVStreamContext *sc, <span class="type">int</span> current_sample)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int64_t</span> range_size;</span><br><span class="line"></span><br><span class="line">    sc-&gt;current_sample = current_sample;</span><br><span class="line">    sc-&gt;current_index = current_sample;</span><br><span class="line">    <span class="keyword">if</span> (!sc-&gt;index_ranges) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (sc-&gt;current_index_range = sc-&gt;index_ranges;</span><br><span class="line">        sc-&gt;current_index_range-&gt;end;</span><br><span class="line">        sc-&gt;current_index_range++) &#123;</span><br><span class="line">        range_size = sc-&gt;current_index_range-&gt;end - sc-&gt;current_index_range-&gt;start;</span><br><span class="line">        <span class="keyword">if</span> (range_size &gt; current_sample) &#123;</span><br><span class="line">            sc-&gt;current_index = sc-&gt;current_index_range-&gt;start + current_sample;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current_sample -= range_size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> mp4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg mov demuxer 如何计算 index</title>
      <link href="/2023/08/10/ffmpeg-mov-demuxer-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97-index/"/>
      <url>/2023/08/10/ffmpeg-mov-demuxer-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97-index/</url>
      
        <content type="html"><![CDATA[<p>最近在看 ffmpeg mov demuxer 的代码，发现 mov demuxer 在 read header 的时候就把所有 sample 的 pts、dts、pos 信息都计算出来，存在一个 entry 数组里。这篇文章就分析一下这个过程。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mov_build_index</span><span class="params">(MOVContext *mov, AVStream *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MOVStreamContext *sc = st-&gt;priv_data;</span><br><span class="line">    FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">    <span class="type">int64_t</span> current_offset;</span><br><span class="line">    <span class="type">int64_t</span> current_dts = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stts_index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stsc_index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stss_index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> stps_index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">uint64_t</span> stream_size = <span class="number">0</span>;</span><br><span class="line">    MOVCtts *ctts_data_old = sc-&gt;ctts_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ctts_count_old = sc-&gt;ctts_count;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">build_open_gop_key_points</span>(st);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sc-&gt;elst_count) &#123;</span><br><span class="line">        <span class="comment">// 忽略 edit list</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* only use old uncompressed audio chunk demuxing when stts specifies it */</span></span><br><span class="line">    <span class="keyword">if</span> (!(st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">          sc-&gt;stts_count == <span class="number">1</span> &amp;&amp; sc-&gt;stts_data[<span class="number">0</span>].duration == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> current_sample = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> stts_sample = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> sample_size;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> rap_group_index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> rap_group_sample = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rap_group_present = sc-&gt;rap_group_count &amp;&amp; sc-&gt;rap_group;</span><br><span class="line">        <span class="type">int</span> key_off = (sc-&gt;keyframe_count &amp;&amp; sc-&gt;keyframes[<span class="number">0</span>] &gt; <span class="number">0</span>) || (sc-&gt;stps_count &amp;&amp; sc-&gt;stps_data[<span class="number">0</span>] &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        current_dts -= sc-&gt;dts_shift;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sc-&gt;sample_count || sti-&gt;nb_index_entries)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sc-&gt;sample_count &gt;= UINT_MAX / <span class="built_in">sizeof</span>(*sti-&gt;index_entries) - sti-&gt;nb_index_entries)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">av_reallocp_array</span>(&amp;sti-&gt;index_entries,</span><br><span class="line">                              sti-&gt;nb_index_entries + sc-&gt;sample_count,</span><br><span class="line">                              <span class="built_in">sizeof</span>(*sti-&gt;index_entries)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sti-&gt;nb_index_entries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sti-&gt;index_entries_allocated_size = (sti-&gt;nb_index_entries + sc-&gt;sample_count) * <span class="built_in">sizeof</span>(*sti-&gt;index_entries);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先把ctts展开，ctts原来是游程编码形式，把所有entry都展开</span></span><br><span class="line">        <span class="keyword">if</span> (ctts_data_old) &#123;</span><br><span class="line">            <span class="comment">// Expand ctts entries such that we have a 1-1 mapping with samples</span></span><br><span class="line">            <span class="keyword">if</span> (sc-&gt;sample_count &gt;= UINT_MAX / <span class="built_in">sizeof</span>(*sc-&gt;ctts_data))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            sc-&gt;ctts_count = <span class="number">0</span>;</span><br><span class="line">            sc-&gt;ctts_allocated_size = <span class="number">0</span>;</span><br><span class="line">            sc-&gt;ctts_data = <span class="built_in">av_fast_realloc</span>(<span class="literal">NULL</span>, &amp;sc-&gt;ctts_allocated_size,</span><br><span class="line">                                    sc-&gt;sample_count * <span class="built_in">sizeof</span>(*sc-&gt;ctts_data));</span><br><span class="line">            <span class="keyword">if</span> (!sc-&gt;ctts_data) &#123;</span><br><span class="line">                <span class="built_in">av_free</span>(ctts_data_old);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memset</span>((<span class="type">uint8_t</span>*)(sc-&gt;ctts_data), <span class="number">0</span>, sc-&gt;ctts_allocated_size);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ctts_count_old &amp;&amp;</span><br><span class="line">                        sc-&gt;ctts_count &lt; sc-&gt;sample_count; i++)</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ctts_data_old[i].count &amp;&amp;</span><br><span class="line">                            sc-&gt;ctts_count &lt; sc-&gt;sample_count; j++)</span><br><span class="line">                    <span class="built_in">add_ctts_entry</span>(&amp;sc-&gt;ctts_data, &amp;sc-&gt;ctts_count,</span><br><span class="line">                                   &amp;sc-&gt;ctts_allocated_size, <span class="number">1</span>,</span><br><span class="line">                                   ctts_data_old[i].duration);</span><br><span class="line">            <span class="built_in">av_free</span>(ctts_data_old);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每一个chunk</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sc-&gt;chunk_count; i++) &#123;</span><br><span class="line">            <span class="type">int64_t</span> next_offset = i+<span class="number">1</span> &lt; sc-&gt;chunk_count ? sc-&gt;chunk_offsets[i+<span class="number">1</span>] : INT64_MAX;</span><br><span class="line">            <span class="comment">// 先计算当前chunk的chunk offset</span></span><br><span class="line">            current_offset = sc-&gt;chunk_offsets[i];</span><br><span class="line">            <span class="comment">// 计算当前chunk属于哪一个sample to chunk</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">mov_stsc_index_valid</span>(stsc_index, sc-&gt;stsc_count) &amp;&amp;</span><br><span class="line">                i + <span class="number">1</span> == sc-&gt;stsc_data[stsc_index + <span class="number">1</span>].first)</span><br><span class="line">                stsc_index++; <span class="comment">// 计算sample to chunk</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next_offset &gt; current_offset &amp;&amp; sc-&gt;sample_size&gt;<span class="number">0</span> &amp;&amp; sc-&gt;sample_size &lt; sc-&gt;stsz_sample_size &amp;&amp;</span><br><span class="line">                sc-&gt;stsc_data[stsc_index].count * (<span class="type">int64_t</span>)sc-&gt;stsz_sample_size &gt; next_offset - current_offset) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(mov-&gt;fc, AV_LOG_WARNING, <span class="string">&quot;STSZ sample size %d invalid (too large), ignoring\n&quot;</span>, sc-&gt;stsz_sample_size);</span><br><span class="line">                sc-&gt;stsz_sample_size = sc-&gt;sample_size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sc-&gt;stsz_sample_size&gt;<span class="number">0</span> &amp;&amp; sc-&gt;stsz_sample_size &lt; sc-&gt;sample_size) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(mov-&gt;fc, AV_LOG_WARNING, <span class="string">&quot;STSZ sample size %d invalid (too small), ignoring\n&quot;</span>, sc-&gt;stsz_sample_size);</span><br><span class="line">                sc-&gt;stsz_sample_size = sc-&gt;sample_size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前chunk的每一个sample</span></span><br><span class="line">            <span class="comment">// 当前chunk有几个sample由上面sample to chunk描述</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sc-&gt;stsc_data[stsc_index].count; j++) &#123;</span><br><span class="line">                <span class="type">int</span> keyframe = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (current_sample &gt;= sc-&gt;sample_count) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(mov-&gt;fc, AV_LOG_ERROR, <span class="string">&quot;wrong sample count\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断当前sample是不是关键帧，通过当前sample的序号和stss中进行比对</span></span><br><span class="line">                <span class="keyword">if</span> (!sc-&gt;keyframe_absent &amp;&amp; (!sc-&gt;keyframe_count || current_sample+key_off == sc-&gt;keyframes[stss_index])) &#123;</span><br><span class="line">                    keyframe = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (stss_index + <span class="number">1</span> &lt; sc-&gt;keyframe_count)</span><br><span class="line">                        stss_index++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sc-&gt;stps_count &amp;&amp; current_sample+key_off == sc-&gt;stps_data[stps_index]) &#123;</span><br><span class="line">                    keyframe = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (stps_index + <span class="number">1</span> &lt; sc-&gt;stps_count)</span><br><span class="line">                        stps_index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rap_group_present &amp;&amp; rap_group_index &lt; sc-&gt;rap_group_count) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sc-&gt;rap_group[rap_group_index].index &gt; <span class="number">0</span>)</span><br><span class="line">                        keyframe = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (++rap_group_sample == sc-&gt;rap_group[rap_group_index].count) &#123;</span><br><span class="line">                        rap_group_sample = <span class="number">0</span>;</span><br><span class="line">                        rap_group_index++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sc-&gt;keyframe_absent</span><br><span class="line">                    &amp;&amp; !sc-&gt;stps_count</span><br><span class="line">                    &amp;&amp; !rap_group_present</span><br><span class="line">                    &amp;&amp; (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO || (i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>)))</span><br><span class="line">                     keyframe = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (keyframe)</span><br><span class="line">                    distance = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 通过当前sample的序号找到sample size</span></span><br><span class="line">                sample_size = sc-&gt;stsz_sample_size &gt; <span class="number">0</span> ? sc-&gt;stsz_sample_size : sc-&gt;sample_sizes[current_sample];</span><br><span class="line">                <span class="keyword">if</span> (current_offset &gt; INT64_MAX - sample_size) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(mov-&gt;fc, AV_LOG_ERROR, <span class="string">&quot;Current offset %&quot;</span>PRId64<span class="string">&quot; or sample size %u is too large\n&quot;</span>,</span><br><span class="line">                           current_offset,</span><br><span class="line">                           sample_size);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 为当前sample建立index</span></span><br><span class="line">                <span class="keyword">if</span> (sc-&gt;pseudo_stream_id == <span class="number">-1</span> ||</span><br><span class="line">                   sc-&gt;stsc_data[stsc_index].id - <span class="number">1</span> == sc-&gt;pseudo_stream_id) &#123;</span><br><span class="line">                    AVIndexEntry *e;</span><br><span class="line">                    <span class="keyword">if</span> (sample_size &gt; <span class="number">0x3FFFFFFF</span>) &#123;</span><br><span class="line">                        <span class="built_in">av_log</span>(mov-&gt;fc, AV_LOG_ERROR, <span class="string">&quot;Sample size %u is too large\n&quot;</span>, sample_size);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    e = &amp;sti-&gt;index_entries[sti-&gt;nb_index_entries++];</span><br><span class="line">                    e-&gt;pos = current_offset;</span><br><span class="line">                    e-&gt;timestamp = current_dts;</span><br><span class="line">                    e-&gt;size = sample_size;</span><br><span class="line">                    e-&gt;min_distance = distance; <span class="comment">// 离他前一个关键帧的距离</span></span><br><span class="line">                    e-&gt;flags = keyframe ? AVINDEX_KEYFRAME : <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">av_log</span>(mov-&gt;fc, AV_LOG_TRACE, <span class="string">&quot;AVIndex stream %d, sample %u, offset %&quot;</span>PRIx64<span class="string">&quot;, dts %&quot;</span>PRId64<span class="string">&quot;, &quot;</span></span><br><span class="line">                            <span class="string">&quot;size %u, distance %u, keyframe %d\n&quot;</span>, st-&gt;index, current_sample,</span><br><span class="line">                            current_offset, current_dts, sample_size, distance, keyframe);</span><br><span class="line">                    <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp; sti-&gt;nb_index_entries &lt; <span class="number">100</span>)</span><br><span class="line">                        <span class="built_in">ff_rfps_add_frame</span>(mov-&gt;fc, st, current_dts);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                current_offset += sample_size;</span><br><span class="line">                stream_size += sample_size;</span><br><span class="line"></span><br><span class="line">                current_dts += sc-&gt;stts_data[stts_index].duration;</span><br><span class="line"></span><br><span class="line">                distance++;</span><br><span class="line">                stts_sample++;</span><br><span class="line">                current_sample++;</span><br><span class="line">                <span class="keyword">if</span> (stts_index + <span class="number">1</span> &lt; sc-&gt;stts_count &amp;&amp; stts_sample == sc-&gt;stts_data[stts_index].count) &#123;</span><br><span class="line">                    stts_sample = <span class="number">0</span>;</span><br><span class="line">                    stts_index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st-&gt;duration &gt; <span class="number">0</span>)</span><br><span class="line">            st-&gt;codecpar-&gt;bit_rate = stream_size*<span class="number">8</span>*sc-&gt;time_scale/st-&gt;duration;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mov-&gt;ignore_editlist &amp;&amp; mov-&gt;advanced_editlist) &#123;</span><br><span class="line">        <span class="comment">// Fix index according to edit lists.</span></span><br><span class="line">        <span class="built_in">mov_fix_index</span>(mov, st);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update start time of the stream.</span></span><br><span class="line">    <span class="keyword">if</span> (st-&gt;start_time == AV_NOPTS_VALUE &amp;&amp; st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp; sti-&gt;nb_index_entries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        st-&gt;start_time = sti-&gt;index_entries[<span class="number">0</span>].timestamp + sc-&gt;dts_shift;</span><br><span class="line">        <span class="keyword">if</span> (sc-&gt;ctts_data) &#123;</span><br><span class="line">            st-&gt;start_time += sc-&gt;ctts_data[<span class="number">0</span>].duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mov_estimate_video_delay</span>(mov, st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体计算过程：</p><ul><li><p>先把 ctts 展开，ctts 原来是游程编码形式，把所有 entry 都展开</p></li><li><p>遍历每一个 chunk</p><ul><li><p>先计算当前 chunk 的 chunk offset</p></li><li><p>计算当前 chunk 属于哪一个 sample to chunk</p><ul><li>从而获得当前 chunk 的 sample per chunk、当前 chunk 的 stsd index</li></ul></li><li><p>遍历当前 chunk 的每一个 sample</p><ul><li><p>判断当前 sample 是不是关键帧，通过当前 sample 的序号和 stss 中进行比对</p></li><li><p>通过当前 sample 的序号找到 sample size</p></li><li><p>为当前 sample 建立 index</p><ul><li><p>设置 e-&gt;pos，表示 sample 在文件中的位置</p></li><li><p>设置 e-&gt;timestamp，表示 sample 的 dts</p><ul><li>该 dts 是通过累积 stts 来计算的</li></ul></li><li><p>设置 e-&gt;size，表示 sample 的 size</p></li><li><p>设置 e-&gt;min_distance，表示当前 sample 离前一个参考帧的距离，seek 的时候会 seek 到参考帧中</p></li></ul></li></ul></li></ul></li></ul><p>上面就是建立 index 的过程，把 index 建立之后，后续 seek 就很方便了，下篇文章再分析 mov demuxer 中的 seek 过程。</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> mp4 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg rate 参数如何影响 encode 过程</title>
      <link href="/2023/07/29/ffmpeg-rate-%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-encode-%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/07/29/ffmpeg-rate-%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-encode-%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章分析了 ffmpeg rate 参数如何影响 decode 过程，其实也可以给编码过程设置 rate 参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -hide_banner -i <span class="number">1.</span>mp4 -r <span class="number">60</span> <span class="number">2.</span>mp4</span><br></pre></td></tr></table></figure><p>假设上面 1.mp4 是 30fps，但是上面过程指定了输出文件是 60fps，ffmpeg cmd 则会对 1.mp4 进行 duplicate 来自动补帧，也就是将 30fps 的文件变成 60fps，frame 数会增大一倍。接下来就分析一下这个过程。</p><p>不用管 decoder 的 pts 的 timebase，因为 decoder 的 pts 会转换为以 encoder 的 timebase 为单位，encoder 的 timebase 是在下面设置的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">init_output_stream_encode</span><span class="params">(OutputStream *ost, AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">switch</span> (enc_ctx-&gt;codec_type) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">        <span class="built_in">init_encoder_time_base</span>(ost, <span class="built_in">av_inv_q</span>(ost-&gt;frame_rate));</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ost-&gt;frame_rate 则是如果主动给编码设置了 r 参数，就把 r 参数设置给 ost-&gt;frame_rate，否则就使用 ist 的 frame_rate。</p><p>ost-&gt;frame_rate 很重要，他可以决定 encoder 的 timebase：下面的 init_encoder_time_base 中如果没有通过命令行设置 encoder 的 enc_time_base 参数，那么就会把 av_inv_q(ost-&gt;frame_rate)作为 encoder 的 time_base，在上面的例子中最后就把 encoder 的 time_base 设置为 1:60，因为 ost-&gt;frame_rate 是 60</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init_encoder_time_base</span><span class="params">(OutputStream *ost, AVRational default_time_base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputStream *ist = <span class="built_in">get_input_stream</span>(ost);</span><br><span class="line">    AVCodecContext *enc_ctx = ost-&gt;enc_ctx;</span><br><span class="line">    AVFormatContext *oc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ost-&gt;enc_timebase.num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        enc_ctx-&gt;time_base = ost-&gt;enc_timebase;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ost-&gt;enc_timebase.num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ist) &#123;</span><br><span class="line">            enc_ctx-&gt;time_base = ist-&gt;st-&gt;time_base;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oc = output_files[ost-&gt;file_index]-&gt;ctx;</span><br><span class="line">        <span class="built_in">av_log</span>(oc, AV_LOG_WARNING, <span class="string">&quot;Input stream data not available, using default time base\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enc_ctx-&gt;time_base = default_time_base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来再看自动 duplicate 过程。每从 filter 中拿到一个 frame 之后，先把 pts 转换为以 encoder 的 timebase 为单位，然后计算当前 frame 的 duration，计算 duration 时需要以 1&#x2F;ist-&gt;frame_rate 以及 1&#x2F;ost-&gt;frame_rate 中较小的为单位，后面会看到会根据 duration 来进行 duplicate 或者 drop</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">do_video_out</span><span class="params">(OutputFile *of,</span></span></span><br><span class="line"><span class="params"><span class="function">                         OutputStream *ost,</span></span></span><br><span class="line"><span class="params"><span class="function">                         AVFrame *next_picture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    sync_ipts = <span class="built_in">adjust_frame_pts_to_encoder_tb</span>(of, ost, next_picture);</span><br><span class="line">...</span><br><span class="line">    frame_rate = <span class="built_in">av_buffersink_get_frame_rate</span>(filter);</span><br><span class="line">    <span class="keyword">if</span> (frame_rate.num &gt; <span class="number">0</span> &amp;&amp; frame_rate.den &gt; <span class="number">0</span>)</span><br><span class="line">        duration = <span class="number">1</span>/(<span class="built_in">av_q2d</span>(frame_rate) * <span class="built_in">av_q2d</span>(enc-&gt;time_base));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ist &amp;&amp; ist-&gt;st-&gt;start_time != AV_NOPTS_VALUE &amp;&amp; ist-&gt;first_dts != AV_NOPTS_VALUE &amp;&amp; ost-&gt;frame_rate.num)</span><br><span class="line">        duration = <span class="built_in">FFMIN</span>(duration, <span class="number">1</span>/(<span class="built_in">av_q2d</span>(ost-&gt;frame_rate) * <span class="built_in">av_q2d</span>(enc-&gt;time_base)));</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!next_picture) &#123;</span><br><span class="line">        <span class="comment">//end, flushing</span></span><br><span class="line">        nb0_frames = nb_frames = <span class="built_in">mid_pred</span>(ost-&gt;last_nb0_frames[<span class="number">0</span>],</span><br><span class="line">                                          ost-&gt;last_nb0_frames[<span class="number">1</span>],</span><br><span class="line">                                          ost-&gt;last_nb0_frames[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delta0 = sync_ipts - ost-&gt;sync_opts; <span class="comment">// delta0 is the &quot;drift&quot; between the input frame (next_picture) and where it would fall in the output.</span></span><br><span class="line">        delta  = delta0 + duration;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* by default, we output a single frame */</span></span><br><span class="line">        nb0_frames = <span class="number">0</span>; <span class="comment">// tracks the number of times the PREVIOUS frame should be duplicated, mostly for variable framerate (VFR)</span></span><br><span class="line">        nb_frames = <span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (ost-&gt;vsync_method) &#123;</span><br><span class="line">        <span class="keyword">case</span> VSYNC_VSCFR:</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> VSYNC_CFR:</span><br><span class="line">            <span class="comment">// FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c</span></span><br><span class="line">            <span class="keyword">if</span> (frame_drop_threshold &amp;&amp; delta &lt; frame_drop_threshold &amp;&amp; ost-&gt;frame_number) &#123;</span><br><span class="line">                nb_frames = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delta &lt; <span class="number">-1.1</span>)</span><br><span class="line">                nb_frames = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">1.1</span>) &#123;</span><br><span class="line">                nb_frames = <span class="built_in">llrintf</span>(delta);</span><br><span class="line">                <span class="keyword">if</span> (delta0 &gt; <span class="number">1.1</span>)</span><br><span class="line">                    nb0_frames = <span class="built_in">llrintf</span>(delta0 - <span class="number">0.6</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* duplicates frame if needed */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nb_frames; i++) &#123;</span><br><span class="line">        AVFrame *in_picture;</span><br><span class="line">        <span class="type">int</span> forced_keyframe = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> pts_time;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; nb0_frames &amp;&amp; ost-&gt;last_frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">            in_picture = ost-&gt;last_frame;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            in_picture = next_picture;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_picture)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        in_picture-&gt;pts = ost-&gt;sync_opts;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check_recording_time</span>(ost))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        in_picture-&gt;quality = enc-&gt;global_quality;</span><br><span class="line">        in_picture-&gt;pict_type = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ost-&gt;forced_kf_ref_pts == AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">            in_picture-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">            ost-&gt;forced_kf_ref_pts = in_picture-&gt;pts;</span><br><span class="line"></span><br><span class="line">        pts_time = in_picture-&gt;pts != AV_NOPTS_VALUE ?</span><br><span class="line">            (in_picture-&gt;pts - ost-&gt;forced_kf_ref_pts) * <span class="built_in">av_q2d</span>(enc-&gt;time_base) : NAN;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">encode_frame</span>(of, ost, in_picture);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ost-&gt;sync_opts++;</span><br><span class="line">        ost-&gt;frame_number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算完 duration 之后计算当前输入 frame 的 sync_ipts 与下一个期望输出的时间 ost-&gt;sync_opts 的差距 delta0，然后将 delta0 加上上面计算出来的 duration 得到 delta，delta0 用来计算前一张 frame 需要 duplicate 的次数 nb0_frames，delta 用来计算总的 duplicate 的次数（总次数&#x3D;前一张 duplicate 次数 + 当前张的 duplicate 次数）nb_frames。</p><p>在算 nb0_frames 以及 nb_frames 时，就是把 delta0、delta 进行一个取整，所以 encoder 的 time base 非常重要，一般都需要设置为 frame rate，不然的话在算 duplicate&#x2F;drop 的时候就会出问题</p><p>算完 nb0_frames 以及 nb_frames 之后会进行 duplicate（如果需要的话），nb0_frames 代表前一张 duplicate 的次数，nb_frames-nb0_frames 代表当前张的 duplicate 的次数。</p><p>这样说可能不太好理解，举一个例子：</p><p>把一个 30fps 的视频转成 60fps，那么 encoder 的 timebase 就是 1:60，输入视频的 sync_ipts（以 encoder 的 timebase 为单位）就是 0、2、4、6、8、10…，duration（以 encoder 的 timebase 为单位）就是 1（取 1&#x2F;30 和 1&#x2F;60 中较小的）</p><p>输入第 1 张的时候，delta0 是 0，delta 是 1，那么就只需要输出当前图像 1 次，此时 ost-&gt;sync_opts 自增之后成为 1</p><p>输入第二张的时候 delta0 是 1，delta 是 2，此时需要对前一张图像 duplicate 一次，然后再输出当前图像一次，ost-&gt;sync_opts 自增两次变成 3</p><p>输入第 3 张的时候 delta0 是 1，delta 是 2，也需要对前一张图像 duplicate 一次，然后再输出当前图像一次</p><p>所以每输入一张图像，就需要对前一张 duplicate 一次来满足输出 60fps 图像的要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delta0 = sync_ipts - ost-&gt;sync_opts; <span class="comment">// ost-&gt;sync_opts初值是0</span></span><br><span class="line">delta  = delta0 + duration;</span><br></pre></td></tr></table></figure><p>drop 的过程和 duplicate 类似，这里就不再分析。</p><p>从上面的分析中可以看到，encoder 的 timebase 非常重要，每次 duplicate 时会以 encoder 的 timebase 为单位，encoder 的 timebase 应当尽可能以 framerate 为单位，如果设置为不恰当的值会导致输出图像异常 duplicate&#x2F;drop，比如下面，会导致出现非常多的 duplicate</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -hide_banner -i <span class="number">1.</span>mp4 -enc_time_base <span class="number">1</span>:<span class="number">1000</span> <span class="number">2.</span>mp4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg rate 参数如何影响 decode 过程</title>
      <link href="/2023/07/21/ffmpeg-rate-%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-decode-%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/07/21/ffmpeg-rate-%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-decode-%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>最近在读 ffmpeg cmd 源码时，发现了之前忽略的一个问题：如下的 cmd 程序中，假设输入的 1.mp4 是 30fps，那么编码时得到的 mp4 的 fps 是 30 还是 60？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -hide_banner -r <span class="number">60</span> -i <span class="number">1.</span>mp4 <span class="number">2.</span>mp4</span><br></pre></td></tr></table></figure><p>答案是 60fps。在 ffmpeg cmd 中，如果主动设置输入文件的 fps，就会覆盖原始文件的 fps。</p><p>直接看代码：在下面的 decode 过程中，如果设置了 ist-&gt;framerate，就会覆盖 decoded_frame-&gt;pts 为 ist-&gt;cfr_next_pts++，也就是说原有的 pts 会忽略掉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">decode_video</span><span class="params">(InputStream *ist, AVPacket *pkt, <span class="type">int</span> *got_output, <span class="type">int64_t</span> *duration_pts, <span class="type">int</span> eof, <span class="type">int</span> *decode_failed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFrame *decoded_frame = ist-&gt;decoded_frame;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">0</span>, err = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int64_t</span> best_effort_timestamp;</span><br><span class="line">    <span class="type">int64_t</span> dts = AV_NOPTS_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// With fate-indeo3-2, we&#x27;re getting 0-sized packets before EOF for some</span></span><br><span class="line">    <span class="comment">// reason. This seems like a semi-critical bug. Don&#x27;t trigger EOF, and</span></span><br><span class="line">    <span class="comment">// skip the packet.</span></span><br><span class="line">    <span class="keyword">if</span> (!eof &amp;&amp; pkt &amp;&amp; pkt-&gt;size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ist-&gt;dts != AV_NOPTS_VALUE)</span><br><span class="line">        dts = <span class="built_in">av_rescale_q</span>(ist-&gt;dts, AV_TIME_BASE_Q, ist-&gt;st-&gt;time_base);</span><br><span class="line">    <span class="keyword">if</span> (pkt) &#123;</span><br><span class="line">        pkt-&gt;dts = dts; <span class="comment">// ffmpeg.c probably shouldn&#x27;t do this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The old code used to set dts on the drain packet, which does not work</span></span><br><span class="line">    <span class="comment">// with the new API anymore.</span></span><br><span class="line">    <span class="keyword">if</span> (eof) &#123;</span><br><span class="line">        <span class="type">void</span> *<span class="keyword">new</span> = <span class="built_in">av_realloc_array</span>(ist-&gt;dts_buffer, ist-&gt;nb_dts_buffer + <span class="number">1</span>, <span class="built_in">sizeof</span>(ist-&gt;dts_buffer[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        ist-&gt;dts_buffer = <span class="keyword">new</span>;</span><br><span class="line">        ist-&gt;dts_buffer[ist-&gt;nb_dts_buffer++] = dts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">update_benchmark</span>(<span class="literal">NULL</span>);</span><br><span class="line">    ret = <span class="built_in">decode</span>(ist-&gt;dec_ctx, decoded_frame, got_output, pkt);</span><br><span class="line">    <span class="built_in">update_benchmark</span>(<span class="string">&quot;decode_video %d.%d&quot;</span>, ist-&gt;file_index, ist-&gt;st-&gt;index);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        *decode_failed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    best_effort_timestamp= decoded_frame-&gt;best_effort_timestamp;</span><br><span class="line">    *duration_pts = decoded_frame-&gt;pkt_duration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ist-&gt;framerate.num)</span><br><span class="line">        best_effort_timestamp = ist-&gt;cfr_next_pts++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eof &amp;&amp; best_effort_timestamp == AV_NOPTS_VALUE &amp;&amp; ist-&gt;nb_dts_buffer &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        best_effort_timestamp = ist-&gt;dts_buffer[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ist-&gt;nb_dts_buffer - <span class="number">1</span>; i++)</span><br><span class="line">            ist-&gt;dts_buffer[i] = ist-&gt;dts_buffer[i + <span class="number">1</span>];</span><br><span class="line">        ist-&gt;nb_dts_buffer--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(best_effort_timestamp != AV_NOPTS_VALUE) &#123;</span><br><span class="line">        <span class="type">int64_t</span> ts = <span class="built_in">av_rescale_q</span>(decoded_frame-&gt;pts = best_effort_timestamp, ist-&gt;st-&gt;time_base, AV_TIME_BASE_Q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ts != AV_NOPTS_VALUE)</span><br><span class="line">            ist-&gt;next_pts = ist-&gt;pts = ts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ist-&gt;st-&gt;sample_aspect_ratio.num)</span><br><span class="line">        decoded_frame-&gt;sample_aspect_ratio = ist-&gt;st-&gt;sample_aspect_ratio;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">send_frame_to_filters</span>(ist, decoded_frame);</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">av_frame_unref</span>(decoded_frame);</span><br><span class="line">    <span class="keyword">return</span> err &lt; <span class="number">0</span> ? err : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面的 configure_input_video_filter 中，如果设置了 ist-&gt;framerate，buffersrc filter 的 timebase 就会被设置为 av_inv_q(ist-&gt;framerate)，这刚好和上面的逻辑对应起来了，所以 decode 得到的 frame 的 pts 会被输入的 rate 参数覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">configure_input_video_filter</span><span class="params">(FilterGraph *fg, InputFilter *ifilter,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        AVFilterInOut *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext *last_filter;</span><br><span class="line">    <span class="type">const</span> AVFilter *buffer_filt = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    <span class="type">const</span> AVPixFmtDescriptor *desc;</span><br><span class="line">    InputStream *ist = ifilter-&gt;ist;</span><br><span class="line">    InputFile     *f = input_files[ist-&gt;file_index];</span><br><span class="line">    AVRational tb = ist-&gt;framerate.num ? <span class="built_in">av_inv_q</span>(ist-&gt;framerate) :</span><br><span class="line">                                         ist-&gt;st-&gt;time_base;</span><br><span class="line">    AVRational fr = ist-&gt;framerate;</span><br><span class="line">    AVRational sar;</span><br><span class="line">    AVBPrint args;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">255</span>];</span><br><span class="line">    <span class="type">int</span> ret, pad_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int64_t</span> tsoffset = <span class="number">0</span>;</span><br><span class="line">    AVBufferSrcParameters *par = <span class="built_in">av_buffersrc_parameters_alloc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!par)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">    <span class="built_in">memset</span>(par, <span class="number">0</span>, <span class="built_in">sizeof</span>(*par));</span><br><span class="line">    par-&gt;format = AV_PIX_FMT_NONE;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fr.num)</span><br><span class="line">        fr = <span class="built_in">av_guess_frame_rate</span>(input_files[ist-&gt;file_index]-&gt;ctx, ist-&gt;st, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    sar = ifilter-&gt;sample_aspect_ratio;</span><br><span class="line">    <span class="keyword">if</span>(!sar.den)</span><br><span class="line">        sar = (AVRational)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">av_bprint_init</span>(&amp;args, <span class="number">0</span>, AV_BPRINT_SIZE_AUTOMATIC);</span><br><span class="line">    <span class="built_in">av_bprintf</span>(&amp;args,</span><br><span class="line">             <span class="string">&quot;video_size=%dx%d:pix_fmt=%d:time_base=%d/%d:&quot;</span></span><br><span class="line">             <span class="string">&quot;pixel_aspect=%d/%d&quot;</span>,</span><br><span class="line">             ifilter-&gt;width, ifilter-&gt;height, ifilter-&gt;format,</span><br><span class="line">             tb.num, tb.den, sar.num, sar.den);</span><br><span class="line">    <span class="keyword">if</span> (fr.num &amp;&amp; fr.den)</span><br><span class="line">        <span class="built_in">av_bprintf</span>(&amp;args, <span class="string">&quot;:frame_rate=%d/%d&quot;</span>, fr.num, fr.den);</span><br><span class="line">    <span class="built_in">snprintf</span>(name, <span class="built_in">sizeof</span>(name), <span class="string">&quot;graph %d input from stream %d:%d&quot;</span>, fg-&gt;index,</span><br><span class="line">             ist-&gt;file_index, ist-&gt;st-&gt;index);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg cmd 之 pix_fmt 选项</title>
      <link href="/2023/07/15/ffmpeg-cmd-%E4%B9%8B-pix-fmt-%E9%80%89%E9%A1%B9/"/>
      <url>/2023/07/15/ffmpeg-cmd-%E4%B9%8B-pix-fmt-%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>最近在使用 ffmpeg 命令行程序的时候，遇到一个问题：现在希望生成一个测试用的 mp4 文件，希望 x264 编码器输入的图片格式为 yuv420p。下面的 3 条命令中，只有最后一条是有效的，第一条和第二条给 x264 编码器的图片格式都是 yuv444p。接下来就分析一下原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -hide_banner -f lavfi -i testsrc=size=<span class="number">250</span>x120:rate=<span class="number">30</span> -f lavfi -i anullsrc=r=<span class="number">48000</span>:cl=mono -f mp4 -t <span class="number">20</span> z.mp4</span><br><span class="line"></span><br><span class="line">ffmpeg -hide_banner -f lavfi -i testsrc=size=<span class="number">250</span>x120:rate=<span class="number">30</span> -f lavfi -i anullsrc=r=<span class="number">48000</span>:cl=mono -f mp4 -pixel_format yuv420p -t <span class="number">20</span> z.mp4</span><br><span class="line"></span><br><span class="line">ffmpeg -hide_banner -f lavfi -i testsrc=size=<span class="number">250</span>x120:rate=<span class="number">30</span> -f lavfi -i anullsrc=r=<span class="number">48000</span>:cl=mono -f mp4 -pix_fmt yuv420p -t <span class="number">20</span> z.mp4</span><br></pre></td></tr></table></figure><p>从参数解析过程来看，-pixel_format 会被解析为 AVOption，而-pix_fmt 会被解析为 ffmpeg 自己定义的 Option。</p><p>-pixel_format 最后是作为 format option 传给 format ctx，对于没有 pixel_format 选项的格式来说，该选项不起作用，而-pix_fmt 则会设置到 OutputStream、OutputFilter 以及 enc_ctx 中的 pix_fmt 字段。</p><p>到这里可以发现，第一条和第二条命令相当于没有设置 OutputStream、OutputFilter 以及 enc_ctx 中的 pix_fmt 字段，而第三条则显式的设置了 pix_fmt 字段。在 ffmpeg 命令行程序中，对于一组对应的 OutputStream 和 InputStream，如果双方接受的格式不同，那么中间会插入一个 scale&#x2F;resample filter 来自动进行格式转换。</p><p>testsrc 输出的是 rgb24 格式，而 OutputStream、OutputFilter 以及 enc_ctx 中的 pix_fmt 则是在下面设置的，如果命令行参数指定了-pix_fmt，则会设置到 video_enc-&gt;pix_fmt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> OutputStream *<span class="title">new_video_stream</span><span class="params">(OptionsContext *o, AVFormatContext *oc,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> source_index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!ost-&gt;stream_copy) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">MATCH_PER_STREAM_OPT</span>(frame_pix_fmts, str, frame_pix_fmt, oc, st);</span><br><span class="line">        <span class="keyword">if</span> (frame_pix_fmt &amp;&amp; *frame_pix_fmt == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            ost-&gt;keep_pix_fmt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!*++frame_pix_fmt)</span><br><span class="line">                frame_pix_fmt = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (frame_pix_fmt &amp;&amp; (video_enc-&gt;pix_fmt = <span class="built_in">av_get_pix_fmt</span>(frame_pix_fmt)) == AV_PIX_FMT_NONE) &#123;</span><br><span class="line">            <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Unknown pixel format requested: %s.\n&quot;</span>, frame_pix_fmt);</span><br><span class="line">            <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 open_output_file 中，会根据 enc_ctx-&gt;pix_fmt 来设置 OutputFilter 上的 format&#x2F;formats</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">open_output_file</span><span class="params">(OptionsContext *o, <span class="type">const</span> <span class="type">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* set the decoding_needed flags and create simple filtergraphs */</span></span><br><span class="line">    <span class="keyword">for</span> (i = of-&gt;ost_index; i &lt; nb_output_streams; i++) &#123;</span><br><span class="line">        OutputStream *ost = output_streams[i];</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set the filter output constraints */</span></span><br><span class="line">        <span class="keyword">if</span> (ost-&gt;filter) &#123;</span><br><span class="line">            OutputFilter *f = ost-&gt;filter;</span><br><span class="line">            <span class="keyword">switch</span> (ost-&gt;enc_ctx-&gt;codec_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">                f-&gt;frame_rate = ost-&gt;frame_rate;</span><br><span class="line">                f-&gt;width      = ost-&gt;enc_ctx-&gt;width;</span><br><span class="line">                f-&gt;height     = ost-&gt;enc_ctx-&gt;height;</span><br><span class="line">                <span class="keyword">if</span> (ost-&gt;enc_ctx-&gt;pix_fmt != AV_PIX_FMT_NONE) &#123;</span><br><span class="line">                    f-&gt;format = ost-&gt;enc_ctx-&gt;pix_fmt;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f-&gt;formats = ost-&gt;enc-&gt;pix_fmts;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">                <span class="keyword">if</span> (ost-&gt;enc_ctx-&gt;sample_fmt != AV_SAMPLE_FMT_NONE) &#123;</span><br><span class="line">                    f-&gt;format = ost-&gt;enc_ctx-&gt;sample_fmt;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f-&gt;formats = ost-&gt;enc-&gt;sample_fmts;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ost-&gt;enc_ctx-&gt;sample_rate) &#123;</span><br><span class="line">                    f-&gt;sample_rate = ost-&gt;enc_ctx-&gt;sample_rate;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f-&gt;sample_rates = ost-&gt;enc-&gt;supported_samplerates;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ost-&gt;enc_ctx-&gt;ch_layout.nb_channels) &#123;</span><br><span class="line">                    <span class="built_in">set_channel_layout</span>(f, ost);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ost-&gt;enc-&gt;ch_layouts) &#123;</span><br><span class="line">                    f-&gt;ch_layouts = ost-&gt;enc-&gt;ch_layouts;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入 filter 和输出 filter 接受的格式不同，比如输入 filter 为 rgb24，输出 filter 可以接受 yuv420p、nv12 等格式，那么存在一个为输出 filter 选择输出格式的过程。从下面代码可以看到，如果 ost-&gt;enc_ctx-&gt;pix_fmt 不为空，就使用该格式，否则，从 ost-&gt;enc-&gt;pix_fmts 中选择若干合适的格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* May return NULL (no pixel format found), a static string or a string</span></span><br><span class="line"><span class="comment"> * backed by the bprint. Nothing has been written to the AVBPrint in case</span></span><br><span class="line"><span class="comment"> * NULL is returned. The AVBPrint provided should be clean. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">choose_pix_fmts</span><span class="params">(OutputFilter *ofilter, AVBPrint *bprint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OutputStream *ost = ofilter-&gt;ost;</span><br><span class="line">    <span class="type">const</span> AVDictionaryEntry *strict_dict = <span class="built_in">av_dict_get</span>(ost-&gt;encoder_opts, <span class="string">&quot;strict&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (strict_dict)</span><br><span class="line">        <span class="comment">// used by choose_pixel_fmt() and below</span></span><br><span class="line">        <span class="built_in">av_opt_set</span>(ost-&gt;enc_ctx, <span class="string">&quot;strict&quot;</span>, strict_dict-&gt;value, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (ost-&gt;keep_pix_fmt) &#123;</span><br><span class="line">        <span class="built_in">avfilter_graph_set_auto_convert</span>(ofilter-&gt;graph-&gt;graph,</span><br><span class="line">                                            AVFILTER_AUTO_CONVERT_NONE);</span><br><span class="line">        <span class="keyword">if</span> (ost-&gt;enc_ctx-&gt;pix_fmt == AV_PIX_FMT_NONE)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">av_get_pix_fmt_name</span>(ost-&gt;enc_ctx-&gt;pix_fmt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ost-&gt;enc_ctx-&gt;pix_fmt != AV_PIX_FMT_NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">av_get_pix_fmt_name</span>(<span class="built_in">choose_pixel_fmt</span>(ost-&gt;st, ost-&gt;enc_ctx, ost-&gt;enc, ost-&gt;enc_ctx-&gt;pix_fmt));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ost-&gt;enc &amp;&amp; ost-&gt;enc-&gt;pix_fmts) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">enum</span> AVPixelFormat *p;</span><br><span class="line"></span><br><span class="line">        p = ost-&gt;enc-&gt;pix_fmts;</span><br><span class="line">        <span class="keyword">if</span> (ost-&gt;enc_ctx-&gt;strict_std_compliance &gt; FF_COMPLIANCE_UNOFFICIAL) &#123;</span><br><span class="line">            p = <span class="built_in">get_compliance_normal_pix_fmts</span>(ost-&gt;enc, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; *p != AV_PIX_FMT_NONE; p++) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *name = <span class="built_in">av_get_pix_fmt_name</span>(*p);</span><br><span class="line">            <span class="built_in">av_bprintf</span>(bprint, <span class="string">&quot;%s%c&quot;</span>, name, p[<span class="number">1</span>] == AV_PIX_FMT_NONE ? <span class="string">&#x27;\0&#x27;</span> : <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">av_bprint_is_complete</span>(bprint))</span><br><span class="line">            <span class="built_in">exit_program</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> bprint-&gt;str;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 choose_pix_fmts 返回之后，使用输出的格式来创建一个 format filter，该 filter 可选的输出格式为（如果没有指定-pix_fmt，对于 libx264 就是）<code>yuv420p|yuvj420p|yuv422p|yuvj422p|yuv444p|yuvj444p|nv12|nv16|nv21|yuv420p10le|yuv422p10le|yuv444p10le|nv20le</code>，在后续 filter 的格式协商中会根据上游格式和这里的格式来选择一个合适的输出格式，同时，如果两者不同，还会插入一个 scale filter 来做格式转换。在这个例子中，上游输入 <code>rbg24</code>，format 选择的格式是 <code>yuv444p</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">configure_output_video_filter</span><span class="params">(FilterGraph *fg, OutputFilter *ofilter, AVFilterInOut *out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OutputStream *ost = ofilter-&gt;ost;</span><br><span class="line">    OutputFile    *of = output_files[ost-&gt;file_index];</span><br><span class="line">    AVFilterContext *last_filter = out-&gt;filter_ctx;</span><br><span class="line">    AVBPrint bprint;</span><br><span class="line">    <span class="type">int</span> pad_idx = out-&gt;pad_idx;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pix_fmts;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(name, <span class="built_in">sizeof</span>(name), <span class="string">&quot;out_%d_%d&quot;</span>, ost-&gt;file_index, ost-&gt;index);</span><br><span class="line">    ret = <span class="built_in">avfilter_graph_create_filter</span>(&amp;ofilter-&gt;filter,</span><br><span class="line">                                       <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;buffersink&quot;</span>),</span><br><span class="line">                                       name, <span class="literal">NULL</span>, <span class="literal">NULL</span>, fg-&gt;graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ofilter-&gt;width || ofilter-&gt;height) &amp;&amp; ofilter-&gt;ost-&gt;autoscale) &#123;</span><br><span class="line">        <span class="type">char</span> args[<span class="number">255</span>];</span><br><span class="line">        AVFilterContext *filter;</span><br><span class="line">        <span class="type">const</span> AVDictionaryEntry *e = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(args, <span class="built_in">sizeof</span>(args), <span class="string">&quot;%d:%d&quot;</span>,</span><br><span class="line">                 ofilter-&gt;width, ofilter-&gt;height);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((e = <span class="built_in">av_dict_get</span>(ost-&gt;sws_dict, <span class="string">&quot;&quot;</span>, e,</span><br><span class="line">                                AV_DICT_IGNORE_SUFFIX))) &#123;</span><br><span class="line">            <span class="built_in">av_strlcatf</span>(args, <span class="built_in">sizeof</span>(args), <span class="string">&quot;:%s=%s&quot;</span>, e-&gt;key, e-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(name, <span class="built_in">sizeof</span>(name), <span class="string">&quot;scaler_out_%d_%d&quot;</span>,</span><br><span class="line">                 ost-&gt;file_index, ost-&gt;index);</span><br><span class="line">        <span class="keyword">if</span> ((ret = <span class="built_in">avfilter_graph_create_filter</span>(&amp;filter, <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;scale&quot;</span>),</span><br><span class="line">                                                name, args, <span class="literal">NULL</span>, fg-&gt;graph)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">if</span> ((ret = <span class="built_in">avfilter_link</span>(last_filter, pad_idx, filter, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        last_filter = filter;</span><br><span class="line">        pad_idx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_bprint_init</span>(&amp;bprint, <span class="number">0</span>, AV_BPRINT_SIZE_UNLIMITED);</span><br><span class="line">    <span class="keyword">if</span> ((pix_fmts = <span class="built_in">choose_pix_fmts</span>(ofilter, &amp;bprint))) &#123;</span><br><span class="line">        AVFilterContext *filter;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">avfilter_graph_create_filter</span>(&amp;filter,</span><br><span class="line">                                           <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;format&quot;</span>),</span><br><span class="line">                                           <span class="string">&quot;format&quot;</span>, pix_fmts, <span class="literal">NULL</span>, fg-&gt;graph);</span><br><span class="line">        <span class="built_in">av_bprint_finalize</span>(&amp;bprint, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">if</span> ((ret = <span class="built_in">avfilter_link</span>(last_filter, pad_idx, filter, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        last_filter = filter;</span><br><span class="line">        pad_idx     = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ost-&gt;frame_rate.num &amp;&amp; <span class="number">0</span>) &#123;</span><br><span class="line">        AVFilterContext *fps;</span><br><span class="line">        <span class="type">char</span> args[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(args, <span class="built_in">sizeof</span>(args), <span class="string">&quot;fps=%d/%d&quot;</span>, ost-&gt;frame_rate.num,</span><br><span class="line">                 ost-&gt;frame_rate.den);</span><br><span class="line">        <span class="built_in">snprintf</span>(name, <span class="built_in">sizeof</span>(name), <span class="string">&quot;fps_out_%d_%d&quot;</span>,</span><br><span class="line">                 ost-&gt;file_index, ost-&gt;index);</span><br><span class="line">        ret = <span class="built_in">avfilter_graph_create_filter</span>(&amp;fps, <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;fps&quot;</span>),</span><br><span class="line">                                           name, args, <span class="literal">NULL</span>, fg-&gt;graph);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">avfilter_link</span>(last_filter, pad_idx, fps, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        last_filter = fps;</span><br><span class="line">        pad_idx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(name, <span class="built_in">sizeof</span>(name), <span class="string">&quot;trim_out_%d_%d&quot;</span>,</span><br><span class="line">             ost-&gt;file_index, ost-&gt;index);</span><br><span class="line">    ret = <span class="built_in">insert_trim</span>(of-&gt;start_time, of-&gt;recording_time,</span><br><span class="line">                      &amp;last_filter, &amp;pad_idx, name);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">avfilter_link</span>(last_filter, pad_idx, ofilter-&gt;filter, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在研究这个问题的时候，发现 input 也有-pixel_format 和-pix_fmt 选项，这两个选项最后都会作用到 format opt 中，以“pixel_format”的形式，但是需要注意，如果对于没有 pixel_format 选项的 input format 使用该选项，会报错，因为 ffmpeg 会对 input 的 format opt 进行检查，如果发现有没使用的 opt，就会报错，但是 output 没有进行这个检查。</p><p>上面的分析主要是针对 video，但是 audio 也存在格式转换过程，可以通过-sample_fmt 选项指定 enc_ctx 输入的 raw 格式。</p><p>最后还有一个疑问，为什么-pixel_format 会被解释为 format opt？avcodec_options 中明明有 pixel_format 选项。从下面的 opt_find 中可以找到答案：查找到 AVOption 后还要求 AVOption 上的 flags 不为 0，而 avcodec_options 中的 pixel_format 选项的 flags 为 0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> AVOption *<span class="title">opt_find</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">int</span> opt_flags, <span class="type">int</span> search_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVOption *o = <span class="built_in">av_opt_find</span>(obj, name, unit, opt_flags, search_flags);</span><br><span class="line">    <span class="keyword">if</span>(o &amp;&amp; !o-&gt;flags)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> AVOption avcodec_options[] = &#123;</span><br><span class="line">...</span><br><span class="line">&#123;<span class="string">&quot;pixel_format&quot;</span>, <span class="string">&quot;set pixel format&quot;</span>, <span class="built_in">OFFSET</span>(pix_fmt), AV_OPT_TYPE_PIXEL_FMT, &#123;.i64=AV_PIX_FMT_NONE&#125;, <span class="number">-1</span>, INT_MAX, <span class="number">0</span> &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium 多媒体（七）</title>
      <link href="/2023/07/07/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2023/07/07/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>前面几篇文章介绍了 MSE 和 EME 的流程，接下来介绍 WebMediaPlayer 的内容，重点关注：数据如何被解码&#x2F;解密。</p><p>在本系列的第一篇文章里，介绍了 WebMediaPlayerImpl::StartPipeline 的一部分过程，接下来就接着第一篇里的流程继续。</p><p>ChunkDemuxer 初始化结束后会接着初始化 Pipeline，也就是执行 RendererWrapper::ReportMetadata</p><h1 id="RendererWrapper-ReportMetadata"><a href="#RendererWrapper-ReportMetadata" class="headerlink" title="RendererWrapper::ReportMetadata"></a>RendererWrapper::ReportMetadata</h1><p>如果不是 Suspend Start，会继续后面的初始化，否则会执行 <code>pending_callbacks_.reset();</code> 来结束初始化任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> PipelineImpl::RendererWrapper::<span class="built_in">ReportMetadata</span>(StartType start_type) &#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(media_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">  PipelineMetadata metadata;</span><br><span class="line">  std::vector&lt;DemuxerStream*&gt; streams;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (demuxer_-&gt;<span class="built_in">GetType</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> MediaResource::Type::STREAM:</span><br><span class="line">      metadata.timeline_offset = demuxer_-&gt;<span class="built_in">GetTimelineOffset</span>();</span><br><span class="line">      <span class="comment">// TODO(servolk): What should we do about metadata for multiple streams?</span></span><br><span class="line">      streams = demuxer_-&gt;<span class="built_in">GetAllStreams</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>* stream : streams) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stream-&gt;<span class="built_in">type</span>() == DemuxerStream::VIDEO &amp;&amp; !metadata.has_video) &#123;</span><br><span class="line">          metadata.has_video = <span class="literal">true</span>;</span><br><span class="line">          metadata.natural_size = <span class="built_in">GetRotatedVideoSize</span>(</span><br><span class="line">              stream-&gt;<span class="built_in">video_decoder_config</span>().<span class="built_in">video_transformation</span>().rotation,</span><br><span class="line">              stream-&gt;<span class="built_in">video_decoder_config</span>().<span class="built_in">natural_size</span>());</span><br><span class="line">          metadata.video_decoder_config = stream-&gt;<span class="built_in">video_decoder_config</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stream-&gt;<span class="built_in">type</span>() == DemuxerStream::AUDIO &amp;&amp; !metadata.has_audio) &#123;</span><br><span class="line">          metadata.has_audio = <span class="literal">true</span>;</span><br><span class="line">          metadata.audio_decoder_config = stream-&gt;<span class="built_in">audio_decoder_config</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> MediaResource::Type::URL:</span><br><span class="line">      <span class="comment">// We don&#x27;t know if the MediaPlayerRender has Audio/Video until we start</span></span><br><span class="line">      <span class="comment">// playing. Conservatively assume that they do.</span></span><br><span class="line">      metadata.has_video = <span class="literal">true</span>;</span><br><span class="line">      metadata.has_audio = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  main_task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">      FROM_HERE,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;PipelineImpl::OnMetadata, weak_pipeline_, metadata));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If suspended start has not been requested, or is not allowed given the</span></span><br><span class="line">  <span class="comment">// metadata, continue the normal renderer initialization path.</span></span><br><span class="line">  <span class="keyword">if</span> (start_type == StartType::kNormal ||</span><br><span class="line">      (start_type == StartType::kSuspendAfterMetadataForAudioOnly &amp;&amp;</span><br><span class="line">       metadata.has_video)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Abort pending render initialization tasks and suspend the pipeline.</span></span><br><span class="line">  pending_callbacks_.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="built_in">DestroyRenderer</span>();</span><br><span class="line">  shared_state_.suspend_timestamp =</span><br><span class="line">      std::<span class="built_in">max</span>(base::<span class="built_in">TimeDelta</span>(), demuxer_-&gt;<span class="built_in">GetStartTime</span>());</span><br><span class="line">  <span class="built_in">SetState</span>(kSuspended);</span><br><span class="line">  main_task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">      FROM_HERE,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;PipelineImpl::OnSeekDone, weak_pipeline_, <span class="literal">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RendererWrapper-CreateRenderer"><a href="#RendererWrapper-CreateRenderer" class="headerlink" title="RendererWrapper::CreateRenderer"></a>RendererWrapper::CreateRenderer</h1><p>如果不是 Suspend Start，执行 RendererWrapper::CreateRenderer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> PipelineImpl::RendererWrapper::<span class="built_in">CreateRenderer</span>(</span><br><span class="line">    PipelineStatusCallback done_cb) &#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__;</span><br><span class="line">  <span class="built_in">DCHECK</span>(media_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(state_ == kStarting || state_ == kResuming);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">HasEncryptedStream</span>() &amp;&amp; !cdm_context_) &#123;</span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Has encrypted stream but CDM is not set.&quot;</span>;</span><br><span class="line">    create_renderer_done_cb_ = std::<span class="built_in">move</span>(done_cb);</span><br><span class="line">    <span class="built_in">OnWaiting</span>(WaitingReason::kNoCdm);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CreateRendererInternal</span>(std::<span class="built_in">move</span>(done_cb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RendererWrapper::CreateRenderer 中对于加密流会检查是否有 cdm，该 cdm 在创建 webmediaplayer 的时候会尝试通过下面的函数获取，如果没有设置 <code>media_keys_</code>，那么返回空，从而上面的初始化流程要暂时停止，需要等上层给 video 组件设置 <code>media_keys_</code> 继续初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WebContentDecryptionModule*</span></span><br><span class="line"><span class="function"><span class="title">HTMLMediaElementEncryptedMedia::ContentDecryptionModule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> media_keys_ ? media_keys_-&gt;<span class="built_in">ContentDecryptionModule</span>() : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上层给 video 组件设置 media_keys 时会调用下面的函数来继续完成 RendererWrapper::CreateRenderer 中的 CreateRendererInternal 部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMediaKeysHandler::SetNewMediaKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(EME_LOG_LEVEL) &lt;&lt; __func__;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.3 If mediaKeys is not null, run the following steps:</span></span><br><span class="line">  <span class="keyword">if</span> (new_media_keys_) &#123;</span><br><span class="line">    <span class="comment">// 5.3.1 Associate the CDM instance represented by mediaKeys with the</span></span><br><span class="line">    <span class="comment">//       media element for decrypting media data.</span></span><br><span class="line">    <span class="comment">// 5.3.2 If the preceding step failed, run the following steps:</span></span><br><span class="line">    <span class="comment">//       (done in setFailed()).</span></span><br><span class="line">    <span class="comment">// 5.3.3 Queue a task to run the Attempt to Resume Playback If Necessary</span></span><br><span class="line">    <span class="comment">//       algorithm on the media element.</span></span><br><span class="line">    <span class="comment">//       (Handled in Chromium).</span></span><br><span class="line">    <span class="keyword">if</span> (element_-&gt;<span class="built_in">GetWebMediaPlayer</span>()) &#123;</span><br><span class="line">      SuccessCallback success_callback =</span><br><span class="line">          WTF::<span class="built_in">Bind</span>(&amp;SetMediaKeysHandler::Finish, <span class="built_in">WrapPersistent</span>(<span class="keyword">this</span>));</span><br><span class="line">      FailureCallback failure_callback =</span><br><span class="line">          WTF::<span class="built_in">Bind</span>(&amp;SetMediaKeysHandler::SetFailed, <span class="built_in">WrapPersistent</span>(<span class="keyword">this</span>));</span><br><span class="line">      ContentDecryptionModuleResult* result =</span><br><span class="line">          <span class="built_in">MakeGarbageCollected</span>&lt;SetContentDecryptionModuleResult&gt;(</span><br><span class="line">              std::<span class="built_in">move</span>(success_callback), std::<span class="built_in">move</span>(failure_callback));</span><br><span class="line">      element_-&gt;<span class="built_in">GetWebMediaPlayer</span>()-&gt;<span class="built_in">SetContentDecryptionModule</span>(</span><br><span class="line">          new_media_keys_-&gt;<span class="built_in">ContentDecryptionModule</span>(), result-&gt;<span class="built_in">Result</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Don&#x27;t do anything more until |result| is resolved (or rejected).</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MediaKeys doesn&#x27;t need to be set on the player, so continue on.</span></span><br><span class="line">  <span class="built_in">Finish</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面调用了 WebMediaPlayer 的 SetContentDecryptionModule，把 media_keys 里的 WebContentDecryptionModule 设置给 WebMediaPlayerImpl</p><h2 id="WebMediaPlayerImpl-SetContentDecryptionModule"><a href="#WebMediaPlayerImpl-SetContentDecryptionModule" class="headerlink" title="WebMediaPlayerImpl::SetContentDecryptionModule"></a>WebMediaPlayerImpl::SetContentDecryptionModule</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebMediaPlayerImpl::SetContentDecryptionModule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WebContentDecryptionModule* cdm,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebContentDecryptionModuleResult result)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: cdm = &quot;</span> &lt;&lt; cdm;</span><br><span class="line">  <span class="built_in">DCHECK</span>(main_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Once the CDM is set it can&#x27;t be cleared as there may be frames being</span></span><br><span class="line">  <span class="comment">// decrypted on other threads. So fail this request.</span></span><br><span class="line">  <span class="comment">// http://crbug.com/462365#c7.</span></span><br><span class="line">  <span class="keyword">if</span> (!cdm) &#123;</span><br><span class="line">    result.<span class="built_in">CompleteWithError</span>(</span><br><span class="line">        kWebContentDecryptionModuleExceptionInvalidStateError, <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;The existing ContentDecryptionModule object cannot be removed at this &quot;</span></span><br><span class="line">        <span class="string">&quot;time.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a local copy of `result` to avoid problems with the callback</span></span><br><span class="line">  <span class="comment">// getting passed to the media thread and causing `result` to be destructed</span></span><br><span class="line">  <span class="comment">// on the wrong thread in some failure conditions. Blink should prevent</span></span><br><span class="line">  <span class="comment">// multiple simultaneous calls.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(!set_cdm_result_);</span><br><span class="line">  set_cdm_result_ = std::<span class="built_in">make_unique</span>&lt;WebContentDecryptionModuleResult&gt;(result);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetCdmInternal</span>(cdm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续调用 SetCdmInternal</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebMediaPlayerImpl::SetCdmInternal</span><span class="params">(WebContentDecryptionModule* cdm)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(main_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(cdm);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> was_encrypted = is_encrypted_;</span><br><span class="line">  is_encrypted_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recreate the watch time reporter if necessary.</span></span><br><span class="line">  <span class="keyword">if</span> (!was_encrypted) &#123;</span><br><span class="line">    media_metrics_provider_-&gt;<span class="built_in">SetIsEME</span>();</span><br><span class="line">    <span class="keyword">if</span> (watch_time_reporter_)</span><br><span class="line">      <span class="built_in">CreateWatchTimeReporter</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  WebContentDecryptionModuleImpl* web_cdm =</span><br><span class="line">      <span class="built_in">ToWebContentDecryptionModuleImpl</span>(cdm);</span><br><span class="line">  <span class="keyword">auto</span> cdm_context_ref = web_cdm-&gt;<span class="built_in">GetCdmContextRef</span>();</span><br><span class="line">  <span class="keyword">if</span> (!cdm_context_ref) &#123;</span><br><span class="line">    <span class="built_in">NOTREACHED</span>();</span><br><span class="line">    <span class="built_in">OnCdmAttached</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Arrival of `cdm_config_` unblocks recording of encrypted stats. Attempt to</span></span><br><span class="line">  <span class="comment">// create the stats reporter. Note, we do NOT guard this within !was_encypted</span></span><br><span class="line">  <span class="comment">// above because often the CDM arrives after the call to</span></span><br><span class="line">  <span class="comment">// OnEncryptedMediaInitData().</span></span><br><span class="line">  cdm_config_ = web_cdm-&gt;<span class="built_in">GetCdmConfig</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(!cdm_config_-&gt;key_system.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">  media_metrics_provider_-&gt;<span class="built_in">SetKeySystem</span>(cdm_config_-&gt;key_system);</span><br><span class="line">  <span class="keyword">if</span> (cdm_config_-&gt;use_hw_secure_codecs)</span><br><span class="line">    media_metrics_provider_-&gt;<span class="built_in">SetIsHardwareSecure</span>();</span><br><span class="line">  <span class="built_in">CreateVideoDecodeStatsReporter</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span>* cdm_context = cdm_context_ref-&gt;<span class="built_in">GetCdmContext</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(cdm_context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Keep the reference to the CDM, as it shouldn&#x27;t be destroyed until</span></span><br><span class="line">  <span class="comment">// after the pipeline is done with the `cdm_context`.</span></span><br><span class="line">  pending_cdm_context_ref_ = std::<span class="built_in">move</span>(cdm_context_ref);</span><br><span class="line">  pipeline_controller_-&gt;<span class="built_in">SetCdm</span>(</span><br><span class="line">      cdm_context,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;WebMediaPlayerImpl::OnCdmAttached, weak_this_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PipelineController-SetCdm"><a href="#PipelineController-SetCdm" class="headerlink" title="PipelineController::SetCdm"></a>PipelineController::SetCdm</h3><p>继续调用 PipelineController::SetCdm</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PipelineController::SetCdm</span><span class="params">(CdmContext* cdm_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                                CdmAttachedCB cdm_attached_cb)</span> </span>&#123;</span><br><span class="line">  pipeline_-&gt;<span class="built_in">SetCdm</span>(cdm_context, std::<span class="built_in">move</span>(cdm_attached_cb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PipelineImpl::SetCdm</span><span class="params">(CdmContext* cdm_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                          CdmAttachedCB cdm_attached_cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line">  <span class="built_in">DCHECK</span>(thread_checker_.<span class="built_in">CalledOnValidThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(cdm_context);</span><br><span class="line">  <span class="built_in">DCHECK</span>(cdm_attached_cb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not checking IsRunning() so we can set the CDM before Start().</span></span><br><span class="line"></span><br><span class="line">  media_task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">      FROM_HERE,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::SetCdm,</span><br><span class="line">                     base::<span class="built_in">Unretained</span>(renderer_wrapper_.<span class="built_in">get</span>()), cdm_context,</span><br><span class="line">                     <span class="built_in">BindToCurrentLoop</span>(std::<span class="built_in">move</span>(cdm_attached_cb))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PipelineImpl-RendererWrapper-SetCdm"><a href="#PipelineImpl-RendererWrapper-SetCdm" class="headerlink" title="PipelineImpl::RendererWrapper::SetCdm"></a>PipelineImpl::RendererWrapper::SetCdm</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> PipelineImpl::RendererWrapper::<span class="built_in">SetCdm</span>(CdmContext* cdm_context,</span><br><span class="line">                                           CdmAttachedCB cdm_attached_cb) &#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(media_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(cdm_context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If there&#x27;s already a renderer, set the CDM on the renderer directly.</span></span><br><span class="line">  <span class="keyword">if</span> (shared_state_.renderer) &#123;</span><br><span class="line">    shared_state_.renderer-&gt;<span class="built_in">SetCdm</span>(</span><br><span class="line">        cdm_context, base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::OnCdmAttached,</span><br><span class="line">                                    weak_factory_.<span class="built_in">GetWeakPtr</span>(),</span><br><span class="line">                                    std::<span class="built_in">move</span>(cdm_attached_cb), cdm_context));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, wait for the Renderer to be created and the CDM will be set</span></span><br><span class="line">  <span class="comment">// in InitializeRenderer().</span></span><br><span class="line">  cdm_context_ = cdm_context;</span><br><span class="line">  std::<span class="built_in">move</span>(cdm_attached_cb).<span class="built_in">Run</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Continue Renderer creation if it&#x27;s waiting for the CDM to be set.</span></span><br><span class="line">  <span class="keyword">if</span> (create_renderer_done_cb_)</span><br><span class="line">    <span class="built_in">CreateRendererInternal</span>(std::<span class="built_in">move</span>(create_renderer_done_cb_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WebMediaPlayerImpl-OnCdmAttached"><a href="#WebMediaPlayerImpl-OnCdmAttached" class="headerlink" title="WebMediaPlayerImpl::OnCdmAttached"></a>WebMediaPlayerImpl::OnCdmAttached</h5><p>RendererWrapper::SetCdm 中设置 cdm_context 然后调用 cdm_attached_cb</p><p>而 cdm_attached_cb 就是 WebMediaPlayerImpl::OnCdmAttached</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebMediaPlayerImpl::OnCdmAttached</span><span class="params">(<span class="type">bool</span> success)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: success = &quot;</span> &lt;&lt; success;</span><br><span class="line">  <span class="built_in">DCHECK</span>(main_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(pending_cdm_context_ref_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the CDM is set from the constructor there is no promise</span></span><br><span class="line">  <span class="comment">// (`set_cdm_result_`) to fulfill.</span></span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    media_log_-&gt;<span class="built_in">SetProperty</span>&lt;MediaLogProperty::kIsVideoEncrypted&gt;(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This will release the previously attached CDM (if any).</span></span><br><span class="line">    cdm_context_ref_ = std::<span class="built_in">move</span>(pending_cdm_context_ref_);</span><br><span class="line">    <span class="keyword">if</span> (set_cdm_result_) &#123;</span><br><span class="line">      set_cdm_result_-&gt;<span class="built_in">Complete</span>();</span><br><span class="line">      set_cdm_result_.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pending_cdm_context_ref_.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="keyword">if</span> (set_cdm_result_) &#123;</span><br><span class="line">    set_cdm_result_-&gt;<span class="built_in">CompleteWithError</span>(</span><br><span class="line">        kWebContentDecryptionModuleExceptionNotSupportedError, <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;Unable to set ContentDecryptionModule object&quot;</span>);</span><br><span class="line">    set_cdm_result_.<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="PipelineImpl-RendererWrapper-CreateRendererInternal"><a href="#PipelineImpl-RendererWrapper-CreateRendererInternal" class="headerlink" title="PipelineImpl::RendererWrapper::CreateRendererInternal"></a>PipelineImpl::RendererWrapper::CreateRendererInternal</h5><p>PipelineImpl::RendererWrapper::SetCdm 的最后继续完成 CreateRendererInternal</p><p>下面的 <code>default_renderer_</code> 在 PipelineImpl::Start 中通过 <code>create_renderer_cb_</code> 创建，<code>create_renderer_cb_</code> 其实是 WebMediaPlayerImpl::CreateRenderer，WebMediaPlayerImpl::CreateRenderer 里面会调用 <code>renderer_factory_selector_</code> 来选择 renderer_factory，然后由 renderer_factory 创建 renderer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> PipelineImpl::RendererWrapper::<span class="built_in">CreateRendererInternal</span>(</span><br><span class="line">    PipelineStatusCallback done_cb) &#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(state_ == kStarting || state_ == kResuming);</span><br><span class="line">  <span class="built_in">DCHECK</span>(cdm_context_ || !<span class="built_in">HasEncryptedStream</span>())</span><br><span class="line">      &lt;&lt; <span class="string">&quot;CDM should be available now if has encrypted stream&quot;</span>;</span><br><span class="line"></span><br><span class="line">  absl::optional&lt;RendererType&gt; renderer_type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_WIN)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(IS_WIN)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(xhwang): During Resume(), the |default_renderer_| might already match</span></span><br><span class="line">  <span class="comment">// the |renderer_type|, in which case we shouldn&#x27;t need to create a new one.</span></span><br><span class="line">  <span class="keyword">if</span> (!default_renderer_ || renderer_type) &#123;</span><br><span class="line">    <span class="comment">// Create the Renderer asynchronously on the main task runner. Use</span></span><br><span class="line">    <span class="comment">// BindToCurrentLoop to call OnRendererCreated() on the media task runner.</span></span><br><span class="line">    <span class="keyword">auto</span> renderer_created_cb = <span class="built_in">BindToCurrentLoop</span>(</span><br><span class="line">        base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::OnRendererCreated,</span><br><span class="line">                       weak_factory_.<span class="built_in">GetWeakPtr</span>(), std::<span class="built_in">move</span>(done_cb)));</span><br><span class="line">    main_task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">        FROM_HERE,</span><br><span class="line">        base::<span class="built_in">BindOnce</span>(&amp;PipelineImpl::AsyncCreateRenderer, weak_pipeline_,</span><br><span class="line">                       renderer_type, std::<span class="built_in">move</span>(renderer_created_cb)));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Just use the default one.</span></span><br><span class="line">  <span class="built_in">OnRendererCreated</span>(std::<span class="built_in">move</span>(done_cb), std::<span class="built_in">move</span>(default_renderer_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="WebMediaPlayerImpl-CreateRenderer"><a href="#WebMediaPlayerImpl-CreateRenderer" class="headerlink" title="WebMediaPlayerImpl::CreateRenderer"></a>WebMediaPlayerImpl::CreateRenderer</h6><p><code>renderer_factory_selector_</code> 是在创建 webmediaplayer 时传给 webmediaplayer 的参数，<code>renderer_factory_selector_</code> 具体是在 MediaFactory::CreateRendererFactorySelector 函数中创建的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;media::Renderer&gt; <span class="title">WebMediaPlayerImpl::CreateRenderer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;media::RendererType&gt; renderer_type)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(main_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure that overlays are enabled if they&#x27;re always allowed.</span></span><br><span class="line">  <span class="keyword">if</span> (always_enable_overlays_)</span><br><span class="line">    <span class="built_in">EnableOverlay</span>();</span><br><span class="line"></span><br><span class="line">  media::RequestOverlayInfoCB request_overlay_info_cb;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_ANDROID)</span></span><br><span class="line">  request_overlay_info_cb = media::<span class="built_in">BindToCurrentLoop</span>(base::<span class="built_in">BindRepeating</span>(</span><br><span class="line">      &amp;WebMediaPlayerImpl::OnOverlayInfoRequested, weak_this_));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (renderer_type) &#123;</span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__</span><br><span class="line">             &lt;&lt; <span class="string">&quot;: renderer_type=&quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(renderer_type.<span class="built_in">value</span>());</span><br><span class="line">    renderer_factory_selector_-&gt;<span class="built_in">SetBaseRendererType</span>(renderer_type.<span class="built_in">value</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> old_uses_audio_service = <span class="built_in">UsesAudioService</span>(renderer_type_);</span><br><span class="line">  renderer_type_ = renderer_factory_selector_-&gt;<span class="built_in">GetCurrentRendererType</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> new_uses_audio_service = <span class="built_in">UsesAudioService</span>(renderer_type_);</span><br><span class="line">  <span class="keyword">if</span> (new_uses_audio_service != old_uses_audio_service)</span><br><span class="line">    client_-&gt;<span class="built_in">DidUseAudioServiceChange</span>(new_uses_audio_service);</span><br><span class="line"></span><br><span class="line">  media_metrics_provider_-&gt;<span class="built_in">SetRendererType</span>(renderer_type_);</span><br><span class="line">  media_log_-&gt;<span class="built_in">SetProperty</span>&lt;MediaLogProperty::kRendererName&gt;(renderer_type_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> renderer_factory_selector_-&gt;<span class="built_in">GetCurrentFactory</span>()-&gt;<span class="built_in">CreateRenderer</span>(</span><br><span class="line">      media_task_runner_, worker_task_runner_, audio_source_provider_.<span class="built_in">get</span>(),</span><br><span class="line">      compositor_.<span class="built_in">get</span>(), std::<span class="built_in">move</span>(request_overlay_info_cb),</span><br><span class="line">      client_-&gt;<span class="built_in">TargetColorSpace</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看 RendererFactory 的 CreateRenderer 函数，注意下面把 CreateXXXDecoders 作为 XXXRenderer 的回调函数，后面创建 Decoder 会通过 CreateXXXDecoders，而 CreateXXXDecoders 里面调用创建 RendererFactory 时传给他的 decoder_factory，该 decoder_factory 来自 MediaFactory::GetDecoderFactory</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Renderer&gt; <span class="title">DefaultRendererFactory::CreateRenderer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> scoped_refptr&lt;base::SingleThreadTaskRunner&gt;&amp; media_task_runner,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> scoped_refptr&lt;base::TaskRunner&gt;&amp; worker_task_runner,</span></span></span><br><span class="line"><span class="params"><span class="function">    AudioRendererSink* audio_renderer_sink,</span></span></span><br><span class="line"><span class="params"><span class="function">    VideoRendererSink* video_renderer_sink,</span></span></span><br><span class="line"><span class="params"><span class="function">    RequestOverlayInfoCB request_overlay_info_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> gfx::ColorSpace&amp; target_color_space)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(audio_renderer_sink);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_ptr&lt;AudioRenderer&gt; <span class="title">audio_renderer</span><span class="params">(<span class="keyword">new</span> AudioRendererImpl(</span></span></span><br><span class="line"><span class="params"><span class="function">      media_task_runner, audio_renderer_sink,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// Unretained is safe here, because the RendererFactory is guaranteed to</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// outlive the RendererImpl. The RendererImpl is destroyed when WMPI</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// destructor calls pipeline_controller_.Stop() -&gt; PipelineImpl::Stop() -&gt;</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// RendererWrapper::Stop -&gt; RendererWrapper::DestroyRenderer(). And the</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// RendererFactory is owned by WMPI and gets called after WMPI destructor</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// finishes.</span></span></span></span><br><span class="line"><span class="params"><span class="function">      base::BindRepeating(&amp;DefaultRendererFactory::CreateAudioDecoders,</span></span></span><br><span class="line"><span class="params"><span class="function">                          base::Unretained(<span class="keyword">this</span>), media_task_runner),</span></span></span><br><span class="line"><span class="params"><span class="function">#<span class="keyword">if</span> BUILDFLAG(IS_ANDROID)</span></span></span><br><span class="line"><span class="params"><span class="function">      media_log_))</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      media_log_, speech_recognition_client_.<span class="built_in">get</span>()));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  GpuVideoAcceleratorFactories* gpu_factories = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (get_gpu_factories_cb_)</span><br><span class="line">    gpu_factories = get_gpu_factories_cb_.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;GpuMemoryBufferVideoFramePool&gt; gmb_pool;</span><br><span class="line">  <span class="keyword">if</span> (gpu_factories &amp;&amp; gpu_factories-&gt;<span class="built_in">ShouldUseGpuMemoryBuffersForVideoFrames</span>(</span><br><span class="line">                           <span class="literal">false</span> <span class="comment">/* for_media_stream */</span>)) &#123;</span><br><span class="line">    gmb_pool = std::<span class="built_in">make_unique</span>&lt;GpuMemoryBufferVideoFramePool&gt;(</span><br><span class="line">        media_task_runner, std::<span class="built_in">move</span>(worker_task_runner), gpu_factories);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_ptr&lt;VideoRenderer&gt; <span class="title">video_renderer</span><span class="params">(<span class="keyword">new</span> VideoRendererImpl(</span></span></span><br><span class="line"><span class="params"><span class="function">      media_task_runner, video_renderer_sink,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// Unretained is safe here, because the RendererFactory is guaranteed to</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// outlive the RendererImpl. The RendererImpl is destroyed when WMPI</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// destructor calls pipeline_controller_.Stop() -&gt; PipelineImpl::Stop() -&gt;</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// RendererWrapper::Stop -&gt; RendererWrapper::DestroyRenderer(). And the</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// RendererFactory is owned by WMPI and gets called after WMPI destructor</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="comment">// finishes.</span></span></span></span><br><span class="line"><span class="params"><span class="function">      base::BindRepeating(&amp;DefaultRendererFactory::CreateVideoDecoders,</span></span></span><br><span class="line"><span class="params"><span class="function">                          base::Unretained(<span class="keyword">this</span>), media_task_runner,</span></span></span><br><span class="line"><span class="params"><span class="function">                          std::move(request_overlay_info_cb),</span></span></span><br><span class="line"><span class="params"><span class="function">                          target_color_space, gpu_factories),</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="literal">true</span>, media_log_, std::move(gmb_pool)))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;RendererImpl&gt;(</span><br><span class="line">      media_task_runner, std::<span class="built_in">move</span>(audio_renderer), std::<span class="built_in">move</span>(video_renderer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="PipelineImpl-RendererWrapper-OnRendererCreated"><a href="#PipelineImpl-RendererWrapper-OnRendererCreated" class="headerlink" title="PipelineImpl::RendererWrapper::OnRendererCreated"></a>PipelineImpl::RendererWrapper::OnRendererCreated</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> PipelineImpl::RendererWrapper::<span class="built_in">OnRendererCreated</span>(</span><br><span class="line">    PipelineStatusCallback done_cb,</span><br><span class="line">    std::unique_ptr&lt;Renderer&gt; renderer) &#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: renderer=&quot;</span> &lt;&lt; renderer.<span class="built_in">get</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(media_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">    std::<span class="built_in">move</span>(done_cb).<span class="built_in">Run</span>(PIPELINE_ERROR_INITIALIZATION_FAILED);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">base::AutoLock <span class="title">auto_lock</span><span class="params">(shared_state_lock_)</span></span>;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!shared_state_.renderer);</span><br><span class="line">    shared_state_.renderer = std::<span class="built_in">move</span>(renderer);</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">move</span>(done_cb).<span class="built_in">Run</span>(PIPELINE_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一篇文章就先到这里，主要介绍了 RendererWrapper::CreateRenderer 的流程，下篇文章分析 RendererWrapper::InitializeRenderer</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium 多媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium 多媒体（六）</title>
      <link href="/2023/07/07/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2023/07/07/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Chromium-多媒体（六）"><a href="#Chromium-多媒体（六）" class="headerlink" title="Chromium 多媒体（六）"></a>Chromium 多媒体（六）</h1><p>这篇文章继续介绍 EME 相关的内容。</p><p>上一篇文章介绍了 MediaKeySystemAccess 创建 MediaKeys 的过程，这篇文章介绍 MediaKeys 创建 MediaKeySession 以及 MediaKeySession 的一些方法。</p><h1 id="encrypted-事件"><a href="#encrypted-事件" class="headerlink" title="encrypted 事件"></a>encrypted 事件</h1><p>首先我们分析 video 组件的 encrypted 事件何时触发。</p><p>这部分其实之前介绍 MSE 的时候有分析过。当往 MP4StreamParser 中送数据的时候，如果 moov 中有加密的 track，会通过回调往上通知 encrypted 事件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MP4StreamParser::ParseMoov</span><span class="params">(BoxReader* reader)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (!moov_-&gt;pssh.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">OnEncryptedMediaInitData</span>(moov_-&gt;pssh);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MP4StreamParser::OnEncryptedMediaInitData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;ProtectionSystemSpecificHeader&gt;&amp; headers)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO(strobe): ensure that the value of init_data (all PSSH headers</span></span><br><span class="line">  <span class="comment">// concatenated in arbitrary order) matches the EME spec.</span></span><br><span class="line">  <span class="comment">// See https://www.w3.org/Bugs/Public/show_bug.cgi?id=17673.</span></span><br><span class="line">  <span class="type">size_t</span> total_size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; headers.<span class="built_in">size</span>(); i++)</span><br><span class="line">    total_size += headers[i].raw_box.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">init_data</span><span class="params">(total_size)</span></span>;</span><br><span class="line">  <span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; headers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;init_data[pos], &amp;headers[i].raw_box[<span class="number">0</span>],</span><br><span class="line">           headers[i].raw_box.<span class="built_in">size</span>());</span><br><span class="line">    pos += headers[i].raw_box.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  encrypted_media_init_data_cb_.<span class="built_in">Run</span>(EmeInitDataType::CENC, init_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>encrypted_media_init_data_cb_</code> 就是 SourceBufferState::OnEncryptedMediaInitData</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SourceBufferState::OnEncryptedMediaInitData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    EmeInitDataType type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; init_data)</span> </span>&#123;</span><br><span class="line">  encrypted_media_init_data_reported_ = <span class="literal">true</span>;</span><br><span class="line">  encrypted_media_init_data_cb_.<span class="built_in">Run</span>(type, init_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SourceBufferState 里的 <code>encrypted_media_init_data_cb_</code> 就是 WebMediaPlayerImpl::OnEncryptedMediaInitData</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebMediaPlayerImpl::OnEncryptedMediaInitData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    media::EmeInitDataType init_data_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; init_data)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(init_data_type != media::EmeInitDataType::UNKNOWN);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RecordEncryptedEvent</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recreate the watch time reporter if necessary.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> was_encrypted = is_encrypted_;</span><br><span class="line">  is_encrypted_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!was_encrypted) &#123;</span><br><span class="line">    media_metrics_provider_-&gt;<span class="built_in">SetIsEME</span>();</span><br><span class="line">    <span class="keyword">if</span> (watch_time_reporter_)</span><br><span class="line">      <span class="built_in">CreateWatchTimeReporter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `was_encrypted` = false means we didn&#x27;t have a CDM prior to observing</span></span><br><span class="line">    <span class="comment">// encrypted media init data. Reset the reporter until the CDM arrives. See</span></span><br><span class="line">    <span class="comment">// SetCdmInternal().</span></span><br><span class="line">    <span class="built_in">DCHECK</span>(!cdm_config_);</span><br><span class="line">    video_decode_stats_reporter_.<span class="built_in">reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  encrypted_client_-&gt;<span class="built_in">Encrypted</span>(</span><br><span class="line">      init_data_type, init_data.<span class="built_in">data</span>(),</span><br><span class="line">      base::<span class="built_in">saturated_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(init_data.<span class="built_in">size</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>encrypted_client_</code> 就是 ModulesInitializer::CreateWebMediaPlayer 中创建的 HTMLMediaElementEncryptedMedia，不记得的可以回去看看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HTMLMediaElementEncryptedMedia&amp; <span class="title">HTMLMediaElementEncryptedMedia::From</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HTMLMediaElement&amp; element)</span> </span>&#123;</span><br><span class="line">  HTMLMediaElementEncryptedMedia* supplement =</span><br><span class="line">      Supplement&lt;HTMLMediaElement&gt;::<span class="built_in">From</span>&lt;HTMLMediaElementEncryptedMedia&gt;(</span><br><span class="line">          element);</span><br><span class="line">  <span class="keyword">if</span> (!supplement) &#123;</span><br><span class="line">    supplement = <span class="built_in">MakeGarbageCollected</span>&lt;HTMLMediaElementEncryptedMedia&gt;(element);</span><br><span class="line">    <span class="built_in">ProvideTo</span>(element, supplement);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *supplement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的 HTMLMediaElementEncryptedMedia::Encrypted 函数中通过 CreateEncryptedEvent 函数创建了一个 EncryptedEvent，然后将该 EncryptedEvent 进行 Schedule</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HTMLMediaElementEncryptedMedia::Encrypted</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    media::EmeInitDataType init_data_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* init_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> init_data_length)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(EME_LOG_LEVEL) &lt;&lt; __func__;</span><br><span class="line"></span><br><span class="line">  Event* event;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetSupplementable</span>()-&gt;<span class="built_in">IsMediaDataCorsSameOrigin</span>()) &#123;</span><br><span class="line">    event = <span class="built_in">CreateEncryptedEvent</span>(init_data_type, init_data, init_data_length);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Current page is not allowed to see content from the media file,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t return the initData. However, they still get an event.</span></span><br><span class="line">    event = <span class="built_in">CreateEncryptedEvent</span>(media::EmeInitDataType::UNKNOWN, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">GetSupplementable</span>()-&gt;<span class="built_in">GetExecutionContext</span>()-&gt;<span class="built_in">AddConsoleMessage</span>(</span><br><span class="line">        <span class="built_in">MakeGarbageCollected</span>&lt;ConsoleMessage&gt;(</span><br><span class="line">            mojom::ConsoleMessageSource::kJavaScript,</span><br><span class="line">            mojom::ConsoleMessageLevel::kWarning,</span><br><span class="line">            <span class="string">&quot;Media element must be CORS-same-origin with &quot;</span></span><br><span class="line">            <span class="string">&quot;the embedding page. If cross-origin, you &quot;</span></span><br><span class="line">            <span class="string">&quot;should use the `crossorigin` attribute and &quot;</span></span><br><span class="line">            <span class="string">&quot;make sure CORS headers on the media data &quot;</span></span><br><span class="line">            <span class="string">&quot;response are CORS-same-origin.&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  event-&gt;<span class="built_in">SetTarget</span>(<span class="built_in">GetSupplementable</span>());</span><br><span class="line">  <span class="built_in">GetSupplementable</span>()-&gt;<span class="built_in">ScheduleEvent</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MediaKeys-createSession"><a href="#MediaKeys-createSession" class="headerlink" title="MediaKeys::createSession"></a>MediaKeys::createSession</h1><p>在 encrypted 事件中，通过 MediaKeys 去创建 Session</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MediaKeySession* <span class="title">MediaKeys::createSession</span><span class="params">(ScriptState* script_state,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> String&amp; session_type_string,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          ExceptionState&amp; exception_state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(MEDIA_KEYS_LOG_LEVEL)</span><br><span class="line">      &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; session_type_string;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// From http://w3c.github.io/encrypted-media/#createSession</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// When this method is invoked, the user agent must run the following steps:</span></span><br><span class="line">  <span class="comment">// 1. If this object&#x27;s persistent state allowed value is false and</span></span><br><span class="line">  <span class="comment">//    sessionType is not &quot;temporary&quot;, throw a new DOMException whose name is</span></span><br><span class="line">  <span class="comment">//    NotSupportedError.</span></span><br><span class="line">  <span class="comment">//    (Chromium ensures that only session types supported by the</span></span><br><span class="line">  <span class="comment">//    configuration are listed in supportedSessionTypes.)</span></span><br><span class="line">  <span class="comment">// 2. If the Key System implementation represented by this object&#x27;s cdm</span></span><br><span class="line">  <span class="comment">//    implementation value does not support sessionType, throw a new</span></span><br><span class="line">  <span class="comment">//    DOMException whose name is NotSupportedError.</span></span><br><span class="line">  WebEncryptedMediaSessionType session_type =</span><br><span class="line">      EncryptedMediaUtils::<span class="built_in">ConvertToSessionType</span>(session_type_string);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">SessionTypeSupported</span>(session_type)) &#123;</span><br><span class="line">    exception_state.<span class="built_in">ThrowDOMException</span>(DOMExceptionCode::kNotSupportedError,</span><br><span class="line">                                      <span class="string">&quot;Unsupported session type.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. Let session be a new MediaKeySession object, and initialize it as</span></span><br><span class="line">  <span class="comment">//    follows:</span></span><br><span class="line">  <span class="comment">//    (Initialization is performed in the constructor.)</span></span><br><span class="line">  <span class="comment">// 4. Return session.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MakeGarbageCollected</span>&lt;MediaKeySession&gt;(script_state, <span class="keyword">this</span>, session_type,</span><br><span class="line">                                               config_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 MediaKeySession 的构造函数中调用 WebContentDecryptionModuleImpl::CreateSession</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">MediaKeySession::<span class="built_in">MediaKeySession</span>(ScriptState* script_state,</span><br><span class="line">                                 MediaKeys* media_keys,</span><br><span class="line">                                 WebEncryptedMediaSessionType session_type,</span><br><span class="line">                                 <span class="type">const</span> MediaKeysConfig&amp; config)</span><br><span class="line">    : <span class="built_in">ExecutionContextLifecycleObserver</span>(ExecutionContext::<span class="built_in">From</span>(script_state)),</span><br><span class="line">      <span class="built_in">async_event_queue_</span>(</span><br><span class="line">          <span class="built_in">MakeGarbageCollected</span>&lt;EventQueue&gt;(<span class="built_in">GetExecutionContext</span>(),</span><br><span class="line">                                           TaskType::kMediaElementEvent)),</span><br><span class="line">      <span class="built_in">media_keys_</span>(media_keys),</span><br><span class="line">      <span class="built_in">session_type_</span>(session_type),</span><br><span class="line">      <span class="built_in">config_</span>(config),</span><br><span class="line">      <span class="built_in">expiration_</span>(std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">quiet_NaN</span>()),</span><br><span class="line">      <span class="built_in">key_statuses_map_</span>(<span class="built_in">MakeGarbageCollected</span>&lt;MediaKeyStatusMap&gt;()),</span><br><span class="line">      <span class="built_in">closed_promise_</span>(<span class="built_in">MakeGarbageCollected</span>&lt;ClosedPromise&gt;(</span><br><span class="line">          ExecutionContext::<span class="built_in">From</span>(script_state))),</span><br><span class="line">      <span class="built_in">action_timer_</span>(ExecutionContext::<span class="built_in">From</span>(script_state)</span><br><span class="line">                        -&gt;<span class="built_in">GetTaskRunner</span>(TaskType::kMiscPlatformAPI),</span><br><span class="line">                    <span class="keyword">this</span>,</span><br><span class="line">                    &amp;MediaKeySession::ActionTimerFired) &#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(MEDIA_KEY_SESSION_LOG_LEVEL) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  InstanceCounters::<span class="built_in">IncrementCounter</span>(InstanceCounters::kMediaKeySessionCounter);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the matching Chromium object. It will not be usable until</span></span><br><span class="line">  <span class="comment">// initializeNewSession() is called in response to the user calling</span></span><br><span class="line">  <span class="comment">// generateRequest().</span></span><br><span class="line">  WebContentDecryptionModule* cdm = media_keys-&gt;<span class="built_in">ContentDecryptionModule</span>();</span><br><span class="line">  session_ = cdm-&gt;<span class="built_in">CreateSession</span>(session_type);</span><br><span class="line">  session_-&gt;<span class="built_in">SetClientInterface</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// From https://w3c.github.io/encrypted-media/#createSession:</span></span><br><span class="line">  <span class="comment">// MediaKeys::createSession(), step 3.</span></span><br><span class="line">  <span class="comment">// 3.1 Let the sessionId attribute be the empty string.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(session_id_.<span class="built_in">IsEmpty</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.2 Let the expiration attribute be NaN.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(std::<span class="built_in">isnan</span>(expiration_));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.3 Let the closed attribute be a new promise.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(!<span class="built_in">closed</span>(script_state).<span class="built_in">IsUndefinedOrNull</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.4 Let the keyStatuses attribute be empty.</span></span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(<span class="number">0u</span>, key_statuses_map_-&gt;<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.5 Let the session type be sessionType.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(session_type_ != WebEncryptedMediaSessionType::kUnknown);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.6 Let uninitialized be true.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(is_uninitialized_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.7 Let callable be false.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(!is_callable_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.8 Let the use distinctive identifier value be this object&#x27;s</span></span><br><span class="line">  <span class="comment">// use distinctive identifier.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> Implement this (http://crbug.com/448922).</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.9 Let the cdm implementation value be this object&#x27;s cdm implementation.</span></span><br><span class="line">  <span class="comment">// 3.10 Let the cdm instance value be this object&#x27;s cdm instance.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 WebContentDecryptionModuleImpl::CreateSession 中调用 CdmSessionAdapter::CreateSession</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;WebContentDecryptionModuleSession&gt;</span></span><br><span class="line"><span class="function"><span class="title">WebContentDecryptionModuleImpl::CreateSession</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WebEncryptedMediaSessionType session_type)</span> </span>&#123;</span><br><span class="line">  base::<span class="built_in">UmaHistogramEnumeration</span>(</span><br><span class="line">      adapter_-&gt;<span class="built_in">GetKeySystemUMAPrefix</span>() + kCreateSessionSessionTypeUMAName,</span><br><span class="line">      session_type);</span><br><span class="line">  <span class="keyword">return</span> adapter_-&gt;<span class="built_in">CreateSession</span>(session_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CdmSessionAdapter::CreateSession 创建并返回 WebContentDecryptionModuleSessionImpl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;WebContentDecryptionModuleSessionImpl&gt;</span></span><br><span class="line"><span class="function"><span class="title">CdmSessionAdapter::CreateSession</span><span class="params">(WebEncryptedMediaSessionType session_type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WebContentDecryptionModuleSessionImpl&gt;(<span class="keyword">this</span>,</span><br><span class="line">                                                                 session_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WebContentDecryptionModuleSessionImpl::<span class="built_in">WebContentDecryptionModuleSessionImpl</span>(</span><br><span class="line">    <span class="type">const</span> scoped_refptr&lt;CdmSessionAdapter&gt;&amp; adapter,</span><br><span class="line">    WebEncryptedMediaSessionType session_type)</span><br><span class="line">    : <span class="built_in">adapter_</span>(adapter),</span><br><span class="line">      <span class="built_in">session_type_</span>(<span class="built_in">ConvertSessionType</span>(session_type)),</span><br><span class="line">      <span class="built_in">has_close_been_called_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">is_closed_</span>(<span class="literal">false</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="MediaKeySession-generateRequest"><a href="#MediaKeySession-generateRequest" class="headerlink" title="MediaKeySession::generateRequest"></a>MediaKeySession::generateRequest</h1><p>创建完 MediaKeySession 后，会调用 MediaKeySession::generateRequest 方法，把之前 MP4StreamParser::ParseMoov 解析到的 init data 送给 CDM，并获得一个回执，然后将该回执发送给 License 服务器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ScriptPromise <span class="title">MediaKeySession::generateRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ScriptState* script_state,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> String&amp; init_data_type_string,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DOMArrayPiece&amp; init_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    ExceptionState&amp; exception_state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(MEDIA_KEY_SESSION_LOG_LEVEL)</span><br><span class="line">      &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; init_data_type_string;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// From https://w3c.github.io/encrypted-media/#generateRequest:</span></span><br><span class="line">  <span class="comment">// Generates a request based on the initData. When this method is invoked,</span></span><br><span class="line">  <span class="comment">// the user agent must run the following steps:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. If this object&#x27;s closing or closed value is true, return a promise</span></span><br><span class="line">  <span class="comment">//    rejected with an InvalidStateError.</span></span><br><span class="line">  <span class="keyword">if</span> (is_closing_ || is_closed_)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CreateRejectedPromiseAlreadyClosed</span>(exception_state);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. If this object&#x27;s uninitialized value is false, return a promise</span></span><br><span class="line">  <span class="comment">//    rejected with an InvalidStateError.</span></span><br><span class="line">  <span class="keyword">if</span> (!is_uninitialized_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CreateRejectedPromiseAlreadyInitialized</span>(exception_state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. Let this object&#x27;s uninitialized be false.</span></span><br><span class="line">  is_uninitialized_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. If initDataType is the empty string, return a promise rejected</span></span><br><span class="line">  <span class="comment">//    with a newly created TypeError.</span></span><br><span class="line">  <span class="keyword">if</span> (init_data_type_string.<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">    exception_state.<span class="built_in">ThrowTypeError</span>(<span class="string">&quot;The initDataType parameter is empty.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ScriptPromise</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. If initData is an empty array, return a promise rejected with a</span></span><br><span class="line">  <span class="comment">//    newly created TypeError.</span></span><br><span class="line">  <span class="keyword">if</span> (!init_data.<span class="built_in">ByteLength</span>()) &#123;</span><br><span class="line">    exception_state.<span class="built_in">ThrowTypeError</span>(<span class="string">&quot;The initData parameter is empty.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ScriptPromise</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. If the Key System implementation represented by this object&#x27;s cdm</span></span><br><span class="line">  <span class="comment">//    implementation value does not support initDataType as an</span></span><br><span class="line">  <span class="comment">//    Initialization Data Type, return a promise rejected with a new</span></span><br><span class="line">  <span class="comment">//    DOMException whose name is NotSupportedError. String comparison</span></span><br><span class="line">  <span class="comment">//    is case-sensitive.</span></span><br><span class="line">  <span class="comment">//    (blink side doesn&#x27;t know what the CDM supports, so the proper check</span></span><br><span class="line">  <span class="comment">//     will be done on the Chromium side. However, we can verify that</span></span><br><span class="line">  <span class="comment">//     |initDataType| is one of the registered values.)</span></span><br><span class="line">  media::EmeInitDataType init_data_type =</span><br><span class="line">      EncryptedMediaUtils::<span class="built_in">ConvertToInitDataType</span>(init_data_type_string);</span><br><span class="line">  <span class="keyword">if</span> (init_data_type == media::EmeInitDataType::UNKNOWN) &#123;</span><br><span class="line">    exception_state.<span class="built_in">ThrowDOMException</span>(DOMExceptionCode::kNotSupportedError,</span><br><span class="line">                                      <span class="string">&quot;The initialization data type &#x27;&quot;</span> +</span><br><span class="line">                                          init_data_type_string +</span><br><span class="line">                                          <span class="string">&quot;&#x27; is not supported.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ScriptPromise</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7. Let init data be a copy of the contents of the initData parameter.</span></span><br><span class="line">  DOMArrayBuffer* init_data_buffer =</span><br><span class="line">      DOMArrayBuffer::<span class="built_in">Create</span>(init_data.<span class="built_in">Data</span>(), init_data.<span class="built_in">ByteLength</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8. Let session type be this object&#x27;s session type.</span></span><br><span class="line">  <span class="comment">//    (Done in constructor.)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9. Let promise be a new promise.</span></span><br><span class="line">  NewSessionResultPromise* result =</span><br><span class="line">      <span class="built_in">MakeGarbageCollected</span>&lt;NewSessionResultPromise&gt;(script_state, config_,</span><br><span class="line">                                                    <span class="keyword">this</span>);</span><br><span class="line">  ScriptPromise promise = result-&gt;<span class="built_in">Promise</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10. Run the following steps asynchronously (done in generateRequestTask())</span></span><br><span class="line">  pending_actions_.<span class="built_in">push_back</span>(PendingAction::<span class="built_in">CreatePendingGenerateRequest</span>(</span><br><span class="line">      result, init_data_type, init_data_buffer));</span><br><span class="line">  <span class="built_in">DCHECK</span>(!action_timer_.<span class="built_in">IsActive</span>());</span><br><span class="line">  action_timer_.<span class="built_in">StartOneShot</span>(base::<span class="built_in">TimeDelta</span>(), FROM_HERE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 11. Return promise.</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面其实没有直接执行 generateRequest，而是创建了一个 PendingAction，实际执行在 MediaKeySession::GenerateRequestTask，该函数中调用 WebContentDecryptionModuleSessionImpl::InitializeNewSession</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaKeySession::GenerateRequestTask</span><span class="params">(ContentDecryptionModuleResult* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          media::EmeInitDataType init_data_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          DOMArrayBuffer* init_data_buffer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> Continue step 10 of MediaKeySession::generateRequest().</span></span><br><span class="line">  <span class="built_in">DVLOG</span>(MEDIA_KEY_SESSION_LOG_LEVEL) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initializeNewSession() in Chromium will execute steps 10.1 to 10.9.</span></span><br><span class="line">  session_-&gt;<span class="built_in">InitializeNewSession</span>(</span><br><span class="line">      init_data_type, <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(init_data_buffer-&gt;<span class="built_in">Data</span>()),</span><br><span class="line">      init_data_buffer-&gt;<span class="built_in">ByteLength</span>(), result-&gt;<span class="built_in">Result</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remaining steps (10.10) executed in finishGenerateRequest(),</span></span><br><span class="line">  <span class="comment">// called when |result| is resolved.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebContentDecryptionModuleSessionImpl::InitializeNewSession 调用了 CdmSessionAdapter::InitializeNewSession</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebContentDecryptionModuleSessionImpl::InitializeNewSession</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    media::EmeInitDataType eme_init_data_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* init_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> init_data_length,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebContentDecryptionModuleResult result)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(init_data);</span><br><span class="line">  <span class="built_in">DCHECK</span>(session_id_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(thread_checker_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// From https://w3c.github.io/encrypted-media/#generateRequest.</span></span><br><span class="line">  <span class="comment">// 6. If the Key System implementation represented by this object&#x27;s cdm</span></span><br><span class="line">  <span class="comment">//    implementation value does not support initDataType as an Initialization</span></span><br><span class="line">  <span class="comment">//    Data Type, return a promise rejected with a NotSupportedError.</span></span><br><span class="line">  <span class="comment">//    String comparison is case-sensitive.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsSupportedKeySystemWithInitDataType</span>(adapter_-&gt;<span class="built_in">GetKeySystem</span>(),</span><br><span class="line">                                            eme_init_data_type)) &#123;</span><br><span class="line">    std::string message =</span><br><span class="line">        <span class="string">&quot;The initialization data type is not supported by the key system.&quot;</span>;</span><br><span class="line">    result.<span class="built_in">CompleteWithError</span>(</span><br><span class="line">        kWebContentDecryptionModuleExceptionNotSupportedError, <span class="number">0</span>,</span><br><span class="line">        WebString::<span class="built_in">FromUTF8</span>(message));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10.1 If the init data is not valid for initDataType, reject promise with</span></span><br><span class="line">  <span class="comment">//      a newly created TypeError.</span></span><br><span class="line">  <span class="comment">// 10.2 Let sanitized init data be a validated and sanitized version of init</span></span><br><span class="line">  <span class="comment">//      data. The user agent must thoroughly validate the Initialization Data</span></span><br><span class="line">  <span class="comment">//      before passing it to the CDM. This includes verifying that the length</span></span><br><span class="line">  <span class="comment">//      and values of fields are reasonable, verifying that values are within</span></span><br><span class="line">  <span class="comment">//      reasonable limits, and stripping irrelevant, unsupported, or unknown</span></span><br><span class="line">  <span class="comment">//      data or fields. It is recommended that user agents pre-parse,</span></span><br><span class="line">  <span class="comment">//      sanitize, and/or generate a fully sanitized version of the</span></span><br><span class="line">  <span class="comment">//      Initialization Data. If the Initialization Data format specified by</span></span><br><span class="line">  <span class="comment">//      initDataType supports multiple entries, the user agent should remove</span></span><br><span class="line">  <span class="comment">//      entries that are not needed by the CDM. The user agent must not</span></span><br><span class="line">  <span class="comment">//      re-order entries within the Initialization Data.</span></span><br><span class="line">  <span class="comment">// 10.3 If the preceding step failed, reject promise with a newly created</span></span><br><span class="line">  <span class="comment">//      TypeError.</span></span><br><span class="line">  std::vector&lt;<span class="type">uint8_t</span>&gt; sanitized_init_data;</span><br><span class="line">  std::string message;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">SanitizeInitData</span>(eme_init_data_type, init_data, init_data_length,</span><br><span class="line">                        &amp;sanitized_init_data, &amp;message)) &#123;</span><br><span class="line">    result.<span class="built_in">CompleteWithError</span>(kWebContentDecryptionModuleExceptionTypeError, <span class="number">0</span>,</span><br><span class="line">                             WebString::<span class="built_in">FromUTF8</span>(message));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10.4 If sanitized init data is empty, reject promise with a</span></span><br><span class="line">  <span class="comment">//      NotSupportedError.</span></span><br><span class="line">  <span class="keyword">if</span> (sanitized_init_data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    result.<span class="built_in">CompleteWithError</span>(</span><br><span class="line">        kWebContentDecryptionModuleExceptionNotSupportedError, <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;No initialization data provided.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10.5 Let session id be the empty string.</span></span><br><span class="line">  <span class="comment">//      (Done in constructor.)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10.6 Let message be null.</span></span><br><span class="line">  <span class="comment">// 10.7 Let message type be null.</span></span><br><span class="line">  <span class="comment">//      (Done by CDM.)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10.8 Let cdm be the CDM instance represented by this object&#x27;s cdm</span></span><br><span class="line">  <span class="comment">//      instance value.</span></span><br><span class="line">  <span class="comment">// 10.9 Use the cdm to execute the following steps:</span></span><br><span class="line">  adapter_-&gt;<span class="built_in">InitializeNewSession</span>(</span><br><span class="line">      eme_init_data_type, sanitized_init_data, session_type_,</span><br><span class="line">      std::<span class="built_in">unique_ptr</span>&lt;media::NewSessionCdmPromise&gt;(</span><br><span class="line">          <span class="keyword">new</span> <span class="built_in">NewSessionCdmResultPromise</span>(</span><br><span class="line">              result, adapter_-&gt;<span class="built_in">GetKeySystemUMAPrefix</span>(),</span><br><span class="line">              kGenerateRequestUMAName,</span><br><span class="line">              base::<span class="built_in">BindOnce</span>(</span><br><span class="line">                  &amp;WebContentDecryptionModuleSessionImpl::OnSessionInitialized,</span><br><span class="line">                  weak_ptr_factory_.<span class="built_in">GetWeakPtr</span>()),</span><br><span class="line">              &#123;SessionInitStatus::NEW_SESSION&#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CdmSessionAdapter-InitializeNewSession"><a href="#CdmSessionAdapter-InitializeNewSession" class="headerlink" title="CdmSessionAdapter::InitializeNewSession"></a>CdmSessionAdapter::InitializeNewSession</h2><p>CdmSessionAdapter::InitializeNewSession 调用了 MojoCdm::CreateSessionAndGenerateRequest</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CdmSessionAdapter::InitializeNewSession</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    media::EmeInitDataType init_data_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; init_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    media::CdmSessionType session_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;media::NewSessionCdmPromise&gt; promise)</span> </span>&#123;</span><br><span class="line">  cdm_-&gt;<span class="built_in">CreateSessionAndGenerateRequest</span>(session_type, init_data_type, init_data,</span><br><span class="line">                                        std::<span class="built_in">move</span>(promise));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MojoCdm::CreateSessionAndGenerateRequest 则调用自己的 remote 端，也就是 MojoCdmService::CreateSessionAndGenerateRequest</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MojoCdm::CreateSessionAndGenerateRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CdmSessionType session_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    EmeInitDataType init_data_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; init_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;NewSessionCdmPromise&gt; promise)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(thread_checker_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!remote_cdm_) &#123;</span><br><span class="line">    promise-&gt;<span class="built_in">reject</span>(media::CdmPromise::Exception::INVALID_STATE_ERROR, <span class="number">0</span>,</span><br><span class="line">                    <span class="string">&quot;CDM connection lost.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> promise_id = cdm_promise_adapter_.<span class="built_in">SavePromise</span>(std::<span class="built_in">move</span>(promise));</span><br><span class="line">  remote_cdm_-&gt;<span class="built_in">CreateSessionAndGenerateRequest</span>(</span><br><span class="line">      session_type, init_data_type, init_data,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;MojoCdm::OnNewSessionCdmPromiseResult,</span><br><span class="line">                     base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>), promise_id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MojoCdmService::CreateSessionAndGenerateRequest 则调用之前 CreatePlatformCdmFactory 函数创建的 <code>cdm_</code> 的 CreateSessionAndGenerateRequest 方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MojoCdmService::CreateSessionAndGenerateRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CdmSessionType session_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    EmeInitDataType init_data_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; init_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    CreateSessionAndGenerateRequestCallback callback)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line">  cdm_-&gt;<span class="built_in">CreateSessionAndGenerateRequest</span>(</span><br><span class="line">      session_type, init_data_type, init_data,</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;NewSessionMojoCdmPromise&gt;(std::<span class="built_in">move</span>(callback)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是 Android 平台，那么之前 InterfaceFactoryImpl::GetCdmFactory 得到的就是 AndroidCdmFactory，通过 AndroidCdmFactory::Create 创建的 Cdm 就是 MediaDrmBridge，而 MediaDrmBridge 里面有 MediaDrmStorageBridge，MediaDrmStorageBridge 里面还有更深层次的成员，这里不往下追踪</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaDrmBridge::CreateSessionAndGenerateRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CdmSessionType session_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    media::EmeInitDataType init_data_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; init_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;media::NewSessionCdmPromise&gt; promise)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line"></span><br><span class="line">  JNIEnv* env = <span class="built_in">AttachCurrentThread</span>();</span><br><span class="line">  ScopedJavaLocalRef&lt;jbyteArray&gt; j_init_data;</span><br><span class="line">  ScopedJavaLocalRef&lt;jobjectArray&gt; j_optional_parameters;</span><br><span class="line"></span><br><span class="line">  MediaDrmBridgeClient* client = <span class="built_in">GetMediaDrmBridgeClient</span>();</span><br><span class="line">  <span class="keyword">if</span> (client) &#123;</span><br><span class="line">    MediaDrmBridgeDelegate* delegate =</span><br><span class="line">        client-&gt;<span class="built_in">GetMediaDrmBridgeDelegate</span>(scheme_uuid_);</span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">      std::vector&lt;<span class="type">uint8_t</span>&gt; init_data_from_delegate;</span><br><span class="line">      std::vector&lt;std::string&gt; optional_parameters_from_delegate;</span><br><span class="line">      <span class="keyword">if</span> (!delegate-&gt;<span class="built_in">OnCreateSession</span>(init_data_type, init_data,</span><br><span class="line">                                     &amp;init_data_from_delegate,</span><br><span class="line">                                     &amp;optional_parameters_from_delegate)) &#123;</span><br><span class="line">        promise-&gt;<span class="built_in">reject</span>(CdmPromise::Exception::TYPE_ERROR, <span class="number">0</span>,</span><br><span class="line">                        <span class="string">&quot;Invalid init data.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!init_data_from_delegate.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        j_init_data =</span><br><span class="line">            base::android::<span class="built_in">ToJavaByteArray</span>(env, init_data_from_delegate.<span class="built_in">data</span>(),</span><br><span class="line">                                           init_data_from_delegate.<span class="built_in">size</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!optional_parameters_from_delegate.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        j_optional_parameters = base::android::<span class="built_in">ToJavaArrayOfStrings</span>(</span><br><span class="line">            env, optional_parameters_from_delegate);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!j_init_data) &#123;</span><br><span class="line">    j_init_data =</span><br><span class="line">        base::android::<span class="built_in">ToJavaByteArray</span>(env, init_data.<span class="built_in">data</span>(), init_data.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ScopedJavaLocalRef&lt;jstring&gt; j_mime =</span><br><span class="line">      <span class="built_in">ConvertUTF8ToJavaString</span>(env, <span class="built_in">ConvertInitDataType</span>(init_data_type));</span><br><span class="line">  <span class="type">uint32_t</span> key_type =</span><br><span class="line">      <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(<span class="built_in">ConvertCdmSessionType</span>(session_type));</span><br><span class="line">  <span class="type">uint32_t</span> promise_id = cdm_promise_adapter_.<span class="built_in">SavePromise</span>(std::<span class="built_in">move</span>(promise));</span><br><span class="line">  <span class="built_in">Java_MediaDrmBridge_createSessionFromNative</span>(</span><br><span class="line">      env, j_media_drm_, j_init_data, j_mime, key_type, j_optional_parameters,</span><br><span class="line">      promise_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面通过 JNI 接口调用到 MediaDrm，这里不深究细节，上面方法最终调用到下面的 java 代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chromium/media/base/android/java/src/org/chromium/media/MediaDrmBridge.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a session, and generate a request with |initData| and |mime|.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param initData Data needed to generate the key request.</span></span><br><span class="line"><span class="comment"> * @param mime Mime type.</span></span><br><span class="line"><span class="comment"> * @param keyType Key type.</span></span><br><span class="line"><span class="comment"> * @param optionalParameters Additional data to pass to getKeyRequest.</span></span><br><span class="line"><span class="comment"> * @param promiseId Promise ID for this call.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">createSession</span><span class="params">(byte[] initData, String mime, <span class="type">int</span> keyType,</span></span></span><br><span class="line"><span class="params"><span class="function">        HashMap&lt;String, String&gt; optionalParameters, <span class="type">long</span> promiseId)</span> </span>&#123;</span><br><span class="line">    Log.<span class="built_in">d</span>(TAG, <span class="string">&quot;createSession()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMediaDrm == null) &#123;</span><br><span class="line">        Log.<span class="built_in">e</span>(TAG, <span class="string">&quot;createSession() called when MediaDrm is null.&quot;</span>);</span><br><span class="line">        <span class="built_in">onPromiseRejected</span>(promiseId, <span class="string">&quot;MediaDrm released previously.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert mMediaCryptoSession != null;</span><br><span class="line">    assert !mProvisioningPending;</span><br><span class="line"></span><br><span class="line">    boolean newSessionOpened = <span class="literal">false</span>;</span><br><span class="line">    SessionId sessionId = null;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        byte[] drmId = <span class="built_in">openSession</span>();</span><br><span class="line">        <span class="keyword">if</span> (drmId == null) &#123;</span><br><span class="line">            <span class="built_in">onPromiseRejected</span>(promiseId, <span class="string">&quot;Open session failed.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        newSessionOpened = <span class="literal">true</span>;</span><br><span class="line">        assert keyType == MediaDrm.KEY_TYPE_STREAMING || keyType == MediaDrm.KEY_TYPE_OFFLINE;</span><br><span class="line">        sessionId = (keyType == MediaDrm.KEY_TYPE_OFFLINE)</span><br><span class="line">                ? SessionId.<span class="built_in">createPersistentSessionId</span>(drmId)</span><br><span class="line">                : SessionId.<span class="built_in">createTemporarySessionId</span>(drmId);</span><br><span class="line"></span><br><span class="line">        MediaDrm.KeyRequest request =</span><br><span class="line">                <span class="built_in">getKeyRequest</span>(sessionId, initData, mime, keyType, optionalParameters);</span><br><span class="line">        <span class="keyword">if</span> (request == null) &#123;</span><br><span class="line">            <span class="built_in">closeSessionNoException</span>(sessionId);</span><br><span class="line">            <span class="built_in">onPromiseRejected</span>(promiseId, <span class="string">&quot;Generate request failed.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Success!</span></span><br><span class="line">        Log.<span class="built_in">d</span>(TAG, <span class="string">&quot;createSession(): Session (%s) created.&quot;</span>, sessionId.<span class="built_in">toHexString</span>());</span><br><span class="line">        <span class="built_in">onPromiseResolvedWithSession</span>(promiseId, sessionId);</span><br><span class="line">        <span class="built_in">onSessionMessage</span>(sessionId, request);</span><br><span class="line">        mSessionManager.<span class="built_in">put</span>(sessionId, mime, keyType);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (android.media.NotProvisionedException e) &#123;</span><br><span class="line">        Log.<span class="built_in">e</span>(TAG, <span class="string">&quot;Device not provisioned&quot;</span>, e);</span><br><span class="line">        <span class="keyword">if</span> (newSessionOpened) &#123;</span><br><span class="line">            <span class="built_in">closeSessionNoException</span>(sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">onPromiseRejected</span>(promiseId, <span class="string">&quot;Device not provisioned during createSession().&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">onPromiseResolvedWithSession</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> promiseId, <span class="keyword">final</span> SessionId sessionId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNativeMediaDrmBridgeValid</span>()) &#123;</span><br><span class="line">        MediaDrmBridgeJni.<span class="built_in">get</span>().<span class="built_in">onPromiseResolvedWithSession</span>(</span><br><span class="line">                mNativeMediaDrmBridge, MediaDrmBridge.<span class="keyword">this</span>, promiseId, sessionId.<span class="built_in">emeId</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="built_in">RequiresApi</span>(Build.VERSION_CODES.M)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">onSessionMessage</span><span class="params">(<span class="keyword">final</span> SessionId sessionId, <span class="keyword">final</span> MediaDrm.KeyRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNativeMediaDrmBridgeValid</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> requestType = MediaDrm.KeyRequest.REQUEST_TYPE_INITIAL;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        requestType = request.<span class="built_in">getRequestType</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Prior to M, getRequestType() is not supported. Do our best guess here: Assume</span></span><br><span class="line">        <span class="comment">// requests with a URL are renewals and all others are initial requests.</span></span><br><span class="line">        requestType = request.<span class="built_in">getDefaultUrl</span>().<span class="built_in">isEmpty</span>()</span><br><span class="line">                ? MediaDrm.KeyRequest.REQUEST_TYPE_INITIAL</span><br><span class="line">                : MediaDrm.KeyRequest.REQUEST_TYPE_RENEWAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MediaDrmBridgeJni.<span class="built_in">get</span>().<span class="built_in">onSessionMessage</span>(mNativeMediaDrmBridge, MediaDrmBridge.<span class="keyword">this</span>,</span><br><span class="line">            sessionId.<span class="built_in">emeId</span>(), requestType, request.<span class="built_in">getData</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面调用了 onPromiseResolvedWithSession 和 onSessionMessage 两个函数，前者 Resolve Promise，后者返回回执信息，这两步是分开的</p><h2 id="MediaDrmBridge-OnPromiseResolvedWithSession"><a href="#MediaDrmBridge-OnPromiseResolvedWithSession" class="headerlink" title="MediaDrmBridge::OnPromiseResolvedWithSession"></a>MediaDrmBridge::OnPromiseResolvedWithSession</h2><p>onPromiseResolvedWithSession 往上会调用到 MediaDrmBridge::OnPromiseResolvedWithSession，从 MediaDrmBridge::OnPromiseResolvedWithSession 开始逐步往上 Resolve Promise</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaDrmBridge::OnPromiseResolvedWithSession</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> JavaParamRef&lt;jobject&gt;&amp; j_media_drm,</span></span></span><br><span class="line"><span class="params"><span class="function">    jint j_promise_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> JavaParamRef&lt;jbyteArray&gt;&amp; j_session_id)</span> </span>&#123;</span><br><span class="line">  std::string session_id;</span><br><span class="line">  <span class="built_in">JavaByteArrayToString</span>(env, j_session_id, &amp;session_id);</span><br><span class="line">  task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">      FROM_HERE, base::<span class="built_in">BindOnce</span>(&amp;MediaDrmBridge::ResolvePromiseWithSession,</span><br><span class="line">                                weak_factory_.<span class="built_in">GetWeakPtr</span>(), j_promise_id,</span><br><span class="line">                                std::<span class="built_in">move</span>(session_id)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaDrmBridge::ResolvePromiseWithSession</span><span class="params">(<span class="type">uint32_t</span> promise_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">const</span> std::string&amp; session_id)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line">  cdm_promise_adapter_.<span class="built_in">ResolvePromise</span>(promise_id, session_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后回到 MojoCdm::OnNewSessionCdmPromiseResult</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MojoCdm::OnNewSessionCdmPromiseResult</span><span class="params">(<span class="type">uint32_t</span> promise_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           mojom::CdmPromiseResultPtr result,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">const</span> std::string&amp; session_id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (result-&gt;success) &#123;</span><br><span class="line">    cdm_session_tracker_.<span class="built_in">AddSession</span>(session_id);</span><br><span class="line">    cdm_promise_adapter_.<span class="built_in">ResolvePromise</span>(promise_id, session_id);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cdm_promise_adapter_.<span class="built_in">RejectPromise</span>(promise_id, result-&gt;exception,</span><br><span class="line">                                       result-&gt;system_code,</span><br><span class="line">                                       result-&gt;error_message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 session_id 返回给上层</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NewSessionCdmResultPromise::resolve</span><span class="params">(<span class="type">const</span> std::string&amp; session_id)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: session_id = &quot;</span> &lt;&lt; session_id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// |new_session_created_cb_| uses a WeakPtr&lt;&gt; and may not do anything</span></span><br><span class="line">  <span class="comment">// if the session object has been destroyed.</span></span><br><span class="line">  SessionInitStatus status = SessionInitStatus::UNKNOWN_STATUS;</span><br><span class="line">  std::<span class="built_in">move</span>(new_session_created_cb_).<span class="built_in">Run</span>(session_id, &amp;status);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!base::<span class="built_in">Contains</span>(expected_statuses_, status)) &#123;</span><br><span class="line">    <span class="built_in">reject</span>(Exception::INVALID_STATE_ERROR, <span class="number">0</span>,</span><br><span class="line">           <span class="string">&quot;Cannot finish session initialization&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MarkPromiseSettled</span>();</span><br><span class="line">  <span class="built_in">ReportCdmResultUMA</span>(key_system_uma_prefix_ + uma_name_, <span class="number">0</span>,</span><br><span class="line">                     <span class="built_in">ConvertStatusToUMAResult</span>(status));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Only report time for promise resolution (not rejection).</span></span><br><span class="line">  base::<span class="built_in">UmaHistogramTimes</span>(key_system_uma_prefix_ + kTimeUMAPrefix + uma_name_,</span><br><span class="line">                          base::TimeTicks::<span class="built_in">Now</span>() - creation_time_);</span><br><span class="line"></span><br><span class="line">  web_cdm_result_.<span class="built_in">CompleteWithSession</span>(<span class="built_in">ConvertStatus</span>(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>new_session_created_cb_</code> 就是 WebContentDecryptionModuleSessionImpl::OnSessionInitialized</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebContentDecryptionModuleSessionImpl::OnSessionInitialized</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    SessionInitStatus* status)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(thread_checker_);</span><br><span class="line">  <span class="comment">// CDM will return NULL if the session to be loaded can&#x27;t be found.</span></span><br><span class="line">  <span class="keyword">if</span> (session_id.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    *status = SessionInitStatus::SESSION_NOT_FOUND;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(session_id_.<span class="built_in">empty</span>()) &lt;&lt; <span class="string">&quot;Session ID may not be changed once set.&quot;</span>;</span><br><span class="line">  session_id_ = session_id;</span><br><span class="line">  *status =</span><br><span class="line">      adapter_-&gt;<span class="built_in">RegisterSession</span>(session_id_, weak_ptr_factory_.<span class="built_in">GetWeakPtr</span>())</span><br><span class="line">          ? SessionInitStatus::NEW_SESSION</span><br><span class="line">          : SessionInitStatus::SESSION_ALREADY_EXISTS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MediaDrmBridge-OnSessionMessage"><a href="#MediaDrmBridge-OnSessionMessage" class="headerlink" title="MediaDrmBridge::OnSessionMessage"></a>MediaDrmBridge::OnSessionMessage</h2><p>将 Cdm 的回执回传是通过另一个接口，也就是 <code>session_message_cb_</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaDrmBridge::OnSessionMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> JavaParamRef&lt;jobject&gt;&amp; j_media_drm,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> JavaParamRef&lt;jbyteArray&gt;&amp; j_session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    jint j_message_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> JavaParamRef&lt;jbyteArray&gt;&amp; j_message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">uint8_t</span>&gt; message;</span><br><span class="line">  <span class="built_in">JavaByteArrayToByteVector</span>(env, j_message, &amp;message);</span><br><span class="line">  CdmMessageType message_type =</span><br><span class="line">      <span class="built_in">GetMessageType</span>(<span class="built_in">static_cast</span>&lt;RequestType&gt;(j_message_type));</span><br><span class="line"></span><br><span class="line">  std::string session_id;</span><br><span class="line">  <span class="built_in">JavaByteArrayToString</span>(env, j_session_id, &amp;session_id);</span><br><span class="line">  task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">      FROM_HERE, base::<span class="built_in">BindOnce</span>(session_message_cb_, std::<span class="built_in">move</span>(session_id),</span><br><span class="line">                                message_type, message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>session_message_cb_</code> 往上会调用到 MojoCdmService::OnSessionMessage</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MojoCdmService::OnSessionMessage</span><span class="params">(<span class="type">const</span> std::string&amp; session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      ::media::CdmMessageType message_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line">  <span class="keyword">if</span> (client_) &#123;</span><br><span class="line">    client_-&gt;<span class="built_in">OnSessionMessage</span>(session_id, message_type, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>client_</code> 是 MojoCdm 构造函数中设置的，这样 MojoCdm 和 MojoCdmService 可以互相调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">MojoCdm::<span class="built_in">MojoCdm</span>(mojo::Remote&lt;mojom::ContentDecryptionModule&gt; remote_cdm,</span><br><span class="line">                 media::mojom::CdmContextPtr cdm_context,</span><br><span class="line">                 <span class="type">const</span> SessionMessageCB&amp; session_message_cb,</span><br><span class="line">                 <span class="type">const</span> SessionClosedCB&amp; session_closed_cb,</span><br><span class="line">                 <span class="type">const</span> SessionKeysChangeCB&amp; session_keys_change_cb,</span><br><span class="line">                 <span class="type">const</span> SessionExpirationUpdateCB&amp; session_expiration_update_cb)</span><br><span class="line">    : <span class="built_in">remote_cdm_</span>(std::<span class="built_in">move</span>(remote_cdm)),</span><br><span class="line">      <span class="built_in">cdm_id_</span>(cdm_context-&gt;cdm_id),</span><br><span class="line">      <span class="built_in">decryptor_remote_</span>(std::<span class="built_in">move</span>(cdm_context-&gt;decryptor)),</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_WIN)</span></span><br><span class="line">      <span class="built_in">requires_media_foundation_renderer_</span>(</span><br><span class="line">          cdm_context-&gt;requires_media_foundation_renderer),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(IS_WIN)</span></span></span><br><span class="line">      <span class="built_in">session_message_cb_</span>(session_message_cb),</span><br><span class="line">      <span class="built_in">session_closed_cb_</span>(session_closed_cb),</span><br><span class="line">      <span class="built_in">session_keys_change_cb_</span>(session_keys_change_cb),</span><br><span class="line">      <span class="built_in">session_expiration_update_cb_</span>(session_expiration_update_cb) &#123;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(thread_checker_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(cdm_id_);</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; cdm_id: &quot;</span></span><br><span class="line">           &lt;&lt; CdmContext::<span class="built_in">CdmIdToString</span>(base::<span class="built_in">OptionalOrNullptr</span>(cdm_id_));</span><br><span class="line">  <span class="built_in">DCHECK</span>(session_message_cb_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(session_closed_cb_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(session_keys_change_cb_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(session_expiration_update_cb_);</span><br><span class="line"></span><br><span class="line">  remote_cdm_-&gt;<span class="built_in">SetClient</span>(client_receiver_.<span class="built_in">BindNewEndpointAndPassRemote</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Report a false event here as a baseline.</span></span><br><span class="line">  <span class="built_in">RecordConnectionError</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, set an error handler to catch the connection error.</span></span><br><span class="line">  remote_cdm_.<span class="built_in">set_disconnect_with_reason_handler</span>(</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;MojoCdm::OnConnectionError, base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MojoCdmService::OnSessionMessage 会通过 mojo 调用到 MojoCdm::OnSessionMessage</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MojoCdm::OnSessionMessage</span><span class="params">(<span class="type">const</span> std::string&amp; session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                               MessageType message_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(thread_checker_);</span><br><span class="line"></span><br><span class="line">  session_message_cb_.<span class="built_in">Run</span>(session_id, message_type, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>session_message_cb_</code> 就是 CdmSessionAdapter::OnSessionMessage</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CdmSessionAdapter::OnSessionMessage</span><span class="params">(<span class="type">const</span> std::string&amp; session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         media::CdmMessageType message_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; message)</span> </span>&#123;</span><br><span class="line">  WebContentDecryptionModuleSessionImpl* session = <span class="built_in">GetSession</span>(session_id);</span><br><span class="line">  <span class="built_in">DLOG_IF</span>(WARNING, !session) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; for unknown session &quot;</span></span><br><span class="line">                             &lt;&lt; session_id;</span><br><span class="line">  <span class="keyword">if</span> (session) &#123;</span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">3</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: session_id = &quot;</span> &lt;&lt; session_id;</span><br><span class="line">    session-&gt;<span class="built_in">OnSessionMessage</span>(message_type, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前已经通过 CdmSessionAdapter::RegisterSession 将 session_id 和 <code>base::WeakPtr&lt;WebContentDecryptionModuleSessionImpl&gt;</code> 进行了关联，上面使用 <code>GetSession(session_id)</code> 获得 session_id 对应的 WebContentDecryptionModuleSessionImpl。再往上就不分析了，最终会把回执传给 javascript，然后 javascript 把回执发给 License 服务器，从 License 服务器得到回应后再调用 MediaKeySession::update</p><h1 id="MediaKeySession-update"><a href="#MediaKeySession-update" class="headerlink" title="MediaKeySession::update"></a>MediaKeySession::update</h1><p>最后再看 update 方法，该方法把 License 服务器的回应下传给 Cdm</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ScriptPromise <span class="title">MediaKeySession::update</span><span class="params">(ScriptState* script_state,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">const</span> DOMArrayPiece&amp; response,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      ExceptionState&amp; exception_state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(MEDIA_KEY_SESSION_LOG_LEVEL) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// From https://w3c.github.io/encrypted-media/#update:</span></span><br><span class="line">  <span class="comment">// Provides messages, including licenses, to the CDM. When this method is</span></span><br><span class="line">  <span class="comment">// invoked, the user agent must run the following steps:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. If this object&#x27;s closing or closed value is true, return a promise</span></span><br><span class="line">  <span class="comment">//    rejected with an InvalidStateError.</span></span><br><span class="line">  <span class="keyword">if</span> (is_closing_ || is_closed_)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CreateRejectedPromiseAlreadyClosed</span>(exception_state);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. If this object&#x27;s callable value is false, return a promise</span></span><br><span class="line">  <span class="comment">//    rejected with an InvalidStateError.</span></span><br><span class="line">  <span class="keyword">if</span> (!is_callable_)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CreateRejectedPromiseNotCallable</span>(exception_state);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. If response is an empty array, return a promise rejected with a</span></span><br><span class="line">  <span class="comment">//    newly created TypeError.</span></span><br><span class="line">  <span class="keyword">if</span> (!response.<span class="built_in">ByteLength</span>()) &#123;</span><br><span class="line">    exception_state.<span class="built_in">ThrowTypeError</span>(<span class="string">&quot;The response parameter is empty.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ScriptPromise</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. Let response copy be a copy of the contents of the response parameter.</span></span><br><span class="line">  DOMArrayBuffer* response_copy =</span><br><span class="line">      DOMArrayBuffer::<span class="built_in">Create</span>(response.<span class="built_in">Data</span>(), response.<span class="built_in">ByteLength</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. Let promise be a new promise.</span></span><br><span class="line">  SimpleResultPromise* result = <span class="built_in">MakeGarbageCollected</span>&lt;SimpleResultPromise&gt;(</span><br><span class="line">      script_state, config_, <span class="keyword">this</span>, EmeApiType::kUpdate);</span><br><span class="line">  ScriptPromise promise = result-&gt;<span class="built_in">Promise</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. Run the following steps asynchronously (done in updateTask())</span></span><br><span class="line">  pending_actions_.<span class="built_in">push_back</span>(</span><br><span class="line">      PendingAction::<span class="built_in">CreatePendingUpdate</span>(result, response_copy));</span><br><span class="line">  <span class="keyword">if</span> (!action_timer_.<span class="built_in">IsActive</span>())</span><br><span class="line">    action_timer_.<span class="built_in">StartOneShot</span>(base::<span class="built_in">TimeDelta</span>(), FROM_HERE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7. Return promise.</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的动作在下面执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaKeySession::UpdateTask</span><span class="params">(ContentDecryptionModuleResult* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 DOMArrayBuffer* sanitized_response)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> Continue step 6 of MediaKeySession::update().</span></span><br><span class="line">  <span class="built_in">DVLOG</span>(MEDIA_KEY_SESSION_LOG_LEVEL) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// update() in Chromium will execute steps 6.1 through 6.8.</span></span><br><span class="line">  session_-&gt;<span class="built_in">Update</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(sanitized_response-&gt;<span class="built_in">Data</span>()),</span><br><span class="line">                   sanitized_response-&gt;<span class="built_in">ByteLength</span>(), result-&gt;<span class="built_in">Result</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Last step (6.8.2 Resolve promise) will be done when |result| is resolved.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>session_</code> 就是 WebContentDecryptionModuleSessionImpl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebContentDecryptionModuleSessionImpl::Update</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">uint8_t</span>* response,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> response_length,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebContentDecryptionModuleResult result)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(response);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!session_id_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(thread_checker_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// From https://w3c.github.io/encrypted-media/#update.</span></span><br><span class="line">  <span class="comment">// 6.1 Let sanitized response be a validated and/or sanitized version of</span></span><br><span class="line">  <span class="comment">//     response copy. The user agent should thoroughly validate the response</span></span><br><span class="line">  <span class="comment">//     before passing it to the CDM. This may include verifying values are</span></span><br><span class="line">  <span class="comment">//     within reasonable limits, stripping irrelevant data or fields,</span></span><br><span class="line">  <span class="comment">//     pre-parsing it, sanitizing it, and/or generating a fully sanitized</span></span><br><span class="line">  <span class="comment">//     version. The user agent should check that the length and values of</span></span><br><span class="line">  <span class="comment">//     fields are reasonable. Unknown fields should be rejected or removed.</span></span><br><span class="line">  <span class="comment">// 6.2 If the preceding step failed, or if sanitized response is empty,</span></span><br><span class="line">  <span class="comment">//     reject promise with a newly created TypeError.</span></span><br><span class="line">  std::vector&lt;<span class="type">uint8_t</span>&gt; sanitized_response;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">SanitizeResponse</span>(adapter_-&gt;<span class="built_in">GetKeySystem</span>(), response, response_length,</span><br><span class="line">                        &amp;sanitized_response)) &#123;</span><br><span class="line">    result.<span class="built_in">CompleteWithError</span>(kWebContentDecryptionModuleExceptionTypeError, <span class="number">0</span>,</span><br><span class="line">                             <span class="string">&quot;Invalid response.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  adapter_-&gt;<span class="built_in">UpdateSession</span>(</span><br><span class="line">      session_id_, sanitized_response,</span><br><span class="line">      std::make_unique&lt;CdmResultPromise&lt;&gt;&gt;(</span><br><span class="line">          result, adapter_-&gt;<span class="built_in">GetKeySystemUMAPrefix</span>(), kUpdateSessionUMAName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>adapter_</code> 就是 CdmSessionAdapter</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CdmSessionAdapter::UpdateSession</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; response,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;media::SimpleCdmPromise&gt; promise)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">3</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: session_id = &quot;</span> &lt;&lt; session_id;</span><br><span class="line">  cdm_-&gt;<span class="built_in">UpdateSession</span>(session_id, response, std::<span class="built_in">move</span>(promise));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CdmSessionAdapter::UpdateSession 调用 MojoCdm::UpdateSession</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MojoCdm::UpdateSession</span><span class="params">(<span class="type">const</span> std::string&amp; session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; response,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::unique_ptr&lt;SimpleCdmPromise&gt; promise)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(thread_checker_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!remote_cdm_) &#123;</span><br><span class="line">    promise-&gt;<span class="built_in">reject</span>(media::CdmPromise::Exception::INVALID_STATE_ERROR, <span class="number">0</span>,</span><br><span class="line">                    <span class="string">&quot;CDM connection lost.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> promise_id = cdm_promise_adapter_.<span class="built_in">SavePromise</span>(std::<span class="built_in">move</span>(promise));</span><br><span class="line">  remote_cdm_-&gt;<span class="built_in">UpdateSession</span>(</span><br><span class="line">      session_id, response,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;MojoCdm::OnSimpleCdmPromiseResult, base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>),</span><br><span class="line">                     promise_id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MojoCdm 调用到 MojoCdmService</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MojoCdmService::UpdateSession</span><span class="params">(<span class="type">const</span> std::string&amp; session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; response,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   UpdateSessionCallback callback)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line">  cdm_-&gt;<span class="built_in">UpdateSession</span>(</span><br><span class="line">      session_id, response,</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;SimpleMojoCdmPromise&gt;(std::<span class="built_in">move</span>(callback)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cdm_</code> 如果是 Android，就是 MediaDrmBridge</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaDrmBridge::UpdateSession</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; response,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;media::SimpleCdmPromise&gt; promise)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line"></span><br><span class="line">  JNIEnv* env = <span class="built_in">AttachCurrentThread</span>();</span><br><span class="line">  ScopedJavaLocalRef&lt;jbyteArray&gt; j_response =</span><br><span class="line">      base::android::<span class="built_in">ToJavaByteArray</span>(env, response.<span class="built_in">data</span>(), response.<span class="built_in">size</span>());</span><br><span class="line">  ScopedJavaLocalRef&lt;jbyteArray&gt; j_session_id =</span><br><span class="line">      <span class="built_in">ToJavaByteArray</span>(env, session_id);</span><br><span class="line">  <span class="type">uint32_t</span> promise_id = cdm_promise_adapter_.<span class="built_in">SavePromise</span>(std::<span class="built_in">move</span>(promise));</span><br><span class="line">  <span class="built_in">Java_MediaDrmBridge_updateSession</span>(env, j_media_drm_, j_session_id, j_response,</span><br><span class="line">                                    promise_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是通过 JNI 调用到下面的 updateSession</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Update a session with response.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param emeSessionId Reference ID of session to be updated.</span></span><br><span class="line"><span class="comment"> * @param response Response data from the server.</span></span><br><span class="line"><span class="comment"> * @param promiseId Promise ID of this call.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@<span class="function">CalledByNative</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">updateSession</span><span class="params">(byte[] emeSessionId, byte[] response, <span class="keyword">final</span> <span class="type">long</span> promiseId)</span> </span>&#123;</span><br><span class="line">    Log.<span class="built_in">d</span>(TAG, <span class="string">&quot;updateSession()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (mMediaDrm == null) &#123;</span><br><span class="line">        <span class="built_in">onPromiseRejected</span>(promiseId, <span class="string">&quot;updateSession() called when MediaDrm is null.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SessionId sessionId = <span class="built_in">getSessionIdByEmeId</span>(emeSessionId);</span><br><span class="line">    <span class="keyword">if</span> (sessionId == null) &#123;</span><br><span class="line">        assert <span class="literal">false</span>; <span class="comment">// Should never happen.</span></span><br><span class="line">        <span class="built_in">onPromiseRejected</span>(promiseId,</span><br><span class="line">                <span class="string">&quot;Invalid session in updateSession: &quot;</span> + SessionId.<span class="built_in">toHexString</span>(emeSessionId));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SessionInfo sessionInfo = mSessionManager.<span class="built_in">get</span>(sessionId);</span><br><span class="line">        boolean isKeyRelease = sessionInfo.<span class="built_in">keyType</span>() == MediaDrm.KEY_TYPE_RELEASE;</span><br><span class="line"></span><br><span class="line">        byte[] keySetId = null;</span><br><span class="line">        <span class="keyword">if</span> (isKeyRelease) &#123;</span><br><span class="line">            Log.<span class="built_in">d</span>(TAG, <span class="string">&quot;updateSession() for key release&quot;</span>);</span><br><span class="line">            assert sessionId.<span class="built_in">keySetId</span>() != null;</span><br><span class="line">            mMediaDrm.<span class="built_in">provideKeyResponse</span>(sessionId.<span class="built_in">keySetId</span>(), response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            keySetId = mMediaDrm.<span class="built_in">provideKeyResponse</span>(sessionId.<span class="built_in">drmId</span>(), response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        KeyUpdatedCallback cb = <span class="keyword">new</span> <span class="built_in">KeyUpdatedCallback</span>(sessionId, promiseId, isKeyRelease);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isKeyRelease) &#123;</span><br><span class="line">            mSessionManager.<span class="built_in">clearPersistentSessionInfo</span>(sessionId, cb);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sessionInfo.<span class="built_in">keyType</span>() == MediaDrm.KEY_TYPE_OFFLINE &amp;&amp; keySetId != null</span><br><span class="line">                &amp;&amp; keySetId.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mSessionManager.<span class="built_in">setKeySetId</span>(sessionId, keySetId, cb);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This can be either temporary license update or server certificate update.</span></span><br><span class="line">            cb.<span class="built_in">onResult</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (android.media.NotProvisionedException e) &#123;</span><br><span class="line">        <span class="comment">// TODO(xhwang): Should we handle this?</span></span><br><span class="line">        Log.<span class="built_in">e</span>(TAG, <span class="string">&quot;failed to provide key response&quot;</span>, e);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (android.media.DeniedByServerException e) &#123;</span><br><span class="line">        Log.<span class="built_in">e</span>(TAG, <span class="string">&quot;failed to provide key response&quot;</span>, e);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (java.lang.IllegalStateException e) &#123;</span><br><span class="line">        Log.<span class="built_in">e</span>(TAG, <span class="string">&quot;failed to provide key response&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">onPromiseRejected</span>(promiseId, <span class="string">&quot;Update session failed.&quot;</span>);</span><br><span class="line">    <span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数在 <code>cb.onResult(true);</code> 中调用回调</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">KeyUpdatedCallback</span> implements Callback&lt;Boolean&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SessionId mSessionId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> mPromiseId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> boolean mIsKeyRelease;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeyUpdatedCallback</span>(SessionId sessionId, <span class="type">long</span> promiseId, boolean isKeyRelease) &#123;</span><br><span class="line">        mSessionId = sessionId;</span><br><span class="line">        mPromiseId = promiseId;</span><br><span class="line">        mIsKeyRelease = isKeyRelease;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">onResult</span><span class="params">(Boolean success)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="built_in">onPromiseRejected</span>(mPromiseId, <span class="string">&quot;failed to update key after response accepted&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.<span class="built_in">d</span>(TAG, <span class="string">&quot;Key successfully %s for session %s&quot;</span>, mIsKeyRelease ? <span class="string">&quot;released&quot;</span> : <span class="string">&quot;added&quot;</span>,</span><br><span class="line">                mSessionId.<span class="built_in">toHexString</span>());</span><br><span class="line">        <span class="built_in">onPromiseResolved</span>(mPromiseId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mIsKeyRelease &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) &#123;</span><br><span class="line">            <span class="built_in">onSessionKeysChange</span>(mSessionId,</span><br><span class="line">                    <span class="built_in">getDummyKeysInfo</span>(MediaDrm.KeyStatus.STATUS_USABLE).<span class="built_in">toArray</span>(), <span class="literal">true</span>,</span><br><span class="line">                    mIsKeyRelease);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是分成两个，一个是 OnPromiseResolved，一个是 OnSessionKeysChange</p><h2 id="MediaDrmBridge-OnPromiseResolved"><a href="#MediaDrmBridge-OnPromiseResolved" class="headerlink" title="MediaDrmBridge::OnPromiseResolved"></a>MediaDrmBridge::OnPromiseResolved</h2><p>这个函数会一直向上调用，逐步 Resolve Promise</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaDrmBridge::OnPromiseResolved</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> JavaParamRef&lt;jobject&gt;&amp; j_media_drm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       jint j_promise_id)</span> </span>&#123;</span><br><span class="line">  task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">      FROM_HERE, base::<span class="built_in">BindOnce</span>(&amp;MediaDrmBridge::ResolvePromise,</span><br><span class="line">                                weak_factory_.<span class="built_in">GetWeakPtr</span>(), j_promise_id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MediaDrmBridge-OnSessionKeysChange"><a href="#MediaDrmBridge-OnSessionKeysChange" class="headerlink" title="MediaDrmBridge::OnSessionKeysChange"></a>MediaDrmBridge::OnSessionKeysChange</h2><p>OnSessionKeysChange 则是更新 key 的状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaDrmBridge::OnSessionKeysChange</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> JavaParamRef&lt;jobject&gt;&amp; j_media_drm,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> JavaParamRef&lt;jbyteArray&gt;&amp; j_session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> JavaParamRef&lt;jobjectArray&gt;&amp; j_keys_info,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> has_additional_usable_key,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> is_key_release)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line"></span><br><span class="line">  CdmKeysInfo cdm_keys_info;</span><br><span class="line"></span><br><span class="line">  <span class="function">JavaObjectArrayReader&lt;jobject&gt; <span class="title">j_keys_info_array</span><span class="params">(j_keys_info)</span></span>;</span><br><span class="line">  <span class="built_in">DCHECK_GT</span>(j_keys_info_array.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> j_key_status : j_keys_info_array) &#123;</span><br><span class="line">    ScopedJavaLocalRef&lt;jbyteArray&gt; j_key_id =</span><br><span class="line">        <span class="built_in">Java_KeyStatus_getKeyId</span>(env, j_key_status);</span><br><span class="line">    std::vector&lt;<span class="type">uint8_t</span>&gt; key_id;</span><br><span class="line">    <span class="built_in">JavaByteArrayToByteVector</span>(env, j_key_id, &amp;key_id);</span><br><span class="line">    <span class="built_in">DCHECK</span>(!key_id.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">    jint j_status_code = <span class="built_in">Java_KeyStatus_getStatusCode</span>(env, j_key_status);</span><br><span class="line">    CdmKeyInformation::KeyStatus key_status =</span><br><span class="line">        <span class="built_in">ConvertKeyStatus</span>(<span class="built_in">static_cast</span>&lt;KeyStatus&gt;(j_status_code), is_key_release);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;Key status change: &quot;</span></span><br><span class="line">             &lt;&lt; base::<span class="built_in">HexEncode</span>(&amp;key_id[<span class="number">0</span>], key_id.<span class="built_in">size</span>()) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">             &lt;&lt; key_status;</span><br><span class="line"></span><br><span class="line">    cdm_keys_info.<span class="built_in">push_back</span>(</span><br><span class="line">        std::<span class="built_in">make_unique</span>&lt;CdmKeyInformation&gt;(key_id, key_status, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string session_id;</span><br><span class="line">  <span class="built_in">JavaByteArrayToString</span>(env, j_session_id, &amp;session_id);</span><br><span class="line">  task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">      FROM_HERE,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(session_keys_change_cb_, std::<span class="built_in">move</span>(session_id),</span><br><span class="line">                     has_additional_usable_key, std::<span class="built_in">move</span>(cdm_keys_info)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (has_additional_usable_key) &#123;</span><br><span class="line">    task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">        FROM_HERE, base::<span class="built_in">BindOnce</span>(&amp;MediaDrmBridge::OnHasAdditionalUsableKey,</span><br><span class="line">                                  weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>session_keys_change_cb_</code> 就是 MojoCdmService::OnSessionKeysChange</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MojoCdmService::OnSessionKeysChange</span><span class="params">(<span class="type">const</span> std::string&amp; session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">bool</span> has_additional_usable_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         CdmKeysInfo keys_info)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__</span><br><span class="line">           &lt;&lt; <span class="string">&quot; has_additional_usable_key = &quot;</span> &lt;&lt; has_additional_usable_key;</span><br><span class="line">  <span class="keyword">if</span> (client_) &#123;</span><br><span class="line">    client_-&gt;<span class="built_in">OnSessionKeysChange</span>(session_id, has_additional_usable_key,</span><br><span class="line">                                 std::<span class="built_in">move</span>(keys_info));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MojoCdmService 调用 MojoCdm</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MojoCdm::OnSessionKeysChange</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> has_additional_usable_key,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;std::unique_ptr&lt;CdmKeyInformation&gt;&gt; keys_info)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(thread_checker_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (has_additional_usable_key)</span><br><span class="line">    event_callbacks_.<span class="built_in">Notify</span>(Event::kHasAdditionalUsableKey);</span><br><span class="line"></span><br><span class="line">  session_keys_change_cb_.<span class="built_in">Run</span>(session_id, has_additional_usable_key,</span><br><span class="line">                              std::<span class="built_in">move</span>(keys_info));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>session_keys_change_cb_</code> 是 CdmSessionAdapter::OnSessionKeysChange</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CdmSessionAdapter::OnSessionKeysChange</span><span class="params">(<span class="type">const</span> std::string&amp; session_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">bool</span> has_additional_usable_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            media::CdmKeysInfo keys_info)</span> </span>&#123;</span><br><span class="line">  WebContentDecryptionModuleSessionImpl* session = <span class="built_in">GetSession</span>(session_id);</span><br><span class="line">  <span class="built_in">DLOG_IF</span>(WARNING, !session) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; for unknown session &quot;</span></span><br><span class="line">                             &lt;&lt; session_id;</span><br><span class="line">  <span class="keyword">if</span> (session) &#123;</span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: session_id = &quot;</span> &lt;&lt; session_id;</span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;  - has_additional_usable_key = &quot;</span> &lt;&lt; has_additional_usable_key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info : keys_info)</span><br><span class="line">      <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;  - &quot;</span> &lt;&lt; *(info.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    session-&gt;<span class="built_in">OnSessionKeysChange</span>(has_additional_usable_key,</span><br><span class="line">                                 std::<span class="built_in">move</span>(keys_info));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用 WebContentDecryptionModuleSessionImpl::OnSessionKeysChange</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebContentDecryptionModuleSessionImpl::OnSessionKeysChange</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> has_additional_usable_key,</span></span></span><br><span class="line"><span class="params"><span class="function">    media::CdmKeysInfo keys_info)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(thread_checker_);</span><br><span class="line">  <span class="function">WebVector&lt;WebEncryptedMediaKeyInformation&gt; <span class="title">keys</span><span class="params">(keys_info.size())</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; keys_info.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; key_info = keys_info[i];</span><br><span class="line">    keys[i].<span class="built_in">SetId</span>(<span class="built_in">WebData</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;key_info-&gt;key_id[<span class="number">0</span>]),</span><br><span class="line">                          key_info-&gt;key_id.<span class="built_in">size</span>()));</span><br><span class="line">    keys[i].<span class="built_in">SetStatus</span>(<span class="built_in">ConvertCdmKeyStatus</span>(key_info-&gt;status));</span><br><span class="line">    keys[i].<span class="built_in">SetSystemCode</span>(key_info-&gt;system_code);</span><br><span class="line"></span><br><span class="line">    base::<span class="built_in">UmaHistogramSparse</span>(</span><br><span class="line">        adapter_-&gt;<span class="built_in">GetKeySystemUMAPrefix</span>() + kKeyStatusSystemCodeUMAName,</span><br><span class="line">        key_info-&gt;system_code);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now send the event to blink.</span></span><br><span class="line">  client_-&gt;<span class="built_in">OnSessionKeysChange</span>(keys, has_additional_usable_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>client_</code> 就是 MediaKeySession</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaKeySession::OnSessionKeysChange</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebVector&lt;WebEncryptedMediaKeyInformation&gt;&amp; keys,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> has_additional_usable_key)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(MEDIA_KEY_SESSION_LOG_LEVEL)</span><br><span class="line">      &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;) with &quot;</span> &lt;&lt; keys.<span class="built_in">size</span>()</span><br><span class="line">      &lt;&lt; <span class="string">&quot; keys and hasAdditionalUsableKey is &quot;</span></span><br><span class="line">      &lt;&lt; (has_additional_usable_key ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// From https://w3c.github.io/encrypted-media/#update-key-statuses:</span></span><br><span class="line">  <span class="comment">// The following steps are run:</span></span><br><span class="line">  <span class="comment">// 1. Let the session be the associated MediaKeySession object.</span></span><br><span class="line">  <span class="comment">// 2. Let the input statuses be the sequence of pairs key ID and</span></span><br><span class="line">  <span class="comment">//    associated MediaKeyStatus pairs.</span></span><br><span class="line">  <span class="comment">// 3. Let the statuses be session&#x27;s keyStatuses attribute.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. Run the following steps to replace the contents of statuses:</span></span><br><span class="line">  <span class="comment">// 4.1 Empty statuses.</span></span><br><span class="line">  key_statuses_map_-&gt;<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.2 For each pair in input statuses.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; keys.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 4.2.1 Let pair be the pair.</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; key = keys[i];</span><br><span class="line">    <span class="comment">// 4.2.2 Insert an entry for pair&#x27;s key ID into statuses with the</span></span><br><span class="line">    <span class="comment">//       value of pair&#x27;s MediaKeyStatus value.</span></span><br><span class="line">    key_statuses_map_-&gt;<span class="built_in">AddEntry</span>(</span><br><span class="line">        key.<span class="built_in">Id</span>(), EncryptedMediaUtils::<span class="built_in">ConvertKeyStatusToString</span>(key.<span class="built_in">Status</span>()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. Queue a task to fire a simple event named keystatuseschange</span></span><br><span class="line">  <span class="comment">//    at the session.</span></span><br><span class="line">  Event* event = Event::<span class="built_in">Create</span>(event_type_names::kKeystatuseschange);</span><br><span class="line">  event-&gt;<span class="built_in">SetTarget</span>(<span class="keyword">this</span>);</span><br><span class="line">  async_event_queue_-&gt;<span class="built_in">EnqueueEvent</span>(FROM_HERE, *event);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. Queue a task to run the attempt to resume playback if necessary</span></span><br><span class="line">  <span class="comment">//    algorithm on each of the media element(s) whose mediaKeys attribute</span></span><br><span class="line">  <span class="comment">//    is the MediaKeys object that created the session. The user agent</span></span><br><span class="line">  <span class="comment">//    may choose to skip this step if it knows resuming will fail.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">FIXME:</span> Attempt to resume playback if |hasAdditionalUsableKey| is true.</span></span><br><span class="line">  <span class="comment">// http://crbug.com/413413</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就把 EME 的基本流程介绍完了。笔者之前做的项目就是把厂商提供的 CDM 库对接到 Chromium，基本上也是仿照 MediaDrmBridge 写的。</p><p>上面的流程中还没有看到具体的视频&#x2F;音频数据是如何解密的，这部分放在后面 WebMediaPlayer 中再介绍。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium 多媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium 多媒体（五）</title>
      <link href="/2023/06/30/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2023/06/30/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这篇文章继续介绍 EME 相关的内容</p><p>在上一篇文章的最后创建了 WebContentDecryptionModuleAccessImpl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebEncryptedMediaClientImpl::OnConfigSelected</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WebEncryptedMediaRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">    KeySystemConfigSelector::Status status,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebMediaKeySystemConfiguration* accumulated_configuration,</span></span></span><br><span class="line"><span class="params"><span class="function">    media::CdmConfig* cdm_config)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  request.<span class="built_in">RequestSucceeded</span>(WebContentDecryptionModuleAccessImpl::<span class="built_in">Create</span>(</span><br><span class="line">      origin, *accumulated_configuration, *cdm_config,</span><br><span class="line">      weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;WebContentDecryptionModuleAccessImpl&gt;</span></span><br><span class="line"><span class="function"><span class="title">WebContentDecryptionModuleAccessImpl::Create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebSecurityOrigin&amp; security_origin,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebMediaKeySystemConfiguration&amp; configuration,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> media::CdmConfig&amp; cdm_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> base::WeakPtr&lt;WebEncryptedMediaClientImpl&gt;&amp; client)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WebContentDecryptionModuleAccessImpl&gt;(</span><br><span class="line">      security_origin, configuration, cdm_config, client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 MediaKeySystemAccessInitializer::RequestSucceeded 中用 WebContentDecryptionModuleAccess 创建了 MediaKeySystemAccess</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaKeySystemAccessInitializer::RequestSucceeded</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;WebContentDecryptionModuleAccess&gt; access)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">3</span>) &lt;&lt; __func__;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsExecutionContextValid</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  resolver_-&gt;<span class="built_in">Resolve</span>(</span><br><span class="line">      <span class="built_in">MakeGarbageCollected</span>&lt;MediaKeySystemAccess&gt;(std::<span class="built_in">move</span>(access)));</span><br><span class="line">  resolver_.<span class="built_in">Clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MediaKeySystemAccess-createMediaKeys"><a href="#MediaKeySystemAccess-createMediaKeys" class="headerlink" title="MediaKeySystemAccess::createMediaKeys"></a>MediaKeySystemAccess::createMediaKeys</h1><p>接下来就是使用 MediaKeySystemAccess::createMediaKeys 来创建 MediaKeys</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ScriptPromise <span class="title">MediaKeySystemAccess::createMediaKeys</span><span class="params">(ScriptState* script_state)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// From http://w3c.github.io/encrypted-media/#createMediaKeys</span></span><br><span class="line">  <span class="comment">// (Reordered to be able to pass values into the promise constructor.)</span></span><br><span class="line">  <span class="comment">// 2.4 Let configuration be the value of this object&#x27;s configuration value.</span></span><br><span class="line">  <span class="comment">// 2.5-2.8. [Set use distinctive identifier and persistent state allowed</span></span><br><span class="line">  <span class="comment">//          based on configuration.]</span></span><br><span class="line">  WebMediaKeySystemConfiguration configuration = access_-&gt;<span class="built_in">GetConfiguration</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. Let promise be a new promise.</span></span><br><span class="line">  MediaKeysConfig config = &#123;<span class="built_in">keySystem</span>(), <span class="built_in">UseHardwareSecureCodecs</span>()&#125;;</span><br><span class="line">  NewCdmResultPromise* helper = <span class="built_in">MakeGarbageCollected</span>&lt;NewCdmResultPromise&gt;(</span><br><span class="line">      script_state, config, configuration.session_types);</span><br><span class="line">  ScriptPromise promise = helper-&gt;<span class="built_in">Promise</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. Asynchronously create and initialize the MediaKeys object.</span></span><br><span class="line">  <span class="comment">// 2.1 Let cdm be the CDM corresponding to this object.</span></span><br><span class="line">  <span class="comment">// 2.2 Load and initialize the cdm if necessary.</span></span><br><span class="line">  <span class="comment">// 2.3 If cdm fails to load or initialize, reject promise with a new</span></span><br><span class="line">  <span class="comment">//     DOMException whose name is the appropriate error name.</span></span><br><span class="line">  <span class="comment">//     (Done if completeWithException() called).</span></span><br><span class="line">  <span class="keyword">auto</span>* execution_context = ExecutionContext::<span class="built_in">From</span>(script_state);</span><br><span class="line">  access_-&gt;<span class="built_in">CreateContentDecryptionModule</span>(</span><br><span class="line">      helper-&gt;<span class="built_in">Result</span>(),</span><br><span class="line">      execution_context-&gt;<span class="built_in">GetTaskRunner</span>(TaskType::kInternalMedia));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReportMetrics</span>(execution_context, <span class="built_in">keySystem</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. Return promise.</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MediaKeySystemAccess::createMediaKeys 内部调用 WebContentDecryptionModuleAccessImpl::CreateContentDecryptionModule</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebContentDecryptionModuleAccessImpl::CreateContentDecryptionModule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WebContentDecryptionModuleResult result,</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt; task_runner)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This method needs to run asynchronously, as it may need to load the CDM.</span></span><br><span class="line">  <span class="comment">// As this object&#x27;s lifetime is controlled by MediaKeySystemAccess on the</span></span><br><span class="line">  <span class="comment">// blink side, copy all values needed by CreateCdm() in case the blink object</span></span><br><span class="line">  <span class="comment">// gets garbage-collected.</span></span><br><span class="line">  <span class="function">std::unique_ptr&lt;WebContentDecryptionModuleResult&gt; <span class="title">result_copy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">new</span> WebContentDecryptionModuleResult(result))</span></span>;</span><br><span class="line">  task_runner-&gt;<span class="built_in">PostTask</span>(FROM_HERE,</span><br><span class="line">                        base::<span class="built_in">BindOnce</span>(&amp;CreateCdm, client_, security_origin_,</span><br><span class="line">                                       cdm_config_, std::<span class="built_in">move</span>(result_copy)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 WebContentDecryptionModuleAccessImpl::CreateContentDecryptionModule 内部又调用了 CreateCdm 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The caller owns the created cdm (passed back using |result|).</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">CreateCdm</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> base::WeakPtr&lt;WebEncryptedMediaClientImpl&gt;&amp; client,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebSecurityOrigin&amp; security_origin,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> media::CdmConfig&amp; cdm_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;WebContentDecryptionModuleResult&gt; result)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// If |client| is gone (due to the frame getting destroyed), it is</span></span><br><span class="line">  <span class="comment">// impossible to create the CDM, so fail.</span></span><br><span class="line">  <span class="keyword">if</span> (!client) &#123;</span><br><span class="line">    result-&gt;<span class="built_in">CompleteWithError</span>(</span><br><span class="line">        kWebContentDecryptionModuleExceptionInvalidStateError, <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;Failed to create CDM.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  client-&gt;<span class="built_in">CreateCdm</span>(security_origin, cdm_config, std::<span class="built_in">move</span>(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CreateCdm 函数内部调用<strong>WebEncryptedMediaClientImpl::CreateCdm</strong>，注意 WebContentDecryptionModuleAccessImpl 中有 WebEncryptedMediaClientImpl 的 WeakPtr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebEncryptedMediaClientImpl::CreateCdm</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebSecurityOrigin&amp; security_origin,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> media::CdmConfig&amp; cdm_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;WebContentDecryptionModuleResult&gt; result)</span> </span>&#123;</span><br><span class="line">  WebContentDecryptionModuleImpl::<span class="built_in">Create</span>(</span><br><span class="line">      cdm_factory_, security_origin, cdm_config,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;CompleteWebContentDecryptionModuleResult,</span><br><span class="line">                     std::<span class="built_in">move</span>(result)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebContentDecryptionModuleImpl-Create"><a href="#WebContentDecryptionModuleImpl-Create" class="headerlink" title="WebContentDecryptionModuleImpl::Create"></a>WebContentDecryptionModuleImpl::Create</h2><p>WebContentDecryptionModuleImpl::Create 内部通过 CdmSessionAdapter 去创建 CDM</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebContentDecryptionModuleImpl::Create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    media::CdmFactory* cdm_factory,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebSecurityOrigin&amp; security_origin,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> media::CdmConfig&amp; cdm_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebCdmCreatedCB web_cdm_created_cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(!security_origin.<span class="built_in">IsNull</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> key_system = cdm_config.key_system;</span><br><span class="line">  <span class="built_in">DCHECK</span>(!key_system.<span class="built_in">empty</span>());</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(ddorwin): This should be a DCHECK.</span></span><br><span class="line">  <span class="keyword">if</span> (!media::KeySystems::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">IsSupportedKeySystem</span>(key_system)) &#123;</span><br><span class="line">    std::string message = <span class="string">&quot;Keysystem &#x27;&quot;</span> + key_system + <span class="string">&quot;&#x27; is not supported.&quot;</span>;</span><br><span class="line">    std::<span class="built_in">move</span>(web_cdm_created_cb).<span class="built_in">Run</span>(<span class="literal">nullptr</span>, message);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If opaque security origin, don&#x27;t try to create the CDM.</span></span><br><span class="line">  <span class="keyword">if</span> (security_origin.<span class="built_in">IsOpaque</span>() || security_origin.<span class="built_in">ToString</span>() == <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">    std::<span class="built_in">move</span>(web_cdm_created_cb)</span><br><span class="line">        .<span class="built_in">Run</span>(<span class="literal">nullptr</span>, <span class="string">&quot;EME use is not allowed on unique origins.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CdmSessionAdapter::CreateCdm() will keep a reference to |adapter|. Then</span></span><br><span class="line">  <span class="comment">// if WebContentDecryptionModuleImpl is successfully created (returned in</span></span><br><span class="line">  <span class="comment">// |web_cdm_created_cb|), it will keep a reference to |adapter|. Otherwise,</span></span><br><span class="line">  <span class="comment">// |adapter| will be destructed.</span></span><br><span class="line">  <span class="function">scoped_refptr&lt;CdmSessionAdapter&gt; <span class="title">adapter</span><span class="params">(<span class="keyword">new</span> CdmSessionAdapter())</span></span>;</span><br><span class="line">  adapter-&gt;<span class="built_in">CreateCdm</span>(cdm_factory, cdm_config, std::<span class="built_in">move</span>(web_cdm_created_cb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CdmSessionAdapter 内部使用 cdm_factory 创建 CDM</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CdmSessionAdapter::CreateCdm</span><span class="params">(media::CdmFactory* cdm_factory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> media::CdmConfig&amp; cdm_config,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  WebCdmCreatedCB web_cdm_created_cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_BEGIN0</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;CdmSessionAdapter::CreateCdm&quot;</span>,</span><br><span class="line">                                    ++trace_id_);</span><br><span class="line"></span><br><span class="line">  base::TimeTicks start_time = base::TimeTicks::<span class="built_in">Now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: WebContentDecryptionModuleImpl::Create() calls this method without</span></span><br><span class="line">  <span class="comment">// holding a reference to the CdmSessionAdapter. Bind OnCdmCreated() with</span></span><br><span class="line">  <span class="comment">// |this| instead of |weak_this| to prevent |this| from being destructed.</span></span><br><span class="line">  base::WeakPtr&lt;CdmSessionAdapter&gt; weak_this = weak_ptr_factory_.<span class="built_in">GetWeakPtr</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(!web_cdm_created_cb_);</span><br><span class="line">  web_cdm_created_cb_ = std::<span class="built_in">move</span>(web_cdm_created_cb);</span><br><span class="line"></span><br><span class="line">  cdm_factory-&gt;<span class="built_in">Create</span>(</span><br><span class="line">      cdm_config,</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;CdmSessionAdapter::OnSessionMessage, weak_this),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;CdmSessionAdapter::OnSessionClosed, weak_this),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;CdmSessionAdapter::OnSessionKeysChange, weak_this),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;CdmSessionAdapter::OnSessionExpirationUpdate,</span><br><span class="line">                          weak_this),</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;CdmSessionAdapter::OnCdmCreated, &lt;strong&gt;<span class="keyword">this</span>&lt;/strong&gt;, cdm_config,</span><br><span class="line">                     start_time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CdmFactory 是在 MediaFactory::GetCdmFactory 中创建的，在该函数中可以配置使用哪个 CdmFactory</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">media::CdmFactory* <span class="title">MediaFactory::GetCdmFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cdm_factory_)</span><br><span class="line">    <span class="keyword">return</span> cdm_factory_.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_FUCHSIA)</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(interface_broker_);</span><br><span class="line">  cdm_factory_ = media::<span class="built_in">CreateFuchsiaCdmFactory</span>(interface_broker_);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BUILDFLAG(ENABLE_MOJO_CDM)</span></span><br><span class="line">  cdm_factory_ =</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;media::MojoCdmFactory&gt;(<span class="built_in">GetMediaInterfaceFactory</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  cdm_factory_ = std::<span class="built_in">make_unique</span>&lt;media::DefaultCdmFactory&gt;();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(ENABLE_MOJO_CDM)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cdm_factory_.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如可以使用 MojoCdmFactory</p><p>MojoCdmFactory 中持有 media::mojom::InterfaceFactory 指针，也就是 MediaInterfaceFactory 的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">media::<span class="function">mojom::InterfaceFactory* <span class="title">MediaFactory::GetMediaInterfaceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(interface_broker_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!media_interface_factory_) &#123;</span><br><span class="line">    media_interface_factory_ =</span><br><span class="line">        std::<span class="built_in">make_unique</span>&lt;MediaInterfaceFactory&gt;(interface_broker_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> media_interface_factory_.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MojoCdmFactory::Create 函数内部则是通过内部 <code>interface_factory_</code>，也就是 MediaInterfaceFactory 的 CreateCdm 方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MojoCdmFactory::Create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> CdmConfig&amp; cdm_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SessionMessageCB&amp; session_message_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SessionClosedCB&amp; session_closed_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SessionKeysChangeCB&amp; session_keys_change_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SessionExpirationUpdateCB&amp; session_expiration_update_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    CdmCreatedCB cdm_created_cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: cdm_config=&quot;</span> &lt;&lt; cdm_config;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If AesDecryptor can be used, always use it here in the local process.</span></span><br><span class="line">  <span class="comment">// Note: We should not run AesDecryptor in the browser process except for</span></span><br><span class="line">  <span class="comment">// testing. See http://crbug.com/441957.</span></span><br><span class="line">  <span class="comment">// Note: Previously MojoRenderer doesn&#x27;t work with local CDMs, this has</span></span><br><span class="line">  <span class="comment">// been solved by using DecryptingRenderer. See http://crbug.com/913775.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CanUseAesDecryptor</span>(cdm_config.key_system)) &#123;</span><br><span class="line">    <span class="function">scoped_refptr&lt;ContentDecryptionModule&gt; <span class="title">cdm</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> AesDecryptor(session_message_cb, session_closed_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                         session_keys_change_cb, session_expiration_update_cb))</span></span>;</span><br><span class="line">    base::ThreadTaskRunnerHandle::<span class="built_in">Get</span>()-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">        FROM_HERE, base::<span class="built_in">BindOnce</span>(std::<span class="built_in">move</span>(cdm_created_cb), cdm, <span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use `mojo::WrapCallbackWithDefaultInvokeIfNotRun()` in case the CDM process</span></span><br><span class="line">  <span class="comment">// crashes.</span></span><br><span class="line">  interface_factory_-&gt;<span class="built_in">CreateCdm</span>(</span><br><span class="line">      cdm_config,</span><br><span class="line">      mojo::<span class="built_in">WrapCallbackWithDefaultInvokeIfNotRun</span>(</span><br><span class="line">          base::<span class="built_in">BindOnce</span>(&amp;OnCdmCreated, session_message_cb, session_closed_cb,</span><br><span class="line">                         session_keys_change_cb, session_expiration_update_cb,</span><br><span class="line">                         std::<span class="built_in">move</span>(cdm_created_cb)),</span><br><span class="line">          mojo::<span class="built_in">NullRemote</span>(), <span class="literal">nullptr</span>, <span class="string">&quot;disconnection error&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MediaInterfaceFactory::CreateCdm 函数使用自己内部对象 <code>media_interface_factory_</code> 的 CreateCdm 方法，而 <code>media_interface_factory_</code> 是 <code>mojo::Remote&lt;media::mojom::InterfaceFactory&gt;</code>，它的另一端是 MediaInterfaceProxy，而 MediaInterfaceProxy 中有 MediaInterfaceFactoryHolder 类的对象，MediaInterfaceFactoryHolder 中有 <code>mojo::Remote&lt;media::mojom::InterfaceFactory&gt;</code> 对象，该对象的另一端是 InterfaceFactoryImpl，所以 MediaInterfaceFactory::CreateCdm 会调用 MediaInterfaceProxy::CreateCdm，然后调用 InterfaceFactoryImpl::CreateCdm</p><h3 id="MediaInterfaceFactory-CreateCdm"><a href="#MediaInterfaceFactory-CreateCdm" class="headerlink" title="MediaInterfaceFactory::CreateCdm"></a>MediaInterfaceFactory::CreateCdm</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaInterfaceFactory::CreateCdm</span><span class="params">(<span class="type">const</span> media::CdmConfig&amp; cdm_config,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      CreateCdmCallback callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>()) &#123;</span><br><span class="line">    task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">        FROM_HERE, base::<span class="built_in">BindOnce</span>(&amp;MediaInterfaceFactory::CreateCdm, weak_this_,</span><br><span class="line">                                  cdm_config, std::<span class="built_in">move</span>(callback)));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: cdm_config=&quot;</span> &lt;&lt; cdm_config;</span><br><span class="line">  <span class="built_in">GetMediaInterfaceFactory</span>()-&gt;<span class="built_in">CreateCdm</span>(cdm_config, std::<span class="built_in">move</span>(callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">media::<span class="function">mojom::InterfaceFactory*</span></span><br><span class="line"><span class="function"><span class="title">MediaInterfaceFactory::GetMediaInterfaceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__;</span><br><span class="line">  <span class="built_in">DCHECK</span>(task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!media_interface_factory_) &#123;</span><br><span class="line">    interface_broker_-&gt;<span class="built_in">GetInterface</span>(</span><br><span class="line">        media_interface_factory_.<span class="built_in">BindNewPipeAndPassReceiver</span>());</span><br><span class="line">    media_interface_factory_.<span class="built_in">set_disconnect_handler</span>(base::<span class="built_in">BindOnce</span>(</span><br><span class="line">        &amp;MediaInterfaceFactory::OnConnectionError, base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> media_interface_factory_.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MediaInterfaceProxy::CreateCdm 内部使用 <code>media_interface_factory_ptr_</code> 的 CreateCdm 方法，<code>media_interface_factory_ptr_</code> 是 <code>std::unique_ptr&lt;MediaInterfaceFactoryHolder&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaInterfaceProxy::CreateCdm</span><span class="params">(<span class="type">const</span> media::CdmConfig&amp; cdm_config,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    CreateCdmCallback create_cdm_cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(thread_checker_.<span class="built_in">CalledOnValidThread</span>());</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: cdm_config=&quot;</span> &lt;&lt; cdm_config;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The remote process may drop the callback (e.g. in case of crash, or CDM</span></span><br><span class="line">  <span class="comment">// loading/initialization failure). Doing it here instead of in the renderer</span></span><br><span class="line">  <span class="comment">// process because the browser is trusted.</span></span><br><span class="line">  <span class="keyword">auto</span> callback = mojo::<span class="built_in">WrapCallbackWithDefaultInvokeIfNotRun</span>(</span><br><span class="line">      std::<span class="built_in">move</span>(create_cdm_cb), mojo::<span class="built_in">NullRemote</span>(), <span class="literal">nullptr</span>,</span><br><span class="line">      <span class="string">&quot;CDM creation failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle `use_hw_secure_codecs` cases first.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(USE_CHROMEOS_PROTECTED_MEDIA)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BUILDFLAG(IS_WIN)</span></span><br><span class="line">...</span><br><span class="line">  <span class="comment">// Fallback to use library CDM below.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(USE_CHROMEOS_PROTECTED_MEDIA)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(ENABLE_LIBRARY_CDMS)</span></span><br><span class="line">  <span class="comment">// Fallback to use CdmFactory even if `use_hw_secure_codecs` is true.</span></span><br><span class="line">  <span class="keyword">auto</span>* factory = <span class="built_in">GetCdmFactory</span>(cdm_config.key_system);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BUILDFLAG(ENABLE_CAST_RENDERER)</span></span><br><span class="line">  <span class="comment">// CDM service lives together with renderer service if cast renderer is</span></span><br><span class="line">  <span class="comment">// enabled, because cast renderer creates its own audio/video decoder. Note</span></span><br><span class="line">  <span class="comment">// that in content_browsertests (and Content Shell in general) we don&#x27;t have</span></span><br><span class="line">  <span class="comment">// an a cast renderer and this interface will be unbound.</span></span><br><span class="line">  <span class="keyword">auto</span>* factory = secondary_interface_factory_-&gt;<span class="built_in">Get</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">// CDM service lives together with audio/video decoder service.</span></span><br><span class="line">  <span class="keyword">auto</span>* factory = media_interface_factory_ptr_-&gt;<span class="built_in">Get</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(ENABLE_LIBRARY_CDMS)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!factory) &#123;</span><br><span class="line">    std::<span class="built_in">move</span>(callback).<span class="built_in">Run</span>(mojo::<span class="built_in">NullRemote</span>(), <span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="string">&quot;Unable to find a CDM factory&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  factory-&gt;<span class="built_in">CreateCdm</span>(cdm_config, std::<span class="built_in">move</span>(callback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InterfaceFactoryImpl-CreateCdm"><a href="#InterfaceFactoryImpl-CreateCdm" class="headerlink" title="InterfaceFactoryImpl::CreateCdm"></a>InterfaceFactoryImpl::CreateCdm</h4><p>最后会调用到 InterfaceFactoryImpl 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InterfaceFactoryImpl::CreateCdm</span><span class="params">(<span class="type">const</span> CdmConfig&amp; cdm_config,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     CreateCdmCallback callback)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(ENABLE_MOJO_CDM)</span></span><br><span class="line">  CdmFactory* cdm_factory = <span class="built_in">GetCdmFactory</span>();</span><br><span class="line">  <span class="keyword">if</span> (!cdm_factory) &#123;</span><br><span class="line">    std::<span class="built_in">move</span>(callback).<span class="built_in">Run</span>(mojo::<span class="built_in">NullRemote</span>(), <span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="string">&quot;CDM Factory creation failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> mojo_cdm_service =</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;MojoCdmService&gt;(&amp;cdm_service_context_);</span><br><span class="line">  <span class="keyword">auto</span>* raw_mojo_cdm_service = mojo_cdm_service.<span class="built_in">get</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(!pending_mojo_cdm_services_.<span class="built_in">count</span>(raw_mojo_cdm_service));</span><br><span class="line">  pending_mojo_cdm_services_[raw_mojo_cdm_service] =</span><br><span class="line">      std::<span class="built_in">move</span>(mojo_cdm_service);</span><br><span class="line">  raw_mojo_cdm_service-&gt;<span class="built_in">Initialize</span>(</span><br><span class="line">      cdm_factory, cdm_config,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;InterfaceFactoryImpl::OnCdmServiceInitialized,</span><br><span class="line">                     weak_ptr_factory_.<span class="built_in">GetWeakPtr</span>(), raw_mojo_cdm_service,</span><br><span class="line">                     std::<span class="built_in">move</span>(callback)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  <span class="comment">// BUILDFLAG(ENABLE_MOJO_CDM)</span></span></span><br><span class="line">  std::<span class="built_in">move</span>(callback).<span class="built_in">Run</span>(mojo::<span class="built_in">NullRemote</span>(), <span class="literal">nullptr</span>,</span><br><span class="line">                          <span class="string">&quot;Mojo CDM not supported&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="InterfaceFactoryImpl-GetCdmFactory"><a href="#InterfaceFactoryImpl-GetCdmFactory" class="headerlink" title="InterfaceFactoryImpl::GetCdmFactory"></a>InterfaceFactoryImpl::GetCdmFactory</h5><p>InterfaceFactoryImpl::CreateCdm 先 GetCdmFactory</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CdmFactory* <span class="title">InterfaceFactoryImpl::GetCdmFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!cdm_factory_) &#123;</span><br><span class="line">    cdm_factory_ =</span><br><span class="line">        mojo_media_client_-&gt;<span class="built_in">CreateCdmFactory</span>(frame_interfaces_.<span class="built_in">get</span>());</span><br><span class="line">    <span class="built_in">LOG_IF</span>(ERROR, !cdm_factory_) &lt;&lt; <span class="string">&quot;CdmFactory not available.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cdm_factory_.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetCdmFactory 通过 <code>mojo_media_client_</code>，而 <code>mojo_media_client_</code> 是在 MediaService 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaService::CreateInterfaceFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    mojo::PendingReceiver&lt;mojom::InterfaceFactory&gt; receiver,</span></span></span><br><span class="line"><span class="params"><span class="function">    mojo::PendingRemote&lt;mojom::FrameInterfaceFactory&gt; frame_interfaces)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Ignore request if service has already stopped.</span></span><br><span class="line">  <span class="keyword">if</span> (!mojo_media_client_)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  interface_factory_receivers_.<span class="built_in">Add</span>(</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;InterfaceFactoryImpl&gt;(std::<span class="built_in">move</span>(frame_interfaces),</span><br><span class="line">                                             mojo_media_client_.<span class="built_in">get</span>()),</span><br><span class="line">      std::<span class="built_in">move</span>(receiver));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从下面的 GetMediaService 可以看到，如果允许在 GPU 中使用 mojo media，那么会使用 GpuProcessHost::RunService 来得到 MediaService 的 Remote，如果是在 Browser 中使用 mojo media，那么直接使用 media::CreateMediaService 函数创建 MediaService</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">media::<span class="function">mojom::MediaService&amp; <span class="title">GetMediaService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> We use sequence-local storage to limit the lifetime of this Remote to</span></span><br><span class="line">  <span class="comment">// that of the UI-thread sequence. This ensures that the Remote is destroyed</span></span><br><span class="line">  <span class="comment">// when the task environment is torn down and reinitialized, e.g. between unit</span></span><br><span class="line">  <span class="comment">// tests.</span></span><br><span class="line">  <span class="type">static</span> base::SequenceLocalStorageSlot&lt;</span><br><span class="line">      mojo::Remote&lt;media::mojom::MediaService&gt;&gt;</span><br><span class="line">      remote_slot;</span><br><span class="line">  <span class="keyword">auto</span>&amp; remote = remote_slot.<span class="built_in">GetOrCreateValue</span>();</span><br><span class="line">  <span class="keyword">if</span> (!remote) &#123;</span><br><span class="line">    <span class="keyword">auto</span> receiver = remote.<span class="built_in">BindNewPipeAndPassReceiver</span>();</span><br><span class="line">    remote.<span class="built_in">reset_on_disconnect</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(ENABLE_MOJO_MEDIA_IN_GPU_PROCESS)</span></span><br><span class="line">    <span class="keyword">auto</span>* process_host = GpuProcessHost::<span class="built_in">Get</span>();</span><br><span class="line">    <span class="keyword">if</span> (process_host) &#123;</span><br><span class="line">      process_host-&gt;<span class="built_in">RunService</span>(std::<span class="built_in">move</span>(receiver));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;GPU process host not available&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BUILDFLAG(ENABLE_MOJO_MEDIA_IN_BROWSER_PROCESS)</span></span><br><span class="line">    <span class="built_in">static_assert</span>(media::mojom::MediaService::kServiceSandbox ==</span><br><span class="line">                      sandbox::mojom::Sandbox::kNoSandbox,</span><br><span class="line">                  <span class="string">&quot;MediaService requested in-browser but not with kNoSandbox&quot;</span>);</span><br><span class="line">    <span class="type">static</span> base::NoDestructor&lt;std::unique_ptr&lt;media::MediaService&gt;&gt; service;</span><br><span class="line">    *service = media::<span class="built_in">CreateMediaService</span>(std::<span class="built_in">move</span>(receiver));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *remote.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Browser-mojo-media"><a href="#Browser-mojo-media" class="headerlink" title="Browser mojo media"></a>Browser mojo media</h6><p>先看 Browser mojo media 的情况，这种情况简单一些</p><p>从下面的代码可知，MojoMediaClient 是 AndroidMojoMediaClient 或者 MediaFoundationMojoMediaClient</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;MediaService&gt; <span class="title">CreateMediaService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    mojo::PendingReceiver&lt;mojom::MediaService&gt; receiver)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_ANDROID)</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MediaService&gt;(</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;AndroidMojoMediaClient&gt;(), std::<span class="built_in">move</span>(receiver));</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BUILDFLAG(IS_WIN)</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MediaService&gt;(</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;MediaFoundationMojoMediaClient&gt;(), std::<span class="built_in">move</span>(receiver));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">NOTREACHED</span>() &lt;&lt; <span class="string">&quot;No MediaService implementation available.&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="GPU-mojo-media"><a href="#GPU-mojo-media" class="headerlink" title="GPU mojo media"></a>GPU mojo media</h6><p>再看 GPU mojo media。</p><p>我们知道，Chromium 有 Browser 进程、Render 进程、还有 GPU 进程，Browser 进程只有一个，而每个页面一般会对应一个 Render 进程，而 GPU 进程则是专门负责和 GPU 打交道</p><p>在 GPU mojo media 的情况下，GetMediaService 使用 GpuProcessHost::RunServiceImpl 来连接 GPU 进程中的 MediaService</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GpuProcessHost::RunServiceImpl</span><span class="params">(mojo::GenericPendingReceiver receiver)</span> </span>&#123;</span><br><span class="line">  process_-&gt;<span class="built_in">child_process</span>()-&gt;<span class="built_in">BindServiceInterface</span>(std::<span class="built_in">move</span>(receiver));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 GPU 进程中的 MediaService 是在 GpuServiceFactory::RunMediaService 中创建的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GpuServiceFactory::RunMediaService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    mojo::PendingReceiver&lt;media::mojom::MediaService&gt; receiver)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(ENABLE_MOJO_MEDIA_IN_GPU_PROCESS)</span></span><br><span class="line">  <span class="comment">// This service will host audio/video decoders, and if these decoding</span></span><br><span class="line">  <span class="comment">// operations are blocked, user may hear audio glitch or see video freezing,</span></span><br><span class="line">  <span class="comment">// hence &quot;user blocking&quot;.</span></span><br><span class="line">  scoped_refptr&lt;base::SingleThreadTaskRunner&gt; task_runner;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_WIN)</span></span><br><span class="line">  <span class="comment">// Run everything on the gpu main thread, since it&#x27;s required for decode swap</span></span><br><span class="line">  <span class="comment">// chains. See SwapChainPresenter::TryPresentToDecodeSwapChain().</span></span><br><span class="line">  task_runner = task_runner_;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">// TODO(crbug.com/786169): Check whether this needs to be single threaded.</span></span><br><span class="line">  task_runner = base::ThreadPool::<span class="built_in">CreateSingleThreadTaskRunner</span>(</span><br><span class="line">      &#123;base::TaskPriority::USER_BLOCKING&#125;);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(IS_WIN)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> FactoryCallback =</span><br><span class="line">      base::OnceCallback&lt;std::<span class="built_in">unique_ptr</span>&lt;media::MediaService&gt;()&gt;;</span><br><span class="line">  FactoryCallback factory =</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;media::CreateGpuMediaService, std::<span class="built_in">move</span>(receiver),</span><br><span class="line">                     gpu_preferences_, gpu_workarounds_, gpu_feature_info_,</span><br><span class="line">                     gpu_info_, task_runner_, media_gpu_channel_manager_,</span><br><span class="line">                     gpu_memory_buffer_factory_, android_overlay_factory_cb_);</span><br><span class="line">  task_runner-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">      FROM_HERE,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(</span><br><span class="line">          [](FactoryCallback factory) &#123;</span><br><span class="line">            <span class="type">static</span> base::NoDestructor&lt;std::unique_ptr&lt;media::MediaService&gt;&gt;</span><br><span class="line">                service&#123;std::<span class="built_in">move</span>(factory).<span class="built_in">Run</span>()&#125;;</span><br><span class="line">          &#125;,</span><br><span class="line">          std::<span class="built_in">move</span>(factory)));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(ENABLE_MOJO_MEDIA_IN_GPU_PROCESS)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数调用了 CreateGpuMediaService 函数，CreateGpuMediaService 函数创建了一个 GpuMojoMediaClient 对象给 MediaService，GpuMojoMediaClient 的方法（如 CreateCdmFactory）会调用一些全局函数（如 CreatePlatformCdmFactory），而这些全局函数在不同平台下有不同的实现，一般会通过编译选项新建相关全局函数的实现，来提供自己平台的 CreateCdm 方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;MediaService&gt; <span class="title">CreateGpuMediaService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    mojo::PendingReceiver&lt;mojom::MediaService&gt; receiver,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> gpu::GpuPreferences&amp; gpu_preferences,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> gpu::GpuDriverBugWorkarounds&amp; gpu_workarounds,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> gpu::GpuFeatureInfo&amp; gpu_feature_info,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> gpu::GPUInfo&amp; gpu_info,</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt; task_runner,</span></span></span><br><span class="line"><span class="params"><span class="function">    base::WeakPtr&lt;MediaGpuChannelManager&gt; media_gpu_channel_manager,</span></span></span><br><span class="line"><span class="params"><span class="function">    gpu::GpuMemoryBufferFactory* gpu_memory_buffer_factory,</span></span></span><br><span class="line"><span class="params"><span class="function">    AndroidOverlayMojoFactoryCB android_overlay_factory_cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MediaService&gt;(</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;GpuMojoMediaClient&gt;(</span><br><span class="line">          gpu_preferences, gpu_workarounds, gpu_feature_info, gpu_info,</span><br><span class="line">          task_runner, media_gpu_channel_manager, gpu_memory_buffer_factory,</span><br><span class="line">          std::<span class="built_in">move</span>(android_overlay_factory_cb)),</span><br><span class="line">      std::<span class="built_in">move</span>(receiver));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 Android 为例，他的 GpuMojoMediaClient 的 CreateCdmFactory 方法调用下面的 CreatePlatformCdmFactory</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;CdmFactory&gt; <span class="title">CreatePlatformCdmFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    mojom::FrameInterfaceFactory* frame_interfaces)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;AndroidCdmFactory&gt;(</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;CreateProvisionFetcher, frame_interfaces),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;CreateMediaDrmStorage, frame_interfaces));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MojoCdmService-Initialize"><a href="#MojoCdmService-Initialize" class="headerlink" title="MojoCdmService::Initialize"></a>MojoCdmService::Initialize</h5><p>在得到 MojoMediaClient 后，会通过他来创建 CdmFactory，然后用该 CdmFactory 来初始化 MojoCdmService</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MojoCdmService::Initialize</span><span class="params">(CdmFactory* cdm_factory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> CdmConfig&amp; cdm_config,</span></span></span><br><span class="line"><span class="params"><span class="function">                                InitializeCB init_cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> weak_this = weak_factory_.<span class="built_in">GetWeakPtr</span>();</span><br><span class="line">  cdm_factory-&gt;<span class="built_in">Create</span>(</span><br><span class="line">      cdm_config,</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;MojoCdmService::OnSessionMessage, weak_this),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;MojoCdmService::OnSessionClosed, weak_this),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;MojoCdmService::OnSessionKeysChange, weak_this),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;MojoCdmService::OnSessionExpirationUpdate,</span><br><span class="line">                          weak_this),</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;MojoCdmService::OnCdmCreated, weak_this,</span><br><span class="line">                     mojo::<span class="built_in">WrapCallbackWithDefaultInvokeIfNotRun</span>(</span><br><span class="line">                         std::<span class="built_in">move</span>(init_cb), <span class="literal">nullptr</span>,</span><br><span class="line">                         <span class="string">&quot;Mojo CDM Service creation aborted&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Initialize 中通过 cdm_factory 的 Create 方法创建，以 AndroidCdmFactory::Create 为例，下面的函数最后调用了 MediaDrmBridgeFactory 来创建 Android 的 Cdm</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidCdmFactory::Create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> CdmConfig&amp; cdm_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SessionMessageCB&amp; session_message_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SessionClosedCB&amp; session_closed_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SessionKeysChangeCB&amp; session_keys_change_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SessionExpirationUpdateCB&amp; session_expiration_update_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    CdmCreatedCB cdm_created_cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bound |cdm_created_cb| so we always fire it asynchronously.</span></span><br><span class="line">  CdmCreatedCB bound_cdm_created_cb =</span><br><span class="line">      <span class="built_in">BindToCurrentLoop</span>(std::<span class="built_in">move</span>(cdm_created_cb));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create AesDecryptor here to support External Clear Key key system.</span></span><br><span class="line">  <span class="comment">// This is used for testing.</span></span><br><span class="line">  <span class="keyword">if</span> (base::FeatureList::<span class="built_in">IsEnabled</span>(media::kExternalClearKeyForTesting) &amp;&amp;</span><br><span class="line">      <span class="built_in">IsExternalClearKey</span>(cdm_config.key_system)) &#123;</span><br><span class="line">    <span class="function">scoped_refptr&lt;ContentDecryptionModule&gt; <span class="title">cdm</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">new</span> AesDecryptor(session_message_cb, session_closed_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                         session_keys_change_cb, session_expiration_update_cb))</span></span>;</span><br><span class="line">    std::<span class="built_in">move</span>(bound_cdm_created_cb).<span class="built_in">Run</span>(cdm, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string error_message;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!MediaDrmBridge::<span class="built_in">IsKeySystemSupported</span>(cdm_config.key_system)) &#123;</span><br><span class="line">    <span class="built_in">ReportMediaDrmBridgeKeySystemSupport</span>(<span class="literal">false</span>);</span><br><span class="line">    std::<span class="built_in">move</span>(bound_cdm_created_cb)</span><br><span class="line">        .<span class="built_in">Run</span>(<span class="literal">nullptr</span>,</span><br><span class="line">             <span class="string">&quot;Key system not supported unexpectedly: &quot;</span> + cdm_config.key_system);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReportMediaDrmBridgeKeySystemSupport</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> factory = std::<span class="built_in">make_unique</span>&lt;MediaDrmBridgeFactory&gt;(create_fetcher_cb_,</span><br><span class="line">                                                         create_storage_cb_);</span><br><span class="line">  <span class="keyword">auto</span>* raw_factory = factory.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">  creation_id_++;</span><br><span class="line">  <span class="keyword">auto</span> result = pending_creations_.<span class="built_in">emplace</span>(</span><br><span class="line">      creation_id_,</span><br><span class="line">      <span class="built_in">PendingCreation</span>(std::<span class="built_in">move</span>(factory), std::<span class="built_in">move</span>(bound_cdm_created_cb)));</span><br><span class="line">  <span class="built_in">CHECK</span>(result.second);</span><br><span class="line"></span><br><span class="line">  raw_factory-&gt;<span class="built_in">Create</span>(cdm_config, session_message_cb, session_closed_cb,</span><br><span class="line">                      session_keys_change_cb, session_expiration_update_cb,</span><br><span class="line">                      base::<span class="built_in">BindOnce</span>(&amp;AndroidCdmFactory::OnCdmCreated,</span><br><span class="line">                                     weak_factory_.<span class="built_in">GetWeakPtr</span>(), creation_id_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果回传"><a href="#结果回传" class="headerlink" title="结果回传"></a>结果回传</h2><p>接下来再看结果回传过程。结果回传主要是通过 cdm_created_cb 回调回传的，把上面的代码从后往前看一遍基本上就清楚了。</p><h3 id="MojoCdmService-OnCdmCreated"><a href="#MojoCdmService-OnCdmCreated" class="headerlink" title="MojoCdmService::OnCdmCreated"></a>MojoCdmService::OnCdmCreated</h3><p>我们从 MojoCdmService::OnCdmCreated 开始，MojoCdmService::OnCdmCreated 接受 ContentDecryptionModule 的 scoped_refptr 参数，该参数就是 AndroidCdmFactory::Create 中创建的对象</p><p>MojoCdmService::OnCdmCreated 中还可能会创建 MojoDecryptorService</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MojoCdmService::OnCdmCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InitializeCB init_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> scoped_refptr&lt;::media::ContentDecryptionModule&gt;&amp; cdm,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; error_message)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO(xhwang): This should not happen when KeySystemInfo is properly</span></span><br><span class="line">  <span class="comment">// populated. See http://crbug.com/469366</span></span><br><span class="line">  <span class="keyword">if</span> (!cdm) &#123;</span><br><span class="line">    <span class="comment">// Make sure the error string is non-empty on failure.</span></span><br><span class="line">    <span class="keyword">auto</span> non_empty_error_message =</span><br><span class="line">        error_message.<span class="built_in">empty</span>() ? <span class="string">&quot;CDM creation failed&quot;</span> : error_message;</span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; non_empty_error_message;</span><br><span class="line">    std::<span class="built_in">move</span>(init_cb).<span class="built_in">Run</span>(<span class="literal">nullptr</span>, non_empty_error_message);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cdm_ = cdm;</span><br><span class="line">  cdm_id_ = context_-&gt;<span class="built_in">RegisterCdm</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: CDM successfully registered with ID &quot;</span></span><br><span class="line">           &lt;&lt; CdmContext::<span class="built_in">CdmIdToString</span>(base::<span class="built_in">OptionalOrNullptr</span>(cdm_id_));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> mojo_cdm_context = mojom::CdmContext::<span class="built_in">New</span>();</span><br><span class="line">  mojo_cdm_context-&gt;cdm_id = <span class="built_in">cdm_id</span>();</span><br><span class="line"></span><br><span class="line">  CdmContext* <span class="type">const</span> cdm_context = cdm_-&gt;<span class="built_in">GetCdmContext</span>();</span><br><span class="line">  <span class="keyword">if</span> (cdm_context) &#123;</span><br><span class="line">    <span class="comment">// If |cdm| has a decryptor, create the MojoDecryptorService</span></span><br><span class="line">    <span class="comment">// and pass the connection back to the client.</span></span><br><span class="line">    <span class="keyword">if</span> (cdm_context-&gt;<span class="built_in">GetDecryptor</span>()) &#123;</span><br><span class="line">      <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: CDM supports Decryptor.&quot;</span>;</span><br><span class="line">      mojo::PendingRemote&lt;mojom::Decryptor&gt; decryptor_remote;</span><br><span class="line">      <span class="comment">// Both |cdm_| and |decryptor_| are owned by |this|, so we don&#x27;t need to</span></span><br><span class="line">      <span class="comment">// pass in a CdmContextRef.</span></span><br><span class="line">      decryptor_ = std::<span class="built_in">make_unique</span>&lt;MojoDecryptorService&gt;(</span><br><span class="line">          cdm_context-&gt;<span class="built_in">GetDecryptor</span>(), <span class="comment">/*cdm_context_ref=*/</span><span class="literal">nullptr</span>);</span><br><span class="line">      decryptor_receiver_ = std::make_unique&lt;mojo::Receiver&lt;mojom::Decryptor&gt;&gt;(</span><br><span class="line">          decryptor_.<span class="built_in">get</span>(), decryptor_remote.<span class="built_in">InitWithNewPipeAndPassReceiver</span>());</span><br><span class="line">      <span class="comment">// base::Unretained is safe because |decryptor_receiver_| is owned by</span></span><br><span class="line">      <span class="comment">// |this|. If |this| is destructed, |decryptor_receiver_| will be</span></span><br><span class="line">      <span class="comment">// destructed as well and the error handler should never be called.</span></span><br><span class="line">      <span class="comment">// The disconnection can happen due to race conditions during render</span></span><br><span class="line">      <span class="comment">// process teardown or crash.</span></span><br><span class="line">      decryptor_receiver_-&gt;<span class="built_in">set_disconnect_handler</span>(base::<span class="built_in">BindOnce</span>(</span><br><span class="line">          &amp;MojoCdmService::OnDecryptorConnectionError, base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)));</span><br><span class="line">      mojo_cdm_context-&gt;decryptor = std::<span class="built_in">move</span>(decryptor_remote);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_WIN)</span></span><br><span class="line">    mojo_cdm_context-&gt;requires_media_foundation_renderer =</span><br><span class="line">        cdm_context-&gt;<span class="built_in">RequiresMediaFoundationRenderer</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(IS_WIN)</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">move</span>(init_cb).<span class="built_in">Run</span>(std::<span class="built_in">move</span>(mojo_cdm_context), <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InterfaceFactoryImpl-OnCdmServiceInitialized"><a href="#InterfaceFactoryImpl-OnCdmServiceInitialized" class="headerlink" title="InterfaceFactoryImpl::OnCdmServiceInitialized"></a>InterfaceFactoryImpl::OnCdmServiceInitialized</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InterfaceFactoryImpl::OnCdmServiceInitialized</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MojoCdmService* raw_mojo_cdm_service,</span></span></span><br><span class="line"><span class="params"><span class="function">    CreateCdmCallback callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    mojom::CdmContextPtr cdm_context,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; error_message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(raw_mojo_cdm_service);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove pending MojoCdmService from the mapping in all cases.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(pending_mojo_cdm_services_.<span class="built_in">count</span>(raw_mojo_cdm_service));</span><br><span class="line">  <span class="keyword">auto</span> mojo_cdm_service =</span><br><span class="line">      std::<span class="built_in">move</span>(pending_mojo_cdm_services_[raw_mojo_cdm_service]);</span><br><span class="line">  pending_mojo_cdm_services_.<span class="built_in">erase</span>(raw_mojo_cdm_service);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cdm_context) &#123;</span><br><span class="line">    std::<span class="built_in">move</span>(callback).<span class="built_in">Run</span>(mojo::<span class="built_in">NullRemote</span>(), <span class="literal">nullptr</span>, error_message);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mojo::PendingRemote&lt;mojom::ContentDecryptionModule&gt; remote;</span><br><span class="line">  cdm_receivers_.<span class="built_in">Add</span>(std::<span class="built_in">move</span>(mojo_cdm_service),</span><br><span class="line">                     remote.<span class="built_in">InitWithNewPipeAndPassReceiver</span>());</span><br><span class="line">  std::<span class="built_in">move</span>(callback).<span class="built_in">Run</span>(std::<span class="built_in">move</span>(remote), std::<span class="built_in">move</span>(cdm_context), <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="OnCdmCreated"><a href="#OnCdmCreated" class="headerlink" title="OnCdmCreated"></a>OnCdmCreated</h5><p>一路往上，就到了 OnCdmCreated，这里创建了 MojoCdm</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnCdmCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SessionMessageCB&amp; session_message_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SessionClosedCB&amp; session_closed_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SessionKeysChangeCB&amp; session_keys_change_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SessionExpirationUpdateCB&amp; session_expiration_update_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    CdmCreatedCB cdm_created_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    mojo::PendingRemote&lt;mojom::ContentDecryptionModule&gt; cdm_remote,</span></span></span><br><span class="line"><span class="params"><span class="function">    media::mojom::CdmContextPtr cdm_context,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; error_message)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Convert from a PendingRemote to Remote so we can verify that it is</span></span><br><span class="line">  <span class="comment">// connected, this will also check if |cdm_remote| is null.</span></span><br><span class="line">  <span class="function">mojo::Remote&lt;mojom::ContentDecryptionModule&gt; <span class="title">remote</span><span class="params">(std::move(cdm_remote))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!remote || !remote.<span class="built_in">is_connected</span>() || !cdm_context) &#123;</span><br><span class="line">    std::<span class="built_in">move</span>(cdm_created_cb).<span class="built_in">Run</span>(<span class="literal">nullptr</span>, error_message);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">move</span>(cdm_created_cb)</span><br><span class="line">      .<span class="built_in">Run</span>(base::<span class="built_in">MakeRefCounted</span>&lt;MojoCdm&gt;(</span><br><span class="line">               std::<span class="built_in">move</span>(remote), std::<span class="built_in">move</span>(cdm_context), session_message_cb,</span><br><span class="line">               session_closed_cb, session_keys_change_cb,</span><br><span class="line">               session_expiration_update_cb),</span><br><span class="line">           <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往上，就到了 CdmSessionAdapter::OnCdmCreated，在这里创建了 WebContentDecryptionModuleImpl，注意这里把 CdmSessionAdapter 传给了 WebContentDecryptionModuleImpl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CdmSessionAdapter::OnCdmCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> media::CdmConfig&amp; cdm_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    base::TimeTicks start_time,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> scoped_refptr&lt;media::ContentDecryptionModule&gt;&amp; cdm,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; error_message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: &quot;</span></span><br><span class="line">           &lt;&lt; (cdm ? <span class="string">&quot;success&quot;</span> : <span class="string">&quot;failure (&quot;</span> + error_message + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!cdm_);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_END2</span>(</span><br><span class="line">      <span class="string">&quot;media&quot;</span>, <span class="string">&quot;CdmSessionAdapter::CreateCdm&quot;</span>, trace_id_, <span class="string">&quot;success&quot;</span>,</span><br><span class="line">      (cdm ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>), <span class="string">&quot;error_message&quot;</span>, error_message);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> key_system_name_for_uma = media::<span class="built_in">GetKeySystemNameForUMA</span>(</span><br><span class="line">      cdm_config.key_system, cdm_config.use_hw_secure_codecs);</span><br><span class="line">  <span class="keyword">auto</span> key_system_uma_prefix = kMediaEME + key_system_name_for_uma + kDot;</span><br><span class="line">  base::<span class="built_in">UmaHistogramBoolean</span>(key_system_uma_prefix + kCreateCdmUMAName,</span><br><span class="line">                            cdm ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cdm) &#123;</span><br><span class="line">    std::<span class="built_in">move</span>(web_cdm_created_cb_).<span class="built_in">Run</span>(<span class="literal">nullptr</span>, error_message);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  key_system_uma_prefix_ = std::<span class="built_in">move</span>(key_system_uma_prefix);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Only report time for successful CDM creation.</span></span><br><span class="line">  base::<span class="built_in">UmaHistogramTimes</span>(key_system_uma_prefix_ + kTimeToCreateCdmUMAName,</span><br><span class="line">                          base::TimeTicks::<span class="built_in">Now</span>() - start_time);</span><br><span class="line"></span><br><span class="line">  cdm_config_ = cdm_config;</span><br><span class="line"></span><br><span class="line">  cdm_ = cdm;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">move</span>(web_cdm_created_cb_)</span><br><span class="line">      .<span class="built_in">Run</span>(<span class="keyword">new</span> <span class="built_in">WebContentDecryptionModuleImpl</span>(<span class="keyword">this</span>), <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="CompleteWebContentDecryptionModuleResult"><a href="#CompleteWebContentDecryptionModuleResult" class="headerlink" title="CompleteWebContentDecryptionModuleResult"></a>CompleteWebContentDecryptionModuleResult</h6><p>再往上就是 CompleteWebContentDecryptionModuleResult</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompleteWebContentDecryptionModuleResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;WebContentDecryptionModuleResult&gt; result,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebContentDecryptionModule* cdm,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; error_message)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cdm) &#123;</span><br><span class="line">    result-&gt;<span class="built_in">CompleteWithError</span>(</span><br><span class="line">        kWebContentDecryptionModuleExceptionNotSupportedError, <span class="number">0</span>,</span><br><span class="line">        WebString::<span class="built_in">FromUTF8</span>(error_message));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result-&gt;<span class="built_in">CompleteWithContentDecryptionModule</span>(cdm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebContentDecryptionModuleResult::CompleteWithContentDecryptionModule 调用内部 <code>impl_</code> 的 CompleteWithContentDecryptionModule</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebContentDecryptionModuleResult::CompleteWithContentDecryptionModule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WebContentDecryptionModule* cdm)</span> </span>&#123;</span><br><span class="line">  impl_-&gt;<span class="built_in">CompleteWithContentDecryptionModule</span>(cdm);</span><br><span class="line">  <span class="built_in">Reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 CompleteWithContentDecryptionModule 中用 WebContentDecryptionModule 创建 MediaKeys 并 resolve promise</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewCdmResultPromise</span> : <span class="keyword">public</span> ContentDecryptionModuleResultPromise &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CompleteWithContentDecryptionModule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      WebContentDecryptionModule* cdm)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Continued from step 2.8 of createMediaKeys().</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsValidToFulfillPromise</span>())</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.9. Let media keys be a new MediaKeys object.</span></span><br><span class="line">    <span class="keyword">auto</span>* media_keys = <span class="built_in">MakeGarbageCollected</span>&lt;MediaKeys&gt;(</span><br><span class="line">        <span class="built_in">GetExecutionContext</span>(), supported_session_types_, base::<span class="built_in">WrapUnique</span>(cdm),</span><br><span class="line">        config_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.10. Resolve promise with media keys.</span></span><br><span class="line">    <span class="built_in">Resolve</span>(media_keys);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一篇文章就到这里，主要介绍了通过 MediaKeySystemAccess 创建 MediaKeys 的过程。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium 多媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium 多媒体（四）</title>
      <link href="/2023/06/30/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/06/30/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>之前的几篇文章介绍了 MSE 的内容，接下来介绍 EME 部分，笔者之前做的项目就是和 EME 相关的。</p><p>EME 全称 Encrypted Media Extensions，通过 EME，浏览器应用可以在 web 上播放加密视频。目前市面上主流的内容解密模块（Content Decryption Module）有微软的 PlayReady 和谷歌的 Widevine，苹果也有一套自己的解密标准 FairPlay。</p><p>还是以一个例子为研究对象。</p><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>下面的代码主要做了以下事情</p><ul><li>调用 navigator.requestMediaKeySystemAccess 创建 MediaKeySystemAccess 对象</li><li>通过 MediaKeySystemAccess 对象创建 MediaKeys</li><li>然后将 MediaKeys 设置给 video 标签</li><li>然后在 video 标签的 encrypted 事件中通过 MediaKeys 创建 MediaKeySession</li><li>然后调用 MediaKeySession.generateRequest 方法向 CDM 申请 Request，后面会分析 encrypted 事件何时触发</li><li>在收到 CDM 的 Request 之后通过网络送给 License 服务器</li><li>从 License 服务器得到回应之后再把回应通过 MediaKeySession.update 送回 CDM</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define a key: hardcoded in this example</span></span><br><span class="line"><span class="comment">// – this corresponds to the key used for encryption</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">KEY</span> = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([</span><br><span class="line">  <span class="number">0xeb</span>, <span class="number">0xdd</span>, <span class="number">0x62</span>, <span class="number">0xf1</span>, <span class="number">0x68</span>, <span class="number">0x14</span>, <span class="number">0xd2</span>, <span class="number">0x7b</span>, <span class="number">0x68</span>, <span class="number">0xef</span>, <span class="number">0x12</span>, <span class="number">0x2a</span>, <span class="number">0xfc</span>,</span><br><span class="line">  <span class="number">0xe4</span>, <span class="number">0xae</span>, <span class="number">0x3c</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">initDataTypes</span>: [<span class="string">&#x27;webm&#x27;</span>],</span><br><span class="line">    <span class="attr">videoCapabilities</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">contentType</span>: <span class="string">&#x27;video/webm; codecs=&quot;vp8&quot;&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line"><span class="comment">// 添加对video的encrypted的事件的监听</span></span><br><span class="line">video.<span class="title function_">addEventListener</span>(<span class="string">&#x27;encrypted&#x27;</span>, handleEncrypted, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">navigator</span><br><span class="line">  .<span class="title function_">requestMediaKeySystemAccess</span>(<span class="string">&#x27;org.w3.clearkey&#x27;</span>, config)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">keySystemAccess</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> keySystemAccess.<span class="title function_">createMediaKeys</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">createdMediaKeys</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> video.<span class="title function_">setMediaKeys</span>(createdMediaKeys);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Failed to set up MediaKeys&#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleEncrypted</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> session = video.<span class="property">mediaKeys</span>.<span class="title function_">createSession</span>();</span><br><span class="line">  session.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, handleMessage, <span class="literal">false</span>);</span><br><span class="line">  session</span><br><span class="line">    .<span class="title function_">generateRequest</span>(event.<span class="property">initDataType</span>, event.<span class="property">initData</span>)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Failed to generate a license request&#x27;</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleMessage</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// If you had a license server, you would make an asynchronous XMLHttpRequest</span></span><br><span class="line">  <span class="comment">// with event.message as the body.  The response from the server, as a</span></span><br><span class="line">  <span class="comment">// Uint8Array, would then be passed to session.update().</span></span><br><span class="line">  <span class="comment">// Instead, we will generate the license synchronously on the client, using</span></span><br><span class="line">  <span class="comment">// the hard-coded KEY at the top.</span></span><br><span class="line">  <span class="keyword">var</span> license = <span class="title function_">generateLicense</span>(event.<span class="property">message</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> session = event.<span class="property">target</span>;</span><br><span class="line">  session.<span class="title function_">update</span>(license).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Failed to update the session&#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert Uint8Array into base64 using base64url alphabet, without padding.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toBase64</span>(<span class="params">u8arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">btoa</span>(<span class="title class_">String</span>.<span class="property">fromCharCode</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, u8arr))</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/\+/g</span>, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/\//g</span>, <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/=*$/</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This takes the place of a license server.</span></span><br><span class="line"><span class="comment">// kids is an array of base64-encoded key IDs</span></span><br><span class="line"><span class="comment">// keys is an array of base64-encoded keys</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateLicense</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="comment">// Parse the clearkey license request.</span></span><br><span class="line">  <span class="keyword">var</span> request = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="keyword">new</span> <span class="title class_">TextDecoder</span>().<span class="title function_">decode</span>(message));</span><br><span class="line">  <span class="comment">// We only know one key, so there should only be one key ID.</span></span><br><span class="line">  <span class="comment">// A real license server could easily serve multiple keys.</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">assert</span>(request.<span class="property">kids</span>.<span class="property">length</span> === <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> keyObj = &#123;</span><br><span class="line">    <span class="attr">kty</span>: <span class="string">&#x27;oct&#x27;</span>,</span><br><span class="line">    <span class="attr">alg</span>: <span class="string">&#x27;A128KW&#x27;</span>,</span><br><span class="line">    <span class="attr">kid</span>: request.<span class="property">kids</span>[<span class="number">0</span>],</span><br><span class="line">    <span class="attr">k</span>: <span class="title function_">toBase64</span>(<span class="variable constant_">KEY</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TextEncoder</span>().<span class="title function_">encode</span>(</span><br><span class="line">    <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">      <span class="attr">keys</span>: [keyObj],</span><br><span class="line">    &#125;),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="requestMediaKeySystemAccess"><a href="#requestMediaKeySystemAccess" class="headerlink" title="requestMediaKeySystemAccess"></a>requestMediaKeySystemAccess</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ScriptPromise <span class="title">NavigatorRequestMediaKeySystemAccess::requestMediaKeySystemAccess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ScriptState* script_state,</span></span></span><br><span class="line"><span class="params"><span class="function">    Navigator&amp; navigator,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> String&amp; key_system,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> HeapVector&lt;Member&lt;MediaKeySystemConfiguration&gt;&gt;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">        supported_configurations,</span></span></span><br><span class="line"><span class="params"><span class="function">    ExceptionState&amp; exception_state)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  MediaKeySystemAccessInitializer* initializer =</span><br><span class="line">      <span class="built_in">MakeGarbageCollected</span>&lt;MediaKeySystemAccessInitializer&gt;(</span><br><span class="line">          script_state, key_system, supported_configurations);</span><br><span class="line">  ScriptPromise promise = initializer-&gt;<span class="built_in">Promise</span>();</span><br><span class="line"></span><br><span class="line">  MediaKeysController* controller =</span><br><span class="line">      MediaKeysController::<span class="built_in">From</span>(window-&gt;<span class="built_in">GetFrame</span>()-&gt;<span class="built_in">GetPage</span>());</span><br><span class="line">  WebEncryptedMediaClient* media_client =</span><br><span class="line">      controller-&gt;<span class="built_in">EncryptedMediaClient</span>(window);</span><br><span class="line">  media_client-&gt;<span class="built_in">RequestMediaKeySystemAccess</span>(</span><br><span class="line">      <span class="built_in">WebEncryptedMediaRequest</span>(initializer));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WebEncryptedMediaClient* <span class="title">MediaKeysController::EncryptedMediaClient</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ExecutionContext* context)</span> </span>&#123;</span><br><span class="line">  WebLocalFrameImpl* web_frame =</span><br><span class="line">      WebLocalFrameImpl::<span class="built_in">FromFrame</span>(<span class="built_in">To</span>&lt;LocalDOMWindow&gt;(context)-&gt;<span class="built_in">GetFrame</span>());</span><br><span class="line">  <span class="keyword">return</span> web_frame-&gt;<span class="built_in">Client</span>()-&gt;<span class="built_in">EncryptedMediaClient</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>web_frame-&gt;Client()</code> 返回的是 RenderFrameImpl，和之前是一样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">blink::WebEncryptedMediaClient* <span class="title">RenderFrameImpl::EncryptedMediaClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> media_factory_.<span class="built_in">EncryptedMediaClient</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebEncryptedMediaClientImpl 中有 CdmFactory</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">blink::WebEncryptedMediaClient* <span class="title">MediaFactory::EncryptedMediaClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!web_encrypted_media_client_) &#123;</span><br><span class="line">    web_encrypted_media_client_ = std::<span class="built_in">make_unique</span>&lt;</span><br><span class="line">        blink::WebEncryptedMediaClientImpl&gt;(</span><br><span class="line">        <span class="built_in">GetCdmFactory</span>(), render_frame_-&gt;<span class="built_in">GetMediaPermission</span>(),</span><br><span class="line">        std::<span class="built_in">make_unique</span>&lt;blink::KeySystemConfigSelector::WebLocalFrameDelegate&gt;(</span><br><span class="line">            render_frame_-&gt;<span class="built_in">GetWebFrame</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> web_encrypted_media_client_.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 RenderFrameImpl 和 MediaFactory 是非常重要的两个类，Render、Decoder、CdmFactory 都在这里创建</p><h2 id="WebEncryptedMediaClientImpl-WebEncryptedMediaClientImpl"><a href="#WebEncryptedMediaClientImpl-WebEncryptedMediaClientImpl" class="headerlink" title="WebEncryptedMediaClientImpl::WebEncryptedMediaClientImpl"></a>WebEncryptedMediaClientImpl::WebEncryptedMediaClientImpl</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WebEncryptedMediaClientImpl::<span class="built_in">WebEncryptedMediaClientImpl</span>(</span><br><span class="line">    media::CdmFactory* cdm_factory,</span><br><span class="line">    media::MediaPermission* media_permission,</span><br><span class="line">    std::unique_ptr&lt;KeySystemConfigSelector::WebLocalFrameDelegate&gt;</span><br><span class="line">        web_frame_delegate)</span><br><span class="line">    : <span class="built_in">cdm_factory_</span>(cdm_factory),</span><br><span class="line">      <span class="built_in">key_systems_</span>(media::KeySystems::<span class="built_in">GetInstance</span>()),</span><br><span class="line">      <span class="built_in">key_system_config_selector_</span>(key_systems_,</span><br><span class="line">                                  media_permission,</span><br><span class="line">                                  std::<span class="built_in">move</span>(web_frame_delegate)) &#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(cdm_factory_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>key_systems_</code> 是全局唯一实例，<code>key_system_config_selector_</code> 持有 <code>key_systems_</code>，后面 <code>key_system_config_selector_</code> 会从 <code>key_systems_</code> 中选择合适的 KeySystem</p><h2 id="WebEncryptedMediaClientImpl-RequestMediaKeySystemAccess"><a href="#WebEncryptedMediaClientImpl-RequestMediaKeySystemAccess" class="headerlink" title="WebEncryptedMediaClientImpl::RequestMediaKeySystemAccess"></a>WebEncryptedMediaClientImpl::RequestMediaKeySystemAccess</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebEncryptedMediaClientImpl::RequestMediaKeySystemAccess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WebEncryptedMediaRequest request)</span> </span>&#123;</span><br><span class="line">  pending_requests_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(request));</span><br><span class="line">  key_systems_-&gt;<span class="built_in">UpdateIfNeeded</span>(</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;WebEncryptedMediaClientImpl::OnKeySystemsUpdated,</span><br><span class="line">                     weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KeySystemsImpl-UpdateIfNeeded"><a href="#KeySystemsImpl-UpdateIfNeeded" class="headerlink" title="KeySystemsImpl::UpdateIfNeeded"></a>KeySystemsImpl::UpdateIfNeeded</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KeySystemsImpl::UpdateIfNeeded</span><span class="params">(base::OnceClosure done_cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is_updating_) &#123;</span><br><span class="line">    update_callbacks_.<span class="built_in">AddUnsafe</span>(std::<span class="built_in">move</span>(done_cb));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">move</span>(done_cb).<span class="built_in">Run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KeySystemsImpl-KeySystemsImpl"><a href="#KeySystemsImpl-KeySystemsImpl" class="headerlink" title="KeySystemsImpl::KeySystemsImpl"></a>KeySystemsImpl::KeySystemsImpl</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KeySystemsImpl::<span class="built_in">KeySystemsImpl</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; entry : kMimeTypeToCodecsMap)</span><br><span class="line">    <span class="built_in">RegisterMimeType</span>(entry.mime_type, entry.codecs);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">UpdateSupportedKeySystems</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="KeySystemsImpl-RegisterMimeType"><a href="#KeySystemsImpl-RegisterMimeType" class="headerlink" title="KeySystemsImpl::RegisterMimeType"></a>KeySystemsImpl::RegisterMimeType</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mapping between containers and their codecs.</span></span><br><span class="line"><span class="comment">// Only audio codecs can belong to a &quot;audio/*&quot; mime_type, and only video codecs</span></span><br><span class="line"><span class="comment">// can belong to a &quot;video/*&quot; mime_type.</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MimeTypeToCodecs kMimeTypeToCodecsMap[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;audio/webm&quot;</span>, EME_CODEC_WEBM_AUDIO_ALL&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;video/webm&quot;</span>, EME_CODEC_WEBM_VIDEO_ALL&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;audio/mp4&quot;</span>, EME_CODEC_MP4_AUDIO_ALL&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;video/mp4&quot;</span>, EME_CODEC_MP4_VIDEO_ALL&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(USE_PROPRIETARY_CODECS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(ENABLE_MSE_MPEG2TS_STREAM_PARSER)</span></span><br><span class="line">    &#123;<span class="string">&quot;video/mp2t&quot;</span>, EME_CODEC_MP2T_VIDEO_ALL&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(ENABLE_MSE_MPEG2TS_STREAM_PARSER)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(USE_PROPRIETARY_CODECS)</span></span></span><br><span class="line">&#125;;      <span class="comment">// namespace media</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adds the MIME type with the codec mask after verifying the validity.</span></span><br><span class="line"><span class="comment">// Only this function should modify |mime_type_to_codecs_map_|.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KeySystemsImpl::RegisterMimeType</span><span class="params">(<span class="type">const</span> std::string&amp; mime_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      SupportedCodecs codecs)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(thread_checker_.<span class="built_in">CalledOnValidThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(!mime_type_to_codecs_map_.<span class="built_in">count</span>(mime_type));</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsValidMimeTypeCodecsCombination</span>(mime_type, codecs))</span><br><span class="line">      &lt;&lt; <span class="string">&quot;: mime_type = &quot;</span> &lt;&lt; mime_type &lt;&lt; <span class="string">&quot;, codecs = &quot;</span> &lt;&lt; codecs;</span><br><span class="line"></span><br><span class="line">  mime_type_to_codecs_map_[mime_type] = codecs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="KeySystemsImpl-UpdateSupportedKeySystems"><a href="#KeySystemsImpl-UpdateSupportedKeySystems" class="headerlink" title="KeySystemsImpl::UpdateSupportedKeySystems"></a>KeySystemsImpl::UpdateSupportedKeySystems</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KeySystemsImpl::UpdateSupportedKeySystems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(!is_updating_);</span><br><span class="line">  is_updating_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">GetMediaClient</span>()) &#123;</span><br><span class="line">    <span class="built_in">OnSupportedKeySystemsUpdated</span>(&#123;&#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetMediaClient</span>()-&gt;<span class="built_in">GetSupportedKeySystems</span>(</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;KeySystemsImpl::OnSupportedKeySystemsUpdated,</span><br><span class="line">                          weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetMediaClient()</code> 函数返回 RenderMediaClient 的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderMediaClient::Initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> RenderMediaClient* client = <span class="keyword">new</span> <span class="built_in">RenderMediaClient</span>();</span><br><span class="line">  media::<span class="built_in">SetMediaClient</span>(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="RenderMediaClient-GetSupportedKeySystems"><a href="#RenderMediaClient-GetSupportedKeySystems" class="headerlink" title="RenderMediaClient::GetSupportedKeySystems"></a>RenderMediaClient::GetSupportedKeySystems</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderMediaClient::GetSupportedKeySystems</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    media::GetSupportedKeySystemsCB cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">GetContentClient</span>()-&gt;<span class="built_in">renderer</span>()-&gt;<span class="built_in">GetSupportedKeySystems</span>(std::<span class="built_in">move</span>(cb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RenderMediaClient::GetSupportedKeySystems</code> 内部使用 <code>GetContentClient()</code> 获得 ContentRendererClient 的子类，这个子类是需要不同平台自己实现，比如下面的 XXXContentRendererClient 就支持 Widevine、Playready 两种 CDM</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">XXXContentRendererClient::GetSupportedKeySystems</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    media::GetSupportedKeySystemsCB cb)</span> </span>&#123;</span><br><span class="line">  media::KeySystemPropertiesVector key_systems;</span><br><span class="line">  <span class="keyword">if</span> (base::FeatureList::<span class="built_in">IsEnabled</span>(media::kExternalClearKeyForTesting))</span><br><span class="line">    key_systems.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;cdm::ExternalClearKeyProperties&gt;());</span><br><span class="line">  key_systems.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;WidevineProperties&gt;());</span><br><span class="line">  key_systems.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;PlayreadyProperties&gt;());</span><br><span class="line">  std::<span class="built_in">move</span>(cb).<span class="built_in">Run</span>(std::<span class="built_in">move</span>(key_systems));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WidevineProperties、PlayreadyProperties</code> 继承 <code>media::KeySystemProperties</code>，其实现了相应的方法来表明当前 CDM 的属性，比如支持哪些加密模式（CBCS、CENC），是否支持 Persistent 模式，支持哪些 Codec</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidevineProperties</span> : <span class="keyword">public</span> media::KeySystemProperties &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">GetBaseKeySystemName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsSupportedInitDataType</span><span class="params">(media::EmeInitDataType init_data_type)</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">  <span class="function">media::EmeConfigRule <span class="title">GetEncryptionSchemeConfigRule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      media::EncryptionScheme encryption_scheme)</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">  <span class="function">media::SupportedCodecs <span class="title">GetSupportedCodecs</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">  <span class="function">media::SupportedCodecs <span class="title">GetSupportedHwSecureCodecs</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">  <span class="function">media::EmeConfigRule <span class="title">GetRobustnessConfigRule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::string&amp; key_system,</span></span></span><br><span class="line"><span class="params"><span class="function">      media::EmeMediaType media_type,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::string&amp; requested_robustness,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">bool</span>* <span class="comment">/*hw_secure_requirement*/</span>)</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">  <span class="function">media::EmeConfigRule <span class="title">GetPersistentLicenseSessionSupport</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">  <span class="function">media::EmeFeatureSupport <span class="title">GetPersistentStateSupport</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">  <span class="function">media::EmeFeatureSupport <span class="title">GetDistinctiveIdentifierSupport</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">UseAesDecryptor</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">WidevineProperties::GetBaseKeySystemName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;com.widevine.alpha&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WidevineProperties::IsSupportedInitDataType</span><span class="params">(media::EmeInitDataType init_data_type)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> init_data_type == media::EmeInitDataType::CENC ||</span><br><span class="line">         init_data_type == media::EmeInitDataType::WEBM ||</span><br><span class="line">         init_data_type == media::EmeInitDataType::KEYIDS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">media::EmeConfigRule <span class="title">WidevineProperties::GetEncryptionSchemeConfigRule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    media::EncryptionScheme encryption_scheme)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (encryption_scheme) &#123;</span><br><span class="line">    <span class="keyword">case</span> media::EncryptionScheme::kCenc:</span><br><span class="line">    <span class="keyword">case</span> media::EncryptionScheme::kCbcs:</span><br><span class="line">      <span class="keyword">return</span> media::EmeConfigRule::SUPPORTED;</span><br><span class="line">    <span class="keyword">case</span> media::EncryptionScheme::kUnencrypted:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">NOTREACHED</span>();</span><br><span class="line">  <span class="keyword">return</span> media::EmeConfigRule::NOT_SUPPORTED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">media::SupportedCodecs <span class="title">WidevineProperties::GetSupportedCodecs</span><span class="params">()</span> <span class="type">const</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// On Android, Vorbis, VP8, AAC and AVC1 are supported in MediaCodec:</span></span><br><span class="line">  <span class="comment">// http://developer.android.com/guide/appendix/media-formats.html</span></span><br><span class="line">  <span class="comment">// VP9 support is device dependent.</span></span><br><span class="line">  <span class="keyword">return</span> media::EME_CODEC_VIDEO_ALL | media::EME_CODEC_AUDIO_ALL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">media::SupportedCodecs <span class="title">WidevineProperties::GetSupportedHwSecureCodecs</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> media::EME_CODEC_VIDEO_ALL | media::EME_CODEC_AUDIO_ALL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">media::EmeConfigRule <span class="title">WidevineProperties::GetRobustnessConfigRule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; key_system,</span></span></span><br><span class="line"><span class="params"><span class="function">    media::EmeMediaType media_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; requested_robustness,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">bool</span>* <span class="comment">/*hw_secure_requirement*/</span>)</span> <span class="type">const</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> media::EmeConfigRule::SUPPORTED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">media::EmeConfigRule <span class="title">WidevineProperties::GetPersistentLicenseSessionSupport</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> media::EmeConfigRule::NOT_SUPPORTED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">media::EmeFeatureSupport <span class="title">WidevineProperties::GetPersistentStateSupport</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> media::EmeFeatureSupport::NOT_SUPPORTED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">media::EmeFeatureSupport <span class="title">WidevineProperties::GetDistinctiveIdentifierSupport</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> media::EmeFeatureSupport::NOT_SUPPORTED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WidevineProperties::UseAesDecryptor</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure><h6 id="KeySystemsImpl-OnSupportedKeySystemsUpdated"><a href="#KeySystemsImpl-OnSupportedKeySystemsUpdated" class="headerlink" title="KeySystemsImpl::OnSupportedKeySystemsUpdated"></a>KeySystemsImpl::OnSupportedKeySystemsUpdated</h6><p>获得 KeySystem 信息后调用 OnSupportedKeySystemsUpdated 将 KeySystem 信息回传给 WebEncryptedMediaClientImpl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KeySystemsImpl::OnSupportedKeySystemsUpdated</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    KeySystemPropertiesVector key_systems)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__;</span><br><span class="line"></span><br><span class="line">  is_updating_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clear Key is always supported.</span></span><br><span class="line">  key_systems.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> <span class="built_in">ClearKeyProperties</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ProcessSupportedKeySystems</span>(std::<span class="built_in">move</span>(key_systems));</span><br><span class="line"></span><br><span class="line">  update_callbacks_.<span class="built_in">Notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KeySystemsImpl::ProcessSupportedKeySystems</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    KeySystemPropertiesVector key_systems)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(thread_checker_.<span class="built_in">CalledOnValidThread</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clear `key_system_properties_map_` before we repopulating it.</span></span><br><span class="line">  key_system_properties_map_.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; properties : key_systems) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!properties-&gt;<span class="built_in">GetBaseKeySystemName</span>().<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">DCHECK</span>(properties-&gt;<span class="built_in">GetPersistentStateSupport</span>() !=</span><br><span class="line">           EmeFeatureSupport::INVALID);</span><br><span class="line">    <span class="built_in">DCHECK</span>(properties-&gt;<span class="built_in">GetDistinctiveIdentifierSupport</span>() !=</span><br><span class="line">           EmeFeatureSupport::INVALID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsPotentiallySupportedKeySystem</span>(properties-&gt;<span class="built_in">GetBaseKeySystemName</span>())) &#123;</span><br><span class="line">      <span class="comment">// If you encounter this path, see the comments for the function above.</span></span><br><span class="line">      <span class="built_in">DLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Unsupported name &#x27;&quot;</span> &lt;&lt; properties-&gt;<span class="built_in">GetBaseKeySystemName</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;&#x27;. See code comments.&quot;</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Supporting persistent state is a prerequisite for supporting persistent</span></span><br><span class="line">    <span class="comment">// sessions.</span></span><br><span class="line">    <span class="keyword">if</span> (properties-&gt;<span class="built_in">GetPersistentStateSupport</span>() ==</span><br><span class="line">        EmeFeatureSupport::NOT_SUPPORTED) &#123;</span><br><span class="line">      <span class="built_in">DCHECK</span>(properties-&gt;<span class="built_in">GetPersistentLicenseSessionSupport</span>() ==</span><br><span class="line">             EmeConfigRule::NOT_SUPPORTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CanBlock</span>(*properties)) &#123;</span><br><span class="line">      <span class="built_in">DCHECK</span>(properties-&gt;<span class="built_in">GetDistinctiveIdentifierSupport</span>() ==</span><br><span class="line">             EmeFeatureSupport::ALWAYS_ENABLED);</span><br><span class="line">      <span class="built_in">DCHECK</span>(properties-&gt;<span class="built_in">GetPersistentStateSupport</span>() ==</span><br><span class="line">             EmeFeatureSupport::ALWAYS_ENABLED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> base_key_system_name = properties-&gt;<span class="built_in">GetBaseKeySystemName</span>();</span><br><span class="line">    <span class="built_in">DCHECK</span>(!key_system_properties_map_.<span class="built_in">count</span>(base_key_system_name))</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Key system &#x27;&quot;</span> &lt;&lt; base_key_system_name &lt;&lt; <span class="string">&quot;&#x27; already registered&quot;</span>;</span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Adding key system &quot;</span> &lt;&lt; base_key_system_name;</span><br><span class="line">    key_system_properties_map_[base_key_system_name] = std::<span class="built_in">move</span>(properties);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####### WebEncryptedMediaClientImpl::OnKeySystemsUpdated</p><p>KeySystemsImpl::OnSupportedKeySystemsUpdated 的最后调用 WebEncryptedMediaClientImpl::OnKeySystemsUpdated</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebEncryptedMediaClientImpl::OnKeySystemsUpdated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> requests = std::<span class="built_in">move</span>(pending_requests_);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; request : requests)</span><br><span class="line">    <span class="built_in">SelectConfig</span>(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pending_requests_</code> 就是 WebEncryptedMediaClientImpl::RequestMediaKeySystemAccess 中的参数，SelectConfig 会处理每一个 Request</p><p>SelectConfig 内部通过 <code>key_system_config_selector_</code>，而 <code>key_system_config_selector_</code> 内部有 key_system，<code>key_system_config_selector_</code> 通过 key_system 选择完毕后使用 WebEncryptedMediaClientImpl::OnConfigSelected 回传结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebEncryptedMediaClientImpl::SelectConfig</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WebEncryptedMediaRequest request)</span> </span>&#123;</span><br><span class="line">  key_system_config_selector_.<span class="built_in">SelectConfig</span>(</span><br><span class="line">      request.<span class="built_in">KeySystem</span>(), request.<span class="built_in">SupportedConfigurations</span>(),</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;WebEncryptedMediaClientImpl::OnConfigSelected,</span><br><span class="line">                     weak_factory_.<span class="built_in">GetWeakPtr</span>(), request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KeySystemConfigSelector::SelectConfig</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebString&amp; key_system,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebVector&lt;WebMediaKeySystemConfiguration&gt;&amp; candidate_configurations,</span></span></span><br><span class="line"><span class="params"><span class="function">    SelectConfigCB cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">MSG</span>(<span class="string">&quot;key_system: %s \n&quot;</span>, (key_system.<span class="built_in">ContainsOnlyASCII</span>() ? key_system.<span class="built_in">Ascii</span>().<span class="built_in">c_str</span>() : key_system.<span class="built_in">Latin1</span>().<span class="built_in">c_str</span>()));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  std::string key_system_ascii = key_system.<span class="built_in">Ascii</span>();</span><br><span class="line">  <span class="keyword">if</span> (!key_systems_-&gt;<span class="built_in">IsSupportedKeySystem</span>(key_system_ascii)) &#123;</span><br><span class="line">    std::<span class="built_in">move</span>(cb).<span class="built_in">Run</span>(Status::kUnsupportedKeySystem, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> is_encrypted_media_enabled =</span><br><span class="line">      media_permission_-&gt;<span class="built_in">IsEncryptedMediaEnabled</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Only report this UMA at most once per renderer process.</span></span><br><span class="line">  <span class="type">static</span> <span class="type">bool</span> has_reported_encrypted_media_enabled_uma = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!has_reported_encrypted_media_enabled_uma) &#123;</span><br><span class="line">    has_reported_encrypted_media_enabled_uma = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">UMA_HISTOGRAM_BOOLEAN</span>(<span class="string">&quot;Media.EME.EncryptedMediaEnabled&quot;</span>,</span><br><span class="line">                          is_encrypted_media_enabled);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// According to Section 9 &quot;Common Key Systems&quot;: All user agents MUST support</span></span><br><span class="line">  <span class="comment">// the common key systems described in this section.</span></span><br><span class="line">  <span class="comment">//   9.1 Clear Key</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Therefore, always support Clear Key key system and only check settings for</span></span><br><span class="line">  <span class="comment">// other key systems.</span></span><br><span class="line">  <span class="keyword">if</span> (!is_encrypted_media_enabled &amp;&amp; !media::<span class="built_in">IsClearKey</span>(key_system_ascii)) &#123;</span><br><span class="line">    std::<span class="built_in">move</span>(cb).<span class="built_in">Run</span>(Status::kUnsupportedKeySystem, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.2-6.4. Implemented by OnSelectConfig().</span></span><br><span class="line">  <span class="comment">// TODO(sandersd): This should be async, ideally not on the main thread.</span></span><br><span class="line">  <span class="keyword">auto</span> request = std::<span class="built_in">make_unique</span>&lt;SelectionRequest&gt;();</span><br><span class="line">  request-&gt;key_system = key_system_ascii;</span><br><span class="line">  request-&gt;candidate_configurations = candidate_configurations;</span><br><span class="line">  request-&gt;cb = std::<span class="built_in">move</span>(cb);</span><br><span class="line">  <span class="built_in">SelectConfigInternal</span>(std::<span class="built_in">move</span>(request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KeySystemConfigSelector::SelectConfigInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;SelectionRequest&gt; request)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">3</span>) &lt;&lt; __func__;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Continued from requestMediaKeySystemAccess(), step 6, from</span></span><br><span class="line">  <span class="comment">// https://w3c.github.io/encrypted-media/#requestmediakeysystemaccess</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 6.2. Let implementation be the implementation of keySystem.</span></span><br><span class="line">  <span class="comment">//      (|key_systems_| fills this role.)</span></span><br><span class="line">  <span class="comment">// 6.3. For each value in supportedConfigurations:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; request-&gt;candidate_configurations.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 6.3.1. Let candidate configuration be the value.</span></span><br><span class="line">    <span class="comment">// 6.3.2. Let supported configuration be the result of executing the Get</span></span><br><span class="line">    <span class="comment">//        Supported Configuration algorithm on implementation, candidate</span></span><br><span class="line">    <span class="comment">//        configuration, and origin.</span></span><br><span class="line">    <span class="comment">// 6.3.3. If supported configuration is not NotSupported, [initialize</span></span><br><span class="line">    <span class="comment">//        and return a new MediaKeySystemAccess object.]</span></span><br><span class="line">    <span class="function">ConfigState <span class="title">config_state</span><span class="params">(request-&gt;was_permission_requested,</span></span></span><br><span class="line"><span class="params"><span class="function">                             request-&gt;is_permission_granted)</span></span>;</span><br><span class="line">    WebMediaKeySystemConfiguration accumulated_configuration;</span><br><span class="line">    media::CdmConfig cdm_config;</span><br><span class="line">    ConfigurationSupport support = <span class="built_in">GetSupportedConfiguration</span>(</span><br><span class="line">        request-&gt;key_system, request-&gt;candidate_configurations[i],</span><br><span class="line">        &amp;config_state, &amp;accumulated_configuration);</span><br><span class="line">    <span class="keyword">switch</span> (support) &#123;</span><br><span class="line">      <span class="keyword">case</span> CONFIGURATION_NOT_SUPPORTED:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> CONFIGURATION_REQUIRES_PERMISSION:</span><br><span class="line">        <span class="keyword">if</span> (request-&gt;was_permission_requested) &#123;</span><br><span class="line">          <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;Rejecting requested configuration because &quot;</span></span><br><span class="line">                   &lt;&lt; <span class="string">&quot;permission was denied.&quot;</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">DVLOG</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;Request permission.&quot;</span>;</span><br><span class="line">        media_permission_-&gt;<span class="built_in">RequestPermission</span>(</span><br><span class="line">            media::MediaPermission::PROTECTED_MEDIA_IDENTIFIER,</span><br><span class="line">            base::<span class="built_in">BindOnce</span>(&amp;KeySystemConfigSelector::OnPermissionResult,</span><br><span class="line">                           weak_factory_.<span class="built_in">GetWeakPtr</span>(), std::<span class="built_in">move</span>(request)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> CONFIGURATION_SUPPORTED:</span><br><span class="line">        std::string key_system = request-&gt;key_system;</span><br><span class="line">        <span class="keyword">if</span> (key_systems_-&gt;<span class="built_in">ShouldUseBaseKeySystemName</span>(key_system))</span><br><span class="line">          key_system = key_systems_-&gt;<span class="built_in">GetBaseKeySystemName</span>(key_system);</span><br><span class="line">        cdm_config.key_system = key_system;</span><br><span class="line"></span><br><span class="line">        cdm_config.allow_distinctive_identifier =</span><br><span class="line">            (accumulated_configuration.distinctive_identifier ==</span><br><span class="line">             EmeFeatureRequirement::kRequired);</span><br><span class="line">        cdm_config.allow_persistent_state =</span><br><span class="line">            (accumulated_configuration.persistent_state ==</span><br><span class="line">             EmeFeatureRequirement::kRequired);</span><br><span class="line">        cdm_config.use_hw_secure_codecs =</span><br><span class="line">            config_state.<span class="built_in">AreHwSecureCodecsRequired</span>();</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">move</span>(request-&gt;cb)</span><br><span class="line">            .<span class="built_in">Run</span>(Status::kSupported, &amp;accumulated_configuration, &amp;cdm_config);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.4. Reject promise with a NotSupportedError.</span></span><br><span class="line">  std::<span class="built_in">move</span>(request-&gt;cb).<span class="built_in">Run</span>(Status::kUnsupportedConfigs, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######## WebEncryptedMediaClientImpl::OnConfigSelected</p><p>OnConfigSelected 用输入的 CdmConfig 创建 WebContentDecryptionModuleAccessImpl，WebContentDecryptionModuleAccessImpl 就对应了上面例子中的 MediaKeySystemAccess，后面会通过 MediaKeySystemAccess 去创建 MediaKeys，这部分下篇文章再介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebEncryptedMediaClientImpl::OnConfigSelected</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WebEncryptedMediaRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">    KeySystemConfigSelector::Status status,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebMediaKeySystemConfiguration* accumulated_configuration,</span></span></span><br><span class="line"><span class="params"><span class="function">    media::CdmConfig* cdm_config)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update encrypted_media_supported_types_browsertest.cc if updating these</span></span><br><span class="line">  <span class="comment">// strings.</span></span><br><span class="line">  <span class="comment">// TODO(xhwang): Consider using different messages for kUnsupportedKeySystem</span></span><br><span class="line">  <span class="comment">// and kUnsupportedConfigs.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> kUnsupportedKeySystemOrConfigMessage[] =</span><br><span class="line">      <span class="string">&quot;Unsupported keySystem or supportedConfigurations.&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle unsupported cases first.</span></span><br><span class="line">  <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">    <span class="keyword">case</span> KeySystemConfigSelector::Status::kUnsupportedKeySystem:</span><br><span class="line">    <span class="keyword">case</span> KeySystemConfigSelector::Status::kUnsupportedConfigs:</span><br><span class="line">      request.<span class="built_in">RequestNotSupported</span>(kUnsupportedKeySystemOrConfigMessage);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> KeySystemConfigSelector::Status::kSupported:</span><br><span class="line">      <span class="keyword">break</span>;  <span class="comment">// Handled below.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the requested key system to match what&#x27;s reported in</span></span><br><span class="line">  <span class="comment">// RequestMediaKeySystemAccess().</span></span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(status, KeySystemConfigSelector::Status::kSupported);</span><br><span class="line">  <span class="built_in">GetReporter</span>(request.<span class="built_in">KeySystem</span>())-&gt;<span class="built_in">ReportSupported</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the frame is closed while the permission prompt is displayed,</span></span><br><span class="line">  <span class="comment">// the permission prompt is dismissed and this may result in the</span></span><br><span class="line">  <span class="comment">// requestMediaKeySystemAccess request succeeding. However, the blink</span></span><br><span class="line">  <span class="comment">// objects may have been cleared, so check if this is the case and simply</span></span><br><span class="line">  <span class="comment">// reject the request.</span></span><br><span class="line">  WebSecurityOrigin origin = request.<span class="built_in">GetSecurityOrigin</span>();</span><br><span class="line">  <span class="keyword">if</span> (origin.<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">    request.<span class="built_in">RequestNotSupported</span>(<span class="string">&quot;Unable to create MediaKeySystemAccess&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the returned key system which should be used for CDM creation.</span></span><br><span class="line">  request.<span class="built_in">RequestSucceeded</span>(WebContentDecryptionModuleAccessImpl::<span class="built_in">Create</span>(</span><br><span class="line">      origin, *accumulated_configuration, *cdm_config,</span><br><span class="line">      weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这篇文章主要介绍了 requestMediaKeySystemAccess 的过程，核心是通过 WebEncryptedMediaClientImpl::RequestMediaKeySystemAccess 函数，如果想让自己的系统支持哪些 CDM，需要实现 ContentRendererClient 的子类，在子类中重载 GetSupportedKeySystems 方法。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium 多媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium 多媒体（三）</title>
      <link href="/2023/06/27/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/06/27/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这篇文章接着上一篇继续分析 SourceBuffer::appendBuffer 过程，希望理清楚 buffer 是如何在 StreamParser、FrameProcessor 中传递，以及上面 MP4StreamParser、SourceBufferState 中的 CallBack 是何时被调用的</p><h1 id="SourceBuffer-appendBuffer"><a href="#SourceBuffer-appendBuffer" class="headerlink" title="SourceBuffer::appendBuffer"></a>SourceBuffer::appendBuffer</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SourceBuffer::appendBuffer</span><span class="params">(DOMArrayBuffer* data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ExceptionState&amp; exception_state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; size=&quot;</span> &lt;&lt; data-&gt;<span class="built_in">ByteLength</span>();</span><br><span class="line">  <span class="comment">// Section 3.2 appendBuffer()</span></span><br><span class="line">  <span class="comment">// https://dvcs.w3.org/hg/html-media/raw-file/default/media-source/media-source.html#widl-SourceBuffer-appendBuffer-void-ArrayBufferView-data</span></span><br><span class="line">  <span class="built_in">AppendBufferInternal</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*&gt;(data-&gt;<span class="built_in">Data</span>()),</span><br><span class="line">                       data-&gt;<span class="built_in">ByteLength</span>(), exception_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>appendBuffer 内部调用 AppendBufferInternal</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SourceBuffer::AppendBufferInternal</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        ExceptionState&amp; exception_state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_BEGIN1</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;SourceBuffer::appendBuffer&quot;</span>,</span><br><span class="line">                                    <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>), <span class="string">&quot;size&quot;</span>, size);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do remainder of steps of prepare append algorithm and appendBuffer only if</span></span><br><span class="line">  <span class="comment">// attachment is usable and underlying demuxer is protected from destruction</span></span><br><span class="line">  <span class="comment">// (applicable especially for MSE-in-Worker case). Note, we must have</span></span><br><span class="line">  <span class="comment">// |source_| and |source_| must have an attachment because !IsRemoved().</span></span><br><span class="line">  <span class="keyword">if</span> (!source_-&gt;<span class="built_in">RunUnlessElementGoneOrClosingUs</span>(WTF::<span class="built_in">Bind</span>(</span><br><span class="line">          &amp;SourceBuffer::AppendBufferInternal_Locked, <span class="built_in">WrapPersistent</span>(<span class="keyword">this</span>),</span><br><span class="line">          WTF::<span class="built_in">Unretained</span>(data), size, WTF::<span class="built_in">Unretained</span>(&amp;exception_state)))) &#123;</span><br><span class="line">    <span class="comment">// TODO(https://crbug.com/878133): Determine in specification what the</span></span><br><span class="line">    <span class="comment">// specific, app-visible, exception should be for this case.</span></span><br><span class="line">    MediaSource::<span class="built_in">LogAndThrowDOMException</span>(</span><br><span class="line">        exception_state, DOMExceptionCode::kInvalidStateError,</span><br><span class="line">        <span class="string">&quot;Worker MediaSource attachment is closing&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SourceBuffer::AppendBufferInternal_Locked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">    ExceptionState* exception_state,</span></span></span><br><span class="line"><span class="params"><span class="function">    MediaSourceAttachmentSupplement::ExclusiveKey <span class="comment">/* passkey */</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (data) &#123;</span><br><span class="line">    <span class="comment">// We are guaranteed to not have anything in |pending_append_data_|</span></span><br><span class="line">    <span class="comment">// currently. Instead of adding the new data to an empty WTF::Vector, which</span></span><br><span class="line">    <span class="comment">// could crash on OOM during the inherent allocation, we instead just</span></span><br><span class="line">    <span class="comment">// attempt to allocate specifically the needed size and copy the input data</span></span><br><span class="line">    <span class="comment">// to it. We do not need vector iterator semantics, just a basic byte</span></span><br><span class="line">    <span class="comment">// buffer. This allows us to use the underlying allocator&#x27;s ability to</span></span><br><span class="line">    <span class="comment">// return null if the allocation fails, instead of causing OOM.</span></span><br><span class="line">    <span class="comment">// TODO(crbug.com/1266639): Consider further optimizations.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AllocatePendingAppendData</span>(base::<span class="built_in">checked_cast</span>&lt;<span class="type">wtf_size_t</span>&gt;(size))) &#123;</span><br><span class="line">      <span class="built_in">DCHECK</span>(!pending_append_data_);</span><br><span class="line">      <span class="built_in">DCHECK</span>(!pending_append_data_size_);</span><br><span class="line">      <span class="built_in">DCHECK</span>(!pending_append_data_offset_);</span><br><span class="line">      MediaSource::<span class="built_in">LogAndThrowDOMException</span>(</span><br><span class="line">          *exception_state, DOMExceptionCode::kQuotaExceededError,</span><br><span class="line">          <span class="string">&quot;Unable to allocate space required to buffer appended media.&quot;</span>);</span><br><span class="line">      <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_END0</span>(</span><br><span class="line">          <span class="string">&quot;media&quot;</span>, <span class="string">&quot;SourceBuffer::prepareAsyncAppend&quot;</span>, <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy |data| into |pending_append_data_| and continue.</span></span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        !WTF::PartitionAllocator::kIsGarbageCollected,</span><br><span class="line">        <span class="string">&quot;Ensure that we can use simple memcpy when using PartitionAllocator&quot;</span>);</span><br><span class="line">    <span class="built_in">DCHECK</span>(pending_append_data_);</span><br><span class="line">    <span class="built_in">DCHECK_EQ</span>(pending_append_data_size_, base::<span class="built_in">checked_cast</span>&lt;<span class="type">wtf_size_t</span>&gt;(size));</span><br><span class="line">    <span class="built_in">DCHECK</span>(!pending_append_data_offset_);</span><br><span class="line">    <span class="built_in">memcpy</span>(pending_append_data_.<span class="built_in">get</span>(), data, size);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. Asynchronously run the buffer append algorithm.</span></span><br><span class="line">  append_buffer_async_task_handle_ = <span class="built_in">PostCancellableTask</span>(</span><br><span class="line">      *<span class="built_in">GetExecutionContext</span>()-&gt;<span class="built_in">GetTaskRunner</span>(TaskType::kMediaElementEvent),</span><br><span class="line">      FROM_HERE,</span><br><span class="line">      WTF::<span class="built_in">Bind</span>(&amp;SourceBuffer::AppendBufferAsyncPart, <span class="built_in">WrapPersistent</span>(<span class="keyword">this</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_END0</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;prepareAsyncAppend&quot;</span>,</span><br><span class="line">                                  <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>));</span><br><span class="line">  <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_BEGIN1</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;delay&quot;</span>, <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>),</span><br><span class="line">                                    <span class="string">&quot;type&quot;</span>, <span class="string">&quot;initialDelay&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SourceBuffer::AppendBufferAsyncPart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Do the async append operation only if attachment is usable and underlying</span></span><br><span class="line">  <span class="comment">// demuxer is protected from destruction (applicable especially for</span></span><br><span class="line">  <span class="comment">// MSE-in-Worker case).</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(!<span class="built_in">IsRemoved</span>());  <span class="comment">// So must have |source_| and it must have attachment.</span></span><br><span class="line">  <span class="keyword">if</span> (!source_-&gt;<span class="built_in">RunUnlessElementGoneOrClosingUs</span>(WTF::<span class="built_in">Bind</span>(</span><br><span class="line">          &amp;SourceBuffer::AppendBufferAsyncPart_Locked, <span class="built_in">WrapPersistent</span>(<span class="keyword">this</span>)))) &#123;</span><br><span class="line">    <span class="comment">// TODO(https://crbug.com/878133): Determine in specification what the</span></span><br><span class="line">    <span class="comment">// specific, app-visible, behavior should be for this case. In this</span></span><br><span class="line">    <span class="comment">// implementation:</span></span><br><span class="line">    <span class="comment">// 1) If main context isn&#x27;t destroyed yet, then there must be a pending</span></span><br><span class="line">    <span class="comment">// MediaSource::Close() call which will call RemovedFromMediaSource()</span></span><br><span class="line">    <span class="comment">// eventually if still safe to do so (and that will cleanly shutdown pending</span></span><br><span class="line">    <span class="comment">// async append state if we just do nothing here now, or</span></span><br><span class="line">    <span class="comment">// 2) If main context is destroyed, then our context will be destroyed soon.</span></span><br><span class="line">    <span class="comment">// We cannot safely access the underlying demuxer. So the safest thing to do</span></span><br><span class="line">    <span class="comment">// is nothing here now.</span></span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; this=&quot;</span> &lt;&lt; <span class="keyword">this</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;: Worker MediaSource attachment is closing&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SourceBuffer::AppendBufferAsyncPart_Locked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MediaSourceAttachmentSupplement::ExclusiveKey pass_key)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(source_);</span><br><span class="line">  source_-&gt;<span class="built_in">AssertAttachmentsMutexHeldIfCrossThreadForDebugging</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(updating_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Section 3.5.4 Buffer Append Algorithm</span></span><br><span class="line">  <span class="comment">// https://dvcs.w3.org/hg/html-media/raw-file/default/media-source/media-source.html#sourcebuffer-buffer-append</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. Run the segment parser loop algorithm.</span></span><br><span class="line">  <span class="comment">// Step 2 doesn&#x27;t apply since we run Step 1 synchronously here.</span></span><br><span class="line">  <span class="built_in">DCHECK_GE</span>(pending_append_data_size_, pending_append_data_offset_);</span><br><span class="line">  <span class="type">wtf_size_t</span> append_size =</span><br><span class="line">      pending_append_data_size_ - pending_append_data_offset_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Impose an arbitrary max size for a single append() call so that an append</span></span><br><span class="line">  <span class="comment">// doesn&#x27;t block the renderer event loop very long. This value was selected</span></span><br><span class="line">  <span class="comment">// by looking at YouTube SourceBuffer usage across a variety of bitrates.</span></span><br><span class="line">  <span class="comment">// This value allows relatively large appends while keeping append() call</span></span><br><span class="line">  <span class="comment">// duration in the ~5-15ms range. Note that even in MSE-in-Worker case, we</span></span><br><span class="line">  <span class="comment">// retain this behavior because some synchronous operations done by the main</span></span><br><span class="line">  <span class="comment">// thread media element on our attachment block until we are finished and have</span></span><br><span class="line">  <span class="comment">// exited the attachment&#x27;s RunExclusively() callback scope.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">wtf_size_t</span> kMaxAppendSize = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">if</span> (append_size &gt; kMaxAppendSize)</span><br><span class="line">    append_size = kMaxAppendSize;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_END0</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;delay&quot;</span>, <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>));</span><br><span class="line">  <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_BEGIN1</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;appending&quot;</span>, <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>),</span><br><span class="line">                                    <span class="string">&quot;appendSize&quot;</span>, append_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// |zero| is used for 0 byte appends so we always have a valid pointer.</span></span><br><span class="line">  <span class="comment">// We need to convey all appends, even 0 byte ones to |m_webSourceBuffer|</span></span><br><span class="line">  <span class="comment">// so that it can clear its end of stream state if necessary.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> zero = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>* append_data = &amp;zero;</span><br><span class="line">  <span class="keyword">if</span> (append_size) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(pending_append_data_);</span><br><span class="line">    append_data = pending_append_data_.<span class="built_in">get</span>() + pending_append_data_offset_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> append_success =</span><br><span class="line">      web_source_buffer_-&gt;<span class="built_in">Append</span>(append_data, append_size, &amp;timestamp_offset_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!append_success) &#123;</span><br><span class="line">    <span class="built_in">ClearPendingAppendData</span>();</span><br><span class="line">    <span class="comment">// Note that AppendError() calls NotifyDurationChanged, so a cross-thread</span></span><br><span class="line">    <span class="comment">// attachment will send updated buffered and seekable information to the</span></span><br><span class="line">    <span class="comment">// main thread here, too.</span></span><br><span class="line">    <span class="built_in">AppendError</span>(pass_key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pending_append_data_offset_ += append_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pending_append_data_offset_ &lt; pending_append_data_size_) &#123;</span><br><span class="line">      append_buffer_async_task_handle_ = <span class="built_in">PostCancellableTask</span>(</span><br><span class="line">          *<span class="built_in">GetExecutionContext</span>()-&gt;<span class="built_in">GetTaskRunner</span>(TaskType::kMediaElementEvent),</span><br><span class="line">          FROM_HERE,</span><br><span class="line">          WTF::<span class="built_in">Bind</span>(&amp;SourceBuffer::AppendBufferAsyncPart,</span><br><span class="line">                    <span class="built_in">WrapPersistent</span>(<span class="keyword">this</span>)));</span><br><span class="line">      <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_END0</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;appending&quot;</span>,</span><br><span class="line">                                      <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>));</span><br><span class="line">      <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_BEGIN1</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;delay&quot;</span>, <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>),</span><br><span class="line">                                        <span class="string">&quot;type&quot;</span>, <span class="string">&quot;nextPieceDelay&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Set the updating attribute to false.</span></span><br><span class="line">    updating_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">ClearPendingAppendData</span>();</span><br><span class="line"></span><br><span class="line">    source_-&gt;<span class="built_in">SendUpdatedInfoToMainThreadCache</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. Queue a task to fire a simple event named update at this SourceBuffer</span></span><br><span class="line">    <span class="comment">//    object.</span></span><br><span class="line">    <span class="built_in">ScheduleEvent</span>(event_type_names::kUpdate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. Queue a task to fire a simple event named updateend at this</span></span><br><span class="line">    <span class="comment">//    SourceBuffer object.</span></span><br><span class="line">    <span class="built_in">ScheduleEvent</span>(event_type_names::kUpdateend);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_END0</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;appending&quot;</span>, <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>));</span><br><span class="line">  <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_END0</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;SourceBuffer::appendBuffer&quot;</span>,</span><br><span class="line">                                  <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> media_time = <span class="built_in">GetMediaTime</span>();</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">3</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; done. this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; media_time=&quot;</span> &lt;&lt; media_time</span><br><span class="line">           &lt;&lt; <span class="string">&quot; buffered=&quot;</span></span><br><span class="line">           &lt;&lt; <span class="built_in">WebTimeRangesToString</span>(web_source_buffer_-&gt;<span class="built_in">Buffered</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SourceBuffer::appendBuffer 最终会调用到 WebSourceBufferImpl::appendBuffer</p><h2 id="WebSourceBufferImpl-appendBuffer"><a href="#WebSourceBufferImpl-appendBuffer" class="headerlink" title="WebSourceBufferImpl::appendBuffer"></a>WebSourceBufferImpl::appendBuffer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WebSourceBufferImpl::Append</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">unsigned</span> length,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">double</span>* timestamp_offset)</span> </span>&#123;</span><br><span class="line">  base::TimeDelta old_offset = timestamp_offset_;</span><br><span class="line">  <span class="type">bool</span> success = demuxer_-&gt;<span class="built_in">AppendData</span>(id_, data, length, append_window_start_,</span><br><span class="line">                                      append_window_end_, &amp;timestamp_offset_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Coded frame processing may update the timestamp offset. If the caller</span></span><br><span class="line">  <span class="comment">// provides a non-nullptr |timestamp_offset| and frame processing changes the</span></span><br><span class="line">  <span class="comment">// timestamp offset, report the new offset to the caller. Do not update the</span></span><br><span class="line">  <span class="comment">// caller&#x27;s offset otherwise, to preserve any pre-existing value that may have</span></span><br><span class="line">  <span class="comment">// more than microsecond precision.</span></span><br><span class="line">  <span class="keyword">if</span> (timestamp_offset &amp;&amp; old_offset != timestamp_offset_)</span><br><span class="line">    *timestamp_offset = timestamp_offset_.<span class="built_in">InSecondsF</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ChunkDemuxer-AppendData"><a href="#ChunkDemuxer-AppendData" class="headerlink" title="ChunkDemuxer::AppendData"></a>ChunkDemuxer::AppendData</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ChunkDemuxer::AppendData</span><span class="params">(<span class="type">const</span> std::string&amp; id,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">uint8_t</span>* data,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> length,</span></span></span><br><span class="line"><span class="params"><span class="function">                              base::TimeDelta append_window_start,</span></span></span><br><span class="line"><span class="params"><span class="function">                              base::TimeDelta append_window_end,</span></span></span><br><span class="line"><span class="params"><span class="function">                              base::TimeDelta* timestamp_offset)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;AppendData(&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(!id.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(timestamp_offset);</span><br><span class="line"></span><br><span class="line">  Ranges&lt;base::TimeDelta&gt; ranges;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">base::AutoLock <span class="title">auto_lock</span><span class="params">(lock_)</span></span>;</span><br><span class="line">    <span class="built_in">DCHECK_NE</span>(state_, ENDED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Capture if any of the SourceBuffers are waiting for data before we start</span></span><br><span class="line">    <span class="comment">// parsing.</span></span><br><span class="line">    <span class="type">bool</span> old_waiting_for_data = <span class="built_in">IsSeekWaitingForData_Locked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0u</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DCHECK</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (state_) &#123;</span><br><span class="line">      <span class="keyword">case</span> INITIALIZING:</span><br><span class="line">      <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">        <span class="built_in">DCHECK</span>(<span class="built_in">IsValidId</span>(id));</span><br><span class="line">        <span class="keyword">if</span> (!source_state_map_[id]-&gt;<span class="built_in">Append</span>(data, length, append_window_start,</span><br><span class="line">                                           append_window_end,</span><br><span class="line">                                           timestamp_offset)) &#123;</span><br><span class="line">          <span class="built_in">ReportError_Locked</span>(CHUNK_DEMUXER_ERROR_APPEND_FAILED);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> PARSE_ERROR:</span><br><span class="line">      <span class="keyword">case</span> WAITING_FOR_INIT:</span><br><span class="line">      <span class="keyword">case</span> ENDED:</span><br><span class="line">      <span class="keyword">case</span> SHUTDOWN:</span><br><span class="line">        <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;AppendData(): called in unexpected state &quot;</span> &lt;&lt; state_;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to see if data was appended at the pending seek point. This</span></span><br><span class="line">    <span class="comment">// indicates we have parsed enough data to complete the seek. Work is still</span></span><br><span class="line">    <span class="comment">// in progress at this point, but it&#x27;s okay since |seek_cb_| will post.</span></span><br><span class="line">    <span class="keyword">if</span> (old_waiting_for_data &amp;&amp; !<span class="built_in">IsSeekWaitingForData_Locked</span>() &amp;&amp; seek_cb_)</span><br><span class="line">      <span class="built_in">RunSeekCB_Locked</span>(PIPELINE_OK);</span><br><span class="line"></span><br><span class="line">    ranges = <span class="built_in">GetBufferedRanges_Locked</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  host_-&gt;<span class="built_in">OnBufferedTimeRangesChanged</span>(ranges);</span><br><span class="line">  progress_cb_.<span class="built_in">Run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SourceBufferState-Append"><a href="#SourceBufferState-Append" class="headerlink" title="SourceBufferState::Append"></a>SourceBufferState::Append</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SourceBufferState::Append</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* data,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">size_t</span> length,</span></span></span><br><span class="line"><span class="params"><span class="function">                               base::TimeDelta append_window_start,</span></span></span><br><span class="line"><span class="params"><span class="function">                               base::TimeDelta append_window_end,</span></span></span><br><span class="line"><span class="params"><span class="function">                               base::TimeDelta* timestamp_offset)</span> </span>&#123;</span><br><span class="line">  append_in_progress_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">DCHECK</span>(timestamp_offset);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!timestamp_offset_during_append_);</span><br><span class="line">  append_window_start_during_append_ = append_window_start;</span><br><span class="line">  append_window_end_during_append_ = append_window_end;</span><br><span class="line">  timestamp_offset_during_append_ = timestamp_offset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(wolenetz): Curry and pass a NewBuffersCB here bound with append window</span></span><br><span class="line">  <span class="comment">// and timestamp offset pointer. See http://crbug.com/351454.</span></span><br><span class="line">  <span class="type">bool</span> result = stream_parser_-&gt;<span class="built_in">Parse</span>(data, length);</span><br><span class="line">  <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">    <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_)</span><br><span class="line">        &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: stream parsing failed. Data size=&quot;</span> &lt;&lt; length</span><br><span class="line">        &lt;&lt; <span class="string">&quot; append_window_start=&quot;</span> &lt;&lt; append_window_start.<span class="built_in">InSecondsF</span>()</span><br><span class="line">        &lt;&lt; <span class="string">&quot; append_window_end=&quot;</span> &lt;&lt; append_window_end.<span class="built_in">InSecondsF</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  timestamp_offset_during_append_ = <span class="literal">nullptr</span>;</span><br><span class="line">  append_in_progress_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MP4StreamParser-Parse"><a href="#MP4StreamParser-Parse" class="headerlink" title="MP4StreamParser::Parse"></a>MP4StreamParser::Parse</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MP4StreamParser::Parse</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* buf, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_NE</span>(state_, kWaitingForInit);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state_ == kError)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  queue_.<span class="built_in">Push</span>(buf, size);</span><br><span class="line"></span><br><span class="line">  BufferQueueMap buffers;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(sandersd): Remove these bools. ParseResult replaced their purpose, but</span></span><br><span class="line">  <span class="comment">// this method needs to be refactored to complete that work.</span></span><br><span class="line">  <span class="type">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> err = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (state_) &#123;</span><br><span class="line">      <span class="keyword">case</span> kWaitingForInit:</span><br><span class="line">      <span class="keyword">case</span> kError:</span><br><span class="line">        <span class="built_in">NOTREACHED</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kParsingBoxes: &#123;</span><br><span class="line">        ParseResult pr = <span class="built_in">ParseBox</span>();</span><br><span class="line">        result = pr == ParseResult::kOk;</span><br><span class="line">        err = pr == ParseResult::kError;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kWaitingForSampleData:</span><br><span class="line">        result = <span class="built_in">HaveEnoughDataToEnqueueSamples</span>();</span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">          <span class="built_in">ChangeState</span>(kEmittingSamples);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kEmittingSamples: &#123;</span><br><span class="line">        ParseResult pr = <span class="built_in">EnqueueSample</span>(&amp;buffers);</span><br><span class="line">        result = pr == ParseResult::kOk;</span><br><span class="line">        err = pr == ParseResult::kError;</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">          <span class="type">int64_t</span> max_clear = runs_-&gt;<span class="built_in">GetMaxClearOffset</span>() + moof_head_;</span><br><span class="line">          err = !<span class="built_in">ReadAndDiscardMDATsUntil</span>(max_clear);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (result &amp;&amp; !err);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!err)</span><br><span class="line">    err = !<span class="built_in">SendAndFlushSamples</span>(&amp;buffers);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">DLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Error while parsing MP4&quot;</span>;</span><br><span class="line">    moov_.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">Reset</span>();</span><br><span class="line">    <span class="built_in">ChangeState</span>(kError);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="MP4StreamParser-ParseBox"><a href="#MP4StreamParser-ParseBox" class="headerlink" title="MP4StreamParser::ParseBox"></a>MP4StreamParser::ParseBox</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ParseResult <span class="title">MP4StreamParser::ParseBox</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>* buf;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  queue_.<span class="built_in">Peek</span>(&amp;buf, &amp;size);</span><br><span class="line">  <span class="keyword">if</span> (!size)</span><br><span class="line">    <span class="keyword">return</span> ParseResult::kNeedMoreData;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;BoxReader&gt; reader;</span><br><span class="line">  ParseResult result =</span><br><span class="line">      BoxReader::<span class="built_in">ReadTopLevelBox</span>(buf, size, media_log_, &amp;reader);</span><br><span class="line">  <span class="keyword">if</span> (result != ParseResult::kOk)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(reader);</span><br><span class="line">  <span class="keyword">if</span> (reader-&gt;<span class="built_in">type</span>() == FOURCC_MOOV) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseMoov</span>(reader.<span class="built_in">get</span>()))</span><br><span class="line">      <span class="keyword">return</span> ParseResult::kError;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reader-&gt;<span class="built_in">type</span>() == FOURCC_MOOF) &#123;</span><br><span class="line">    moof_head_ = queue_.<span class="built_in">head</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseMoof</span>(reader.<span class="built_in">get</span>()))</span><br><span class="line">      <span class="keyword">return</span> ParseResult::kError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up first mdat offset for ReadMDATsUntil().</span></span><br><span class="line">    mdat_tail_ = queue_.<span class="built_in">head</span>() + reader-&gt;<span class="built_in">box_size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return early to avoid evicting &#x27;moof&#x27; data from queue. Auxiliary info may</span></span><br><span class="line">    <span class="comment">// be located anywhere in the file, including inside the &#x27;moof&#x27; itself.</span></span><br><span class="line">    <span class="comment">// (Since &#x27;default-base-is-moof&#x27; is mandated, no data references can come</span></span><br><span class="line">    <span class="comment">// before the head of the &#x27;moof&#x27;, so keeping this box around is sufficient.)</span></span><br><span class="line">    <span class="keyword">return</span> ParseResult::kOk;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// TODO(wolenetz,chcunningham): Enforce more strict adherence to MSE byte</span></span><br><span class="line">    <span class="comment">// stream spec for ftyp and styp. See http://crbug.com/504514.</span></span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;Skipping top-level box: &quot;</span> &lt;&lt; <span class="built_in">FourCCToString</span>(reader-&gt;<span class="built_in">type</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queue_.<span class="built_in">Pop</span>(reader-&gt;<span class="built_in">box_size</span>());</span><br><span class="line">  <span class="keyword">return</span> ParseResult::kOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####### MP4StreamParser::ParseMoov</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MP4StreamParser::ParseMoov</span><span class="params">(BoxReader* reader)</span> </span>&#123;</span><br><span class="line">  moov_ = std::<span class="built_in">make_unique</span>&lt;Movie&gt;();</span><br><span class="line">  <span class="built_in">RCHECK</span>(moov_-&gt;<span class="built_in">Parse</span>(reader));</span><br><span class="line">  runs_.<span class="built_in">reset</span>();</span><br><span class="line">  audio_track_ids_.<span class="built_in">clear</span>();</span><br><span class="line">  video_track_ids_.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  has_audio_ = <span class="literal">false</span>;</span><br><span class="line">  has_video_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_ptr&lt;MediaTracks&gt; <span class="title">media_tracks</span><span class="params">(<span class="keyword">new</span> MediaTracks())</span></span>;</span><br><span class="line">  AudioDecoderConfig audio_config;</span><br><span class="line">  VideoDecoderConfig video_config;</span><br><span class="line">  <span class="type">int</span> detected_audio_track_count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> detected_video_track_count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> detected_text_track_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::vector&lt;Track&gt;::const_iterator track = moov_-&gt;tracks.<span class="built_in">begin</span>();</span><br><span class="line">       track != moov_-&gt;tracks.<span class="built_in">end</span>(); ++track) &#123;</span><br><span class="line">    <span class="type">const</span> SampleDescription&amp; samp_descr =</span><br><span class="line">        track-&gt;media.information.sample_table.description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(wolenetz): When codec reconfigurations are supported, detect and</span></span><br><span class="line">    <span class="comment">// send a codec reconfiguration for fragments using a sample description</span></span><br><span class="line">    <span class="comment">// index different from the previous one. See https://crbug.com/748250.</span></span><br><span class="line">    <span class="type">size_t</span> desc_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> t = <span class="number">0</span>; t &lt; moov_-&gt;extends.tracks.<span class="built_in">size</span>(); t++) &#123;</span><br><span class="line">      <span class="type">const</span> TrackExtends&amp; trex = moov_-&gt;extends.tracks[t];</span><br><span class="line">      <span class="keyword">if</span> (trex.track_id == track-&gt;header.track_id) &#123;</span><br><span class="line">        desc_idx = trex.default_sample_description_index;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RCHECK</span>(desc_idx &gt; <span class="number">0</span>);</span><br><span class="line">    desc_idx -= <span class="number">1</span>;  <span class="comment">// BMFF descriptor index is one-based</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (track-&gt;media.handler.type == kAudio) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (track-&gt;media.handler.type == kVideo) &#123;</span><br><span class="line">      detected_video_track_count++;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">RCHECK</span>(!samp_descr.video_entries.<span class="built_in">empty</span>());</span><br><span class="line">      <span class="keyword">if</span> (desc_idx &gt;= samp_descr.video_entries.<span class="built_in">size</span>())</span><br><span class="line">        desc_idx = <span class="number">0</span>;</span><br><span class="line">      <span class="type">const</span> VideoSampleEntry&amp; entry = samp_descr.video_entries[desc_idx];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!entry.<span class="built_in">IsFormatValid</span>()) &#123;</span><br><span class="line">        <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Unsupported video format 0x&quot;</span></span><br><span class="line">                                     &lt;&lt; std::hex &lt;&lt; entry.format</span><br><span class="line">                                     &lt;&lt; <span class="string">&quot; in stsd box.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// TODO(strobe): Recover correct crop box</span></span><br><span class="line">      <span class="function">gfx::Size <span class="title">coded_size</span><span class="params">(entry.width, entry.height)</span></span>;</span><br><span class="line">      <span class="function">gfx::Rect <span class="title">visible_rect</span><span class="params">(coded_size)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If PASP is available, use the coded size and PASP to calculate the</span></span><br><span class="line">      <span class="comment">// natural size. Otherwise, use the size in track header for natural size.</span></span><br><span class="line">      VideoAspectRatio aspect_ratio;</span><br><span class="line">      <span class="keyword">if</span> (entry.pixel_aspect.h_spacing != <span class="number">1</span> ||</span><br><span class="line">          entry.pixel_aspect.v_spacing != <span class="number">1</span>) &#123;</span><br><span class="line">        aspect_ratio = VideoAspectRatio::<span class="built_in">PAR</span>(entry.pixel_aspect.h_spacing,</span><br><span class="line">                                             entry.pixel_aspect.v_spacing);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (track-&gt;header.width &amp;&amp; track-&gt;header.height) &#123;</span><br><span class="line">        aspect_ratio =</span><br><span class="line">            VideoAspectRatio::<span class="built_in">DAR</span>(track-&gt;header.width, track-&gt;header.height);</span><br><span class="line">      &#125;</span><br><span class="line">      gfx::Size natural_size = aspect_ratio.<span class="built_in">GetNaturalSize</span>(visible_rect);</span><br><span class="line"></span><br><span class="line">      <span class="type">uint32_t</span> video_track_id = track-&gt;header.track_id;</span><br><span class="line">      <span class="keyword">if</span> (video_track_ids_.<span class="built_in">find</span>(video_track_id) != video_track_ids_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Video track with track_id=&quot;</span> &lt;&lt; video_track_id</span><br><span class="line">            &lt;&lt; <span class="string">&quot; already present.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">bool</span> is_track_encrypted = entry.sinf.info.track_encryption.is_encrypted;</span><br><span class="line">      EncryptionScheme scheme = EncryptionScheme::kUnencrypted;</span><br><span class="line">      <span class="keyword">if</span> (is_track_encrypted) &#123;</span><br><span class="line">        scheme = <span class="built_in">GetEncryptionScheme</span>(entry.sinf);</span><br><span class="line">        <span class="keyword">if</span> (scheme == EncryptionScheme::kUnencrypted)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      video_config.<span class="built_in">Initialize</span>(entry.video_codec, entry.video_codec_profile,</span><br><span class="line">                              VideoDecoderConfig::AlphaMode::kIsOpaque,</span><br><span class="line">                              VideoColorSpace::<span class="built_in">REC709</span>(),</span><br><span class="line">                              <span class="built_in">CalculateRotation</span>(track-&gt;header, moov_-&gt;header),</span><br><span class="line">                              coded_size, visible_rect, natural_size,</span><br><span class="line">                              <span class="comment">// No decoder-specific buffer needed for AVC;</span></span><br><span class="line">                              <span class="comment">// SPS/PPS are embedded in the video stream</span></span><br><span class="line">                              <span class="built_in">EmptyExtraData</span>(), scheme);</span><br><span class="line">      video_config.<span class="built_in">set_aspect_ratio</span>(aspect_ratio);</span><br><span class="line">      video_config.<span class="built_in">set_level</span>(entry.video_codec_level);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (entry.video_color_space.<span class="built_in">IsSpecified</span>())</span><br><span class="line">        video_config.<span class="built_in">set_color_space_info</span>(entry.video_color_space);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (entry.mastering_display_color_volume ||</span><br><span class="line">          entry.content_light_level_information) &#123;</span><br><span class="line">        gfx::HDRMetadata hdr_metadata;</span><br><span class="line">        <span class="keyword">if</span> (entry.mastering_display_color_volume) &#123;</span><br><span class="line">          hdr_metadata.color_volume_metadata = <span class="built_in">ConvertMdcvToColorVolumeMetadata</span>(</span><br><span class="line">              *entry.mastering_display_color_volume);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.content_light_level_information) &#123;</span><br><span class="line">          hdr_metadata.max_content_light_level =</span><br><span class="line">              entry.content_light_level_information-&gt;max_content_light_level;</span><br><span class="line">          hdr_metadata.max_frame_average_light_level =</span><br><span class="line">              entry.content_light_level_information</span><br><span class="line">                  -&gt;max_pic_average_light_level;</span><br><span class="line">        &#125;</span><br><span class="line">        video_config.<span class="built_in">set_hdr_metadata</span>(hdr_metadata);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;video_track_id=&quot;</span> &lt;&lt; video_track_id</span><br><span class="line">               &lt;&lt; <span class="string">&quot; config=&quot;</span> &lt;&lt; video_config.<span class="built_in">AsHumanReadableString</span>();</span><br><span class="line">      <span class="keyword">if</span> (!video_config.<span class="built_in">IsValidConfig</span>()) &#123;</span><br><span class="line">        <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Invalid video decoder config: &quot;</span></span><br><span class="line">                                     &lt;&lt; video_config.<span class="built_in">AsHumanReadableString</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      has_video_ = <span class="literal">true</span>;</span><br><span class="line">      video_track_ids_.<span class="built_in">insert</span>(video_track_id);</span><br><span class="line">      <span class="keyword">auto</span> track_kind =</span><br><span class="line">          MediaTrack::<span class="built_in">Kind</span>(video_track_ids_.<span class="built_in">size</span>() == <span class="number">1</span> ? <span class="string">&quot;main&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">      media_tracks-&gt;<span class="built_in">AddVideoTrack</span>(</span><br><span class="line">          video_config, video_track_id, track_kind,</span><br><span class="line">          MediaTrack::<span class="built_in">Label</span>(track-&gt;media.handler.name),</span><br><span class="line">          MediaTrack::<span class="built_in">Language</span>(track-&gt;media.header.<span class="built_in">language</span>()));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(wolenetz): Investigate support in MSE and Chrome MSE for CEA 608/708</span></span><br><span class="line">    <span class="comment">// embedded caption data in video track. At time of init segment parsing, we</span></span><br><span class="line">    <span class="comment">// don&#x27;t have this data (unless maybe by SourceBuffer&#x27;s mimetype).</span></span><br><span class="line">    <span class="comment">// See https://crbug.com/597073</span></span><br><span class="line">    <span class="keyword">if</span> (track-&gt;media.handler.type == kText)</span><br><span class="line">      detected_text_track_count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!moov_-&gt;pssh.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">OnEncryptedMediaInitData</span>(moov_-&gt;pssh);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RCHECK</span>(config_cb_.<span class="built_in">Run</span>(std::<span class="built_in">move</span>(media_tracks), <span class="built_in">TextTrackConfigMap</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="function">StreamParser::InitParameters <span class="title">params</span><span class="params">(kInfiniteDuration)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (moov_-&gt;extends.header.fragment_duration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    params.duration = <span class="built_in">TimeDeltaFromRational</span>(</span><br><span class="line">        moov_-&gt;extends.header.fragment_duration, moov_-&gt;header.timescale);</span><br><span class="line">    <span class="keyword">if</span> (params.duration == kNoTimestamp) &#123;</span><br><span class="line">      <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Fragment duration exceeds representable &quot;</span></span><br><span class="line">                                   &lt;&lt; <span class="string">&quot;limit&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    params.liveness = StreamLiveness::kRecorded;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moov_-&gt;header.duration &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             ((moov_-&gt;header.version == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               moov_-&gt;header.duration !=</span><br><span class="line">                   std::numeric_limits&lt;<span class="type">uint32_t</span>&gt;::<span class="built_in">max</span>()) ||</span><br><span class="line">              (moov_-&gt;header.version == <span class="number">1</span> &amp;&amp;</span><br><span class="line">               moov_-&gt;header.duration !=</span><br><span class="line">                   std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>()))) &#123;</span><br><span class="line">    <span class="comment">// In ISO/IEC 14496-12:2012, 8.2.2.3: &quot;If the duration cannot be determined</span></span><br><span class="line">    <span class="comment">// then duration is set to all 1s.&quot;</span></span><br><span class="line">    <span class="comment">// The duration field is either 32-bit or 64-bit depending on the version in</span></span><br><span class="line">    <span class="comment">// MovieHeaderBox. We interpret not 0 and not all 1&#x27;s here as &quot;known</span></span><br><span class="line">    <span class="comment">// duration&quot;.</span></span><br><span class="line">    params.duration =</span><br><span class="line">        <span class="built_in">TimeDeltaFromRational</span>(moov_-&gt;header.duration, moov_-&gt;header.timescale);</span><br><span class="line">    <span class="keyword">if</span> (params.duration == kNoTimestamp) &#123;</span><br><span class="line">      <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Movie duration exceeds representable &quot;</span></span><br><span class="line">                                   &lt;&lt; <span class="string">&quot;limit&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    params.liveness = StreamLiveness::kRecorded;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// In ISO/IEC 14496-12:2005(E), 8.30.2: &quot;.. If an MP4 file is created in</span></span><br><span class="line">    <span class="comment">// real-time, such as used in live streaming, it is not likely that the</span></span><br><span class="line">    <span class="comment">// fragment_duration is known in advance and this (mehd) box may be</span></span><br><span class="line">    <span class="comment">// omitted.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We have an unknown duration (neither any mvex fragment_duration nor moov</span></span><br><span class="line">    <span class="comment">// duration value indicated a known duration, above.)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(wolenetz): Investigate gating liveness detection on timeline_offset</span></span><br><span class="line">    <span class="comment">// when it&#x27;s populated. See http://crbug.com/312699</span></span><br><span class="line">    params.liveness = StreamLiveness::kLive;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;liveness: &quot;</span> &lt;&lt; <span class="built_in">GetStreamLivenessName</span>(params.liveness);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (init_cb_) &#123;</span><br><span class="line">    params.detected_audio_track_count = detected_audio_track_count;</span><br><span class="line">    params.detected_video_track_count = detected_video_track_count;</span><br><span class="line">    params.detected_text_track_count = detected_text_track_count;</span><br><span class="line">    std::<span class="built_in">move</span>(init_cb_).<span class="built_in">Run</span>(params);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######## SourceBufferState::OnNewConfigs</p><p>MP4StreamParser::ParseMoov 在遍历完 track 之后，会调用 <code>config_cb_</code>，也就是 SourceBufferState::OnNewConfigs 去创建 ChunkDemuxerStream</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SourceBufferState::OnNewConfigs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::string expected_codecs,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;MediaTracks&gt; tracks,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> StreamParser::TextTrackConfigMap&amp; text_configs)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(tracks.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; expected_codecs=&quot;</span> &lt;&lt; expected_codecs</span><br><span class="line">           &lt;&lt; <span class="string">&quot; tracks=&quot;</span> &lt;&lt; tracks-&gt;<span class="built_in">tracks</span>().<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">DCHECK_GE</span>(state_, PENDING_PARSER_CONFIG);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MSE spec allows new configs to be emitted only during Append, but not</span></span><br><span class="line">  <span class="comment">// during Flush or parser reset operations.</span></span><br><span class="line">  <span class="built_in">CHECK</span>(append_in_progress_);</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> success = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(wolenetz): Update codec string strictness, if necessary, once spec</span></span><br><span class="line">  <span class="comment">// issue https://github.com/w3c/media-source/issues/161 is resolved.</span></span><br><span class="line">  std::vector&lt;AudioCodec&gt; expected_acodecs = expected_audio_codecs_;</span><br><span class="line">  std::vector&lt;VideoCodec&gt; expected_vcodecs = expected_video_codecs_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(wolenetz): Once codec strictness is relaxed, we can change</span></span><br><span class="line">  <span class="comment">// |allow_codec_changes| to always be true. Until then, we only allow codec</span></span><br><span class="line">  <span class="comment">// changes on explicit ChangeType().</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> allow_codec_changes = state_ == PENDING_PARSER_RECONFIG;</span><br><span class="line"></span><br><span class="line">  FrameProcessor::TrackIdChanges track_id_changes;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; track : tracks-&gt;<span class="built_in">tracks</span>()) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; track_id = track-&gt;<span class="built_in">bytestream_track_id</span>(); <span class="comment">//就是mp4里的track id</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (track-&gt;<span class="built_in">type</span>() == MediaTrack::Audio) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (track-&gt;<span class="built_in">type</span>() == MediaTrack::Video) &#123;</span><br><span class="line">      VideoDecoderConfig video_config = tracks-&gt;<span class="built_in">getVideoConfig</span>(track_id);</span><br><span class="line">      <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;Video track_id=&quot;</span> &lt;&lt; track_id</span><br><span class="line">               &lt;&lt; <span class="string">&quot; config: &quot;</span> &lt;&lt; video_config.<span class="built_in">AsHumanReadableString</span>();</span><br><span class="line">      <span class="built_in">DCHECK</span>(video_config.<span class="built_in">IsValidConfig</span>());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (video_config.<span class="built_in">codec</span>() == VideoCodec::kHEVC) &#123;</span><br><span class="line">...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; it = std::<span class="built_in">find</span>(expected_vcodecs.<span class="built_in">begin</span>(),</span><br><span class="line">                                 expected_vcodecs.<span class="built_in">end</span>(), video_config.<span class="built_in">codec</span>());</span><br><span class="line">      <span class="keyword">if</span> (it == expected_vcodecs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Video stream codec &quot;</span></span><br><span class="line">                                     &lt;&lt; <span class="built_in">GetCodecName</span>(video_config.<span class="built_in">codec</span>())</span><br><span class="line">                                     &lt;&lt; <span class="string">&quot; doesn&#x27;t match SourceBuffer codecs.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      expected_vcodecs.<span class="built_in">erase</span>(it);</span><br><span class="line"></span><br><span class="line">      ChunkDemuxerStream* stream = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (!first_init_segment_received_) &#123;</span><br><span class="line">        <span class="built_in">DCHECK</span>(video_streams_.<span class="built_in">find</span>(track_id) == video_streams_.<span class="built_in">end</span>());</span><br><span class="line">        stream = create_demuxer_stream_cb_.<span class="built_in">Run</span>(DemuxerStream::VIDEO);</span><br><span class="line">        <span class="keyword">if</span> (!stream || !frame_processor_-&gt;<span class="built_in">AddTrack</span>(track_id, stream)) &#123;</span><br><span class="line">          <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Failed to create video stream.&quot;</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        video_streams_[track_id] = stream;</span><br><span class="line"></span><br><span class="line">        media_log_-&gt;<span class="built_in">SetProperty</span>&lt;MediaLogProperty::kVideoTracks&gt;(</span><br><span class="line">            std::vector&lt;VideoDecoderConfig&gt;&#123;video_config&#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (video_streams_.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">auto</span> stream_it = video_streams_.<span class="built_in">find</span>(track_id);</span><br><span class="line">          <span class="keyword">if</span> (stream_it != video_streams_.<span class="built_in">end</span>())</span><br><span class="line">            stream = stream_it-&gt;second;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// If there is only one video track then bytestream id might change in</span></span><br><span class="line">          <span class="comment">// a new init segment. So update our state and notify frame processor.</span></span><br><span class="line">          <span class="type">const</span> <span class="keyword">auto</span>&amp; stream_it = video_streams_.<span class="built_in">begin</span>();</span><br><span class="line">          <span class="keyword">if</span> (stream_it != video_streams_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            stream = stream_it-&gt;second;</span><br><span class="line">            <span class="keyword">if</span> (stream_it-&gt;first != track_id) &#123;</span><br><span class="line">              track_id_changes[stream_it-&gt;first] = track_id;</span><br><span class="line">              video_streams_[track_id] = stream;</span><br><span class="line">              video_streams_.<span class="built_in">erase</span>(stream_it-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stream) &#123;</span><br><span class="line">          <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Got unexpected video track&quot;</span></span><br><span class="line">                                       &lt;&lt; <span class="string">&quot; track_id=&quot;</span> &lt;&lt; track_id;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      track-&gt;<span class="built_in">set_id</span>(stream-&gt;<span class="built_in">media_track_id</span>());</span><br><span class="line">      success &amp;= stream-&gt;<span class="built_in">UpdateVideoConfig</span>(video_config, allow_codec_changes,</span><br><span class="line">                                           media_log_);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Error: unsupported media track type &quot;</span></span><br><span class="line">                                   &lt;&lt; track-&gt;<span class="built_in">type</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!expected_acodecs.<span class="built_in">empty</span>() || !expected_vcodecs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; acodec : expected_acodecs) &#123;</span><br><span class="line">      <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Initialization segment misses expected &quot;</span></span><br><span class="line">                                   &lt;&lt; <span class="built_in">GetCodecName</span>(acodec) &lt;&lt; <span class="string">&quot; track.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; vcodec : expected_vcodecs) &#123;</span><br><span class="line">      <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Initialization segment misses expected &quot;</span></span><br><span class="line">                                   &lt;&lt; <span class="built_in">GetCodecName</span>(vcodec) &lt;&lt; <span class="string">&quot; track.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (text_streams_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itr = text_configs.<span class="built_in">begin</span>(); itr != text_configs.<span class="built_in">end</span>(); ++itr) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (audio_streams_.<span class="built_in">empty</span>() &amp;&amp; video_streams_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: couldn&#x27;t find a valid audio or video stream&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!frame_processor_-&gt;<span class="built_in">UpdateTrackIds</span>(track_id_changes)) &#123;</span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: failed to remap track ids in frame processor&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  frame_processor_-&gt;<span class="built_in">SetAllTrackBuffersNeedRandomAccessPoint</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!first_init_segment_received_) &#123;</span><br><span class="line">    first_init_segment_received_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">SetStreamMemoryLimits</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;OnNewConfigs() : &quot;</span> &lt;&lt; (success ? <span class="string">&quot;success&quot;</span> : <span class="string">&quot;failed&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == PENDING_PARSER_CONFIG)</span><br><span class="line">      state_ = PENDING_PARSER_INIT;</span><br><span class="line">    <span class="keyword">if</span> (state_ == PENDING_PARSER_RECONFIG)</span><br><span class="line">      state_ = PENDING_PARSER_REINIT;</span><br><span class="line">    <span class="built_in">DCHECK</span>(init_segment_received_cb_);</span><br><span class="line">    init_segment_received_cb_.<span class="built_in">Run</span>(std::<span class="built_in">move</span>(tracks));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######### ChunkDemuxer::CreateDemuxerStream</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ChunkDemuxerStream* <span class="title">ChunkDemuxer::CreateDemuxerStream</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; source_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    DemuxerStream::Type type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// New ChunkDemuxerStreams can be created only during initialization segment</span></span><br><span class="line">  <span class="comment">// processing, which happens when a new chunk of data is appended and the</span></span><br><span class="line">  <span class="comment">// lock_ must be held by ChunkDemuxer::AppendData/Chunks.</span></span><br><span class="line">  lock_.<span class="built_in">AssertAcquired</span>();</span><br><span class="line"></span><br><span class="line">  MediaTrack::Id media_track_id = <span class="built_in">GenerateMediaTrackId</span>();</span><br><span class="line"></span><br><span class="line">  OwnedChunkDemuxerStreamVector* owning_vector = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> DemuxerStream::AUDIO:</span><br><span class="line">      owning_vector = &amp;audio_streams_;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DemuxerStream::VIDEO:</span><br><span class="line">      owning_vector = &amp;video_streams_;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DemuxerStream::TEXT:</span><br><span class="line">      owning_vector = &amp;text_streams_;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DemuxerStream::UNKNOWN:</span><br><span class="line">      <span class="built_in">NOTREACHED</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;ChunkDemuxerStream&gt; stream =</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;ChunkDemuxerStream&gt;(type, media_track_id);</span><br><span class="line">  <span class="built_in">DCHECK</span>(track_id_to_demux_stream_map_.<span class="built_in">find</span>(media_track_id) ==</span><br><span class="line">         track_id_to_demux_stream_map_.<span class="built_in">end</span>());</span><br><span class="line">  track_id_to_demux_stream_map_[media_track_id] = stream.<span class="built_in">get</span>();</span><br><span class="line">  id_to_streams_map_[source_id].<span class="built_in">push_back</span>(stream.<span class="built_in">get</span>());</span><br><span class="line">  stream-&gt;<span class="built_in">SetEnabled</span>(owning_vector-&gt;<span class="built_in">empty</span>(), base::<span class="built_in">TimeDelta</span>());</span><br><span class="line">  owning_vector-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(stream));</span><br><span class="line">  <span class="keyword">return</span> owning_vector-&gt;<span class="built_in">back</span>().<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######## SourceBufferState::OnSourceInitDone</p><p>MP4StreamParser::ParseMoov 的最后会触发 <code>init_cb_</code>，也就是 SourceBufferState::OnSourceInitDone</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SourceBufferState::OnSourceInitDone</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> StreamParser::InitParameters&amp; params)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We&#x27;ve either yet-to-run |init_cb_| if pending init, or we&#x27;ve previously</span></span><br><span class="line">  <span class="comment">// run it if pending reinit.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>((init_cb_ &amp;&amp; state_ == PENDING_PARSER_INIT) ||</span><br><span class="line">         (!init_cb_ &amp;&amp; state_ == PENDING_PARSER_REINIT));</span><br><span class="line">  State old_state = state_;</span><br><span class="line">  state_ = PARSER_INITIALIZED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (old_state == PENDING_PARSER_INIT)</span><br><span class="line">    std::<span class="built_in">move</span>(init_cb_).<span class="built_in">Run</span>(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######### ChunkDemuxer::OnSourceInitDone</p><p>SourceBufferState::OnSourceInitDone 会往上调用 ChunkDemuxer::OnSourceInitDone</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChunkDemuxer::OnSourceInitDone</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; source_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> StreamParser::InitParameters&amp; params)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;OnSourceInitDone source_id=&quot;</span> &lt;&lt; source_id</span><br><span class="line">           &lt;&lt; <span class="string">&quot; duration=&quot;</span> &lt;&lt; params.duration.<span class="built_in">InSecondsF</span>();</span><br><span class="line">  lock_.<span class="built_in">AssertAcquired</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(wolenetz): Change these to DCHECKs once less verification in release</span></span><br><span class="line">  <span class="comment">// build is needed. See https://crbug.com/786975.</span></span><br><span class="line">  <span class="built_in">CHECK</span>(!pending_source_init_ids_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">IsValidId</span>(source_id));</span><br><span class="line">  <span class="built_in">CHECK</span>(pending_source_init_ids_.<span class="built_in">find</span>(source_id) !=</span><br><span class="line">        pending_source_init_ids_.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">CHECK</span>(init_cb_);</span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(state_, INITIALIZING);</span><br><span class="line">  <span class="keyword">if</span> (audio_streams_.<span class="built_in">empty</span>() &amp;&amp; video_streams_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">ReportError_Locked</span>(DEMUXER_ERROR_COULD_NOT_OPEN);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!params.duration.<span class="built_in">is_zero</span>() &amp;&amp; duration_ == kNoTimestamp)</span><br><span class="line">    <span class="built_in">UpdateDuration</span>(params.duration);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!params.timeline_offset.<span class="built_in">is_null</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timeline_offset_.<span class="built_in">is_null</span>() &amp;&amp;</span><br><span class="line">        params.timeline_offset != timeline_offset_) &#123;</span><br><span class="line">      <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_)</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Timeline offset is not the same across all SourceBuffers.&quot;</span>;</span><br><span class="line">      <span class="built_in">ReportError_Locked</span>(DEMUXER_ERROR_COULD_NOT_OPEN);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeline_offset_ = params.timeline_offset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (params.liveness != StreamLiveness::kUnknown) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : audio_streams_)</span><br><span class="line">      s-&gt;<span class="built_in">SetLiveness</span>(params.liveness);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : video_streams_)</span><br><span class="line">      s-&gt;<span class="built_in">SetLiveness</span>(params.liveness);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait until all streams have initialized.</span></span><br><span class="line">  pending_source_init_ids_.<span class="built_in">erase</span>(source_id);</span><br><span class="line">  <span class="keyword">if</span> (!pending_source_init_ids_.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SeekAllSources</span>(<span class="built_in">GetStartTime</span>());</span><br><span class="line">  <span class="built_in">StartReturningData</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (duration_ == kNoTimestamp)</span><br><span class="line">    duration_ = kInfiniteDuration;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The demuxer is now initialized after the |start_timestamp_| was set.</span></span><br><span class="line">  <span class="comment">// TODO(wolenetz): Change these to DCHECKs once less verification in release</span></span><br><span class="line">  <span class="comment">// build is needed. See https://crbug.com/786975.</span></span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(state_, INITIALIZING);</span><br><span class="line">  <span class="built_in">ChangeState_Locked</span>(INITIALIZED);</span><br><span class="line">  <span class="built_in">RunInitCB_Locked</span>(PIPELINE_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChunkDemuxer::RunInitCB_Locked</span><span class="params">(PipelineStatus status)</span> </span>&#123;</span><br><span class="line">  lock_.<span class="built_in">AssertAcquired</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(init_cb_);</span><br><span class="line">  <span class="built_in">TRACE_EVENT_ASYNC_END1</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;ChunkDemuxer::Initialize&quot;</span>, <span class="keyword">this</span>, <span class="string">&quot;status&quot;</span>,</span><br><span class="line">                         <span class="built_in">PipelineStatusToString</span>(status));</span><br><span class="line">  std::<span class="built_in">move</span>(init_cb_).<span class="built_in">Run</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init_cb_</code> 是 RendererWrapper::ReportMetadata，到这里继续初始化 pipeline</p><p>####### MP4StreamParser::ParseMoof</p><p>从下面的代码逻辑来看，通过 MSE 送的 mp4 文件，必须有 Moof，也就是必须是 fragment MP4，否则状态转不到 kWaitingForSampleData</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MP4StreamParser::ParseMoof</span><span class="params">(BoxReader* reader)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RCHECK</span>(moov_.<span class="built_in">get</span>());  <span class="comment">// Must already have initialization segment</span></span><br><span class="line">  MovieFragment moof;</span><br><span class="line">  <span class="built_in">RCHECK</span>(moof.<span class="built_in">Parse</span>(reader));</span><br><span class="line">  <span class="keyword">if</span> (!runs_)</span><br><span class="line">    runs_ = std::<span class="built_in">make_unique</span>&lt;TrackRunIterator&gt;(moov_.<span class="built_in">get</span>(), media_log_);</span><br><span class="line">  <span class="built_in">RCHECK</span>(runs_-&gt;<span class="built_in">Init</span>(moof));</span><br><span class="line">  <span class="built_in">RCHECK</span>(<span class="built_in">ComputeHighestEndOffset</span>(moof));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!moof.pssh.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">OnEncryptedMediaInitData</span>(moof.pssh);</span><br><span class="line"></span><br><span class="line">  new_segment_cb_.<span class="built_in">Run</span>();</span><br><span class="line">  <span class="built_in">ChangeState</span>(kWaitingForSampleData);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="MP4StreamParser-HaveEnoughDataToEnqueueSamples"><a href="#MP4StreamParser-HaveEnoughDataToEnqueueSamples" class="headerlink" title="MP4StreamParser::HaveEnoughDataToEnqueueSamples"></a>MP4StreamParser::HaveEnoughDataToEnqueueSamples</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MP4StreamParser::HaveEnoughDataToEnqueueSamples</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(state_, kWaitingForSampleData);</span><br><span class="line">  <span class="comment">// For muxed content, make sure we have data up to |highest_end_offset_|</span></span><br><span class="line">  <span class="comment">// so we can ensure proper enqueuing behavior. Otherwise assume we have enough</span></span><br><span class="line">  <span class="comment">// data and allow per sample offset checks to meter sample enqueuing.</span></span><br><span class="line">  <span class="comment">// TODO(acolwell): Fix trun box handling so we don&#x27;t have to special case</span></span><br><span class="line">  <span class="comment">// muxed content.</span></span><br><span class="line">  <span class="keyword">return</span> !(has_audio_ &amp;&amp; has_video_ &amp;&amp;</span><br><span class="line">           queue_.<span class="built_in">tail</span>() &lt; highest_end_offset_ + moof_head_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="MP4StreamParser-EnqueueSample"><a href="#MP4StreamParser-EnqueueSample" class="headerlink" title="MP4StreamParser::EnqueueSample"></a>MP4StreamParser::EnqueueSample</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ParseResult <span class="title">MP4StreamParser::EnqueueSample</span><span class="params">(BufferQueueMap* buffers)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(state_, kEmittingSamples);</span><br><span class="line">...</span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>* buf;</span><br><span class="line">  <span class="type">int</span> buf_size;</span><br><span class="line">  queue_.<span class="built_in">Peek</span>(&amp;buf, &amp;buf_size);</span><br><span class="line">  <span class="keyword">if</span> (!buf_size)</span><br><span class="line">    <span class="keyword">return</span> ParseResult::kNeedMoreData;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> audio =</span><br><span class="line">      audio_track_ids_.<span class="built_in">find</span>(runs_-&gt;<span class="built_in">track_id</span>()) != audio_track_ids_.<span class="built_in">end</span>();</span><br><span class="line">  <span class="type">bool</span> video =</span><br><span class="line">      video_track_ids_.<span class="built_in">find</span>(runs_-&gt;<span class="built_in">track_id</span>()) != video_track_ids_.<span class="built_in">end</span>();</span><br><span class="line">...</span><br><span class="line">  queue_.<span class="built_in">PeekAt</span>(runs_-&gt;<span class="built_in">sample_offset</span>() + moof_head_, &amp;buf, &amp;buf_size);</span><br><span class="line">...</span><br><span class="line">  <span class="type">int</span> sample_size = base::<span class="built_in">checked_cast</span>&lt;<span class="type">int</span>&gt;(runs_-&gt;<span class="built_in">sample_size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf_size &lt; sample_size)</span><br><span class="line">    <span class="keyword">return</span> ParseResult::kNeedMoreData;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;DecryptConfig&gt; decrypt_config;</span><br><span class="line">  std::vector&lt;SubsampleEntry&gt; subsamples;</span><br><span class="line">  <span class="keyword">if</span> (runs_-&gt;<span class="built_in">is_encrypted</span>()) &#123;</span><br><span class="line">    decrypt_config = runs_-&gt;<span class="built_in">GetDecryptConfig</span>();</span><br><span class="line">    <span class="keyword">if</span> (!decrypt_config)</span><br><span class="line">      <span class="keyword">return</span> ParseResult::kError;</span><br><span class="line">    subsamples = decrypt_config-&gt;<span class="built_in">subsamples</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This may change if analysis results indicate runs_-&gt;is_keyframe() is</span></span><br><span class="line">  <span class="comment">// opposite of what the coded frame contains.</span></span><br><span class="line">  <span class="type">bool</span> is_keyframe = runs_-&gt;<span class="built_in">is_keyframe</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">frame_buf</span><span class="params">(buf, buf + sample_size)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (video) &#123;</span><br><span class="line">    <span class="keyword">if</span> (runs_-&gt;<span class="built_in">video_description</span>().video_codec == VideoCodec::kH264 ||</span><br><span class="line">        runs_-&gt;<span class="built_in">video_description</span>().video_codec == VideoCodec::kHEVC ||</span><br><span class="line">        runs_-&gt;<span class="built_in">video_description</span>().video_codec == VideoCodec::kDolbyVision) &#123;</span><br><span class="line">      <span class="built_in">DCHECK</span>(runs_-&gt;<span class="built_in">video_description</span>().frame_bitstream_converter);</span><br><span class="line">      BitstreamConverter::AnalysisResult analysis;</span><br><span class="line">      <span class="keyword">if</span> (!runs_-&gt;<span class="built_in">video_description</span>()</span><br><span class="line">               .frame_bitstream_converter-&gt;<span class="built_in">ConvertAndAnalyzeFrame</span>(</span><br><span class="line">                   &amp;frame_buf, is_keyframe, &amp;subsamples, &amp;analysis)) &#123;</span><br><span class="line">        <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Failed to prepare video sample for decode&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ParseResult::kError;</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br><span class="line">      <span class="comment">// Use |analysis.is_keyframe|, if it was actually determined, for logging</span></span><br><span class="line">      <span class="comment">// if the analysis mismatches the container&#x27;s keyframe metadata for</span></span><br><span class="line">      <span class="comment">// |frame_buf|.</span></span><br><span class="line">      <span class="keyword">if</span> (analysis.is_keyframe.<span class="built_in">has_value</span>() &amp;&amp;</span><br><span class="line">          is_keyframe != analysis.is_keyframe.<span class="built_in">value</span>()) &#123;</span><br><span class="line">        <span class="built_in">LIMITED_MEDIA_LOG</span>(DEBUG, media_log_, num_video_keyframe_mismatches_,</span><br><span class="line">                          kMaxVideoKeyframeMismatchLogs)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;ISO-BMFF container metadata for video frame indicates that the &quot;</span></span><br><span class="line">               <span class="string">&quot;frame is &quot;</span></span><br><span class="line">            &lt;&lt; (is_keyframe ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;not &quot;</span>)</span><br><span class="line">            &lt;&lt; <span class="string">&quot;a keyframe, but the video frame contents indicate the &quot;</span></span><br><span class="line">               <span class="string">&quot;opposite.&quot;</span>;</span><br><span class="line">        <span class="comment">// As of September 2018, it appears that all of Edge, Firefox, Safari</span></span><br><span class="line">        <span class="comment">// work with content that marks non-avc-keyframes as a keyframe in the</span></span><br><span class="line">        <span class="comment">// container. Encoders/muxers/old streams still exist that produce</span></span><br><span class="line">        <span class="comment">// all-keyframe mp4 video tracks, though many of the coded frames are</span></span><br><span class="line">        <span class="comment">// not keyframes (likely workaround due to the impact on low-latency</span></span><br><span class="line">        <span class="comment">// live streams until https://crbug.com/229412 was fixed).  We&#x27;ll trust</span></span><br><span class="line">        <span class="comment">// the AVC frame&#x27;s keyframe-ness over the mp4 container&#x27;s metadata if</span></span><br><span class="line">        <span class="comment">// they mismatch. If other out-of-order codecs in mp4 (e.g. HEVC, DV)</span></span><br><span class="line">        <span class="comment">// implement keyframe analysis in their frame_bitstream_converter, we&#x27;ll</span></span><br><span class="line">        <span class="comment">// similarly trust that analysis instead of the mp4.</span></span><br><span class="line">        is_keyframe = analysis.is_keyframe.<span class="built_in">value</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (decrypt_config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!subsamples.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// Create a new config with the updated subsamples.</span></span><br><span class="line">      decrypt_config = std::<span class="built_in">make_unique</span>&lt;DecryptConfig&gt;(</span><br><span class="line">          decrypt_config-&gt;<span class="built_in">encryption_scheme</span>(), decrypt_config-&gt;<span class="built_in">key_id</span>(),</span><br><span class="line">          decrypt_config-&gt;<span class="built_in">iv</span>(), subsamples,</span><br><span class="line">          decrypt_config-&gt;<span class="built_in">encryption_pattern</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else, use the existing config.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  StreamParserBuffer::Type buffer_type = audio ? DemuxerStream::AUDIO :</span><br><span class="line">      DemuxerStream::VIDEO;</span><br><span class="line"></span><br><span class="line">  scoped_refptr&lt;StreamParserBuffer&gt; stream_buf =</span><br><span class="line">      StreamParserBuffer::<span class="built_in">CopyFrom</span>(&amp;frame_buf[<span class="number">0</span>], frame_buf.<span class="built_in">size</span>(), is_keyframe,</span><br><span class="line">                                   buffer_type, runs_-&gt;<span class="built_in">track_id</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (decrypt_config)</span><br><span class="line">    stream_buf-&gt;<span class="built_in">set_decrypt_config</span>(std::<span class="built_in">move</span>(decrypt_config));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (runs_-&gt;<span class="built_in">duration</span>() != kNoTimestamp) &#123;</span><br><span class="line">    stream_buf-&gt;<span class="built_in">set_duration</span>(runs_-&gt;<span class="built_in">duration</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Frame duration exceeds representable &quot;</span></span><br><span class="line">                                 &lt;&lt; <span class="string">&quot;limit&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ParseResult::kError;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (runs_-&gt;<span class="built_in">cts</span>() != kNoTimestamp) &#123;</span><br><span class="line">    stream_buf-&gt;<span class="built_in">set_timestamp</span>(runs_-&gt;<span class="built_in">cts</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Frame PTS exceeds representable limit&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ParseResult::kError;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (runs_-&gt;<span class="built_in">dts</span>() != kNoDecodeTimestamp) &#123;</span><br><span class="line">    stream_buf-&gt;<span class="built_in">SetDecodeTimestamp</span>(runs_-&gt;<span class="built_in">dts</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Frame DTS exceeds representable limit&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ParseResult::kError;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;Emit &quot;</span> &lt;&lt; (audio ? <span class="string">&quot;audio&quot;</span> : <span class="string">&quot;video&quot;</span>) &lt;&lt; <span class="string">&quot; frame: &quot;</span></span><br><span class="line">           &lt;&lt; <span class="string">&quot; track_id=&quot;</span> &lt;&lt; runs_-&gt;<span class="built_in">track_id</span>() &lt;&lt; <span class="string">&quot;, key=&quot;</span> &lt;&lt; is_keyframe</span><br><span class="line">           &lt;&lt; <span class="string">&quot;, dur=&quot;</span> &lt;&lt; runs_-&gt;<span class="built_in">duration</span>().<span class="built_in">InMilliseconds</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;, dts=&quot;</span> &lt;&lt; runs_-&gt;<span class="built_in">dts</span>().<span class="built_in">InMilliseconds</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;, cts=&quot;</span> &lt;&lt; runs_-&gt;<span class="built_in">cts</span>().<span class="built_in">InMilliseconds</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;, size=&quot;</span> &lt;&lt; sample_size;</span><br><span class="line"></span><br><span class="line">  (*buffers)[runs_-&gt;<span class="built_in">track_id</span>()].<span class="built_in">push_back</span>(stream_buf);</span><br><span class="line">  <span class="keyword">if</span> (!runs_-&gt;<span class="built_in">AdvanceSample</span>())</span><br><span class="line">    <span class="keyword">return</span> ParseResult::kError;</span><br><span class="line">  <span class="keyword">return</span> ParseResult::kOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="MP4StreamParser-SendAndFlushSamples"><a href="#MP4StreamParser-SendAndFlushSamples" class="headerlink" title="MP4StreamParser::SendAndFlushSamples"></a>MP4StreamParser::SendAndFlushSamples</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MP4StreamParser::SendAndFlushSamples</span><span class="params">(BufferQueueMap* buffers)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (buffers-&gt;<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="type">bool</span> success = new_buffers_cb_.<span class="built_in">Run</span>(*buffers);</span><br><span class="line">  buffers-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####### SourceBufferState::OnNewBuffers</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SourceBufferState::OnNewBuffers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> StreamParser::BufferQueueMap&amp; buffer_queue_map)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; buffer_queues=&quot;</span> &lt;&lt; buffer_queue_map.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(state_, PARSER_INITIALIZED);</span><br><span class="line">  <span class="built_in">DCHECK</span>(timestamp_offset_during_append_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(parsing_media_segment_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it : buffer_queue_map) &#123;</span><br><span class="line">    <span class="type">const</span> StreamParser::BufferQueue&amp; bufq = it.second;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!bufq.<span class="built_in">empty</span>());</span><br><span class="line">    media_segment_has_data_for_track_[it.first] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> base::TimeDelta timestamp_offset_before_processing =</span><br><span class="line">      *timestamp_offset_during_append_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate the new timestamp offset for audio/video tracks if the stream</span></span><br><span class="line">  <span class="comment">// parser corresponds to MSE MIME type with &#x27;Generate Timestamps Flag&#x27; set</span></span><br><span class="line">  <span class="comment">// true.</span></span><br><span class="line">  base::TimeDelta predicted_timestamp_offset =</span><br><span class="line">      timestamp_offset_before_processing;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">generate_timestamps_flag</span>()) &#123;</span><br><span class="line">    base::TimeDelta min_end_timestamp = kNoTimestamp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it : buffer_queue_map) &#123;</span><br><span class="line">      <span class="type">const</span> StreamParser::BufferQueue&amp; bufq = it.second;</span><br><span class="line">      <span class="built_in">DCHECK</span>(!bufq.<span class="built_in">empty</span>());</span><br><span class="line">      <span class="keyword">if</span> (min_end_timestamp == kNoTimestamp ||</span><br><span class="line">          <span class="built_in">EndTimestamp</span>(bufq) &lt; min_end_timestamp) &#123;</span><br><span class="line">        min_end_timestamp = <span class="built_in">EndTimestamp</span>(bufq);</span><br><span class="line">        <span class="built_in">DCHECK_NE</span>(kNoTimestamp, min_end_timestamp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (min_end_timestamp != kNoTimestamp)</span><br><span class="line">      predicted_timestamp_offset += min_end_timestamp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!frame_processor_-&gt;<span class="built_in">ProcessFrames</span>(</span><br><span class="line">          buffer_queue_map, append_window_start_during_append_,</span><br><span class="line">          append_window_end_during_append_, timestamp_offset_during_append_)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Only update the timestamp offset if the frame processor hasn&#x27;t already.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">generate_timestamps_flag</span>() &amp;&amp;</span><br><span class="line">      timestamp_offset_before_processing == *timestamp_offset_during_append_) &#123;</span><br><span class="line">    <span class="comment">// TODO(wolenetz): This prediction assumes the last frame in each track</span></span><br><span class="line">    <span class="comment">// isn&#x27;t dropped by append window trimming. See https://crbug.com/850316.</span></span><br><span class="line">    *timestamp_offset_during_append_ = predicted_timestamp_offset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######## FrameProcessor::ProcessFrames</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FrameProcessor::ProcessFrames</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> StreamParser::BufferQueueMap&amp; buffer_queue_map,</span></span></span><br><span class="line"><span class="params"><span class="function">    base::TimeDelta append_window_start,</span></span></span><br><span class="line"><span class="params"><span class="function">    base::TimeDelta append_window_end,</span></span></span><br><span class="line"><span class="params"><span class="function">    base::TimeDelta* timestamp_offset)</span> </span>&#123;</span><br><span class="line">  StreamParser::BufferQueue frames;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">MergeBufferQueues</span>(buffer_queue_map, &amp;frames)) &#123;</span><br><span class="line">    <span class="built_in">MEDIA_LOG</span>(ERROR, media_log_) &lt;&lt; <span class="string">&quot;Parsed buffers not in DTS sequence&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(!frames.<span class="built_in">empty</span>());</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// Implements the coded frame processing algorithm&#x27;s outer loop for step 1.</span></span><br><span class="line">  <span class="comment">// Note that ProcessFrame() implements an inner loop for a single frame that</span></span><br><span class="line">  <span class="comment">// handles &quot;jump to the Loop Top step to restart processing of the current</span></span><br><span class="line">  <span class="comment">// coded frame&quot; per June 9, 2016 MSE spec editor&#x27;s draft:</span></span><br><span class="line">  <span class="comment">// https://rawgit.com/w3c/media-source/d8f901f22/</span></span><br><span class="line">  <span class="comment">//     index.html#sourcebuffer-coded-frame-processing</span></span><br><span class="line">  <span class="comment">// 1. For each coded frame in the media segment run the following steps:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; frame : frames) &#123;</span><br><span class="line">    <span class="comment">// Skip any 0-byte audio or video buffers, since they cannot produce any</span></span><br><span class="line">    <span class="comment">// valid decode output (and are rejected by FFmpeg A/V decode.) Retain</span></span><br><span class="line">    <span class="comment">// 0-byte text buffers because their |side_data| just might be useful, and</span></span><br><span class="line">    <span class="comment">// we don&#x27;t feed them to FFmpeg later.</span></span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;<span class="built_in">data_size</span>() &amp;&amp; frame-&gt;<span class="built_in">type</span>() != DemuxerStream::TEXT) &#123;</span><br><span class="line">      <span class="built_in">LIMITED_MEDIA_LOG</span>(DEBUG, media_log_, num_skipped_empty_frame_warnings_,</span><br><span class="line">                        kMaxSkippedEmptyFrameWarnings)</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Discarding empty audio or video coded frame, PTS=&quot;</span></span><br><span class="line">          &lt;&lt; frame-&gt;<span class="built_in">timestamp</span>().<span class="built_in">InMicroseconds</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot;us, DTS=&quot;</span> &lt;&lt; frame-&gt;<span class="built_in">GetDecodeTimestamp</span>().<span class="built_in">InMicroseconds</span>() &lt;&lt; <span class="string">&quot;us&quot;</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ProcessFrame</span>(frame, append_window_start, append_window_end,</span><br><span class="line">                      timestamp_offset)) &#123;</span><br><span class="line">      <span class="built_in">FlushProcessedFrames</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max_group_end_timestamp =</span><br><span class="line">        std::<span class="built_in">max</span>(group_end_timestamp_, max_group_end_timestamp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">FlushProcessedFrames</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. - 4. Are handled by the WebMediaPlayer / Pipeline / Media Element.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. If the media segment contains data beyond the current duration, then run</span></span><br><span class="line">  <span class="comment">//    the duration change algorithm with new duration set to the maximum of</span></span><br><span class="line">  <span class="comment">//    the current duration and the group end timestamp.</span></span><br><span class="line">  <span class="keyword">if</span> (max_group_end_timestamp &gt; group_end_timestamp_) &#123;</span><br><span class="line">    <span class="comment">// Log a parse warning. For now at least, we don&#x27;t also log this to</span></span><br><span class="line">    <span class="comment">// media-internals.</span></span><br><span class="line">    <span class="built_in">DCHECK</span>(parse_warning_cb_);</span><br><span class="line">    parse_warning_cb_.<span class="built_in">Run</span>(</span><br><span class="line">        SourceBufferParseWarning::kGroupEndTimestampDecreaseWithinMediaSegment);</span><br><span class="line">  &#125;</span><br><span class="line">  update_duration_cb_.<span class="built_in">Run</span>(group_end_timestamp_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######### FrameProcessor::ProcessFrame</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FrameProcessor::ProcessFrame</span><span class="params">(scoped_refptr&lt;StreamParserBuffer&gt; frame,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  base::TimeDelta append_window_start,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  base::TimeDelta append_window_end,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  base::TimeDelta* timestamp_offset)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    base::TimeDelta presentation_timestamp = frame-&gt;<span class="built_in">timestamp</span>();</span><br><span class="line">    DecodeTimestamp decode_timestamp = frame-&gt;<span class="built_in">GetDecodeTimestamp</span>();</span><br><span class="line">    base::TimeDelta frame_duration = frame-&gt;<span class="built_in">duration</span>();</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 5. Let track buffer equal the track buffer that the coded frame will be</span></span><br><span class="line">    <span class="comment">//    added to.</span></span><br><span class="line">    StreamParser::TrackId track_id = frame-&gt;<span class="built_in">track_id</span>();</span><br><span class="line">    MseTrackBuffer* track_buffer = <span class="built_in">FindTrack</span>(track_id);</span><br><span class="line">...</span><br><span class="line">    frame-&gt;<span class="built_in">set_timestamp</span>(presentation_timestamp);</span><br><span class="line">    frame-&gt;<span class="built_in">SetDecodeTimestamp</span>(decode_timestamp);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!track_buffer-&gt;<span class="built_in">EnqueueProcessedFrame</span>(std::<span class="built_in">move</span>(frame)))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NOTREACHED</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######### FrameProcessor::FlushProcessedFrames</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FrameProcessor::FlushProcessedFrames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;()&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> itr = track_buffers_.<span class="built_in">begin</span>(); itr != track_buffers_.<span class="built_in">end</span>(); ++itr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!itr-&gt;second-&gt;<span class="built_in">FlushProcessedFrames</span>())</span><br><span class="line">      result = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MseTrackBuffer::FlushProcessedFrames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (processed_frames_.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> result = stream_-&gt;<span class="built_in">Append</span>(processed_frames_); <span class="comment">// ChunkDemuxerStream</span></span><br><span class="line">  processed_frames_.<span class="built_in">clear</span>();</span><br><span class="line">  have_flushed_since_last_group_start_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DVLOG_IF</span>(<span class="number">3</span>, !result) &lt;&lt; __func__</span><br><span class="line">                       &lt;&lt; <span class="string">&quot;(): Failure appending processed frames to stream&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最终 frame 会被送到 ChunkDemuxerStream 中，后面会看到读取 frame 时也是通过 ChunkDemuxerStream 的 Read 方法。</p><p>到这里，就把 MSE 的关键步骤都介绍完毕，后面会介绍 EME 以及 WebMediaPlayer 的内容。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium 多媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium 多媒体（二）</title>
      <link href="/2023/06/23/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/06/23/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这篇文章接着上一篇继续分析 ChunkDemuxer 相关的内容。</p><h1 id="MediaSource-addSourceBuffer"><a href="#MediaSource-addSourceBuffer" class="headerlink" title="MediaSource::addSourceBuffer"></a>MediaSource::addSourceBuffer</h1><p>先看 MediaSource::addSourceBuffer 的实现。</p><p>MediaSource::addSourceBuffer 调用 MediaSource::AddSourceBuffer_Locked</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SourceBuffer* <span class="title">MediaSource::addSourceBuffer</span><span class="params">(<span class="type">const</span> String&amp; type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           ExceptionState&amp; exception_state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; type=&quot;</span> &lt;&lt; type;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do remainder of steps only if attachment is usable and underlying demuxer</span></span><br><span class="line">  <span class="comment">// is protected from destruction (applicable especially for MSE-in-Worker</span></span><br><span class="line">  <span class="comment">// case).</span></span><br><span class="line">  SourceBuffer* source_buffer = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note, here we must be open, therefore we must have an attachment.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">RunUnlessElementGoneOrClosingUs</span>(WTF::<span class="built_in">Bind</span>(</span><br><span class="line">          &amp;MediaSource::AddSourceBuffer_Locked, <span class="built_in">WrapPersistent</span>(<span class="keyword">this</span>), type,</span><br><span class="line">          <span class="literal">nullptr</span> <span class="comment">/* audio_config */</span>, <span class="literal">nullptr</span> <span class="comment">/* video_config */</span>,</span><br><span class="line">          WTF::<span class="built_in">Unretained</span>(&amp;exception_state),</span><br><span class="line">          WTF::<span class="built_in">Unretained</span>(&amp;source_buffer)))) &#123;</span><br><span class="line">    <span class="comment">// TODO(https://crbug.com/878133): Determine in specification what the</span></span><br><span class="line">    <span class="comment">// specific, app-visible, exception should be for this case.</span></span><br><span class="line">    <span class="built_in">LogAndThrowDOMException</span>(exception_state,</span><br><span class="line">                            DOMExceptionCode::kInvalidStateError,</span><br><span class="line">                            <span class="string">&quot;Worker MediaSource attachment is closing&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> source_buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MediaSource::AddSourceBuffer_Locked 内部先通过 MediaSource::CreateWebSourceBuffer 创建 WebSourceBuffer 的对象，然后用该对象创建 SourceBuffer 的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaSource::AddSourceBuffer_Locked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> String&amp; type,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;media::AudioDecoderConfig&gt; audio_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;media::VideoDecoderConfig&gt; video_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    ExceptionState* exception_state,</span></span></span><br><span class="line"><span class="params"><span class="function">    SourceBuffer** created_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    MediaSourceAttachmentSupplement::ExclusiveKey pass_key)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">AssertAttachmentsMutexHeldIfCrossThreadForDebugging</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. Create a new SourceBuffer object and associated resources.</span></span><br><span class="line">  <span class="comment">// TODO(crbug.com/1144908): Plumb the configs through into a new logic in</span></span><br><span class="line">  <span class="comment">// WebSourceBuffer and SourceBufferState such that configs and encoded chunks</span></span><br><span class="line">  <span class="comment">// can be buffered, with appropriate invocations of the</span></span><br><span class="line">  <span class="comment">// InitializationSegmentReceived and AppendError methods.</span></span><br><span class="line">  <span class="function">ContentType <span class="title">content_type</span><span class="params">(type)</span></span>;</span><br><span class="line">  String codecs = content_type.<span class="built_in">Parameter</span>(<span class="string">&quot;codecs&quot;</span>);</span><br><span class="line">  std::unique_ptr&lt;WebSourceBuffer&gt; web_source_buffer = <span class="built_in">CreateWebSourceBuffer</span>(</span><br><span class="line">      content_type.<span class="built_in">GetType</span>(), codecs, std::<span class="built_in">move</span>(audio_config),</span><br><span class="line">      std::<span class="built_in">move</span>(video_config), *exception_state);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!web_source_buffer) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(exception_state-&gt;<span class="built_in">CodeAs</span>&lt;DOMExceptionCode&gt;() ==</span><br><span class="line">               DOMExceptionCode::kNotSupportedError ||</span><br><span class="line">           exception_state-&gt;<span class="built_in">CodeAs</span>&lt;DOMExceptionCode&gt;() ==</span><br><span class="line">               DOMExceptionCode::kQuotaExceededError);</span><br><span class="line">    <span class="comment">// 2. If type contains a MIME type that is not supported ..., then throw a</span></span><br><span class="line">    <span class="comment">//    NotSupportedError exception and abort these steps.</span></span><br><span class="line">    <span class="comment">// 3. If the user agent can&#x27;t handle any more SourceBuffer objects then</span></span><br><span class="line">    <span class="comment">//    throw a QuotaExceededError exception and abort these steps</span></span><br><span class="line">    *created_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> generate_timestamps_flag =</span><br><span class="line">      web_source_buffer-&gt;<span class="built_in">GetGenerateTimestampsFlag</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span>* buffer = <span class="built_in">MakeGarbageCollected</span>&lt;SourceBuffer&gt;(</span><br><span class="line">      std::<span class="built_in">move</span>(web_source_buffer), <span class="keyword">this</span>, async_event_queue_.<span class="built_in">Get</span>());</span><br><span class="line">  <span class="comment">// 8. Add the new object to sourceBuffers and queue a simple task to fire a</span></span><br><span class="line">  <span class="comment">//    simple event named addsourcebuffer at sourceBuffers.</span></span><br><span class="line">  source_buffers_-&gt;<span class="built_in">Add</span>(buffer);</span><br><span class="line">  <span class="comment">//source_buffers_ 就是 SourceBufferList</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Steps 6 and 7 (Set the SourceBuffer&#x27;s mode attribute based on the byte</span></span><br><span class="line">  <span class="comment">// stream format&#x27;s generate timestamps flag). We do this after adding to</span></span><br><span class="line">  <span class="comment">// sourceBuffers (step 8) to enable direct reuse of the SetMode_Locked() logic</span></span><br><span class="line">  <span class="comment">// here, which depends on |buffer| being in |source_buffers_| in our</span></span><br><span class="line">  <span class="comment">// implementation.</span></span><br><span class="line">  <span class="keyword">if</span> (generate_timestamps_flag) &#123;</span><br><span class="line">    buffer-&gt;<span class="built_in">SetMode_Locked</span>(SourceBuffer::<span class="built_in">SequenceKeyword</span>(), exception_state,</span><br><span class="line">                           pass_key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    buffer-&gt;<span class="built_in">SetMode_Locked</span>(SourceBuffer::<span class="built_in">SegmentsKeyword</span>(), exception_state,</span><br><span class="line">                           pass_key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9. Return the new object to the caller.</span></span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">3</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; this=&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; type=&quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">           &lt;&lt; buffer;</span><br><span class="line">  *created_buffer = buffer;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MediaSource-CreateWebSourceBuffer"><a href="#MediaSource-CreateWebSourceBuffer" class="headerlink" title="MediaSource::CreateWebSourceBuffer"></a>MediaSource::CreateWebSourceBuffer</h2><p>CreateWebSourceBuffer 函数通过 <code>web_media_source_</code> 来进行 AddSourceBuffer，<code>web_media_source_</code> 是 WebMediaSourceImpl 类型的对象，是在 WebMediaPlayerImpl::OnDemuxerOpened 中创建的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;WebSourceBuffer&gt; <span class="title">MediaSource::CreateWebSourceBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> String&amp; type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> String&amp; codecs,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;media::AudioDecoderConfig&gt; audio_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;media::VideoDecoderConfig&gt; video_config,</span></span></span><br><span class="line"><span class="params"><span class="function">    ExceptionState&amp; exception_state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">AssertAttachmentsMutexHeldIfCrossThreadForDebugging</span>();</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;WebSourceBuffer&gt; web_source_buffer;</span><br><span class="line">  WebMediaSource::AddStatus add_status;</span><br><span class="line">  <span class="keyword">if</span> (audio_config) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!video_config);</span><br><span class="line">    <span class="built_in">DCHECK</span>(type.<span class="built_in">IsNull</span>() &amp;&amp; codecs.<span class="built_in">IsNull</span>());</span><br><span class="line">    web_source_buffer = web_media_source_-&gt;<span class="built_in">AddSourceBuffer</span>(</span><br><span class="line">        std::<span class="built_in">move</span>(audio_config), add_status <span class="comment">/* out */</span>);</span><br><span class="line">    <span class="built_in">DCHECK_NE</span>(add_status, WebMediaSource::kAddStatusNotSupported);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (video_config) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(type.<span class="built_in">IsNull</span>() &amp;&amp; codecs.<span class="built_in">IsNull</span>());</span><br><span class="line">    web_source_buffer = web_media_source_-&gt;<span class="built_in">AddSourceBuffer</span>(</span><br><span class="line">        std::<span class="built_in">move</span>(video_config), add_status <span class="comment">/* out */</span>);</span><br><span class="line">    <span class="built_in">DCHECK_NE</span>(add_status, WebMediaSource::kAddStatusNotSupported);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!type.<span class="built_in">IsNull</span>());</span><br><span class="line">    web_source_buffer =</span><br><span class="line">        web_media_source_-&gt;<span class="built_in">AddSourceBuffer</span>(type, codecs, add_status <span class="comment">/* out */</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (add_status) &#123;</span><br><span class="line">    <span class="keyword">case</span> WebMediaSource::kAddStatusOk:</span><br><span class="line">      <span class="built_in">DCHECK</span>(web_source_buffer);</span><br><span class="line">      <span class="keyword">return</span> web_source_buffer;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NOTREACHED</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebMediaSourceImpl-AddSourceBuffer"><a href="#WebMediaSourceImpl-AddSourceBuffer" class="headerlink" title="WebMediaSourceImpl::AddSourceBuffer"></a>WebMediaSourceImpl::AddSourceBuffer</h3><p>WebMediaSourceImpl::AddSourceBuffer 会在 ChunkDemuxer 内部创建一个 SourceBufferState，然后返回一个标识 id，用该 id 来创建 WebSourceBufferImpl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;WebSourceBuffer&gt; <span class="title">WebMediaSourceImpl::AddSourceBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebString&amp; content_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebString&amp; codecs,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebMediaSource::AddStatus&amp; out_status <span class="comment">/* out */</span>)</span> </span>&#123;</span><br><span class="line">  std::string id = base::<span class="built_in">GenerateGUID</span>();</span><br><span class="line"></span><br><span class="line">  out_status = <span class="built_in">static_cast</span>&lt;WebMediaSource::AddStatus&gt;(</span><br><span class="line">      demuxer_-&gt;<span class="built_in">AddId</span>(id, content_type.<span class="built_in">Utf8</span>(), codecs.<span class="built_in">Utf8</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (out_status == WebMediaSource::kAddStatusOk)</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;WebSourceBufferImpl&gt;(id, demuxer_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ChunkDemuxer::Status <span class="title">ChunkDemuxer::AddId</span><span class="params">(<span class="type">const</span> std::string&amp; id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> std::string&amp; content_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> std::string&amp; codecs)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; id=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; content_type=&quot;</span> &lt;&lt; content_type</span><br><span class="line">           &lt;&lt; <span class="string">&quot; codecs=&quot;</span> &lt;&lt; codecs;</span><br><span class="line">  <span class="function">base::AutoLock <span class="title">auto_lock</span><span class="params">(lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((state_ != WAITING_FOR_INIT &amp;&amp; state_ != INITIALIZING) || <span class="built_in">IsValidId</span>(id))</span><br><span class="line">    <span class="keyword">return</span> kReachedIdLimit;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(wolenetz): Change to DCHECK once less verification in release build is</span></span><br><span class="line">  <span class="comment">// needed. See https://crbug.com/786975.</span></span><br><span class="line">  <span class="built_in">CHECK</span>(init_cb_);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_ptr&lt;media::StreamParser&gt; <span class="title">stream_parser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      CreateParserForTypeAndCodecs(content_type, codecs, media_log_))</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!stream_parser) &#123;</span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; failed: unsupported content_type=&quot;</span> &lt;&lt; content_type</span><br><span class="line">             &lt;&lt; <span class="string">&quot; codecs=&quot;</span> &lt;&lt; codecs;</span><br><span class="line">    <span class="keyword">return</span> ChunkDemuxer::kNotSupported;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AddIdInternal</span>(id, std::<span class="built_in">move</span>(stream_parser),</span><br><span class="line">                       <span class="built_in">ExpectedCodecs</span>(content_type, codecs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建-StreamParser"><a href="#创建-StreamParser" class="headerlink" title="创建 StreamParser"></a>创建 StreamParser</h4><p>ChunkDemuxer::AddId 先创建 StreamParser</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;media::StreamParser&gt; <span class="title">CreateParserForTypeAndCodecs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; content_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; codecs,</span></span></span><br><span class="line"><span class="params"><span class="function">    media::MediaLog* media_log)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::string&gt; parsed_codec_ids;</span><br><span class="line">  media::<span class="built_in">SplitCodecs</span>(codecs, &amp;parsed_codec_ids);</span><br><span class="line">  <span class="keyword">return</span> media::StreamParserFactory::<span class="built_in">Create</span>(content_type, parsed_codec_ids,</span><br><span class="line">                                            media_log);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;StreamParser&gt; <span class="title">StreamParserFactory::Create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; type,</span></span></span><br><span class="line"><span class="params"><span class="function">    base::span&lt;<span class="type">const</span> std::string&gt; codecs,</span></span></span><br><span class="line"><span class="params"><span class="function">    MediaLog* media_log)</span> </span>&#123;</span><br><span class="line">  std::unique_ptr&lt;StreamParser&gt; stream_parser;</span><br><span class="line">  ParserFactoryFunction factory_function;</span><br><span class="line">  std::vector&lt;CodecInfo::HistogramTag&gt; audio_codecs;</span><br><span class="line">  std::vector&lt;CodecInfo::HistogramTag&gt; video_codecs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(crbug.com/535738): Relax the requirement for specific codecs (allow</span></span><br><span class="line">  <span class="comment">// MayBeSupported here), and relocate the logging to the parser configuration</span></span><br><span class="line">  <span class="comment">// callback. This creation method is called in AddId(), and also in</span></span><br><span class="line">  <span class="comment">// CanChangeType() and ChangeType(), so potentially overlogs codecs leading to</span></span><br><span class="line">  <span class="comment">// disproportion versus actually parsed codec configurations from</span></span><br><span class="line">  <span class="comment">// initialization segments. For this work and also recording when implicit</span></span><br><span class="line">  <span class="comment">// codec switching occurs (without explicit ChangeType), see</span></span><br><span class="line">  <span class="comment">// https://crbug.com/535738.</span></span><br><span class="line">  SupportsType supportsType = <span class="built_in">CheckTypeAndCodecs</span>(</span><br><span class="line">      type, codecs, media_log, &amp;factory_function, &amp;audio_codecs, &amp;video_codecs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (IsSupported == supportsType) &#123;</span><br><span class="line">...</span><br><span class="line">    stream_parser.<span class="built_in">reset</span>(<span class="built_in">factory_function</span>(codecs, media_log));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> stream_parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CheckTypeAndCodecs 会检查输入的 type 和 codecs 信息，然后返回一个函数指针用来创建 StreamParser</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> SupportsType <span class="title">CheckTypeAndCodecs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; type,</span></span></span><br><span class="line"><span class="params"><span class="function">    base::span&lt;<span class="type">const</span> std::string&gt; codecs,</span></span></span><br><span class="line"><span class="params"><span class="function">    MediaLog* media_log,</span></span></span><br><span class="line"><span class="params"><span class="function">    ParserFactoryFunction* factory_function,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;CodecInfo::HistogramTag&gt;* audio_codecs,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;CodecInfo::HistogramTag&gt;* video_codecs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Search for the SupportedTypeInfo for |type|.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; type_info : kSupportedTypeInfo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == type_info.type) &#123;</span><br><span class="line">      <span class="keyword">if</span> (codecs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make sure all the codecs specified in |codecs| are</span></span><br><span class="line">      <span class="comment">// in the supported type info.</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; codec_id : codecs) &#123;</span><br><span class="line">        <span class="comment">// Search the type info for a match.</span></span><br><span class="line">        <span class="type">bool</span> found_codec = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; type_info.codecs[i]; ++i) &#123;</span><br><span class="line">          <span class="comment">// Only check a codec pattern if there is one to check. Some types,</span></span><br><span class="line">          <span class="comment">// like audio/mpeg and audio/aac require there be no codecs parameter,</span></span><br><span class="line">          <span class="comment">// and instead have implicit codec. If a codec is provided for such a</span></span><br><span class="line">          <span class="comment">// type then it is not supported by MSE. We don&#x27;t check any other</span></span><br><span class="line">          <span class="comment">// potential matches because none should be configured.</span></span><br><span class="line">          <span class="keyword">if</span> (!type_info.codecs[i]-&gt;pattern) &#123;</span><br><span class="line">            <span class="built_in">DCHECK</span>(i == <span class="number">0</span> &amp;&amp; !type_info.codecs[<span class="number">1</span>])</span><br><span class="line">                &lt;&lt; <span class="string">&quot;For a type with implicit codec, then only one codec must &quot;</span></span><br><span class="line">                   <span class="string">&quot;be configured&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (base::<span class="built_in">MatchPattern</span>(codec_id, type_info.codecs[i]-&gt;pattern) &amp;&amp;</span><br><span class="line">              (!type_info.codecs[i]-&gt;validator ||</span><br><span class="line">               type_info.codecs[i]-&gt;<span class="built_in">validator</span>(codec_id, media_log))) &#123;</span><br><span class="line">            found_codec =</span><br><span class="line">                <span class="built_in">VerifyCodec</span>(type_info.codecs[i], audio_codecs, video_codecs);</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// Since only 1 pattern will match, no need to check others.</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!found_codec) &#123;</span><br><span class="line">          <span class="built_in">MEDIA_LOG</span>(DEBUG, media_log)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;Codec &#x27;&quot;</span> &lt;&lt; codec_id &lt;&lt; <span class="string">&quot;&#x27; is not supported for &#x27;&quot;</span> &lt;&lt; type</span><br><span class="line">              &lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">          <span class="comment">// Though the major/minor type is supported, a codecs parameter value</span></span><br><span class="line">          <span class="comment">// was found to not be supported.</span></span><br><span class="line">          <span class="keyword">return</span> IsNotSupported;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (factory_function)</span><br><span class="line">        *factory_function = type_info.factory_function;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// There was a non-empty |codecs| for this supported |type|, and all of</span></span><br><span class="line">      <span class="comment">// |codecs| are supported for this |type|.</span></span><br><span class="line">      <span class="keyword">return</span> IsSupported;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// |type| didn&#x27;t match any of the supported types.</span></span><br><span class="line">  <span class="keyword">return</span> IsNotSupported;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kSupportedTypeInfo 数组的每一项对应了一个 codec 以及相应的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> SupportedTypeInfo kSupportedTypeInfo[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;video/webm&quot;</span>, &amp;BuildWebMParser, kVideoWebMCodecs&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;audio/webm&quot;</span>, &amp;BuildWebMParser, kAudioWebMCodecs&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;audio/mpeg&quot;</span>, &amp;BuildMP3Parser, kAudioMP3Codecs&#125;,</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Including proprietary MP4 codecs is gated by build flags above.</span></span><br><span class="line">    &#123;<span class="string">&quot;video/mp4&quot;</span>, &amp;BuildMP4Parser, kVideoMP4Codecs&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;audio/mp4&quot;</span>, &amp;BuildMP4Parser, kAudioMP4Codecs&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(USE_PROPRIETARY_CODECS)</span></span><br><span class="line">    &#123;<span class="string">&quot;audio/aac&quot;</span>, &amp;BuildADTSParser, kAudioADTSCodecs&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(ENABLE_MSE_MPEG2TS_STREAM_PARSER)</span></span><br><span class="line">    &#123;<span class="string">&quot;video/mp2t&quot;</span>, &amp;BuildMP2TParser, kVideoMP2TCodecs&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如如果是 MP4 格式，那么就会使用 BuildMP4Parser 来创建 StreamParser</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> StreamParser* <span class="title">BuildMP4Parser</span><span class="params">(base::span&lt;<span class="type">const</span> std::string&gt; codecs,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    MediaLog* media_log)</span> </span>&#123;</span><br><span class="line">  std::set&lt;<span class="type">int</span>&gt; audio_object_types;</span><br><span class="line">  <span class="type">bool</span> has_sbr = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The draft version 0.0.4 FLAC-in-ISO spec</span></span><br><span class="line">  <span class="comment">// (https://github.com/xiph/flac/blob/master/doc/isoflac.txt) does not define</span></span><br><span class="line">  <span class="comment">// any encapsulation using MP4AudioSampleEntry with objectTypeIndication.</span></span><br><span class="line">  <span class="comment">// Rather, it uses a FLAC-specific &quot;fLaC&quot; codingname in the sample entry along</span></span><br><span class="line">  <span class="comment">// with a &quot;dfLa&quot; FLACSpecificBox. We still need to tell our parser to</span></span><br><span class="line">  <span class="comment">// conditionally expect a FLAC stream, hence |has_flac|.</span></span><br><span class="line">  <span class="type">bool</span> has_flac = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; codec_id : codecs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (base::<span class="built_in">MatchPattern</span>(codec_id, kMPEG4FLACCodecInfo.pattern)) &#123;</span><br><span class="line">      has_flac = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(USE_PROPRIETARY_CODECS)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base::<span class="built_in">MatchPattern</span>(codec_id, kMPEG2AACLCCodecInfo.pattern)) &#123;</span><br><span class="line">      audio_object_types.<span class="built_in">insert</span>(mp4::kISO_13818_7_AAC_LC);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base::<span class="built_in">MatchPattern</span>(codec_id, kMPEG4AACCodecInfo.pattern)) &#123;</span><br><span class="line">      <span class="type">int</span> audio_object_type = <span class="built_in">GetMP4AudioObjectType</span>(codec_id, media_log);</span><br><span class="line">      <span class="built_in">DCHECK_GT</span>(audio_object_type, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      audio_object_types.<span class="built_in">insert</span>(mp4::kISO_14496_3);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (audio_object_type == kAACSBRObjectType ||</span><br><span class="line">          audio_object_type == kAACPSObjectType) &#123;</span><br><span class="line">        has_sbr = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(ENABLE_PLATFORM_AC3_EAC3_AUDIO)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base::<span class="built_in">MatchPattern</span>(codec_id, kAC3CodecInfo1.pattern) ||</span><br><span class="line">               base::<span class="built_in">MatchPattern</span>(codec_id, kAC3CodecInfo2.pattern) ||</span><br><span class="line">               base::<span class="built_in">MatchPattern</span>(codec_id, kAC3CodecInfo3.pattern)) &#123;</span><br><span class="line">      audio_object_types.<span class="built_in">insert</span>(mp4::kAC3);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base::<span class="built_in">MatchPattern</span>(codec_id, kEAC3CodecInfo1.pattern) ||</span><br><span class="line">               base::<span class="built_in">MatchPattern</span>(codec_id, kEAC3CodecInfo2.pattern) ||</span><br><span class="line">               base::<span class="built_in">MatchPattern</span>(codec_id, kEAC3CodecInfo3.pattern)) &#123;</span><br><span class="line">      audio_object_types.<span class="built_in">insert</span>(mp4::kEAC3);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(ENABLE_PLATFORM_AC3_EAC3_AUDIO)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(ENABLE_PLATFORM_DTS_AUDIO)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base::<span class="built_in">MatchPattern</span>(codec_id, kDTSCodecInfo1.pattern) ||</span><br><span class="line">               base::<span class="built_in">MatchPattern</span>(codec_id, kDTSCodecInfo2.pattern) ||</span><br><span class="line">               base::<span class="built_in">MatchPattern</span>(codec_id, kDTSCodecInfo3.pattern)) &#123;</span><br><span class="line">      audio_object_types.<span class="built_in">insert</span>(mp4::kDTS);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base::<span class="built_in">MatchPattern</span>(codec_id, kDTSXCodecInfo1.pattern) ||</span><br><span class="line">               base::<span class="built_in">MatchPattern</span>(codec_id, kDTSXCodecInfo2.pattern) ||</span><br><span class="line">               base::<span class="built_in">MatchPattern</span>(codec_id, kDTSXCodecInfo3.pattern)) &#123;</span><br><span class="line">      audio_object_types.<span class="built_in">insert</span>(mp4::kDTSX);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(ENABLE_PLATFORM_DTS_AUDIO)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(USE_PROPRIETARY_CODECS)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> mp4::<span class="built_in">MP4StreamParser</span>(audio_object_types, has_sbr, has_flac);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ChunkDemuxer-AddIdInternal"><a href="#ChunkDemuxer-AddIdInternal" class="headerlink" title="ChunkDemuxer::AddIdInternal"></a>ChunkDemuxer::AddIdInternal</h4><p>ChunkDemuxer::AddId 中创建完 StreamParser 后会调用 AddIdInternal 函数</p><p>AddIdInternal 内部先创建 FrameProcessor，然后用 FrameProcessor 和 StreamParser 去创建 SourceBufferState</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ChunkDemuxer::Status <span class="title">ChunkDemuxer::AddIdInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; id,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;media::StreamParser&gt; stream_parser,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::string expected_codecs)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot; id=&quot;</span> &lt;&lt; id</span><br><span class="line">           &lt;&lt; <span class="string">&quot; expected_codecs=&quot;</span> &lt;&lt; expected_codecs;</span><br><span class="line">  lock_.<span class="built_in">AssertAcquired</span>();</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;FrameProcessor&gt; frame_processor =</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;FrameProcessor&gt;(</span><br><span class="line">          base::<span class="built_in">BindRepeating</span>(&amp;ChunkDemuxer::IncreaseDurationIfNecessary,</span><br><span class="line">                              base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)),</span><br><span class="line">          media_log_);</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;SourceBufferState&gt; source_state =</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;SourceBufferState&gt;(</span><br><span class="line">          std::<span class="built_in">move</span>(stream_parser), std::<span class="built_in">move</span>(frame_processor),</span><br><span class="line">          base::<span class="built_in">BindRepeating</span>(&amp;ChunkDemuxer::CreateDemuxerStream,</span><br><span class="line">                              base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>), id),</span><br><span class="line">          media_log_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(wolenetz): Change these to DCHECKs or switch to returning</span></span><br><span class="line">  <span class="comment">// kReachedIdLimit once less verification in release build is needed. See</span></span><br><span class="line">  <span class="comment">// https://crbug.com/786975.</span></span><br><span class="line">  <span class="built_in">CHECK</span>(pending_source_init_ids_.<span class="built_in">find</span>(id) == pending_source_init_ids_.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">auto</span> insert_result = pending_source_init_ids_.<span class="built_in">insert</span>(id);</span><br><span class="line">  <span class="built_in">CHECK</span>(insert_result.first != pending_source_init_ids_.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">CHECK</span>(*insert_result.first == id);</span><br><span class="line">  <span class="built_in">CHECK</span>(insert_result.second);  <span class="comment">// Only true if insertion succeeded.</span></span><br><span class="line"></span><br><span class="line">  source_state-&gt;<span class="built_in">Init</span>(base::<span class="built_in">BindOnce</span>(&amp;ChunkDemuxer::OnSourceInitDone,</span><br><span class="line">                                    base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>), id),</span><br><span class="line">                     expected_codecs, encrypted_media_init_data_cb_,</span><br><span class="line">                     base::<span class="built_in">NullCallback</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(wolenetz): Change to DCHECKs once less verification in release build</span></span><br><span class="line">  <span class="comment">// is needed. See https://crbug.com/786975.</span></span><br><span class="line">  <span class="built_in">CHECK</span>(!<span class="built_in">IsValidId</span>(id));</span><br><span class="line">  source_state_map_[id] = std::<span class="built_in">move</span>(source_state);</span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">IsValidId</span>(id));</span><br><span class="line">  <span class="keyword">return</span> kOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SourceBufferState-Init"><a href="#SourceBufferState-Init" class="headerlink" title="SourceBufferState::Init"></a>SourceBufferState::Init</h5><p>调用 SourceBufferState::Init 进行初始化。<code>init_cb_</code> 将在 SourceBufferState::OnSourceInitDone 中触发，而 SourceBufferState::OnSourceInitDone 又被作为 StreamParser 的回调</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SourceBufferState::Init</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    StreamParser::InitCB init_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::string&amp; expected_codecs,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> StreamParser::EncryptedMediaInitDataCB&amp; encrypted_media_init_data_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    NewTextTrackCB new_text_track_cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(state_, UNINITIALIZED);</span><br><span class="line">  init_cb_ = std::<span class="built_in">move</span>(init_cb);</span><br><span class="line">  encrypted_media_init_data_cb_ = encrypted_media_init_data_cb;</span><br><span class="line">  new_text_track_cb_ = std::<span class="built_in">move</span>(new_text_track_cb); <span class="comment">// null</span></span><br><span class="line">  state_ = PENDING_PARSER_CONFIG;</span><br><span class="line">  <span class="built_in">InitializeParser</span>(expected_codecs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SourceBufferState::InitializeParser</span><span class="params">(<span class="type">const</span> std::string&amp; expected_codecs)</span> </span>&#123;</span><br><span class="line">  expected_audio_codecs_.<span class="built_in">clear</span>();</span><br><span class="line">  expected_video_codecs_.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; expected_codecs_parsed;</span><br><span class="line">  <span class="built_in">SplitCodecs</span>(expected_codecs, &amp;expected_codecs_parsed);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;AudioCodec&gt; expected_acodecs;</span><br><span class="line">  std::vector&lt;VideoCodec&gt; expected_vcodecs;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; codec_id : expected_codecs_parsed) &#123;</span><br><span class="line">    AudioCodec acodec = <span class="built_in">StringToAudioCodec</span>(codec_id);</span><br><span class="line">    <span class="keyword">if</span> (acodec != AudioCodec::kUnknown) &#123;</span><br><span class="line">      expected_audio_codecs_.<span class="built_in">push_back</span>(acodec);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    VideoCodec vcodec = <span class="built_in">StringToVideoCodec</span>(codec_id);</span><br><span class="line">    <span class="keyword">if</span> (vcodec != VideoCodec::kUnknown) &#123;</span><br><span class="line">      expected_video_codecs_.<span class="built_in">push_back</span>(vcodec);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MEDIA_LOG</span>(INFO, media_log_) &lt;&lt; <span class="string">&quot;Unrecognized media codec: &quot;</span> &lt;&lt; codec_id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stream_parser_-&gt;<span class="built_in">Init</span>(</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;SourceBufferState::OnSourceInitDone,</span><br><span class="line">                     base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;SourceBufferState::OnNewConfigs,</span><br><span class="line">                          base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>), expected_codecs),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;SourceBufferState::OnNewBuffers,</span><br><span class="line">                          base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)),</span><br><span class="line">      !new_text_track_cb_,</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;SourceBufferState::OnEncryptedMediaInitData,</span><br><span class="line">                          base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;SourceBufferState::OnNewMediaSegment,</span><br><span class="line">                          base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;SourceBufferState::OnEndOfMediaSegment,</span><br><span class="line">                          base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)),</span><br><span class="line">      media_log_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SourceBufferState::InitializeParser 中会调用 MP4StreamParser::Init，并且将 SourceBufferState 的函数设置为 MP4StreamParser 的回调，目前重点关注 SourceBufferState::OnSourceInitDone、SourceBufferState::OnNewBuffers、SourceBufferState::OnEncryptedMediaInitData</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MP4StreamParser::Init</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InitCB init_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> NewConfigCB&amp; config_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> NewBuffersCB&amp; new_buffers_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> <span class="comment">/* ignore_text_tracks */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> EncryptedMediaInitDataCB&amp; encrypted_media_init_data_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> NewMediaSegmentCB&amp; new_segment_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> EndMediaSegmentCB&amp; end_of_segment_cb,</span></span></span><br><span class="line"><span class="params"><span class="function">    MediaLog* media_log)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(state_, kWaitingForInit);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!init_cb_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(init_cb);</span><br><span class="line">  <span class="built_in">DCHECK</span>(config_cb);</span><br><span class="line">  <span class="built_in">DCHECK</span>(new_buffers_cb);</span><br><span class="line">  <span class="built_in">DCHECK</span>(encrypted_media_init_data_cb);</span><br><span class="line">  <span class="built_in">DCHECK</span>(new_segment_cb);</span><br><span class="line">  <span class="built_in">DCHECK</span>(end_of_segment_cb);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ChangeState</span>(kParsingBoxes);</span><br><span class="line">  init_cb_ = std::<span class="built_in">move</span>(init_cb);</span><br><span class="line">  config_cb_ = config_cb;</span><br><span class="line">  new_buffers_cb_ = new_buffers_cb;</span><br><span class="line">  encrypted_media_init_data_cb_ = encrypted_media_init_data_cb;</span><br><span class="line">  new_segment_cb_ = new_segment_cb;</span><br><span class="line">  end_of_segment_cb_ = end_of_segment_cb;</span><br><span class="line">  media_log_ = media_log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init_cb_</code> 是在 MP4StreamParser::ParseMoov 中被调用的，也就是上层往 SourceBuffer 中 appendBuffer 后进行 Parse 之后可能会调用，后面会分析 appendBuffer 流程。</p><p><code>new_buffers_cb_</code> 是在 MP4StreamParser::Parse 中调用，该函数就是 SourceBufferState::OnNewBuffers，通过该函数往 FrameProcessor 中送数据，会面也会分析该过程。</p><p><code>encrypted_media_init_data_cb_</code> 也是在 MP4StreamParser::ParseMoov 中被调用，因为加密信息就在 moov 中的 stsd 中的 entry 里面。</p><p>这篇文章先分析到这里，下篇文章分析 SourceBuffer::appendBuffer 相关过程。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium 多媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium 多媒体（一）</title>
      <link href="/2023/06/23/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/06/23/Chromium-%E5%A4%9A%E5%AA%92%E4%BD%93%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>之前做过浏览器多媒体相关的业务，打算写几篇文章总结一下相关内容。</p><p>这篇文章介绍一下 MSE。MSE 全称 Media Source Extensions，通过该标准，浏览器应用可以实现更精细的音视频播放控制。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>我们通过下面的代码分析 MSE 的基本流程。</p><p>下面的代码主要做了以下工作：</p><ul><li>创建 MediaSource 类型的对象 mediaSource</li><li>通过 mediaSource 创建 URL，并将该 URL 赋给 video.src</li><li>监听 mediaSource 的 sourceopen 事件（后续会看到该事件底层是如何触发的）</li><li>在 sourceopen 事件的回调函数中通过 MediaSource 的 addSourceBuffer 方法创建 SourceBuffer 类型的对象 sourceBuffer，并执行 fetch 函数，每当 fetch 函数取得数据时都将数据通过 appendBuffer 送给 sourceBuffer</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#mse-video&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> mineCodes = <span class="string">&#x27;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">MediaSource</span> &amp;&amp; <span class="title class_">MediaSource</span>.<span class="title function_">isTypeSupported</span>(mineCodes)) &#123; </span><br><span class="line">  <span class="comment">// 检测当前环境是否支持 MediaSource API以及是否支持此mineCodes</span></span><br><span class="line">  <span class="keyword">var</span> mediaSource = <span class="keyword">new</span> <span class="title class_">MediaSource</span>();</span><br><span class="line">  <span class="comment">// 使用 mediaSource对象创建blob url，并赋给video.src</span></span><br><span class="line">  video.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(mediaSource);</span><br><span class="line">  mediaSource.<span class="title function_">addEventListener</span>(<span class="string">&#x27;sourceopen&#x27;</span>, sourceOpen); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The Media Source Extensions API is not supported.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sourceOpen</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// URL.revokeObjectURL 主动释放引用</span></span><br><span class="line">  <span class="variable constant_">URL</span>.<span class="title function_">revokeObjectURL</span>(video.<span class="property">src</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> mediaSource = e.<span class="property">target</span>;</span><br><span class="line">  <span class="comment">// addSourceBuffer根据传入的mineCodes，创建一个新的 SourceBuffer 并添加到 MediaSource 的 SourceBuffers 列表</span></span><br><span class="line">  <span class="keyword">var</span> sourceBuffer = mediaSource.<span class="title function_">addSourceBuffer</span>(mineCodes);</span><br><span class="line">  <span class="keyword">var</span> videoUrl = <span class="string">&#x27;video.mp4&#x27;</span>;</span><br><span class="line">  <span class="title function_">fetch</span>(videoUrl)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">arrayBuffer</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">arrayBuffer</span>) &#123;</span><br><span class="line">      sourceBuffer.<span class="title function_">addEventListener</span>(<span class="string">&#x27;updateend&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sourceBuffer.<span class="property">updating</span> &amp;&amp; mediaSource.<span class="property">readyState</span> === <span class="string">&#x27;open&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">// 数据添加完毕后，调用endOfStream结束当前流</span></span><br><span class="line">          mediaSource.<span class="title function_">endOfStream</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 将媒体数据添加到sourceBuffer中</span></span><br><span class="line">      sourceBuffer.<span class="title function_">appendBuffer</span>(arrayBuffer); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createObjectURL"><a href="#createObjectURL" class="headerlink" title="createObjectURL"></a>createObjectURL</h2><p>先看 createObjectURL 做了什么。</p><p>在 createObjectURL 中创建了 MediaSourceAttachment 对象，根据是否是在 Worker 线程中会创建 CrossThreadMediaSourceAttachment 或者 SameThreadMediaSourceAttachment</p><p>MediaSourceAttachment 中持有 MediaSource 的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function">String <span class="title">URLMediaSource::createObjectURL</span><span class="params">(ScriptState* script_state,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       MediaSource* source)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Since WebWorkers previously could not obtain MediaSource objects, we should</span></span><br><span class="line">  <span class="comment">// be on the main thread unless MediaSourceInWorkers is enabled and we&#x27;re in a</span></span><br><span class="line">  <span class="comment">// dedicated worker execution context.</span></span><br><span class="line">  ExecutionContext* execution_context = ExecutionContext::<span class="built_in">From</span>(script_state);</span><br><span class="line">  <span class="built_in">DCHECK</span>(execution_context);</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>() || RuntimeEnabledFeatures::<span class="built_in">MediaSourceInWorkersEnabled</span>(</span><br><span class="line">                               execution_context));</span><br><span class="line">  <span class="built_in">DCHECK</span>(source);</span><br><span class="line"></span><br><span class="line">  MediaSourceAttachment* attachment;</span><br><span class="line">  <span class="keyword">if</span> (execution_context-&gt;<span class="built_in">IsDedicatedWorkerGlobalScope</span>()) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!<span class="built_in">IsMainThread</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PassKey usage here ensures that only we can call the constructor.</span></span><br><span class="line">    attachment = <span class="keyword">new</span> <span class="built_in">CrossThreadMediaSourceAttachment</span>(source, <span class="built_in">PassKey</span>());</span><br><span class="line">    UseCounter::<span class="built_in">Count</span>(execution_context,</span><br><span class="line">                      WebFeature::kCreateObjectURLMediaSourceFromWorker);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Other contexts outside of main window thread or conditionally a dedicated</span></span><br><span class="line">    <span class="comment">// worker thread are not supported (like Shared Worker and Service Worker).</span></span><br><span class="line">    <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>() &amp;&amp; execution_context-&gt;<span class="built_in">IsWindow</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PassKey usage here ensures that only we can call the constructor.</span></span><br><span class="line">    attachment = <span class="keyword">new</span> <span class="built_in">SameThreadMediaSourceAttachment</span>(source, <span class="built_in">PassKey</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UseCounter::<span class="built_in">Count</span>(execution_context, WebFeature::kCreateObjectURLMediaSource);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The creation of a ThreadSafeRefCounted attachment object, above, should</span></span><br><span class="line">  <span class="comment">// have a refcount of 1 immediately. It will be adopted into a scoped_refptr</span></span><br><span class="line">  <span class="comment">// in MediaSourceRegistryImpl::RegisterURL. See also MediaSourceAttachment</span></span><br><span class="line">  <span class="comment">// (and usage in HTMLMediaElement, MediaSourceRegistry&#123;Impl&#125;, and MediaSource)</span></span><br><span class="line">  <span class="comment">// for further detail.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(attachment-&gt;<span class="built_in">HasOneRef</span>());</span><br><span class="line"></span><br><span class="line">  String url = DOMURL::<span class="built_in">CreatePublicURL</span>(execution_context, attachment);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 Attachment 之后，通过 DOMURL::CreatePublicURL 来创建该 MediaSourceAttachment 对应的 String</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> String <span class="title">DOMURL::CreatePublicURL</span><span class="params">(ExecutionContext* execution_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                               URLRegistrable* registrable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> execution_context-&gt;<span class="built_in">GetPublicURLManager</span>().<span class="built_in">RegisterURL</span>(registrable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PublicURLManager&amp; <span class="title">ExecutionContext::GetPublicURLManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!public_url_manager_)</span><br><span class="line">    public_url_manager_ = <span class="built_in">MakeGarbageCollected</span>&lt;PublicURLManager&gt;(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> *public_url_manager_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">PublicURLManager::RegisterURL</span><span class="params">(URLRegistrable* registrable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is_stopped_)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>();</span><br><span class="line"></span><br><span class="line">  SecurityOrigin* origin = <span class="built_in">GetExecutionContext</span>()-&gt;<span class="built_in">GetMutableSecurityOrigin</span>();</span><br><span class="line">  <span class="type">const</span> KURL&amp; url = BlobURL::<span class="built_in">CreatePublicURL</span>(origin);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!url.<span class="built_in">IsEmpty</span>());</span><br><span class="line">  <span class="type">const</span> String&amp; url_string = url.<span class="built_in">GetString</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Collect metrics on how frequently a worker context that makes use of the</span></span><br><span class="line">  <span class="comment">// Blob URL API was created from a data URL. Note that we ignore service</span></span><br><span class="line">  <span class="comment">// workers for this since they can&#x27;t be created from data URLs.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetExecutionContext</span>()-&gt;<span class="built_in">IsWorkerGlobalScope</span>()) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (registrable-&gt;<span class="built_in">IsMojoBlob</span>()) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    URLRegistry* registry = &amp;registrable-&gt;<span class="built_in">Registry</span>();</span><br><span class="line">    registry-&gt;<span class="built_in">RegisterURL</span>(origin, url, registrable);</span><br><span class="line">    url_to_registry_.<span class="built_in">insert</span>(url_string, registry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> url_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MediaSourceAttachment 类有一个静态的 <code>URLRegistry*</code> 成员，上面 <code>registrable-&gt;Registry()</code> 返回的就是该成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">URLRegistry* MediaSourceAttachment::registry_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">URLRegistry&amp; <span class="title">MediaSourceAttachment::Registry</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *registry_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过 <code>registry-&gt;RegisterURL</code> 将 url 和 MediaSourceAttachment 注册到 <code>registry</code> 中，会把他们插入到 <code>media_sources_</code> 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaSourceRegistryImpl::RegisterURL</span><span class="params">(SecurityOrigin*,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> KURL&amp; url,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          URLRegistrable* registrable)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLocker <span class="title">lock</span><span class="params">(map_mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(&amp;registrable-&gt;<span class="built_in">Registry</span>(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  scoped_refptr&lt;MediaSourceAttachment&gt; attachment =</span><br><span class="line">      base::<span class="built_in">AdoptRef</span>(<span class="built_in">static_cast</span>&lt;MediaSourceAttachment*&gt;(registrable));</span><br><span class="line"></span><br><span class="line">  media_sources_.<span class="built_in">Set</span>(url.<span class="built_in">GetString</span>(), std::<span class="built_in">move</span>(attachment));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebMediaPlayer-查找-MediaSourceAttachment"><a href="#WebMediaPlayer-查找-MediaSourceAttachment" class="headerlink" title="WebMediaPlayer 查找 MediaSourceAttachment"></a>WebMediaPlayer 查找 MediaSourceAttachment</h2><p>接下来再看 WebMediaPlayer 查找 MediaSourceAttachment。</p><p>该过程在 HTMLMediaElement::LoadResource 函数中。</p><p>下面的 source 参数包装了 url 的 String，在 LoadResource 函数内会从 source 恢复 url 的 String</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HTMLMediaElement::LoadResource</span><span class="params">(<span class="type">const</span> WebMediaPlayerSource&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> String&amp; content_type)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>());</span><br><span class="line">  KURL url;</span><br><span class="line">  <span class="keyword">if</span> (source.<span class="built_in">IsURL</span>()) &#123;</span><br><span class="line">    url = source.<span class="built_in">GetAsURL</span>();</span><br><span class="line">    <span class="built_in">DCHECK</span>(<span class="built_in">IsSafeToLoadURL</span>(url, kComplain));</span><br><span class="line">    <span class="built_in">DVLOG</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;loadResource(&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">UrlForLoggingMedia</span>(url)</span><br><span class="line">             &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; content_type &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LocalFrame* frame = <span class="built_in">GetDocument</span>().<span class="built_in">GetFrame</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The resource fetch algorithm</span></span><br><span class="line">  <span class="built_in">SetNetworkState</span>(kNetworkLoading);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set current_src_ *before* changing to the cache url, the fact that we are</span></span><br><span class="line">  <span class="comment">// loading from the app cache is an internal detail not exposed through the</span></span><br><span class="line">  <span class="comment">// media element API.</span></span><br><span class="line">  current_src_ = url;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Default this to empty, so that we use |current_src_| unless the player</span></span><br><span class="line">  <span class="comment">// provides one later.</span></span><br><span class="line">  current_src_after_redirects_ = <span class="built_in">KURL</span>();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  media_source_attachment_ =</span><br><span class="line">      MediaSourceAttachment::<span class="built_in">LookupMediaSource</span>(url.<span class="built_in">GetString</span>());</span><br><span class="line">  <span class="keyword">if</span> (media_source_attachment_) &#123;</span><br><span class="line">    <span class="type">bool</span> start_result = <span class="literal">false</span>;</span><br><span class="line">    media_source_tracer_ =</span><br><span class="line">        media_source_attachment_-&gt;<span class="built_in">StartAttachingToMediaElement</span>(<span class="keyword">this</span>,</span><br><span class="line">                                                               &amp;start_result);</span><br><span class="line">    <span class="keyword">if</span> (start_result) &#123;</span><br><span class="line">      <span class="comment">// If the associated feature is enabled, auto-revoke the MediaSource</span></span><br><span class="line">      <span class="comment">// object URL that was used for attachment on successful (start of)</span></span><br><span class="line">      <span class="comment">// attachment. This can help reduce memory bloat later if the app does not</span></span><br><span class="line">      <span class="comment">// revoke the object URL explicitly and the object URL was the only</span></span><br><span class="line">      <span class="comment">// remaining strong reference to an attached HTMLMediaElement+MediaSource</span></span><br><span class="line">      <span class="comment">// cycle of objects that could otherwise be garbage-collectable.</span></span><br><span class="line">      <span class="keyword">if</span> (base::FeatureList::<span class="built_in">IsEnabled</span>(</span><br><span class="line">              media::kRevokeMediaSourceObjectURLOnAttach)) &#123;</span><br><span class="line">        URLFileAPI::<span class="built_in">revokeObjectURL</span>(<span class="built_in">GetExecutionContext</span>(), url.<span class="built_in">GetString</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Forget our reference to the MediaSourceAttachment, so we leave it alone</span></span><br><span class="line">      <span class="comment">// while processing remainder of load failure.</span></span><br><span class="line">      media_source_attachment_.<span class="built_in">reset</span>();</span><br><span class="line">      media_source_tracer_ = <span class="literal">nullptr</span>;</span><br><span class="line">      attempt_load = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> can_load_resource =</span><br><span class="line">      source.<span class="built_in">IsMediaStream</span>() || <span class="built_in">CanLoadURL</span>(url, content_type);</span><br><span class="line">  <span class="keyword">if</span> (attempt_load &amp;&amp; can_load_resource) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!<span class="built_in">GetWebMediaPlayer</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Conditionally defer the load if effective preload is &#x27;none&#x27;.</span></span><br><span class="line">    <span class="comment">// Skip this optional deferral for MediaStream sources or any blob URL,</span></span><br><span class="line">    <span class="comment">// including MediaSource blob URLs.</span></span><br><span class="line">    <span class="keyword">if</span> (!source.<span class="built_in">IsMediaStream</span>() &amp;&amp; !url.<span class="built_in">ProtocolIs</span>(<span class="string">&quot;blob&quot;</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">EffectivePreloadType</span>() == WebMediaPlayer::kPreloadNone) &#123;</span><br><span class="line">      <span class="built_in">DVLOG</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;loadResource(&quot;</span> &lt;&lt; *<span class="keyword">this</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;) : Delaying load because preload == &#x27;none&#x27;&quot;</span>;</span><br><span class="line">      <span class="built_in">DeferLoad</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">StartPlayerLoad</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LookupMediaSource"><a href="#LookupMediaSource" class="headerlink" title="LookupMediaSource"></a>LookupMediaSource</h3><p>上面先通过 LookupMediaSource 查找 url 对应的 MediaSourceAttachment。</p><p><code>registry_</code> 上面已经说过，是 MediaSourceAttachment 中的静态成员，而之前已经通过 <code>registry_-&gt;RegisterURL</code> 将 MediaSourceAttachment 注册到 <code>registry_</code> 中，这里则是通过 <code>registry_-&gt;LookupMediaSource</code> 查找 MediaSourceAttachment</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function">scoped_refptr&lt;MediaSourceAttachment&gt; <span class="title">MediaSourceAttachment::LookupMediaSource</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> String&amp; url)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The only expected caller is an HTMLMediaElement on the main thread.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>());</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This cast is safe because the only setter of |registry_| is SetRegistry().</span></span><br><span class="line">  MediaSourceRegistry* ms_registry =</span><br><span class="line">      <span class="built_in">static_cast</span>&lt;MediaSourceRegistry*&gt;(registry_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ms_registry-&gt;<span class="built_in">LookupMediaSource</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">scoped_refptr&lt;MediaSourceAttachment&gt; <span class="title">MediaSourceRegistryImpl::LookupMediaSource</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> String&amp; url)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLocker <span class="title">lock</span><span class="params">(map_mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(!url.<span class="built_in">IsEmpty</span>());</span><br><span class="line">  <span class="keyword">auto</span> iter = media_sources_.<span class="built_in">find</span>(url);</span><br><span class="line">  <span class="keyword">if</span> (iter == media_sources_.<span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> iter-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StartAttachingToMediaElement"><a href="#StartAttachingToMediaElement" class="headerlink" title="StartAttachingToMediaElement"></a>StartAttachingToMediaElement</h3><p>找到 MediaSourceAttachment 之后就调用 StartAttachingToMediaElement</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MediaSourceTracer*</span></span><br><span class="line"><span class="function"><span class="title">SameThreadMediaSourceAttachment::StartAttachingToMediaElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HTMLMediaElement* element,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span>* success)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">VerifyCalledWhileContextsAliveForDebugging</span>();</span><br><span class="line">  <span class="built_in">DCHECK</span>(success);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  MediaSourceTracer* tracer =</span><br><span class="line">      registered_media_source_-&gt;<span class="built_in">StartAttachingToMediaElement</span>(</span><br><span class="line">          <span class="built_in">WrapRefCounted</span>(<span class="keyword">this</span>), element);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For this same-thread attachment start, a non-nullptr tracer indicates</span></span><br><span class="line">  <span class="comment">// success here.</span></span><br><span class="line">  *success = !!tracer;</span><br><span class="line">  <span class="keyword">return</span> tracer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registered_media_source_</code> 就是 MediaSource，下面函数<strong>将 MediaSourceAttachment 保存在 MediaSource 中</strong>，然后将 MediaSource 保存在 MediaSourceTracer 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MediaSourceTracer* <span class="title">MediaSource::StartAttachingToMediaElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;SameThreadMediaSourceAttachment&gt; attachment,</span></span></span><br><span class="line"><span class="params"><span class="function">    HTMLMediaElement* element)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLocker <span class="title">lock</span><span class="params">(attachment_link_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(!context_already_destroyed_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsClosed</span>());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  media_source_attachment_ = attachment;</span><br><span class="line">  attachment_tracer_ =</span><br><span class="line">      <span class="built_in">MakeGarbageCollected</span>&lt;SameThreadMediaSourceTracer&gt;(element, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> attachment_tracer_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CompleteAttachingToMediaElement"><a href="#CompleteAttachingToMediaElement" class="headerlink" title="CompleteAttachingToMediaElement"></a>CompleteAttachingToMediaElement</h3><p>上面函数只是 attach 的第一部分，剩余的工作是在 CompleteAttachingToMediaElement 中，CompleteAttachingToMediaElement 被 MediaSourceOpened 函数调用，MediaSourceOpened 就对应了上面的 sourceopen 事件，后面会看到 MediaSourceOpened 会被 ChunkDemuxer 的回调函数调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HTMLMediaElement::MediaSourceOpened</span><span class="params">(WebMediaSource* web_media_source)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetShouldDelayLoadEvent</span>(<span class="literal">false</span>);</span><br><span class="line">  media_source_attachment_-&gt;<span class="built_in">CompleteAttachingToMediaElement</span>(</span><br><span class="line">      media_source_tracer_, base::<span class="built_in">WrapUnique</span>(web_media_source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SameThreadMediaSourceAttachment::CompleteAttachingToMediaElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MediaSourceTracer* tracer,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;WebMediaSource&gt; web_media_source)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">VerifyCalledWhileContextsAliveForDebugging</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GetMediaSource</span>(tracer)-&gt;<span class="built_in">CompleteAttachingToMediaElement</span>(</span><br><span class="line">      std::<span class="built_in">move</span>(web_media_source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会调用 MediaSource 的 CompleteAttachingToMediaElement</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaSource::CompleteAttachingToMediaElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;WebMediaSource&gt; web_media_source)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">AssertAttachmentsMutexHeldIfCrossThreadForDebugging</span>();</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLocker <span class="title">lock</span><span class="params">(attachment_link_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DCHECK_EQ</span>(!attachment_tracer_, !<span class="built_in">IsMainThread</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attachment_tracer_) &#123;</span><br><span class="line">      <span class="comment">// Use of a tracer means we must be using same-thread attachment.</span></span><br><span class="line">      <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_END0</span>(</span><br><span class="line">          <span class="string">&quot;media&quot;</span>, <span class="string">&quot;MediaSource::StartAttachingToMediaElement&quot;</span>,</span><br><span class="line">          <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Otherwise, we must be using a cross-thread MSE-in-Workers attachment.</span></span><br><span class="line">      <span class="built_in">TRACE_EVENT_NESTABLE_ASYNC_END0</span>(</span><br><span class="line">          <span class="string">&quot;media&quot;</span>, <span class="string">&quot;MediaSource::StartWorkerAttachingToMainThreadMediaElement&quot;</span>,</span><br><span class="line">          <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DCHECK</span>(web_media_source);</span><br><span class="line">    <span class="built_in">DCHECK</span>(!web_media_source_);</span><br><span class="line">    <span class="built_in">DCHECK</span>(media_source_attachment_);</span><br><span class="line"></span><br><span class="line">    web_media_source_ = std::<span class="built_in">move</span>(web_media_source);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetReadyState</span>(ReadyState::kOpen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 web_media_source 有 ChunkDemuxer 的指针，所以这里将 ChunkDemuxer 设置给了 MediaSource，后面往 MediaSource 中送数据就是送到 ChunkDemuxer 中</p><h2 id="WebMediaPlayer-以及-ChunkDemuxer-的创建"><a href="#WebMediaPlayer-以及-ChunkDemuxer-的创建" class="headerlink" title="WebMediaPlayer 以及 ChunkDemuxer 的创建"></a>WebMediaPlayer 以及 ChunkDemuxer 的创建</h2><p>接下来先不看 addSourceBuffer 相关内容，先看 WebMediaPlayer 以及 ChunkDemuxer 的创建，因为 addSourceBuffer 要在 ChunkDemuxer 初始化之后才执行，我们遵循这个调用流程。</p><h3 id="HTMLMediaElement-StartPlayerLoad"><a href="#HTMLMediaElement-StartPlayerLoad" class="headerlink" title="HTMLMediaElement::StartPlayerLoad"></a>HTMLMediaElement::StartPlayerLoad</h3><p>在 HTMLMediaElement::LoadResource 函数中，执行 StartAttachingToMediaElement 后，会执行 StartPlayerLoad 函数，在 StartPlayerLoad 中创建 WebMediaPlayer 以及启动 WebMediaPlayer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HTMLMediaElement::StartPlayerLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  WebMediaPlayerSource source;</span><br><span class="line">...</span><br><span class="line">  LocalFrame* frame = <span class="built_in">LocalFrameForPlayer</span>();</span><br><span class="line">  web_media_player_ =</span><br><span class="line">      frame-&gt;<span class="built_in">Client</span>()-&gt;<span class="built_in">CreateWebMediaPlayer</span>(*<span class="keyword">this</span>, source, <span class="keyword">this</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LocalFrame* <span class="title">HTMLMediaElement::LocalFrameForPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> opener_document_ ? opener_document_-&gt;<span class="built_in">GetFrame</span>()</span><br><span class="line">                          : <span class="built_in">GetDocument</span>().<span class="built_in">GetFrame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalFrameForPlayer 返回一个 LocalFrame 指针，而 LocalFrame 继承 Frame</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LocalFrameClient* <span class="title">LocalFrame::Client</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;LocalFrameClient*&gt;(Frame::<span class="built_in">Client</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 StartPlayerLoad 中 <code>frame-&gt;Client()</code> 返回 LocalFrameClient 指针，该指针实际指向 LocalFrameClientImpl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// third_party/blink/renderer/core/frame/local_frame_client_impl.cc</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;WebMediaPlayer&gt; <span class="title">LocalFrameClientImpl::CreateWebMediaPlayer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HTMLMediaElement&amp; html_media_element,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebMediaPlayerSource&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebMediaPlayerClient* client)</span> </span>&#123;</span><br><span class="line">  LocalFrame* local_frame = html_media_element.<span class="built_in">LocalFrameForPlayer</span>();</span><br><span class="line">  WebLocalFrameImpl* web_frame = WebLocalFrameImpl::<span class="built_in">FromFrame</span>(local_frame);</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> CoreInitializer::<span class="built_in">GetInstance</span>().<span class="built_in">CreateWebMediaPlayer</span>(</span><br><span class="line">      web_frame-&gt;<span class="built_in">Client</span>(), html_media_element, source, client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ModulesInitializer 是 CoreInitializer 的子类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;WebMediaPlayer&gt; <span class="title">ModulesInitializer::CreateWebMediaPlayer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WebLocalFrameClient* web_frame_client,</span></span></span><br><span class="line"><span class="params"><span class="function">    HTMLMediaElement&amp; html_media_element,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebMediaPlayerSource&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebMediaPlayerClient* media_player_client)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  HTMLMediaElementEncryptedMedia&amp; encrypted_media =</span><br><span class="line">      HTMLMediaElementEncryptedMedia::<span class="built_in">From</span>(html_media_element);</span><br><span class="line">  <span class="function">WebString <span class="title">sink_id</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      HTMLMediaElementAudioOutputDevice::sinkId(html_media_element))</span></span>;</span><br><span class="line">  MediaInspectorContextImpl* context_impl = MediaInspectorContextImpl::<span class="built_in">From</span>(</span><br><span class="line">      *<span class="built_in">To</span>&lt;LocalDOMWindow&gt;(html_media_element.<span class="built_in">GetExecutionContext</span>()));</span><br><span class="line">  FrameWidget* frame_widget =</span><br><span class="line">      html_media_element.<span class="built_in">GetDocument</span>().<span class="built_in">GetFrame</span>()-&gt;<span class="built_in">GetWidgetForLocalRoot</span>();</span><br><span class="line">  <span class="keyword">return</span> base::<span class="built_in">WrapUnique</span>(web_frame_client-&gt;<span class="built_in">CreateMediaPlayer</span>(</span><br><span class="line">      source, media_player_client, context_impl, &amp;encrypted_media,</span><br><span class="line">      encrypted_media.<span class="built_in">ContentDecryptionModule</span>(), sink_id,</span><br><span class="line">      frame_widget-&gt;<span class="built_in">GetLayerTreeSettings</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web_frame_client 实际指向的是 RenderFrameImpl，但是这些 frame 具体是怎么来的笔者也不太清楚，笔者是通过 backtrace 知道会调用到 RenderFrameImpl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CONTENT_EXPORT</span> RenderFrameImpl</span><br><span class="line">    : <span class="keyword">public</span> RenderFrame,</span><br><span class="line">      <span class="keyword">public</span> blink::mojom::ResourceLoadInfoNotifier,</span><br><span class="line">      blink::mojom::AutoplayConfigurationClient,</span><br><span class="line">      <span class="keyword">public</span> mojom::Frame,</span><br><span class="line">      mojom::FrameBindingsControl,</span><br><span class="line">      mojom::MhtmlFileWriter,</span><br><span class="line">      <span class="keyword">public</span> blink::WebLocalFrameClient,</span><br><span class="line">      service_manager::mojom::InterfaceProvider &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以上面最终调用的是 RenderFrameImpl::CreateMediaPlayer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">blink::WebMediaPlayer* <span class="title">RenderFrameImpl::CreateMediaPlayer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> blink::WebMediaPlayerSource&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebMediaPlayerClient* client,</span></span></span><br><span class="line"><span class="params"><span class="function">    blink::MediaInspectorContext* inspector_context,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebMediaPlayerEncryptedMediaClient* encrypted_client,</span></span></span><br><span class="line"><span class="params"><span class="function">    WebContentDecryptionModule* initial_cdm,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> blink::WebString&amp; sink_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> cc::LayerTreeSettings&amp; settings)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> media_factory_.<span class="built_in">CreateMediaPlayer</span>(</span><br><span class="line">      source, client, inspector_context, encrypted_client, initial_cdm, sink_id,</span><br><span class="line">      <span class="built_in">GetLocalRootWebFrameWidget</span>()-&gt;<span class="built_in">GetFrameSinkId</span>(), settings,</span><br><span class="line">      agent_scheduling_group_.<span class="built_in">agent_group_scheduler</span>().<span class="built_in">CompositorTaskRunner</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上面出现了 encrypted_client 和 initial_cdm，这些和 EME 有关，放到后面来分析。</p><h4 id="MediaFactory-CreateMediaPlayer"><a href="#MediaFactory-CreateMediaPlayer" class="headerlink" title="MediaFactory::CreateMediaPlayer"></a>MediaFactory::CreateMediaPlayer</h4><p>在 RenderFrameImpl::CreateMediaPlayer 内部通过 MediaFactory::CreateMediaPlayer 来创建 WebMediaPlayer，MediaFactory::CreateMediaPlayer 函数则创建了 RendererFactorySelector，后面会通过该 Selector 来决定使用哪个 RendererFactory，再使用 RendererFactory 创建 Renderer，创建 Renderer 时也会创建 Decoder，创建 Decoder 也是通过 MediaFactory 实现的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">blink::WebMediaPlayer* <span class="title">MediaFactory::CreateMediaPlayer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> blink::WebMediaPlayerSource&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    blink::WebMediaPlayerClient* client,</span></span></span><br><span class="line"><span class="params"><span class="function">    blink::MediaInspectorContext* inspector_context,</span></span></span><br><span class="line"><span class="params"><span class="function">    blink::WebMediaPlayerEncryptedMediaClient* encrypted_client,</span></span></span><br><span class="line"><span class="params"><span class="function">    blink::WebContentDecryptionModule* initial_cdm,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> blink::WebString&amp; sink_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    viz::FrameSinkId parent_frame_sink_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> cc::LayerTreeSettings&amp; settings,</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">        main_thread_compositor_task_runner)</span> </span>&#123;</span><br><span class="line">  blink::WebLocalFrame* web_frame = render_frame_-&gt;<span class="built_in">GetWebFrame</span>();</span><br><span class="line">  <span class="keyword">auto</span>* delegate = <span class="built_in">GetWebMediaPlayerDelegate</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (source.<span class="built_in">IsMediaStream</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CreateWebMediaPlayerForMediaStream</span>(</span><br><span class="line">        client, inspector_context, sink_id, web_frame, parent_frame_sink_id,</span><br><span class="line">        settings, main_thread_compositor_task_runner);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If |source| was not a MediaStream, it must be a URL.</span></span><br><span class="line">  <span class="comment">// TODO(guidou): Fix this when support for other srcObject types is added.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(source.<span class="built_in">IsURL</span>());</span><br><span class="line">  blink::WebURL url = source.<span class="built_in">GetAsURL</span>();</span><br><span class="line"></span><br><span class="line">  RenderThreadImpl* render_thread = RenderThreadImpl::<span class="built_in">current</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建audio renderer</span></span><br><span class="line">  scoped_refptr&lt;media::SwitchableAudioRendererSink&gt; audio_renderer_sink =</span><br><span class="line">      blink::AudioDeviceFactory::<span class="built_in">NewSwitchableAudioRendererSink</span>(</span><br><span class="line">          blink::WebAudioDeviceSourceType::kMediaElement,</span><br><span class="line">          render_frame_-&gt;<span class="built_in">GetWebFrame</span>()-&gt;<span class="built_in">GetLocalFrameToken</span>(),</span><br><span class="line">          media::<span class="built_in">AudioSinkParameters</span>(<span class="comment">/*session_id=*/</span>base::<span class="built_in">UnguessableToken</span>(),</span><br><span class="line">                                     sink_id.<span class="built_in">Utf8</span>()));</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// This must be created for every new WebMediaPlayer, each instance generates</span></span><br><span class="line">  <span class="comment">// a new player id which is used to collate logs on the browser side.</span></span><br><span class="line">  <span class="keyword">auto</span> media_log = std::<span class="built_in">make_unique</span>&lt;BatchingMediaLog&gt;(</span><br><span class="line">      render_frame_-&gt;<span class="built_in">GetTaskRunner</span>(blink::TaskType::kInternalMedia),</span><br><span class="line">      std::<span class="built_in">move</span>(handlers));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Renderer Factory Selector</span></span><br><span class="line"><span class="comment">// Renderer Factory里面有Decoder Factory</span></span><br><span class="line">  base::WeakPtr&lt;media::MediaObserver&gt; media_observer;</span><br><span class="line">  <span class="keyword">auto</span> factory_selector = <span class="built_in">CreateRendererFactorySelector</span>(</span><br><span class="line">      media_log.<span class="built_in">get</span>(), url, render_frame_-&gt;<span class="built_in">GetRenderFrameMediaPlaybackOptions</span>(),</span><br><span class="line">      <span class="built_in">GetDecoderFactory</span>().<span class="built_in">get</span>(),</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;blink::RemotePlaybackClientWrapperImpl&gt;(client),</span><br><span class="line">      &amp;media_observer);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  mojo::PendingRemote&lt;media::mojom::MediaMetricsProvider&gt; metrics_provider;</span><br><span class="line">  interface_broker_-&gt;<span class="built_in">GetInterface</span>(</span><br><span class="line">      metrics_provider.<span class="built_in">InitWithNewPipeAndPassReceiver</span>());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  scoped_refptr&lt;base::SingleThreadTaskRunner&gt; media_task_runner =</span><br><span class="line">      render_thread-&gt;<span class="built_in">GetMediaThreadTaskRunner</span>();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> video_frame_compositor_task_runner =</span><br><span class="line">      <span class="built_in">GetOrCreateVideoFrameCompositorTaskRunner</span>(render_frame_);</span><br><span class="line">  <span class="keyword">auto</span> vfc = std::<span class="built_in">make_unique</span>&lt;blink::VideoFrameCompositor&gt;(</span><br><span class="line">      video_frame_compositor_task_runner, std::<span class="built_in">move</span>(submitter));</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;media::Demuxer&gt; demuxer_override =</span><br><span class="line">      <span class="built_in">GetContentClient</span>()-&gt;<span class="built_in">renderer</span>()-&gt;<span class="built_in">OverrideDemuxerForUrl</span>(render_frame_, url,</span><br><span class="line">                                                            media_task_runner);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> blink::WebMediaPlayerBuilder::<span class="built_in">Build</span>(</span><br><span class="line">      web_frame, client, encrypted_client, delegate,</span><br><span class="line">      std::<span class="built_in">move</span>(factory_selector), url_index_.<span class="built_in">get</span>(), std::<span class="built_in">move</span>(vfc),</span><br><span class="line">      std::<span class="built_in">move</span>(media_log),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;RenderFrameImpl::DeferMediaLoad,</span><br><span class="line">                          base::<span class="built_in">Unretained</span>(render_frame_),</span><br><span class="line">                          delegate-&gt;<span class="built_in">has_played_media</span>()),</span><br><span class="line">      std::<span class="built_in">move</span>(audio_renderer_sink), std::<span class="built_in">move</span>(media_task_runner),</span><br><span class="line">      render_thread-&gt;<span class="built_in">GetWorkerTaskRunner</span>(),</span><br><span class="line">      render_thread-&gt;<span class="built_in">compositor_task_runner</span>(),</span><br><span class="line">      std::<span class="built_in">move</span>(video_frame_compositor_task_runner),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;v8::Isolate::AdjustAmountOfExternalAllocatedMemory,</span><br><span class="line">                          base::<span class="built_in">Unretained</span>(blink::<span class="built_in">MainThreadIsolate</span>())),</span><br><span class="line">      initial_cdm, request_routing_token_cb_, media_observer,</span><br><span class="line">      enable_instant_source_buffer_gc, embedded_media_experience_enabled,</span><br><span class="line">      std::<span class="built_in">move</span>(metrics_provider),</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;blink::WebSurfaceLayerBridge::Create,</span><br><span class="line">                     parent_frame_sink_id,</span><br><span class="line">                     blink::WebSurfaceLayerBridge::ContainsVideo::kYes),</span><br><span class="line">      RenderThreadImpl::<span class="built_in">current</span>()-&gt;<span class="built_in">SharedMainThreadContextProvider</span>(),</span><br><span class="line">      use_surface_layer,</span><br><span class="line">      render_frame_-&gt;<span class="built_in">GetRenderFrameMediaPlaybackOptions</span>()</span><br><span class="line">          .is_background_suspend_enabled,</span><br><span class="line">      render_frame_-&gt;<span class="built_in">GetRenderFrameMediaPlaybackOptions</span>()</span><br><span class="line">          .is_background_video_playback_enabled,</span><br><span class="line">      render_frame_-&gt;<span class="built_in">GetRenderFrameMediaPlaybackOptions</span>()</span><br><span class="line">          .is_background_video_track_optimization_supported,</span><br><span class="line">      std::<span class="built_in">move</span>(demuxer_override),</span><br><span class="line">      blink::Platform::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetBrowserInterfaceBroker</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WebMediaPlayerImpl-的构造函数"><a href="#WebMediaPlayerImpl-的构造函数" class="headerlink" title="WebMediaPlayerImpl 的构造函数"></a>WebMediaPlayerImpl 的构造函数</h5><p>接下来再看 WebMediaPlayerImpl 的构造函数，这个构造函数参数很多，但是大部分都是把参数赋给相应的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">WebMediaPlayerImpl::<span class="built_in">WebMediaPlayerImpl</span>(</span><br><span class="line">    WebLocalFrame* frame,</span><br><span class="line">    WebMediaPlayerClient* client,</span><br><span class="line">    WebMediaPlayerEncryptedMediaClient* encrypted_client,</span><br><span class="line">    WebMediaPlayerDelegate* delegate,</span><br><span class="line">    std::unique_ptr&lt;media::RendererFactorySelector&gt; renderer_factory_selector,</span><br><span class="line">    UrlIndex* url_index,</span><br><span class="line">    std::unique_ptr&lt;VideoFrameCompositor&gt; compositor,</span><br><span class="line">    std::unique_ptr&lt;media::MediaLog&gt; media_log,</span><br><span class="line">    WebMediaPlayerBuilder::DeferLoadCB defer_load_cb,</span><br><span class="line">    scoped_refptr&lt;media::SwitchableAudioRendererSink&gt; audio_renderer_sink,</span><br><span class="line">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt; media_task_runner,</span><br><span class="line">    scoped_refptr&lt;base::TaskRunner&gt; worker_task_runner,</span><br><span class="line">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt; compositor_task_runner,</span><br><span class="line">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt;</span><br><span class="line">        video_frame_compositor_task_runner,</span><br><span class="line">    WebMediaPlayerBuilder::AdjustAllocatedMemoryCB adjust_allocated_memory_cb,</span><br><span class="line">    WebContentDecryptionModule* initial_cdm,</span><br><span class="line">    media::RequestRoutingTokenCallback request_routing_token_cb,</span><br><span class="line">    base::WeakPtr&lt;media::MediaObserver&gt; media_observer,</span><br><span class="line">    <span class="type">bool</span> enable_instant_source_buffer_gc,</span><br><span class="line">    <span class="type">bool</span> embedded_media_experience_enabled,</span><br><span class="line">    mojo::PendingRemote&lt;media::mojom::MediaMetricsProvider&gt; metrics_provider,</span><br><span class="line">    CreateSurfaceLayerBridgeCB create_bridge_callback,</span><br><span class="line">    scoped_refptr&lt;viz::RasterContextProvider&gt; raster_context_provider,</span><br><span class="line">    <span class="type">bool</span> use_surface_layer,</span><br><span class="line">    <span class="type">bool</span> is_background_suspend_enabled,</span><br><span class="line">    <span class="type">bool</span> is_background_video_playback_enabled,</span><br><span class="line">    <span class="type">bool</span> is_background_video_track_optimization_supported,</span><br><span class="line">    std::unique_ptr&lt;media::Demuxer&gt; demuxer_override,</span><br><span class="line">    scoped_refptr&lt;ThreadSafeBrowserInterfaceBrokerProxy&gt; remote_interfaces)</span><br><span class="line">    : <span class="built_in">frame_</span>(frame),</span><br><span class="line">      <span class="built_in">main_task_runner_</span>(frame-&gt;<span class="built_in">GetTaskRunner</span>(TaskType::kMediaElementEvent)),</span><br><span class="line">      <span class="built_in">media_task_runner_</span>(std::<span class="built_in">move</span>(media_task_runner)),</span><br><span class="line">      <span class="built_in">worker_task_runner_</span>(std::<span class="built_in">move</span>(worker_task_runner)),</span><br><span class="line">      <span class="built_in">media_log_</span>(std::<span class="built_in">move</span>(media_log)),</span><br><span class="line">      <span class="built_in">client_</span>(client),</span><br><span class="line">      <span class="built_in">encrypted_client_</span>(encrypted_client),</span><br><span class="line">      <span class="built_in">delegate_</span>(delegate),</span><br><span class="line">      <span class="built_in">delegate_has_audio_</span>(<span class="built_in">HasUnmutedAudio</span>()),</span><br><span class="line">      <span class="built_in">defer_load_cb_</span>(std::<span class="built_in">move</span>(defer_load_cb)),</span><br><span class="line">      <span class="built_in">adjust_allocated_memory_cb_</span>(std::<span class="built_in">move</span>(adjust_allocated_memory_cb)),</span><br><span class="line">      <span class="built_in">tick_clock_</span>(base::DefaultTickClock::<span class="built_in">GetInstance</span>()),</span><br><span class="line">      <span class="built_in">url_index_</span>(url_index),</span><br><span class="line">      <span class="built_in">raster_context_provider_</span>(std::<span class="built_in">move</span>(raster_context_provider)),</span><br><span class="line">      <span class="built_in">vfc_task_runner_</span>(std::<span class="built_in">move</span>(video_frame_compositor_task_runner)),</span><br><span class="line">      <span class="built_in">compositor_</span>(std::<span class="built_in">move</span>(compositor)),</span><br><span class="line">      <span class="built_in">renderer_factory_selector_</span>(std::<span class="built_in">move</span>(renderer_factory_selector)),</span><br><span class="line">      <span class="built_in">observer_</span>(std::<span class="built_in">move</span>(media_observer)),</span><br><span class="line">      <span class="built_in">enable_instant_source_buffer_gc_</span>(enable_instant_source_buffer_gc),</span><br><span class="line">      <span class="built_in">embedded_media_experience_enabled_</span>(embedded_media_experience_enabled),</span><br><span class="line">      <span class="built_in">use_surface_layer_</span>(use_surface_layer),</span><br><span class="line">      <span class="built_in">create_bridge_callback_</span>(std::<span class="built_in">move</span>(create_bridge_callback)),</span><br><span class="line">      <span class="built_in">request_routing_token_cb_</span>(std::<span class="built_in">move</span>(request_routing_token_cb)),</span><br><span class="line">      <span class="built_in">media_metrics_provider_</span>(std::<span class="built_in">move</span>(metrics_provider)),</span><br><span class="line">      <span class="built_in">is_background_suspend_enabled_</span>(is_background_suspend_enabled),</span><br><span class="line">      <span class="built_in">is_background_video_playback_enabled_</span>(</span><br><span class="line">          is_background_video_playback_enabled),</span><br><span class="line">      <span class="built_in">is_background_video_track_optimization_supported_</span>(</span><br><span class="line">          is_background_video_track_optimization_supported),</span><br><span class="line">      <span class="built_in">simple_watch_timer_</span>(</span><br><span class="line">          base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnSimpleWatchTimerTick,</span><br><span class="line">                              base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)),</span><br><span class="line">          base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::GetCurrentTimeInternal,</span><br><span class="line">                              base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>))),</span><br><span class="line">      <span class="built_in">will_play_helper_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">demuxer_override_</span>(std::<span class="built_in">move</span>(demuxer_override)) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  weak_this_ = weak_factory_.<span class="built_in">GetWeakPtr</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> pipeline = std::<span class="built_in">make_unique</span>&lt;media::PipelineImpl&gt;(</span><br><span class="line">      media_task_runner_, main_task_runner_,</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::CreateRenderer,</span><br><span class="line">                          base::<span class="built_in">Unretained</span>(<span class="keyword">this</span>)),</span><br><span class="line">      media_log_.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  pipeline_controller_ = std::<span class="built_in">make_unique</span>&lt;media::PipelineController&gt;(</span><br><span class="line">      std::<span class="built_in">move</span>(pipeline),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnPipelineSeeked, weak_this_),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnPipelineSuspended, weak_this_),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnBeforePipelineResume,</span><br><span class="line">                          weak_this_),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnPipelineResumed, weak_this_),</span><br><span class="line">      base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnError, weak_this_));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (initial_cdm)</span><br><span class="line">    <span class="built_in">SetCdmInternal</span>(initial_cdm);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> on_audio_source_provider_set_client_callback = base::<span class="built_in">BindOnce</span>(</span><br><span class="line">      [](base::WeakPtr&lt;WebMediaPlayerImpl&gt; self,</span><br><span class="line">         WebMediaPlayerClient* <span class="type">const</span> client) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!self)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        client-&gt;<span class="built_in">DidDisableAudioOutputSinkChanges</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">      weak_this_, client_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(xhwang): When we use an external Renderer, many methods won&#x27;t work,</span></span><br><span class="line">  <span class="comment">// e.g. GetCurrentFrameFromCompositor(). See http://crbug.com/434861</span></span><br><span class="line">  audio_source_provider_ = <span class="keyword">new</span> <span class="built_in">WebAudioSourceProviderImpl</span>(</span><br><span class="line">      std::<span class="built_in">move</span>(audio_renderer_sink), media_log_.<span class="built_in">get</span>(),</span><br><span class="line">      std::<span class="built_in">move</span>(on_audio_source_provider_set_client_callback));</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的具体细节可以暂时不管，他创建并初始化了 WebMediaPlayerImpl 内部的一些成员，比如 Pipeline、PipelineController，这些对象的作用放在后面文章中介绍</p><h3 id="创建-ChunkDemuxer"><a href="#创建-ChunkDemuxer" class="headerlink" title="创建 ChunkDemuxer"></a>创建 ChunkDemuxer</h3><p>创建 ChunkDemuxer 也在 HTMLMediaElement::StartPlayerLoad()中，StartPlayerLoad 创建完 WebMediaPlayer 之后就会执行 WebMediaPlayer 的 Load 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HTMLMediaElement::StartPlayerLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(!web_media_player_);</span><br><span class="line"></span><br><span class="line">  WebMediaPlayerSource source;</span><br><span class="line">  <span class="keyword">if</span> (src_object_) &#123;</span><br><span class="line">    source = <span class="built_in">WebMediaPlayerSource</span>(<span class="built_in">WebMediaStream</span>(src_object_));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LocalFrame* frame = <span class="built_in">LocalFrameForPlayer</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  web_media_player_ =</span><br><span class="line">      frame-&gt;<span class="built_in">Client</span>()-&gt;<span class="built_in">CreateWebMediaPlayer</span>(*<span class="keyword">this</span>, source, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="comment">// Make sure if we create/re-create the WebMediaPlayer that we update our</span></span><br><span class="line">  <span class="comment">// wrapper.</span></span><br><span class="line">  audio_source_provider_.<span class="built_in">Wrap</span>(web_media_player_-&gt;<span class="built_in">GetAudioSourceProvider</span>());</span><br><span class="line">  web_media_player_-&gt;<span class="built_in">SetVolume</span>(<span class="built_in">EffectiveMediaVolume</span>());</span><br><span class="line"></span><br><span class="line">  web_media_player_-&gt;<span class="built_in">SetPoster</span>(<span class="built_in">PosterImageURL</span>());</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> preload = <span class="built_in">EffectivePreloadType</span>();</span><br><span class="line">  web_media_player_-&gt;<span class="built_in">SetPreload</span>(preload);</span><br><span class="line"></span><br><span class="line">  web_media_player_-&gt;<span class="built_in">RequestRemotePlaybackDisabled</span>(</span><br><span class="line">      <span class="built_in">FastHasAttribute</span>(html_names::kDisableremoteplaybackAttr));</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> is_cache_disabled = <span class="literal">false</span>;</span><br><span class="line">  probe::<span class="built_in">IsCacheDisabled</span>(<span class="built_in">GetDocument</span>().<span class="built_in">GetExecutionContext</span>(),</span><br><span class="line">                         &amp;is_cache_disabled);</span><br><span class="line">  <span class="keyword">auto</span> load_timing = web_media_player_-&gt;<span class="built_in">Load</span>(<span class="built_in">GetLoadType</span>(), source, <span class="built_in">CorsMode</span>(),</span><br><span class="line">                                             is_cache_disabled);</span><br><span class="line">  <span class="keyword">if</span> (load_timing == WebMediaPlayer::LoadTiming::kDeferred) &#123;</span><br><span class="line">    <span class="comment">// Deferred media loading is not part of the spec, but intuition is that</span></span><br><span class="line">    <span class="comment">// this should not hold up the Window&#x27;s &quot;load&quot; event (similar to user</span></span><br><span class="line">    <span class="comment">// gesture requirements).</span></span><br><span class="line">    <span class="built_in">SetShouldDelayLoadEvent</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Load 函数中进行 DoLoad</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WebMediaPlayer::LoadTiming <span class="title">WebMediaPlayerImpl::Load</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LoadType load_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> WebMediaPlayerSource&amp; source,</span></span></span><br><span class="line"><span class="params"><span class="function">    CorsMode cors_mode,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> is_cache_disabled)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Only URL or MSE blob URL is supported.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(source.<span class="built_in">IsURL</span>());</span><br><span class="line">  WebURL url = source.<span class="built_in">GetAsURL</span>();</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; load_type &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; <span class="built_in">GURL</span>(url) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">           &lt;&lt; cors_mode &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> is_deferred = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (defer_load_cb_) &#123;</span><br><span class="line">    is_deferred = defer_load_cb_.<span class="built_in">Run</span>(</span><br><span class="line">        base::<span class="built_in">BindOnce</span>(&amp;WebMediaPlayerImpl::DoLoad, weak_this_, load_type, url,</span><br><span class="line">                       cors_mode, is_cache_disabled));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DoLoad</span>(load_type, url, cors_mode, is_cache_disabled);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> is_deferred ? LoadTiming::kDeferred : LoadTiming::kImmediate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 DoLoad 里面调用 StartPipeline</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebMediaPlayerImpl::DoLoad</span><span class="params">(LoadType load_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> WebURL&amp; url,</span></span></span><br><span class="line"><span class="params"><span class="function">                                CorsMode cors_mode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">bool</span> is_cache_disabled)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">TRACE_EVENT1</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;WebMediaPlayerImpl::DoLoad&quot;</span>, <span class="string">&quot;id&quot;</span>, media_log_-&gt;<span class="built_in">id</span>());</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; __func__;</span><br><span class="line">  <span class="built_in">DCHECK</span>(main_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: `url` may be very large, take care when making copies.</span></span><br><span class="line">  loaded_url_ = <span class="built_in">GURL</span>(url);</span><br><span class="line">  load_type_ = load_type;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReportMetrics</span>(load_type, loaded_url_, *frame_, media_log_.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  load_start_time_ = base::TimeTicks::<span class="built_in">Now</span>();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (demuxer_override_ || load_type == kLoadTypeMediaSource) &#123;</span><br><span class="line">    <span class="comment">// If a demuxer override was specified or a Media Source pipeline will be</span></span><br><span class="line">    <span class="comment">// used, the pipeline can start immediately.</span></span><br><span class="line">    <span class="built_in">StartPipeline</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebMediaPlayerImpl-StartPipeline"><a href="#WebMediaPlayerImpl-StartPipeline" class="headerlink" title="WebMediaPlayerImpl::StartPipeline"></a>WebMediaPlayerImpl::StartPipeline</h4><p>下面的 EncryptedMediaInitDataCB 是给 ChunkDemuxer 的 CallBack，当 ChunkDemuxer 遇到一个加密流时会执行此回调去执行初始化行为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebMediaPlayerImpl::StartPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(main_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">  Demuxer::EncryptedMediaInitDataCB encrypted_media_init_data_cb =</span><br><span class="line">      media::<span class="built_in">BindToCurrentLoop</span>(base::<span class="built_in">BindRepeating</span>(</span><br><span class="line">          &amp;WebMediaPlayerImpl::OnEncryptedMediaInitData, weak_this_));</span><br><span class="line"></span><br><span class="line">  vfc_task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">      FROM_HERE,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;VideoFrameCompositor::SetOnNewProcessedFrameCallback,</span><br><span class="line">                     base::<span class="built_in">Unretained</span>(compositor_.<span class="built_in">get</span>()),</span><br><span class="line">                     media::<span class="built_in">BindToCurrentLoop</span>(base::<span class="built_in">BindOnce</span>(</span><br><span class="line">                         &amp;WebMediaPlayerImpl::OnFirstFrame, weak_this_))));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_ANDROID)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(IS_ANDROID)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Figure out which demuxer to use.</span></span><br><span class="line">  <span class="keyword">if</span> (demuxer_override_) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!chunk_demuxer_);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetDemuxer</span>(std::<span class="built_in">move</span>(demuxer_override_));</span><br><span class="line">    <span class="comment">// TODO(https://crbug.com/1076267): Should everything else after this block</span></span><br><span class="line">    <span class="comment">// run in the demuxer override case?</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (load_type_ != kLoadTypeMediaSource) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!chunk_demuxer_);</span><br><span class="line">    <span class="built_in">DCHECK</span>(data_source_);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(ENABLE_FFMPEG)</span></span><br><span class="line">    Demuxer::MediaTracksUpdatedCB media_tracks_updated_cb =</span><br><span class="line">        media::<span class="built_in">BindToCurrentLoop</span>(base::<span class="built_in">BindRepeating</span>(</span><br><span class="line">            &amp;WebMediaPlayerImpl::OnFFmpegMediaTracksUpdated, weak_this_));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SetDemuxer</span>(std::<span class="built_in">make_unique</span>&lt;media::FFmpegDemuxer&gt;(</span><br><span class="line">        media_task_runner_, data_source_.<span class="built_in">get</span>(), encrypted_media_init_data_cb,</span><br><span class="line">        media_tracks_updated_cb, media_log_.<span class="built_in">get</span>(), <span class="built_in">IsLocalFile</span>(loaded_url_)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">OnError</span>(media::DEMUXER_ERROR_COULD_NOT_OPEN);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!chunk_demuxer_);</span><br><span class="line">    <span class="built_in">DCHECK</span>(!data_source_);</span><br><span class="line"></span><br><span class="line">    chunk_demuxer_ = <span class="keyword">new</span> media::<span class="built_in">ChunkDemuxer</span>(</span><br><span class="line">        media::<span class="built_in">BindToCurrentLoop</span>(</span><br><span class="line">            base::<span class="built_in">BindOnce</span>(&amp;WebMediaPlayerImpl::OnDemuxerOpened, weak_this_)),</span><br><span class="line">        media::<span class="built_in">BindToCurrentLoop</span>(</span><br><span class="line">            base::<span class="built_in">BindRepeating</span>(&amp;WebMediaPlayerImpl::OnProgress, weak_this_)),</span><br><span class="line">        encrypted_media_init_data_cb, media_log_.<span class="built_in">get</span>());</span><br><span class="line">    <span class="built_in">SetDemuxer</span>(std::<span class="built_in">unique_ptr</span>&lt;Demuxer&gt;(chunk_demuxer_));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base::FeatureList::<span class="built_in">IsEnabled</span>(</span><br><span class="line">            media::kMemoryPressureBasedSourceBufferGC)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If possible attempt to avoid decoder spool up until playback starts.</span></span><br><span class="line">  <span class="keyword">auto</span> start_type = media::Pipeline::StartType::kNormal;</span><br><span class="line">  <span class="keyword">if</span> (!chunk_demuxer_ &amp;&amp; preload_ == MultiBufferDataSource::METADATA &amp;&amp;</span><br><span class="line">      !client_-&gt;<span class="built_in">CouldPlayIfEnoughData</span>() &amp;&amp; !<span class="built_in">IsStreaming</span>()) &#123;</span><br><span class="line">    start_type =</span><br><span class="line">        (has_poster_ ||</span><br><span class="line">         base::FeatureList::<span class="built_in">IsEnabled</span>(media::kPreloadMetadataLazyLoad))</span><br><span class="line">            ? media::Pipeline::StartType::kSuspendAfterMetadata</span><br><span class="line">            : media::Pipeline::StartType::kSuspendAfterMetadataForAudioOnly;</span><br><span class="line">    attempting_suspended_start_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(sandersd): FileSystem objects may also be non-static, but due to our</span></span><br><span class="line">  <span class="comment">// caching layer such situations are broken already. http://crbug.com/593159</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> is_static = !chunk_demuxer_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... and we&#x27;re ready to go!</span></span><br><span class="line">  <span class="comment">// TODO(sandersd): On Android, defer Start() if the tab is not visible.</span></span><br><span class="line">  seeking_ = <span class="literal">true</span>;</span><br><span class="line">  pipeline_controller_-&gt;<span class="built_in">Start</span>(start_type, demuxer_.<span class="built_in">get</span>(), <span class="keyword">this</span>, <span class="built_in">IsStreaming</span>(),</span><br><span class="line">                              is_static);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，如果不是 MSE，将使用 FFmpegDemuxer，如果是 MSE，使用 ChunkDemuxer。</p><p>上面在创建 ChunkDemuxer 时给 ChunkDemuxer 设置了 WebMediaPlayerImpl::OnDemuxerOpened 作为回调，OnDemuxerOpened 内部调用 MediaSourceOpened，而 MediaSourceOpened 内部调用 CompleteAttachingToMediaElement，这和上面 CompleteAttachingToMediaElement 的调用过程一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebMediaPlayerImpl::OnDemuxerOpened</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(main_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line">  client_-&gt;<span class="built_in">MediaSourceOpened</span>(<span class="keyword">new</span> <span class="built_in">WebMediaSourceImpl</span>(chunk_demuxer_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>encrypted_media_init_data_cb 回调的作用上面已经说过，当 ChunkDemuxer 遇到一个加密流时会通过这个回调向 CDM 模块获得用于解密的密钥</p><h5 id="PipelineController-Start"><a href="#PipelineController-Start" class="headerlink" title="PipelineController::Start"></a>PipelineController::Start</h5><p>接下来再分析 ChunkDemuxer 何时调用 WebMediaPlayerImpl::OnDemuxerOpened。实际上 ChunkDemuxer 会在初始化之后调用这个回调</p><p>在 WebMediaPlayerImpl::StartPipeline 的最后会调用 PipelineController::Start</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PipelineController::Start</span><span class="params">(Pipeline::StartType start_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Demuxer* demuxer,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Pipeline::Client* client,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">bool</span> is_streaming,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">bool</span> is_static)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(thread_checker_.<span class="built_in">CalledOnValidThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(state_, State::STOPPED);</span><br><span class="line">  <span class="built_in">DCHECK</span>(demuxer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Once the pipeline is started, we want to call the seeked callback but</span></span><br><span class="line">  <span class="comment">// without a time update.</span></span><br><span class="line">  pending_startup_ = <span class="literal">true</span>;</span><br><span class="line">  pending_seeked_cb_ = <span class="literal">true</span>;</span><br><span class="line">  state_ = State::STARTING;</span><br><span class="line"></span><br><span class="line">  demuxer_ = demuxer;</span><br><span class="line">  is_streaming_ = is_streaming;</span><br><span class="line">  is_static_ = is_static;</span><br><span class="line">  pipeline_-&gt;<span class="built_in">Start</span>(start_type, demuxer, client,</span><br><span class="line">                   base::<span class="built_in">BindOnce</span>(&amp;PipelineController::OnPipelineStatus,</span><br><span class="line">                                  weak_factory_.<span class="built_in">GetWeakPtr</span>(),</span><br><span class="line">                                  start_type == Pipeline::StartType::kNormal</span><br><span class="line">                                      ? State::PLAYING</span><br><span class="line">                                      : State::PLAYING_OR_SUSPENDED));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PipelineController::Start 又调用 PipelineImpl::Start</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PipelineImpl::Start</span><span class="params">(StartType start_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Demuxer* demuxer,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Client* client,</span></span></span><br><span class="line"><span class="params"><span class="function">                         PipelineStatusCallback seek_cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">2</span>) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: start_type=&quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(start_type);</span><br><span class="line">  <span class="built_in">DCHECK</span>(thread_checker_.<span class="built_in">CalledOnValidThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(demuxer);</span><br><span class="line">  <span class="built_in">DCHECK</span>(client);</span><br><span class="line">  <span class="built_in">DCHECK</span>(seek_cb);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(!client_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!seek_cb_);</span><br><span class="line">  client_ = client;</span><br><span class="line">  seek_cb_ = std::<span class="built_in">move</span>(seek_cb);</span><br><span class="line">  last_media_time_ = base::<span class="built_in">TimeDelta</span>();</span><br><span class="line">  seek_time_ = kNoTimestamp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// By default, create a default renderer to avoid additional start-to-play</span></span><br><span class="line">  <span class="comment">// latency caused by asynchronous Renderer creation. When |start_type| is</span></span><br><span class="line">  <span class="comment">// kSuspendAfterMetadata, latency is not important and the video may never</span></span><br><span class="line">  <span class="comment">// play. In this case, not creating a default renderer to reduce memory usage.</span></span><br><span class="line">  std::unique_ptr&lt;Renderer&gt; default_renderer;</span><br><span class="line">  <span class="keyword">if</span> (start_type != StartType::kSuspendAfterMetadata)</span><br><span class="line">    default_renderer = create_renderer_cb_.<span class="built_in">Run</span>(absl::<span class="literal">nullopt</span>);</span><br><span class="line"></span><br><span class="line">  media_task_runner_-&gt;<span class="built_in">PostTask</span>(</span><br><span class="line">      FROM_HERE,</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::Start,</span><br><span class="line">                     base::<span class="built_in">Unretained</span>(renderer_wrapper_.<span class="built_in">get</span>()), start_type,</span><br><span class="line">                     demuxer, std::<span class="built_in">move</span>(default_renderer),</span><br><span class="line">                     weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PipelineImpl::Start 先通过 <code>create_renderer_cb_</code> 创建 Renderer，然后在 <code>media_task_runner_</code> 中调用 RendererWrapper::Start</p><p>在 RendererWrapper::Start 中会执行一系列的任务 RendererWrapper::InitializeDemuxer、RendererWrapper::ReportMetadata、RendererWrapper::CreateRenderer、RendererWrapper::InitializeRenderer、RendererWrapper::CompleteSeek，这些任务是一个接一个的异步执行的，后面可以写一篇文章介绍一下 SerialRunner 的相关内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> PipelineImpl::RendererWrapper::<span class="built_in">Start</span>(</span><br><span class="line">    StartType start_type,</span><br><span class="line">    Demuxer* demuxer,</span><br><span class="line">    std::unique_ptr&lt;Renderer&gt; default_renderer,</span><br><span class="line">    base::WeakPtr&lt;PipelineImpl&gt; weak_pipeline) &#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(media_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(state_ == kCreated || state_ == kStopped)</span><br><span class="line">      &lt;&lt; <span class="string">&quot;Received start in unexpected state: &quot;</span> &lt;&lt; state_;</span><br><span class="line">  <span class="built_in">DCHECK</span>(!demuxer_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!renderer_ended_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!text_renderer_ended_);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetState</span>(kStarting);</span><br><span class="line">  demuxer_ = demuxer;</span><br><span class="line">  default_renderer_ = std::<span class="built_in">move</span>(default_renderer);</span><br><span class="line">  weak_pipeline_ = weak_pipeline;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setup |error_cb_| on the media thread.</span></span><br><span class="line">  error_cb_ = base::<span class="built_in">BindRepeating</span>(&amp;RendererWrapper::OnPipelineError,</span><br><span class="line">                                  weak_factory_.<span class="built_in">GetWeakPtr</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Queue asynchronous actions required to start.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(!pending_callbacks_);</span><br><span class="line">  SerialRunner::Queue fns;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize demuxer.</span></span><br><span class="line">  fns.<span class="built_in">Push</span>(base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::InitializeDemuxer,</span><br><span class="line">                          weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Once the demuxer is initialized successfully, media metadata must be</span></span><br><span class="line">  <span class="comment">// available - report the metadata to client. If starting without a renderer</span></span><br><span class="line">  <span class="comment">// we&#x27;ll complete initialization at this point.</span></span><br><span class="line">  fns.<span class="built_in">Push</span>(base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::ReportMetadata,</span><br><span class="line">                          weak_factory_.<span class="built_in">GetWeakPtr</span>(), start_type));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create renderer.</span></span><br><span class="line">  fns.<span class="built_in">Push</span>(base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::CreateRenderer,</span><br><span class="line">                          weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize renderer.</span></span><br><span class="line">  fns.<span class="built_in">Push</span>(base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::InitializeRenderer,</span><br><span class="line">                          weak_factory_.<span class="built_in">GetWeakPtr</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run tasks.</span></span><br><span class="line">  pending_callbacks_ = SerialRunner::<span class="built_in">Run</span>(</span><br><span class="line">      std::<span class="built_in">move</span>(fns),</span><br><span class="line">      base::<span class="built_in">BindOnce</span>(&amp;RendererWrapper::CompleteSeek, weak_factory_.<span class="built_in">GetWeakPtr</span>(),</span><br><span class="line">                     base::<span class="built_in">TimeDelta</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="RendererWrapper-InitializeDemuxer"><a href="#RendererWrapper-InitializeDemuxer" class="headerlink" title="RendererWrapper::InitializeDemuxer"></a>RendererWrapper::InitializeDemuxer</h6><p>RendererWrapper::InitializeDemuxer 中会执行 ChunkDemuxer::Initialize</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> PipelineImpl::RendererWrapper::<span class="built_in">InitializeDemuxer</span>(</span><br><span class="line">    PipelineStatusCallback done_cb) &#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(media_task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">  demuxer_-&gt;<span class="built_in">Initialize</span>(<span class="keyword">this</span>, std::<span class="built_in">move</span>(done_cb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChunkDemuxer::Initialize 的最后会 <code>std::move(open_cb).Run();</code>，open_cb 就是 WebMediaPlayerImpl::OnDemuxerOpened</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChunkDemuxer::Initialize</span><span class="params">(DemuxerHost* host,</span></span></span><br><span class="line"><span class="params"><span class="function">                              PipelineStatusCallback init_cb)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DVLOG</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;Initialize()&quot;</span>;</span><br><span class="line">  <span class="built_in">TRACE_EVENT_ASYNC_BEGIN0</span>(<span class="string">&quot;media&quot;</span>, <span class="string">&quot;ChunkDemuxer::Initialize&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  base::OnceClosure open_cb;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Locked scope</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">base::AutoLock <span class="title">auto_lock</span><span class="params">(lock_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (state_ == SHUTDOWN) &#123;</span><br><span class="line">      <span class="comment">// Init cb must only be run after this method returns, so post.</span></span><br><span class="line">      init_cb_ = <span class="built_in">BindToCurrentLoop</span>(std::<span class="built_in">move</span>(init_cb));</span><br><span class="line">      <span class="built_in">RunInitCB_Locked</span>(DEMUXER_ERROR_COULD_NOT_OPEN);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DCHECK_EQ</span>(state_, WAITING_FOR_INIT);</span><br><span class="line">    host_ = host;</span><br><span class="line">    <span class="comment">// Do not post init_cb once this function returns because if there is an</span></span><br><span class="line">    <span class="comment">// error after initialization, the error might be reported before init_cb</span></span><br><span class="line">    <span class="comment">// has a chance to run. This is because ChunkDemuxer::ReportError_Locked</span></span><br><span class="line">    <span class="comment">// directly calls DemuxerHost::OnDemuxerError: crbug.com/633016.</span></span><br><span class="line">    init_cb_ = std::<span class="built_in">move</span>(init_cb);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ChangeState_Locked</span>(INITIALIZING);</span><br><span class="line">    open_cb = std::<span class="built_in">move</span>(open_cb_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">move</span>(open_cb).<span class="built_in">Run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们就知道 source open 事件在何时触发了。</p><p>还有一点要注意，ChunkDemuxer::Initialize 的参数 init_cb 是 RendererWrapper::ReportMetadata，而该函数没有在 ChunkDemuxer::Initialize 之后立刻执行，而是先执行 <code>open_cb_</code>，也就是 WebMediaPlayerImpl::OnDemuxerOpened，在该函数执行后，上层会调用 addSourceBuffer，在 addSourceBuffer 调用中会调用 ChunkDemuxer::AddId，接着调用 ChunkDemuxer::AddIdInternal，在 ChunkDemuxer::AddIdInternal 内部把 ChunkDemuxer::OnSourceInitDone 作为 SourceBufferState 的回调，ChunkDemuxer::OnSourceInitDone 里面才去执行 <code>init_cb_</code> 来继续完成 Pipeline 的初始化。</p><p>这篇文章就介绍到这里，下一篇文章分析一下 ChunkDemuxer 相关的内容，Pipeline 初始化过程先不继续往下，到后面再分析。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium 多媒体 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium base 库之 thread（四）</title>
      <link href="/2023/06/15/Chromium-base-%E5%BA%93%E4%B9%8B-thread%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/06/15/Chromium-base-%E5%BA%93%E4%B9%8B-thread%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>之前的文章都是以 SingleThreadTaskExecutor 为研究对象，这篇文章则介绍 Thread 类。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>还是以一个例子为研究对象。下面的例子创建了一个 thread，然后把这个 thread 的 task_runner 设给了 mojo，让这个线程作为 mojo 的 io 线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">base::Thread <span class="title">ipc_thread</span><span class="params">(<span class="string">&quot;ipc!&quot;</span>)</span></span>;</span><br><span class="line">ipc_thread.<span class="built_in">StartWithOptions</span>(</span><br><span class="line">  base::Thread::<span class="built_in">Options</span>(base::MessagePumpType::IO, <span class="number">0</span>));</span><br><span class="line">mojo::<span class="function">core::ScopedIPCSupport <span class="title">ipc_support</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  ipc_thread.task_runner(),</span></span></span><br><span class="line"><span class="params"><span class="function">  mojo::core::ScopedIPCSupport::ShutdownPolicy::CLEAN)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>Thread 类如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">  <span class="comment">// The thread&#x27;s handle.</span></span><br><span class="line">  PlatformThreadHandle thread_; <span class="comment">// pthread_t</span></span><br><span class="line">  <span class="keyword">mutable</span> base::Lock thread_lock_;  <span class="comment">// Protects |thread_|.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The thread&#x27;s id once it has started.</span></span><br><span class="line">  PlatformThreadId id_ = kInvalidThreadId;</span><br><span class="line">  <span class="comment">// Protects |id_| which must only be read while it&#x27;s signaled.</span></span><br><span class="line">  <span class="keyword">mutable</span> WaitableEvent id_event_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stores Options::timer_slack_ until the sequence manager has been bound to</span></span><br><span class="line">  <span class="comment">// a thread.</span></span><br><span class="line">  TimerSlack timer_slack_ = TIMER_SLACK_NONE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The name of the thread.  Used for debugging purposes.</span></span><br><span class="line">  <span class="type">const</span> std::string name_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The thread&#x27;s Delegate and RunLoop are valid only while the thread is</span></span><br><span class="line">  <span class="comment">// alive. Set by the created thread.</span></span><br><span class="line">  std::unique_ptr&lt;Delegate&gt; delegate_;</span><br><span class="line">  RunLoop* run_loop_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Signaled when the created thread gets ready to use the message loop.</span></span><br><span class="line">  <span class="keyword">mutable</span> WaitableEvent start_event_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>thread_</code> 就是 <code>pthread_t</code></p><p><code>id_</code> 是线程 id</p><p><code>id_event_</code> 和 <code>start_event_</code> 是条件变量，用于当前线程等待 thread 线程，比如当前线程想访问 <code>id_</code> 时需要等 <code>id_event_</code> 被通知</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数比较简单，就是创建了内部的成员数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base/threading/thread.cc</span></span><br><span class="line">Thread::<span class="built_in">Thread</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">    : <span class="built_in">id_event_</span>(WaitableEvent::ResetPolicy::MANUAL,</span><br><span class="line">                WaitableEvent::InitialState::NOT_SIGNALED),</span><br><span class="line">      <span class="built_in">name_</span>(name),</span><br><span class="line">      <span class="built_in">start_event_</span>(WaitableEvent::ResetPolicy::MANUAL,</span><br><span class="line">                   WaitableEvent::InitialState::NOT_SIGNALED) &#123;</span><br><span class="line">  <span class="comment">// Only bind the sequence on Start(): the state is constant between</span></span><br><span class="line">  <span class="comment">// construction and Start() and it&#x27;s thus valid for Start() to be called on</span></span><br><span class="line">  <span class="comment">// another sequence as long as every other operation is then performed on that</span></span><br><span class="line">  <span class="comment">// sequence.</span></span><br><span class="line">  owning_sequence_checker_.<span class="built_in">DetachFromSequence</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动-Thread"><a href="#启动-Thread" class="headerlink" title="启动 Thread"></a>启动 Thread</h3><p>在 Thread 内部，有一个 <code>delegate_</code>，它的作用和前面的 SingleThreadTaskExecutor 类似，这里的 <code>delegate_</code> 是 SequenceManagerThreadDelegate 类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Thread::StartWithOptions</span><span class="params">(Options options)</span> </span>&#123;</span><br><span class="line">  id_event_.<span class="built_in">Reset</span>();</span><br><span class="line">  id_ = kInvalidThreadId;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SetThreadWasQuitProperly</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  timer_slack_ = options.timer_slack;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.delegate) &#123;</span><br><span class="line">    delegate_ = std::<span class="built_in">move</span>(options.delegate);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.message_pump_factory) &#123;</span><br><span class="line">    delegate_ = std::<span class="built_in">make_unique</span>&lt;SequenceManagerThreadDelegate&gt;(</span><br><span class="line">        MessagePumpType::CUSTOM, options.message_pump_factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    delegate_ = std::<span class="built_in">make_unique</span>&lt;SequenceManagerThreadDelegate&gt;(</span><br><span class="line">        options.message_pump_type,</span><br><span class="line">        <span class="built_in">BindOnce</span>([](MessagePumpType type) &#123; <span class="keyword">return</span> MessagePump::<span class="built_in">Create</span>(type); &#125;,</span><br><span class="line">                 options.message_pump_type));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start_event_.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">AutoLock <span class="title">lock</span><span class="params">(thread_lock_)</span></span>;</span><br><span class="line">    <span class="type">bool</span> success =</span><br><span class="line">        options.joinable</span><br><span class="line">            ? PlatformThread::<span class="built_in">CreateWithPriority</span>(options.stack_size, <span class="keyword">this</span>,</span><br><span class="line">                                                 &amp;thread_, options.priority)</span><br><span class="line">            : PlatformThread::<span class="built_in">CreateNonJoinableWithPriority</span>(</span><br><span class="line">                  options.stack_size, <span class="keyword">this</span>, options.priority);</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  joinable_ = options.joinable;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread::Options 类如下，比较简单，不做过多介绍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Thread</span>::Options &#123;</span><br><span class="line">...</span><br><span class="line">    MessagePumpType message_pump_type = MessagePumpType::DEFAULT;</span><br><span class="line">    std::unique_ptr&lt;Delegate&gt; delegate = <span class="literal">nullptr</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">Thread::Options::<span class="built_in">Options</span>(MessagePumpType type, <span class="type">size_t</span> size)</span><br><span class="line">    : <span class="built_in">message_pump_type</span>(type), <span class="built_in">stack_size</span>(size) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="PlatformThread-CreateWithPriority"><a href="#PlatformThread-CreateWithPriority" class="headerlink" title="PlatformThread::CreateWithPriority"></a>PlatformThread::CreateWithPriority</h4><p>这一步创建平台相关的线程，比如在 linux 下创建 pthread 线程，在 windows 下创建 windows 线程，这里只看 pthread 线程的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base/threading/platform_thread.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_WIN)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BUILDFLAG(IS_FUCHSIA)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BUILDFLAG(IS_APPLE)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BUILDFLAG(IS_POSIX)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_WIN)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BUILDFLAG(IS_FUCHSIA)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BUILDFLAG(IS_APPLE)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BUILDFLAG(IS_POSIX)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">pid_t</span> PlatformThreadId;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlatformThreadHandle</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_WIN)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> BUILDFLAG(IS_POSIX) || BUILDFLAG(IS_FUCHSIA)</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">pthread_t</span> Handle;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Handle handle_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> PlatformThreadId <span class="title">kInvalidThreadId</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>PlatformThread::CreateWithPriority 调用 CreateThread 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base/threading/platform_thread_posix.cc</span></span><br><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlatformThread::CreateWithPriority</span><span class="params">(<span class="type">size_t</span> stack_size, Delegate* delegate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        PlatformThreadHandle* thread_handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        ThreadPriority priority)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CreateThread</span>(stack_size, <span class="literal">true</span> <span class="comment">/* joinable thread */</span>, delegate,</span><br><span class="line">                      thread_handle, priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CreateThread 函数内部就是调用了 pthread 的 api 来创建线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base/threading/platform_thread_posix.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CreateThread</span><span class="params">(<span class="type">size_t</span> stack_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">bool</span> joinable,</span></span></span><br><span class="line"><span class="params"><span class="function">                  PlatformThread::Delegate* delegate,</span></span></span><br><span class="line"><span class="params"><span class="function">                  PlatformThreadHandle* thread_handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                  ThreadPriority priority)</span> </span>&#123;</span><br><span class="line">  base::<span class="built_in">InitThreading</span>();</span><br><span class="line">  <span class="type">pthread_attr_t</span> attributes;</span><br><span class="line">  <span class="built_in">pthread_attr_init</span>(&amp;attributes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pthreads are joinable by default, so only specify the detached</span></span><br><span class="line">  <span class="comment">// attribute if the thread should be non-joinable.</span></span><br><span class="line">  <span class="keyword">if</span> (!joinable)</span><br><span class="line">    <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attributes, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get a better default if available.</span></span><br><span class="line">  <span class="keyword">if</span> (stack_size == <span class="number">0</span>)</span><br><span class="line">    stack_size = base::<span class="built_in">GetDefaultThreadStackSize</span>(attributes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stack_size &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">pthread_attr_setstacksize</span>(&amp;attributes, stack_size);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_ptr&lt;ThreadParams&gt; <span class="title">params</span><span class="params">(<span class="keyword">new</span> ThreadParams)</span></span>;</span><br><span class="line">  params-&gt;delegate = delegate;</span><br><span class="line">  params-&gt;joinable = joinable;</span><br><span class="line">  params-&gt;priority = priority;</span><br><span class="line"></span><br><span class="line">  <span class="type">pthread_t</span> handle;</span><br><span class="line">  <span class="type">int</span> err = <span class="built_in">pthread_create</span>(&amp;handle, &amp;attributes, ThreadFunc, params.<span class="built_in">get</span>());</span><br><span class="line">  <span class="type">bool</span> success = !err;</span><br><span class="line">  <span class="keyword">if</span> (success) &#123;</span><br><span class="line">    <span class="comment">// ThreadParams should be deleted on the created thread after used.</span></span><br><span class="line">    std::ignore = params.<span class="built_in">release</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">  *thread_handle = <span class="built_in">PlatformThreadHandle</span>(handle);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_attr_destroy</span>(&amp;attributes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pthread_create 里的主函数是 ThreadFunc。此外注意 params.release()不是释放指针指向的内存，而是释放指针的所有权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base/threading/platform_thread_posix.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadFunc</span><span class="params">(<span class="type">void</span>* params)</span> </span>&#123;</span><br><span class="line">  PlatformThread::Delegate* delegate = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 重新用unique_ptr包装输入的指针</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;ThreadParams&gt; <span class="title">thread_params</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">static_cast</span>&lt;ThreadParams*&gt;(params))</span></span>;</span><br><span class="line"></span><br><span class="line">    delegate = thread_params-&gt;delegate;</span><br><span class="line">    <span class="keyword">if</span> (!thread_params-&gt;joinable)</span><br><span class="line">      base::<span class="built_in">DisallowSingleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !BUILDFLAG(IS_NACL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(USE_PARTITION_ALLOC_AS_MALLOC)</span></span><br><span class="line">    internal::PCScan::<span class="built_in">NotifyThreadCreated</span>(internal::<span class="built_in">GetStackPointer</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_APPLE)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Threads on linux/android may inherit their priority from the thread</span></span><br><span class="line">    <span class="comment">// where they were created. This explicitly sets the priority of all new</span></span><br><span class="line">    <span class="comment">// threads.</span></span><br><span class="line">    PlatformThread::<span class="built_in">SetCurrentThreadPriority</span>(thread_params-&gt;priority);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ThreadIdNameManager::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">RegisterThread</span>(</span><br><span class="line">      PlatformThread::<span class="built_in">CurrentHandle</span>().<span class="built_in">platform_handle</span>(),</span><br><span class="line">      PlatformThread::<span class="built_in">CurrentId</span>());</span><br><span class="line"></span><br><span class="line">  delegate-&gt;<span class="built_in">ThreadMain</span>();</span><br><span class="line"></span><br><span class="line">  ThreadIdNameManager::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">RemoveName</span>(</span><br><span class="line">      PlatformThread::<span class="built_in">CurrentHandle</span>().<span class="built_in">platform_handle</span>(),</span><br><span class="line">      PlatformThread::<span class="built_in">CurrentId</span>());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !BUILDFLAG(IS_NACL) &amp;&amp; BUILDFLAG(USE_PARTITION_ALLOC_AS_MALLOC)</span></span><br><span class="line">  internal::PCScan::<span class="built_in">NotifyThreadDestroyed</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  base::<span class="built_in">TerminateOnThread</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 delegate 指针就是指向 Thread 的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlatformThread</span>::Delegate &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ThreadMain</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> : ...</span><br><span class="line">               PlatformThread::Delegate</span><br><span class="line">               ... &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Thread::ThreadMain 如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::ThreadMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// First, make GetThreadId() available to avoid deadlocks. It could be called</span></span><br><span class="line">  <span class="comment">// any place in the following thread initialization code.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(!id_event_.<span class="built_in">IsSignaled</span>());</span><br><span class="line">  id_ = PlatformThread::<span class="built_in">CurrentId</span>();</span><br><span class="line">  id_event_.<span class="built_in">Signal</span>(); <span class="comment">// 直到此时id_才是可用的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Complete the initialization of our Thread object.</span></span><br><span class="line">  PlatformThread::<span class="built_in">SetName</span>(name_.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This binds CurrentThread and ThreadTaskRunnerHandle.</span></span><br><span class="line">  delegate_-&gt;<span class="built_in">BindToCurrentThread</span>(timer_slack_);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="comment">// Let the thread do extra initialization.</span></span><br><span class="line">  <span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">AutoLock <span class="title">lock</span><span class="params">(running_lock_)</span></span>;</span><br><span class="line">    running_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start_event_.<span class="built_in">Signal</span>(); <span class="comment">// 直到此时，线程才开始</span></span><br><span class="line"></span><br><span class="line">  RunLoop run_loop;</span><br><span class="line">  run_loop_ = &amp;run_loop;</span><br><span class="line">  <span class="built_in">Run</span>(run_loop_);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">AutoLock <span class="title">lock</span><span class="params">(running_lock_)</span></span>;</span><br><span class="line">    running_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Let the thread do extra cleanup.</span></span><br><span class="line">  <span class="built_in">CleanUp</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We can&#x27;t receive messages anymore.</span></span><br><span class="line">  <span class="comment">// (The message loop is destructed at the end of this block)</span></span><br><span class="line">  delegate_.<span class="built_in">reset</span>();</span><br><span class="line">  run_loop_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>delegate_</code> 就是指向 SequenceManagerThreadDelegate 类的指针，接下来就看看这个类。</p><h5 id="SequenceManagerThreadDelegate"><a href="#SequenceManagerThreadDelegate" class="headerlink" title="SequenceManagerThreadDelegate"></a>SequenceManagerThreadDelegate</h5><p>上面流程在 Thread::StartWithOptions 中构造了 SequenceManagerThreadDelegate 类型的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Thread::StartWithOptions</span><span class="params">(Options options)</span> </span>&#123;</span><br><span class="line">  id_event_.<span class="built_in">Reset</span>();</span><br><span class="line">  id_ = kInvalidThreadId;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.delegate) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.message_pump_factory) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    delegate_ = std::<span class="built_in">make_unique</span>&lt;SequenceManagerThreadDelegate&gt;(</span><br><span class="line">        options.message_pump_type,</span><br><span class="line">        <span class="built_in">BindOnce</span>([](MessagePumpType type) &#123; <span class="keyword">return</span> MessagePump::<span class="built_in">Create</span>(type); &#125;,</span><br><span class="line">                 options.message_pump_type));</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h6><p>SequenceManagerThreadDelegate 类如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base/threading/thread.cc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SequenceManagerThreadDelegate</span> : <span class="keyword">public</span> Thread::Delegate &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SequenceManagerThreadDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      MessagePumpType message_pump_type,</span></span></span><br><span class="line"><span class="params"><span class="function">      OnceCallback&lt;std::unique_ptr&lt;MessagePump&gt;()&gt; message_pump_factory)</span></span></span><br><span class="line"><span class="function">      : sequence_manager_(</span></span><br><span class="line"><span class="function">            sequence_manager::internal::SequenceManagerImpl::CreateUnbound(</span></span><br><span class="line"><span class="function">                sequence_manager::SequenceManager::Settings::Builder()</span></span><br><span class="line"><span class="function">                    .SetMessagePumpType(message_pump_type)</span></span><br><span class="line"><span class="function">                    .Build())),</span></span><br><span class="line"><span class="function">        default_task_queue_(sequence_manager_-&gt;CreateTaskQueue(</span></span><br><span class="line"><span class="function">            sequence_manager::TaskQueue::Spec(<span class="string">&quot;default_tq&quot;</span>))),</span></span><br><span class="line"><span class="function">        message_pump_factory_(std::move(message_pump_factory)) &#123;</span></span><br><span class="line">    sequence_manager_-&gt;<span class="built_in">SetDefaultTaskRunner</span>(default_task_queue_-&gt;<span class="built_in">task_runner</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">BindToCurrentThread</span><span class="params">(TimerSlack timer_slack)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    sequence_manager_-&gt;<span class="built_in">BindToMessagePump</span>(</span><br><span class="line">        std::<span class="built_in">move</span>(message_pump_factory_).<span class="built_in">Run</span>());</span><br><span class="line">    sequence_manager_-&gt;<span class="built_in">SetTimerSlack</span>(timer_slack);</span><br><span class="line">    simple_task_executor_.<span class="built_in">emplace</span>(<span class="built_in">GetDefaultTaskRunner</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::unique_ptr&lt;sequence_manager::internal::SequenceManagerImpl&gt;</span><br><span class="line">      sequence_manager_;</span><br><span class="line">  scoped_refptr&lt;sequence_manager::TaskQueue&gt; default_task_queue_;</span><br><span class="line">  OnceCallback&lt;std::<span class="built_in">unique_ptr</span>&lt;MessagePump&gt;()&gt; message_pump_factory_;</span><br><span class="line">  absl::optional&lt;SimpleTaskExecutor&gt; simple_task_executor_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它里面也有一个 SequenceManager 类型的对象，这和 SingleThreadTaskExecutor 一样，而且构造函数里的动作也基本和 SingleThreadTaskExecutor 一致，SingleThreadTaskExecutor 的构造函数如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SingleThreadTaskExecutor::<span class="built_in">SingleThreadTaskExecutor</span>(</span><br><span class="line">    MessagePumpType type,</span><br><span class="line">    std::unique_ptr&lt;MessagePump&gt; pump)</span><br><span class="line">    : <span class="built_in">sequence_manager_</span>(sequence_manager::<span class="built_in">CreateUnboundSequenceManager</span>(</span><br><span class="line">          sequence_manager::SequenceManager::Settings::<span class="built_in">Builder</span>()</span><br><span class="line">              .<span class="built_in">SetMessagePumpType</span>(type)</span><br><span class="line">              .<span class="built_in">Build</span>())),</span><br><span class="line">      <span class="built_in">default_task_queue_</span>(sequence_manager_-&gt;<span class="built_in">CreateTaskQueue</span>(</span><br><span class="line">          sequence_manager::TaskQueue::<span class="built_in">Spec</span>(<span class="string">&quot;default_tq&quot;</span>))),</span><br><span class="line">      <span class="built_in">type_</span>(type),</span><br><span class="line">      <span class="built_in">simple_task_executor_</span>(<span class="built_in">task_runner</span>()) &#123;</span><br><span class="line">  sequence_manager_-&gt;<span class="built_in">SetDefaultTaskRunner</span>(default_task_queue_-&gt;<span class="built_in">task_runner</span>());</span><br><span class="line">  sequence_manager_-&gt;<span class="built_in">BindToMessagePump</span>(std::<span class="built_in">move</span>(pump));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SequenceManagerThreadDelegate 和 SingleThreadTaskExecutor 有一点不同：SequenceManagerThreadDelegate 把 <code>sequence_manager_-&gt;BindToMessagePump</code> 这个动作从构造函数中分离了出来。</p><p>这是因为 <code>BindToMessagePump</code> 需要在 Thread 的线程中执行，之前使用 SingleThreadTaskExecutor 的场景是直接在当前线程创建 SingleThreadTaskExecutor 的对象，将当前线程包装成一个 TaskExecutor，所以不需要考虑 <code>BindToMessagePump</code> 在哪个线程执行的问题，而 Thread 类创建了一个新的线程，此时 SequenceManagerThreadDelegate 的创建应该在当前线程，而 <code>BindToMessagePump</code> 要放在新线程中，从上面 Thread::ThreadMain 函数可知，<code>BindToMessagePump</code> 是在新线程中执行的。</p><p>SequenceManagerThreadDelegate 和 SingleThreadTaskExecutor 差不多，所以之前分析的内容对 SequenceManagerThreadDelegate 也有效，这里就不再赘述。</p><h6 id="BindToCurrentThread"><a href="#BindToCurrentThread" class="headerlink" title="BindToCurrentThread"></a>BindToCurrentThread</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::ThreadMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  delegate_-&gt;<span class="built_in">BindToCurrentThread</span>(timer_slack_);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>delegate_-&gt;BindToCurrentThread</code> 就是 SequenceManagerThreadDelegate::BindToCurrentThread，函数的具体实现上面介绍。</p><h5 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h5><p>Thread::ThreadMain 中也创建了一个 RunLoop，然后执行 Thread::Run</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::ThreadMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  RunLoop run_loop;</span><br><span class="line">  run_loop_ = &amp;run_loop;</span><br><span class="line">  <span class="built_in">Run</span>(run_loop_);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread::Run 如下，就是调用 RunLoop::Run()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::Run</span><span class="params">(RunLoop* run_loop)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Overridable protected method to be called from our |thread_| only.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(id_event_.<span class="built_in">IsSignaled</span>());</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(id_, PlatformThread::<span class="built_in">CurrentId</span>());</span><br><span class="line"></span><br><span class="line">  run_loop-&gt;<span class="built_in">Run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，Thread 内部实现和之前介绍的 SingleThreadTaskExecutor 基本一致，只是 Thread 内部创建了一个新线程，然后将该新线程用 SequenceManagerThreadDelegate 进行了包装。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium base库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium base 库之 thread（三）</title>
      <link href="/2023/06/11/Chromium-base-%E5%BA%93%E4%B9%8B-thread%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/06/11/Chromium-base-%E5%BA%93%E4%B9%8B-thread%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这篇文章接着前面分析 RunLoop 相关内容。</p><p>RunLoop 顾名思义就是一个 Loop，在这个 Loop 里面不停的从 sequence manager 中取 task，然后执行，如果当前没有任务需要执行，就进入 wait，或者有 delayed task，就进入 timed-wait，在 wait 中间也可以被外界唤醒。</p><h2 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h2><h3 id="创建-RunLoop"><a href="#创建-RunLoop" class="headerlink" title="创建 RunLoop"></a>创建 RunLoop</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RunLoop::<span class="built_in">RunLoop</span>(Type type)</span><br><span class="line">    : <span class="built_in">delegate_</span>(<span class="built_in">GetTlsDelegate</span>().<span class="built_in">Get</span>()),</span><br><span class="line">      <span class="built_in">type_</span>(type),</span><br><span class="line">      <span class="built_in">origin_task_runner_</span>(ThreadTaskRunnerHandle::<span class="built_in">Get</span>()) &#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(delegate_) &lt;&lt; <span class="string">&quot;A RunLoop::Delegate must be bound to this thread prior &quot;</span></span><br><span class="line">                       <span class="string">&quot;to using RunLoop.&quot;</span>;</span><br><span class="line">  <span class="built_in">DCHECK</span>(origin_task_runner_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>GetTlsDelegate().Get()</code> 把之前 RunLoop::RegisterDelegateForCurrentThread 存的 thread_controller 取了出来，还通过 ThreadTaskRunnerHandle::Get 获得之前 InitializeThreadTaskRunnerHandle 时存的 ThreadTaskRunnerHandle，在第二篇文章中分析过，ThreadTaskRunnerHandle 创建时会将自身指针保存在 thread local storage 中。</p><h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunLoop::Run</span><span class="params">(<span class="type">const</span> Location&amp; location)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_SEQUENCE</span>(sequence_checker_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">BeforeRun</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If there is a RunLoopTimeout active then set the timeout.</span></span><br><span class="line">  <span class="comment">// TODO(crbug.com/905412): Use real-time for Run() timeouts so that they</span></span><br><span class="line">  <span class="comment">// can be applied even in tests which mock TimeTicks::Now().</span></span><br><span class="line">  CancelableOnceClosure cancelable_timeout;</span><br><span class="line">  <span class="type">const</span> RunLoopTimeout* run_timeout = <span class="built_in">GetTimeoutForCurrentThread</span>();</span><br><span class="line">  <span class="keyword">if</span> (run_timeout) &#123;</span><br><span class="line">    cancelable_timeout.<span class="built_in">Reset</span>(<span class="built_in">BindOnce</span>(&amp;OnRunLoopTimeout, <span class="built_in">Unretained</span>(<span class="keyword">this</span>),</span><br><span class="line">                                      location, run_timeout-&gt;on_timeout));</span><br><span class="line">    origin_task_runner_-&gt;<span class="built_in">PostDelayedTask</span>(</span><br><span class="line">        FROM_HERE, cancelable_timeout.<span class="built_in">callback</span>(), run_timeout-&gt;timeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(<span class="keyword">this</span>, delegate_-&gt;active_run_loops_.<span class="built_in">top</span>());</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> application_tasks_allowed =</span><br><span class="line">      delegate_-&gt;active_run_loops_.<span class="built_in">size</span>() == <span class="number">1U</span> ||</span><br><span class="line">      type_ == Type::kNestableTasksAllowed;</span><br><span class="line">  delegate_-&gt;<span class="built_in">Run</span>(application_tasks_allowed, TimeDelta::<span class="built_in">Max</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AfterRun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BeforeRun"><a href="#BeforeRun" class="headerlink" title="BeforeRun()"></a>BeforeRun()</h4><p>BeforeRun 里面处理 nested RunLoop 相关内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RunLoop::BeforeRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow Quit to be called before Run.</span></span><br><span class="line">  <span class="keyword">if</span> (quit_called_) &#123;</span><br><span class="line">    <span class="built_in">TRACE_EVENT_WITH_FLOW0</span>(<span class="string">&quot;toplevel.flow&quot;</span>, <span class="string">&quot;RunLoop_ExitedEarly&quot;</span>,</span><br><span class="line">                           <span class="built_in">TRACE_ID_LOCAL</span>(<span class="keyword">this</span>), TRACE_EVENT_FLAG_FLOW_IN);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span>&amp; active_run_loops = delegate_-&gt;active_run_loops_;</span><br><span class="line">  active_run_loops.<span class="built_in">push</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> is_nested = active_run_loops.<span class="built_in">size</span>() &gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_nested) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; observer : delegate_-&gt;nesting_observers_)</span><br><span class="line">      observer.<span class="built_in">OnBeginNestedRunLoop</span>();</span><br><span class="line">    <span class="keyword">if</span> (type_ == Type::kNestableTasksAllowed)</span><br><span class="line">      delegate_-&gt;<span class="built_in">EnsureWorkScheduled</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  running_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delegete-gt-Run"><a href="#delegete-gt-Run" class="headerlink" title="delegete_-&gt;Run"></a>delegete_-&gt;Run</h4><p><code>delegate_</code> 就是 thread_controller</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadControllerWithMessagePumpImpl::Run</span><span class="params">(<span class="type">bool</span> application_tasks_allowed,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              TimeDelta timeout)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">RunsTasksInCurrentSequence</span>());</span><br><span class="line">  <span class="comment">// RunLoops can be nested so we need to restore the previous value of</span></span><br><span class="line">  <span class="comment">// |quit_runloop_after| upon exit. NB we could use saturated arithmetic here</span></span><br><span class="line">  <span class="comment">// but don&#x27;t because we have some tests which assert the number of calls to</span></span><br><span class="line">  <span class="comment">// Now.</span></span><br><span class="line">  <span class="function">AutoReset&lt;TimeTicks&gt; <span class="title">quit_runloop_after</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      &amp;main_thread_only().quit_runloop_after,</span></span></span><br><span class="line"><span class="params"><span class="function">      (timeout == TimeDelta::Max()) ? TimeTicks::Max()</span></span></span><br><span class="line"><span class="params"><span class="function">                                    : time_source_-&gt;NowTicks() + timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">main_thread_only</span>().run_level_tracker.<span class="built_in">OnRunLoopStarted</span>(</span><br><span class="line">      RunLevelTracker::kSelectingNextTask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Quit may have been called outside of a Run(), so |quit_pending| might be</span></span><br><span class="line">  <span class="comment">// true here. We can&#x27;t use InTopLevelDoWork() in Quit() as this call may be</span></span><br><span class="line">  <span class="comment">// outside top-level DoWork but still in Run().</span></span><br><span class="line">  <span class="built_in">main_thread_only</span>().quit_pending = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (application_tasks_allowed &amp;&amp; !<span class="built_in">main_thread_only</span>().task_execution_allowed) &#123;</span><br><span class="line">    <span class="comment">// Allow nested task execution as explicitly requested.</span></span><br><span class="line">    <span class="built_in">DCHECK</span>(RunLoop::<span class="built_in">IsNestedOnCurrentThread</span>());</span><br><span class="line">    <span class="built_in">main_thread_only</span>().task_execution_allowed = <span class="literal">true</span>;</span><br><span class="line">    pump_-&gt;<span class="built_in">Run</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">main_thread_only</span>().task_execution_allowed = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pump_-&gt;<span class="built_in">Run</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">main_thread_only</span>().run_level_tracker.<span class="built_in">OnRunLoopEnded</span>();</span><br><span class="line">  <span class="built_in">main_thread_only</span>().quit_pending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// All work items should be over when exiting the loop so hang watching should</span></span><br><span class="line">  <span class="comment">// not be live.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(!hang_watch_scope_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MessagePumpDefault-Run"><a href="#MessagePumpDefault-Run" class="headerlink" title="MessagePumpDefault::Run"></a>MessagePumpDefault::Run</h5><p>ThreadControllerWithMessagePumpImpl::Run 调用 MessagePumpDefault::Run</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessagePumpDefault::Run</span><span class="params">(Delegate* delegate)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoReset&lt;<span class="type">bool</span>&gt; <span class="title">auto_reset_keep_running</span><span class="params">(&amp;keep_running_, <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">...</span><br><span class="line">    Delegate::NextWorkInfo next_work_info = delegate-&gt;<span class="built_in">DoWork</span>();</span><br><span class="line">    <span class="type">bool</span> has_more_immediate_work = next_work_info.<span class="built_in">is_immediate</span>();</span><br><span class="line">    <span class="keyword">if</span> (!keep_running_)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (has_more_immediate_work)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    has_more_immediate_work = delegate-&gt;<span class="built_in">DoIdleWork</span>();</span><br><span class="line">    <span class="keyword">if</span> (!keep_running_)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (has_more_immediate_work)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_work_info.delayed_run_time.<span class="built_in">is_max</span>()) &#123;</span><br><span class="line">      event_.<span class="built_in">Wait</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event_.<span class="built_in">TimedWait</span>(next_work_info.<span class="built_in">remaining_delay</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Since event_ is auto-reset, we don&#x27;t need to do anything special here</span></span><br><span class="line">    <span class="comment">// other than service each delegate method.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="ThreadControllerWithMessagePumpImpl-DoWork"><a href="#ThreadControllerWithMessagePumpImpl-DoWork" class="headerlink" title="ThreadControllerWithMessagePumpImpl::DoWork"></a>ThreadControllerWithMessagePumpImpl::DoWork</h6><p>MessagePumpDefault::Run 会反过来调用 ThreadControllerWithMessagePumpImpl 中的函数，ThreadControllerWithMessagePumpImpl 则会从 SequenceManager 中取任务并执行</p><p><code>main_thread_only().next_delayed_do_work</code> 用于控制唤醒时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">MessagePump::<span class="function">Delegate::NextWorkInfo</span></span><br><span class="line"><span class="function"><span class="title">ThreadControllerWithMessagePumpImpl::DoWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MessagePump::Delegate::NextWorkInfo next_work_info&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  work_deduplicator_.<span class="built_in">OnWorkStarted</span>();</span><br><span class="line">  <span class="function">LazyNow <span class="title">continuation_lazy_now</span><span class="params">(time_source_)</span></span>;</span><br><span class="line">  absl::optional&lt;WakeUp&gt; next_wake_up = <span class="built_in">DoWorkImpl</span>(&amp;continuation_lazy_now);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="comment">// Special-casing here avoids unnecessarily sampling Now() when out of work.</span></span><br><span class="line">  <span class="keyword">if</span> (!next_wake_up) &#123;</span><br><span class="line">    <span class="built_in">main_thread_only</span>().next_delayed_do_work = TimeTicks::<span class="built_in">Max</span>();</span><br><span class="line">    next_work_info.delayed_run_time = TimeTicks::<span class="built_in">Max</span>();</span><br><span class="line">    <span class="keyword">return</span> next_work_info;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The MessagePump will schedule the wake up on our behalf, so we need to</span></span><br><span class="line">  <span class="comment">// update |main_thread_only().next_delayed_do_work|.</span></span><br><span class="line">  <span class="built_in">main_thread_only</span>().next_delayed_do_work = <span class="built_in">WakeUpRunTime</span>(*next_wake_up);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  next_work_info.delayed_run_time = <span class="built_in">CapAtOneDay</span>(</span><br><span class="line">      <span class="built_in">main_thread_only</span>().next_delayed_do_work, &amp;continuation_lazy_now);</span><br><span class="line">  next_work_info.recent_now = continuation_lazy_now.<span class="built_in">Now</span>();</span><br><span class="line">  <span class="keyword">return</span> next_work_info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns |next_run_time| capped at 1 day from |lazy_now|. This is used to</span></span><br><span class="line"><span class="comment">// mitigate https://crbug.com/850450 where some platforms are unhappy with</span></span><br><span class="line"><span class="comment">// delays &gt; 100,000,000 seconds. In practice, a diagnosis metric showed that no</span></span><br><span class="line"><span class="comment">// sleep &gt; 1 hour ever completes (always interrupted by an earlier MessageLoop</span></span><br><span class="line"><span class="comment">// event) and 99% of completed sleeps are the ones scheduled for &lt;= 1 second.</span></span><br><span class="line"><span class="comment">// Details @ https://crrev.com/c/1142589.</span></span><br><span class="line"><span class="function">TimeTicks <span class="title">CapAtOneDay</span><span class="params">(TimeTicks next_run_time, LazyNow* lazy_now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">min</span>(next_run_time, lazy_now-&gt;<span class="built_in">Now</span>() + <span class="built_in">Days</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####### ThreadControllerWithMessagePumpImpl::DoWorkImpl</p><p>下面 <code>main_thread_only().task_source</code> 就是 SequenceManagerImpl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;WakeUp&gt; <span class="title">ThreadControllerWithMessagePumpImpl::DoWorkImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LazyNow* continuation_lazy_now)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">main_thread_only</span>().work_batch_size; i++) &#123;</span><br><span class="line">    <span class="comment">// Include SelectNextTask() in the scope of the work item. This ensures it&#x27;s</span></span><br><span class="line">    <span class="comment">// covered in tracing and hang reports. This is particularly important when</span></span><br><span class="line">    <span class="comment">// SelectNextTask() finds no work immediately after a wakeup, otherwise the</span></span><br><span class="line">    <span class="comment">// power-inefficient wakeup is invisible in tracing.</span></span><br><span class="line">    <span class="keyword">auto</span> work_item_scope = <span class="built_in">BeginWorkItem</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [[nodiscard]] ScopedDoWorkItem MessagePump::BeginWorkItem() &#123;</span></span><br><span class="line"><span class="comment">      return ScopedDoWorkItem(this);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    class MessagePump::ScopedDoWorkItem &#123;</span></span><br><span class="line"><span class="comment">      explicit ScopedDoWorkItem(Delegate* outer) : outer_(outer) &#123;</span></span><br><span class="line"><span class="comment">        outer_-&gt;OnBeginWorkItem();</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> SequencedTaskSource::SelectTaskOption select_task_option =</span><br><span class="line">        power_monitor_.<span class="built_in">IsProcessInPowerSuspendState</span>()</span><br><span class="line">            ? SequencedTaskSource::SelectTaskOption::kSkipDelayedTask</span><br><span class="line">            : SequencedTaskSource::SelectTaskOption::kDefault;</span><br><span class="line">    absl::optional&lt;SequencedTaskSource::SelectedTask&gt; selected_task =</span><br><span class="line">        <span class="built_in">main_thread_only</span>().task_source-&gt;<span class="built_in">SelectNextTask</span>(select_task_option);</span><br><span class="line">    <span class="keyword">if</span> (!selected_task)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the task and assume the worst: it is probably not reentrant.</span></span><br><span class="line">    <span class="function">AutoReset&lt;<span class="type">bool</span>&gt; <span class="title">ban_nested_application_tasks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        &amp;main_thread_only().task_execution_allowed, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: all arguments after task are just passed to a TRACE_EVENT for</span></span><br><span class="line">    <span class="comment">// logging so lambda captures are safe as lambda is executed inline.</span></span><br><span class="line">    task_annotator_.<span class="built_in">RunTask</span>(<span class="string">&quot;ThreadControllerImpl::RunTask&quot;</span>,</span><br><span class="line">                            selected_task-&gt;task,</span><br><span class="line">                            [&amp;selected_task](perfetto::EventContext&amp; ctx) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (selected_task-&gt;task_execution_trace_logger)</span><br><span class="line">                                selected_task-&gt;task_execution_trace_logger.<span class="built_in">Run</span>(</span><br><span class="line">                                    ctx, selected_task-&gt;task);</span><br><span class="line">                            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This processes microtasks and is intentionally included in</span></span><br><span class="line">    <span class="comment">// |work_item_scope|.</span></span><br><span class="line">    <span class="built_in">main_thread_only</span>().task_source-&gt;<span class="built_in">DidRunTask</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When Quit() is called we must stop running the batch because the caller</span></span><br><span class="line">    <span class="comment">// expects per-task granularity.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">main_thread_only</span>().quit_pending)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">main_thread_only</span>().quit_pending)</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Re-check the state of the power after running tasks. An executed task may</span></span><br><span class="line">  <span class="comment">// have been a power change notification.</span></span><br><span class="line">  <span class="type">const</span> SequencedTaskSource::SelectTaskOption select_task_option =</span><br><span class="line">      power_monitor_.<span class="built_in">IsProcessInPowerSuspendState</span>()</span><br><span class="line">          ? SequencedTaskSource::SelectTaskOption::kSkipDelayedTask</span><br><span class="line">          : SequencedTaskSource::SelectTaskOption::kDefault;</span><br><span class="line">  <span class="built_in">main_thread_only</span>().task_source-&gt;<span class="built_in">RemoveAllCanceledDelayedTasksFromFront</span>(</span><br><span class="line">      continuation_lazy_now);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">main_thread_only</span>().task_source-&gt;<span class="built_in">GetPendingWakeUp</span>(continuation_lazy_now,</span><br><span class="line">                                                          select_task_option);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######## SequenceManagerImpl::SelectNextTask</p><p>上面的 task_source 就是 sequence_manager，在最开始的时候就设置了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;SequenceManagerImpl::SelectedTask&gt;</span></span><br><span class="line"><span class="function"><span class="title">SequenceManagerImpl::SelectNextTask</span><span class="params">(SelectTaskOption option)</span> </span>&#123;</span><br><span class="line">  absl::optional&lt;SelectedTask&gt; selected_task = <span class="built_in">SelectNextTaskImpl</span>(option);</span><br><span class="line">  <span class="keyword">if</span> (!selected_task)</span><br><span class="line">    <span class="keyword">return</span> selected_task;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;SequenceManagerImpl::SelectedTask&gt;</span></span><br><span class="line"><span class="function"><span class="title">SequenceManagerImpl::SelectNextTaskImpl</span><span class="params">(SelectTaskOption option)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">Validate</span>());</span><br><span class="line">...</span><br><span class="line">  <span class="built_in">ReloadEmptyWorkQueues</span>();</span><br><span class="line">  <span class="function">LazyNow <span class="title">lazy_now</span><span class="params">(main_thread_clock())</span></span>;</span><br><span class="line">  <span class="built_in">MoveReadyDelayedTasksToWorkQueues</span>(&amp;lazy_now);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we sampled now, check if it&#x27;s time to reclaim memory next time we go</span></span><br><span class="line">  <span class="comment">// idle.</span></span><br><span class="line">  <span class="keyword">if</span> (lazy_now.<span class="built_in">has_value</span>() &amp;&amp;</span><br><span class="line">      lazy_now.<span class="built_in">Now</span>() &gt;= <span class="built_in">main_thread_only</span>().next_time_to_reclaim_memory) &#123;</span><br><span class="line">    <span class="built_in">main_thread_only</span>().memory_reclaim_scheduled = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// main_thread_only().selector之前已经通过AddQueue方法添加了TaskQueueImpl</span></span><br><span class="line">    <span class="comment">// 这里输出的是WorkQueue，也就是immediate_work_queue或者delayed_work_queue</span></span><br><span class="line">    internal::WorkQueue* work_queue =</span><br><span class="line">        <span class="built_in">main_thread_only</span>().selector.<span class="built_in">SelectWorkQueueToService</span>(option);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!work_queue)</span><br><span class="line">      <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the head task was canceled, remove it and run the selector again.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(work_queue-&gt;<span class="built_in">RemoveAllCanceledTasksFromFront</span>()))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(work_queue-&gt;<span class="built_in">GetFrontTask</span>()-&gt;nestable ==</span><br><span class="line">                     Nestable::kNonNestable &amp;&amp;</span><br><span class="line">                 <span class="built_in">main_thread_only</span>().nesting_depth &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">// Defer non-nestable work. NOTE these tasks can be arbitrarily delayed so</span></span><br><span class="line">      <span class="comment">// the additional delay should not be a problem.</span></span><br><span class="line">      <span class="comment">// Note because we don&#x27;t delete queues while nested, it&#x27;s perfectly OK to</span></span><br><span class="line">      <span class="comment">// store the raw pointer for |queue| here.</span></span><br><span class="line">      internal::TaskQueueImpl::DeferredNonNestableTask deferred_task&#123;</span><br><span class="line">          work_queue-&gt;<span class="built_in">TakeTaskFromWorkQueue</span>(), work_queue-&gt;<span class="built_in">task_queue</span>(),</span><br><span class="line">          work_queue-&gt;<span class="built_in">queue_type</span>()&#125;;</span><br><span class="line">      <span class="built_in">main_thread_only</span>().non_nestable_task_queue.<span class="built_in">push_back</span>(</span><br><span class="line">          std::<span class="built_in">move</span>(deferred_task));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(!<span class="built_in">ShouldRunTaskOfPriority</span>(</span><br><span class="line">            work_queue-&gt;<span class="built_in">task_queue</span>()-&gt;<span class="built_in">GetQueuePriority</span>()))) &#123;</span><br><span class="line">      <span class="built_in">TRACE_EVENT0</span>(<span class="built_in">TRACE_DISABLED_BY_DEFAULT</span>(<span class="string">&quot;sequence_manager&quot;</span>),</span><br><span class="line">                   <span class="string">&quot;SequenceManager.YieldToNative&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">main_thread_only</span>().task_execution_stack.<span class="built_in">emplace_back</span>(</span><br><span class="line">        work_queue-&gt;<span class="built_in">TakeTaskFromWorkQueue</span>(), work_queue-&gt;<span class="built_in">task_queue</span>(),</span><br><span class="line">        <span class="built_in">InitializeTaskTiming</span>(work_queue-&gt;<span class="built_in">task_queue</span>()));</span><br><span class="line"></span><br><span class="line">    ExecutingTask&amp; executing_task =</span><br><span class="line">        *<span class="built_in">main_thread_only</span>().task_execution_stack.<span class="built_in">rbegin</span>();</span><br><span class="line">    <span class="built_in">NotifyWillProcessTask</span>(&amp;executing_task, &amp;lazy_now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maybe invalidate the delayed task handle. |pending_task| is guaranteed to</span></span><br><span class="line">    <span class="comment">// be valid here (not canceled).</span></span><br><span class="line">    executing_task.pending_task.<span class="built_in">WillRunTask</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SelectedTask</span>(</span><br><span class="line">        executing_task.pending_task,</span><br><span class="line">        executing_task.task_queue-&gt;<span class="built_in">task_execution_trace_logger</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就不再往下看，只需要知道从 immediate_work_queue 或者 delayed_work_queue 中取得了一个 task</p><p>######## SequenceManagerImpl::RemoveAllCanceledDelayedTasksFromFront</p><p>移除已经 cancel 的任务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SequenceManagerImpl::RemoveAllCanceledDelayedTasksFromFront</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LazyNow* lazy_now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!g_no_wake_ups_for_canceled_tasks.<span class="built_in">load</span>(std::memory_order_relaxed))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">main_thread_only</span>().wake_up_queue-&gt;<span class="built_in">RemoveAllCanceledDelayedTasksFromFront</span>(</span><br><span class="line">      lazy_now);</span><br><span class="line">  <span class="built_in">main_thread_only</span>()</span><br><span class="line">      .non_waking_wake_up_queue-&gt;<span class="built_in">RemoveAllCanceledDelayedTasksFromFront</span>(</span><br><span class="line">          lazy_now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WakeUpQueue::RemoveAllCanceledDelayedTasksFromFront</span><span class="params">(LazyNow* lazy_now)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Repeatedly trim the front of the top queue until it stabilizes. This is</span></span><br><span class="line">  <span class="comment">// needed because a different queue can become the top one once you remove the</span></span><br><span class="line">  <span class="comment">// canceled tasks.</span></span><br><span class="line">  <span class="keyword">while</span> (!wake_up_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span>* top_queue = wake_up_queue_.<span class="built_in">top</span>().queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If no tasks are removed from the top queue, then it means the top queue</span></span><br><span class="line">    <span class="comment">// cannot change anymore.</span></span><br><span class="line">    <span class="keyword">if</span> (!top_queue-&gt;<span class="built_in">RemoveAllCanceledDelayedTasksFromFront</span>(lazy_now))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TaskQueueImpl::RemoveAllCanceledDelayedTasksFromFront</span><span class="params">(LazyNow* lazy_now)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Because task destructors could have a side-effect of posting new tasks, we</span></span><br><span class="line">  <span class="comment">// move all the cancelled tasks into a temporary container before deleting</span></span><br><span class="line">  <span class="comment">// them. This is to avoid the queue from changing while iterating over it.</span></span><br><span class="line">  StackVector&lt;Task, <span class="number">8</span>&gt; tasks_to_delete;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">main_thread_only</span>().delayed_incoming_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">const</span> Task&amp; task = <span class="built_in">main_thread_only</span>().delayed_incoming_queue.<span class="built_in">top</span>();</span><br><span class="line">    <span class="built_in">CHECK</span>(task.task);</span><br><span class="line">    <span class="keyword">if</span> (!task.task.<span class="built_in">IsCancelled</span>())</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    tasks_to_delete-&gt;<span class="built_in">push_back</span>(</span><br><span class="line">        <span class="built_in">main_thread_only</span>().delayed_incoming_queue.<span class="built_in">take_top</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tasks_to_delete-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">UpdateWakeUp</span>(lazy_now);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######## SequenceManagerImpl::GetPendingWakeUp</p><p>这里是返回 WakeUp 信息，因为上面移除了 cancel 的任务，同时更新了 wake up</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;WakeUp&gt; <span class="title">SequenceManagerImpl::GetPendingWakeUp</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LazyNow* lazy_now,</span></span></span><br><span class="line"><span class="params"><span class="function">    SelectTaskOption option)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="built_in">ReloadEmptyWorkQueues</span>();</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AdjustWakeUp</span>(<span class="built_in">GetNextDelayedWakeUpWithOption</span>(option), lazy_now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;WakeUp&gt; <span class="title">SequenceManagerImpl::GetNextDelayedWakeUpWithOption</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SelectTaskOption option)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (option == SelectTaskOption::kSkipDelayedTask)</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">GetNextDelayedWakeUp</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，就是从 wake_up_queue 中读取唤醒时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;WakeUp&gt; <span class="title">SequenceManagerImpl::GetNextDelayedWakeUp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">main_thread_only</span>().wake_up_queue-&gt;<span class="built_in">GetNextDelayedWakeUp</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;WakeUp&gt; <span class="title">SequenceManagerImpl::AdjustWakeUp</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;WakeUp&gt; wake_up,</span></span></span><br><span class="line"><span class="params"><span class="function">    LazyNow* lazy_now)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(associated_thread_-&gt;thread_checker);</span><br><span class="line">  <span class="keyword">if</span> (!wake_up)</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  <span class="comment">// Overdue work needs to be run immediately.</span></span><br><span class="line">  <span class="keyword">if</span> (lazy_now-&gt;<span class="built_in">Now</span>() &gt;= wake_up-&gt;<span class="built_in">earliest_time</span>())</span><br><span class="line">    <span class="keyword">return</span> WakeUp&#123;&#125;;</span><br><span class="line">  <span class="comment">// If |time_domain| is present, we don&#x27;t want an actual OS level delayed wake</span></span><br><span class="line">  <span class="comment">// up scheduled, so pretend we have no more work. This will result in</span></span><br><span class="line">  <span class="comment">// appearing idle and |time_domain| will decide what to do in</span></span><br><span class="line">  <span class="comment">// MaybeFastForwardToWakeUp().</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">main_thread_only</span>().time_domain)</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  <span class="keyword">return</span> *wake_up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的过程是一样的。</p><h4 id="AfterRun"><a href="#AfterRun" class="headerlink" title="AfterRun()"></a>AfterRun()</h4><p>这一步也是处理嵌套 RunLoop</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunLoop::AfterRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_SEQUENCE</span>(sequence_checker_);</span><br><span class="line"></span><br><span class="line">  running_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span>&amp; active_run_loops = delegate_-&gt;active_run_loops_;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(active_run_loops.<span class="built_in">top</span>(), <span class="keyword">this</span>);</span><br><span class="line">  active_run_loops.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Exiting a nested RunLoop?</span></span><br><span class="line">  <span class="keyword">if</span> (!active_run_loops.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; observer : delegate_-&gt;nesting_observers_)</span><br><span class="line">      observer.<span class="built_in">OnExitNestedRunLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute deferred Quit, if any:</span></span><br><span class="line">    <span class="keyword">if</span> (active_run_loops.<span class="built_in">top</span>()-&gt;quit_called_)</span><br><span class="line">      delegate_-&gt;<span class="built_in">Quit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲到这里，Chromium 的 thread 基本上就是分析完了。可以发现，Chromium 的 thread 本质上也是一个线程执行一个 Loop，在这个 Loop 中不停的从任务队列中取任务，但是他有很多独特之处，比如：</p><ul><li>支持 delayed task，允许用户发送一个延迟执行的任务</li><li>可以在线程内继续 post task</li><li>充分使用 Bind 和 Callback 等函数式编程工具</li><li>嵌套 RunLoop（文章里面没说）</li><li>…</li></ul><p>总的来说，Chromium 的 thread 有不少值得学习的地方。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium base库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium base 库之 thread（二）</title>
      <link href="/2023/06/11/Chromium-base-%E5%BA%93%E4%B9%8B-thread%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/06/11/Chromium-base-%E5%BA%93%E4%B9%8B-thread%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这篇文章接着上一篇继续分析往 taskqueue 里面 post task 的过程，以及 post task 后如何唤醒 thread。</p><p>假设使用了 ThreadTaskRunnerHandle 来 post task，那么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数，会设置thread local指针指向自身</span></span><br><span class="line">ThreadTaskRunnerHandle::<span class="built_in">ThreadTaskRunnerHandle</span>(</span><br><span class="line">    scoped_refptr&lt;SingleThreadTaskRunner&gt; task_runner)</span><br><span class="line">    : <span class="built_in">task_runner_</span>(std::<span class="built_in">move</span>(task_runner)),</span><br><span class="line">      <span class="built_in">sequenced_task_runner_handle_</span>(task_runner_) &#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(task_runner_-&gt;<span class="built_in">BelongsToCurrentThread</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(!thread_task_runner_tls.<span class="built_in">Pointer</span>()-&gt;<span class="built_in">Get</span>());</span><br><span class="line">  thread_task_runner_tls.<span class="built_in">Pointer</span>()-&gt;<span class="built_in">Set</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而上面 task_runner 参数就是 TaskQueueImpl::CreateTaskRunner 创建的 SingleThreadTaskRunner 的子类 TaskQueueImpl::TaskRunner，TaskQueueImpl::TaskRunner 是 TaskQueueImpl 内部的类，他继承 SingleThreadTaskRunner</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_refptr&lt;SingleThreadTaskRunner&gt; <span class="title">TaskQueueImpl::CreateTaskRunner</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskType task_type)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MakeRefCounted</span>&lt;TaskRunner&gt;(task_poster_, associated_thread_,</span><br><span class="line">                                    task_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意，在 base namespace 里面也有一个 TaskRunner 类，SingleThreadTaskRunner 是 base::TaskRunner 的子类，在 base::TaskRunner 中定义了 PostTask 和 PostDelayedTask 方法，其中前者是非虚函数，后者是虚函数，前者会调用后者，而后者交给子类实现，也就是这里的 base::TaskQueueImpl::TaskRunner。</p><h3 id="base-TaskRunner-PostTask"><a href="#base-TaskRunner-PostTask" class="headerlink" title="base::TaskRunner::PostTask"></a>base::TaskRunner::PostTask</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base/task/task_runner.cc</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TaskRunner::PostTask</span><span class="params">(<span class="type">const</span> Location&amp; from_here, OnceClosure task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">PostDelayedTask</span>(from_here, std::<span class="built_in">move</span>(task), base::<span class="built_in">TimeDelta</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用子类实现的 PostDelayedTask</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> TaskQueueImpl::TaskRunner::<span class="built_in">PostDelayedTask</span>(<span class="type">const</span> Location&amp; location,</span><br><span class="line">                                                OnceClosure callback,</span><br><span class="line">                                                TimeDelta delay) &#123;</span><br><span class="line">  <span class="keyword">return</span> task_poster_-&gt;<span class="built_in">PostTask</span>(<span class="built_in">PostedTask</span>(<span class="keyword">this</span>, std::<span class="built_in">move</span>(callback), location,</span><br><span class="line">                                           delay, Nestable::kNestable,</span><br><span class="line">                                           task_type_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PostedTask 类是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base/task/sequence_manager/tasks.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BASE_EXPORT</span> PostedTask &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PostedTask</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;SequencedTaskRunner&gt; task_runner,</span></span></span><br><span class="line"><span class="params"><span class="function">    OnceClosure callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    Location location,</span></span></span><br><span class="line"><span class="params"><span class="function">    TimeDelta delay,</span></span></span><br><span class="line"><span class="params"><span class="function">    Nestable nestable,</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskType task_type,</span></span></span><br><span class="line"><span class="params"><span class="function">    WeakPtr&lt;DelayedTaskHandleDelegate&gt; delayed_task_handle_delegate)</span></span></span><br><span class="line"><span class="function">    : callback(std::move(callback)),</span></span><br><span class="line"><span class="function">      location(location),</span></span><br><span class="line"><span class="function">      nestable(nestable),</span></span><br><span class="line"><span class="function">      task_type(task_type),</span></span><br><span class="line"><span class="function">      delay_or_delayed_run_time(delay),</span></span><br><span class="line"><span class="function">      task_runner(std::move(task_runner)),</span></span><br><span class="line"><span class="function">      delayed_task_handle_delegate(std::move(delayed_task_handle_delegate)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_delayed</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="built_in">holds_alternative</span>&lt;TimeTicks&gt;(delay_or_delayed_run_time)</span><br><span class="line">               ? !absl::<span class="built_in">get</span>&lt;TimeTicks&gt;(delay_or_delayed_run_time).<span class="built_in">is_null</span>()</span><br><span class="line">               : !absl::<span class="built_in">get</span>&lt;TimeDelta&gt;(delay_or_delayed_run_time).<span class="built_in">is_zero</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TaskQueueImpl::TaskRunner::PostDelayedTask 会调用 TaskQueueImpl::GuardedTaskPoster::PostTask</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> TaskQueueImpl::GuardedTaskPoster::<span class="built_in">PostTask</span>(PostedTask task) &#123;</span><br><span class="line">  <span class="comment">// Do not process new PostTasks while we are handling a PostTask (tracing</span></span><br><span class="line">  <span class="comment">// has to do this) as it can lead to a deadlock and defer it instead.</span></span><br><span class="line">  ScopedDeferTaskPosting disallow_task_posting;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> token = operations_controller_.<span class="built_in">TryBeginOperation</span>();</span><br><span class="line">  <span class="keyword">if</span> (!token)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  outer_-&gt;<span class="built_in">PostTask</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>outer_</code> 是 <code>const raw_ptr&lt;TaskQueueImpl&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueImpl::PostTask</span><span class="params">(PostedTask task)</span> </span>&#123;</span><br><span class="line">  CurrentThread current_thread =</span><br><span class="line">      associated_thread_-&gt;<span class="built_in">IsBoundToCurrentThread</span>()</span><br><span class="line">          ? TaskQueueImpl::CurrentThread::kMainThread</span><br><span class="line">          : TaskQueueImpl::CurrentThread::kNotMainThread;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (!task.<span class="built_in">is_delayed</span>()) &#123;</span><br><span class="line">    <span class="built_in">PostImmediateTaskImpl</span>(std::<span class="built_in">move</span>(task), current_thread);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">PostDelayedTaskImpl</span>(std::<span class="built_in">move</span>(task), current_thread);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里根据是否是 delay，分别调用不同的函数</p><h4 id="PostImmediateTaskImpl"><a href="#PostImmediateTaskImpl" class="headerlink" title="PostImmediateTaskImpl"></a>PostImmediateTaskImpl</h4><p>先将 task 送到 <code>any_thread_.immediate_incoming_queue</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueImpl::PostImmediateTaskImpl</span><span class="params">(PostedTask task,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          CurrentThread current_thread)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> should_schedule_work = <span class="literal">false</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    base::<span class="function">internal::CheckedAutoLock <span class="title">lock</span><span class="params">(any_thread_lock_)</span></span>;</span><br><span class="line">...</span><br><span class="line">    EnqueueOrder sequence_number = sequence_manager_-&gt;<span class="built_in">GetNextSequenceNumber</span>();</span><br><span class="line">    <span class="type">bool</span> was_immediate_incoming_queue_empty =</span><br><span class="line">        any_thread_.immediate_incoming_queue.<span class="built_in">empty</span>();</span><br><span class="line">    <span class="comment">// 将task送到immediate_incoming_queue</span></span><br><span class="line">    any_thread_.immediate_incoming_queue.<span class="built_in">push_back</span>(</span><br><span class="line">        <span class="built_in">Task</span>(std::<span class="built_in">move</span>(task), sequence_number, sequence_number, queue_time));</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (was_immediate_incoming_queue_empty &amp;&amp;</span><br><span class="line">        any_thread_.immediate_work_queue_empty) &#123;</span><br><span class="line">      empty_queues_to_reload_handle_.<span class="built_in">SetActive</span>(<span class="literal">true</span>);</span><br><span class="line">      should_schedule_work =</span><br><span class="line">          any_thread_.post_immediate_task_should_schedule_work;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (should_schedule_work)</span><br><span class="line">    sequence_manager_-&gt;<span class="built_in">ScheduleWork</span>();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简要介绍一下 <code>empty_queues_to_reload_handle_.SetActive(true);</code> 的作用，执行这一步后，SequenceManagerImpl 将来可能会执行 TaskQueueImpl::ReloadEmptyImmediateWorkQueue</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AtomicFlagSet::AtomicFlag</span></span><br><span class="line"><span class="function"><span class="title">SequenceManagerImpl::GetFlagToRequestReloadForEmptyQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskQueueImpl* task_queue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> empty_queues_to_reload_.<span class="built_in">AddFlag</span>(<span class="built_in">BindRepeating</span>(</span><br><span class="line">      &amp;TaskQueueImpl::ReloadEmptyImmediateWorkQueue, <span class="built_in">Unretained</span>(task_queue)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SequenceManagerImpl::ReloadEmptyWorkQueues</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// There are two cases where a queue needs reloading.  First, it might be</span></span><br><span class="line">  <span class="comment">// completely empty and we&#x27;ve just posted a task (this method handles that</span></span><br><span class="line">  <span class="comment">// case). Secondly if the work queue becomes empty when calling</span></span><br><span class="line">  <span class="comment">// WorkQueue::TakeTaskFromWorkQueue (handled there).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Invokes callbacks created by GetFlagToRequestReloadForEmptyQueue above.</span></span><br><span class="line">  empty_queues_to_reload_.<span class="built_in">RunActiveCallbacks</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueImpl::ReloadEmptyImmediateWorkQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">main_thread_only</span>().immediate_work_queue-&gt;<span class="built_in">Empty</span>());</span><br><span class="line">  <span class="built_in">main_thread_only</span>().immediate_work_queue-&gt;<span class="built_in">TakeImmediateIncomingQueueTasks</span>();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkQueue::TakeImmediateIncomingQueueTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(tasks_.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">  task_queue_-&gt;<span class="built_in">TakeImmediateIncomingQueueTasks</span>(&amp;tasks_);</span><br><span class="line">  <span class="keyword">if</span> (tasks_.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueImpl::TakeImmediateIncomingQueueTasks</span><span class="params">(TaskDeque* queue)</span> </span>&#123;</span><br><span class="line">  base::<span class="function">internal::CheckedAutoLock <span class="title">lock</span><span class="params">(any_thread_lock_)</span></span>;</span><br><span class="line">  <span class="built_in">DCHECK</span>(queue-&gt;<span class="built_in">empty</span>());</span><br><span class="line">  queue-&gt;<span class="built_in">swap</span>(any_thread_.immediate_incoming_queue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since |immediate_incoming_queue| is empty, now is a good time to consider</span></span><br><span class="line">  <span class="comment">// reducing it&#x27;s capacity if we&#x27;re wasting memory.</span></span><br><span class="line">  any_thread_.immediate_incoming_queue.<span class="built_in">MaybeShrinkQueue</span>();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">UpdateCrossThreadQueueStateLocked</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UpdateCrossThreadQueueStateLocked 在 TaskQueueImpl 构造时就会执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueImpl::UpdateCrossThreadQueueStateLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  any_thread_.immediate_work_queue_empty =</span><br><span class="line">      <span class="built_in">main_thread_only</span>().immediate_work_queue-&gt;<span class="built_in">Empty</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">main_thread_only</span>().throttler) &#123;</span><br><span class="line">    <span class="comment">// If there&#x27;s a Throttler, always ScheduleWork() when immediate work is</span></span><br><span class="line">    <span class="comment">// posted and the queue is enabled, to ensure that</span></span><br><span class="line">    <span class="comment">// Throttler::OnHasImmediateTask() is invoked.</span></span><br><span class="line">    any_thread_.post_immediate_task_should_schedule_work = <span class="built_in">IsQueueEnabled</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Otherwise, ScheduleWork() only if the queue is enabled and there isn&#x27;t a</span></span><br><span class="line">    <span class="comment">// fence to prevent the task from being executed.</span></span><br><span class="line">    any_thread_.post_immediate_task_should_schedule_work =</span><br><span class="line">        <span class="built_in">IsQueueEnabled</span>() &amp;&amp; !<span class="built_in">main_thread_only</span>().current_fence;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面还有一点值得注意，为什么是下面两个条件都满足时才会激活 <code>empty_queues_to_reload_handle_</code>？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">was_immediate_incoming_queue_empty &amp;&amp; any_thread_.immediate_work_queue_empty</span><br></pre></td></tr></table></figure><p>是因为下面在取任务时，如果 immediate_work_queue 为空，会尝试从 immediate_incoming_queue 取任务。这就保证了只有 immediate_work_queue 和 immediate_incoming_queue 都为空时才需要 reload task queue。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">WorkQueue::TakeTaskFromWorkQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(work_queue_sets_);</span><br><span class="line">  <span class="built_in">DCHECK</span>(!tasks_.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">  Task pending_task = std::<span class="built_in">move</span>(tasks_.<span class="built_in">front</span>());</span><br><span class="line">  tasks_.<span class="built_in">pop_front</span>();</span><br><span class="line">  <span class="comment">// NB immediate tasks have a different pipeline to delayed ones.</span></span><br><span class="line">  <span class="keyword">if</span> (tasks_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// NB delayed tasks are inserted via Push, no don&#x27;t need to reload those.</span></span><br><span class="line">    <span class="keyword">if</span> (queue_type_ == QueueType::kImmediate) &#123;</span><br><span class="line">      <span class="comment">// Short-circuit the queue reload so that OnPopMinQueueInSet does the</span></span><br><span class="line">      <span class="comment">// right thing.</span></span><br><span class="line">      task_queue_-&gt;<span class="built_in">TakeImmediateIncomingQueueTasks</span>(&amp;tasks_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Since the queue is empty, now is a good time to consider reducing it&#x27;s</span></span><br><span class="line">    <span class="comment">// capacity if we&#x27;re wasting memory.</span></span><br><span class="line">    tasks_.<span class="built_in">MaybeShrinkQueue</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(work_queue_sets_);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DCHECK_IS_ON()</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">// OnPopMinQueueInSet calls GetFrontTaskOrder which checks</span></span><br><span class="line">  <span class="comment">// BlockedByFence() so we don&#x27;t need to here.</span></span><br><span class="line">  work_queue_sets_-&gt;<span class="built_in">OnPopMinQueueInSet</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  task_queue_-&gt;<span class="built_in">TraceQueueSize</span>();</span><br><span class="line">  <span class="keyword">return</span> pending_task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SequenceManagerImpl-ScheduleWork"><a href="#SequenceManagerImpl-ScheduleWork" class="headerlink" title="SequenceManagerImpl::ScheduleWork"></a>SequenceManagerImpl::ScheduleWork</h5><p>ScheduleWork 最终会给 MessagePumpDefault 中的 <code>event_</code> 发信号，将 MessagePumpDefault 从等待中唤醒</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SequenceManagerImpl::ScheduleWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  controller_-&gt;<span class="built_in">ScheduleWork</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadControllerWithMessagePumpImpl::ScheduleWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  base::internal::CheckedLock::<span class="built_in">AssertNoLockHeldOnCurrentThread</span>();</span><br><span class="line">  <span class="keyword">if</span> (work_deduplicator_.<span class="built_in">OnWorkRequested</span>() ==</span><br><span class="line">      ShouldScheduleWork::kScheduleImmediate) &#123;</span><br><span class="line">    pump_-&gt;<span class="built_in">ScheduleWork</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessagePumpDefault::ScheduleWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Since this can be called on any thread, we need to ensure that our Run</span></span><br><span class="line">  <span class="comment">// loop wakes up.</span></span><br><span class="line">  event_.<span class="built_in">Signal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PostDelayedTaskImpl"><a href="#PostDelayedTaskImpl" class="headerlink" title="PostDelayedTaskImpl"></a>PostDelayedTaskImpl</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueImpl::PostDelayedTaskImpl</span><span class="params">(PostedTask posted_task,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        CurrentThread current_thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Use CHECK instead of DCHECK to crash earlier. See http://crbug.com/711167</span></span><br><span class="line">  <span class="comment">// for details.</span></span><br><span class="line">  <span class="built_in">CHECK</span>(posted_task.callback);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread == CurrentThread::kMainThread) &#123;</span><br><span class="line">    <span class="function">LazyNow <span class="title">lazy_now</span><span class="params">(sequence_manager_-&gt;main_thread_clock())</span></span>;</span><br><span class="line">    Task pending_task = <span class="built_in">MakeDelayedTask</span>(std::<span class="built_in">move</span>(posted_task), &amp;lazy_now);</span><br><span class="line">    sequence_manager_-&gt;<span class="built_in">MaybeAddLeewayToTask</span>(pending_task);</span><br><span class="line">    <span class="built_in">PushOntoDelayedIncomingQueueFromMainThread</span>(</span><br><span class="line">        std::<span class="built_in">move</span>(pending_task), &amp;lazy_now,</span><br><span class="line">        <span class="comment">/* notify_task_annotator */</span> <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LazyNow <span class="built_in">lazy_now</span>(sequence_manager_-&gt;<span class="built_in">any_thread_clock</span>());</span><br><span class="line">    <span class="built_in">PushOntoDelayedIncomingQueue</span>(</span><br><span class="line">        <span class="built_in">MakeDelayedTask</span>(std::<span class="built_in">move</span>(posted_task), &amp;lazy_now));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TaskQueueImpl-MakeDelayedTask"><a href="#TaskQueueImpl-MakeDelayedTask" class="headerlink" title="TaskQueueImpl::MakeDelayedTask"></a>TaskQueueImpl::MakeDelayedTask</h5><p>lazy_now 就是当前时间，会把当前时间加上 time delta 得到绝对时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">TaskQueueImpl::MakeDelayedTask</span><span class="params">(PostedTask delayed_task,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    LazyNow* lazy_now)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  EnqueueOrder sequence_number = sequence_manager_-&gt;<span class="built_in">GetNextSequenceNumber</span>();</span><br><span class="line">  base::TimeDelta delay;</span><br><span class="line">  WakeUpResolution resolution = WakeUpResolution::kLow;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_WIN)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(IS_WIN)</span></span></span><br><span class="line">  <span class="keyword">if</span> (absl::<span class="built_in">holds_alternative</span>&lt;base::TimeDelta&gt;(</span><br><span class="line">          delayed_task.delay_or_delayed_run_time)) &#123;</span><br><span class="line">    delay = absl::<span class="built_in">get</span>&lt;base::TimeDelta&gt;(delayed_task.delay_or_delayed_run_time);</span><br><span class="line">    delayed_task.delay_or_delayed_run_time = lazy_now-&gt;<span class="built_in">Now</span>() + delay;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BUILDFLAG(IS_WIN)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// BUILDFLAG(IS_WIN)</span></span></span><br><span class="line">  <span class="comment">// leeway isn&#x27;t specified yet since this may be called from any thread.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Task</span>(std::<span class="built_in">move</span>(delayed_task), sequence_number, <span class="built_in">EnqueueOrder</span>(),</span><br><span class="line">              lazy_now-&gt;<span class="built_in">Now</span>(), resolution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TaskQueueImpl-PushOntoDelayedIncomingQueue"><a href="#TaskQueueImpl-PushOntoDelayedIncomingQueue" class="headerlink" title="TaskQueueImpl::PushOntoDelayedIncomingQueue"></a>TaskQueueImpl::PushOntoDelayedIncomingQueue</h5><p>可以看到，如果不是从 main thread 发送任务，需要包装一下，变成 main thread 发送任务，也就是说，发送一个 ImmediateTask，在该 ImmediateTask 内部将这个 pending_task 放在相应的 queue 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueImpl::PushOntoDelayedIncomingQueue</span><span class="params">(Task pending_task)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">auto</span> task_runner = pending_task.task_runner;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> task_type = pending_task.task_type;</span><br><span class="line">  <span class="built_in">PostImmediateTaskImpl</span>(</span><br><span class="line">      <span class="built_in">PostedTask</span>(std::<span class="built_in">move</span>(task_runner),</span><br><span class="line">                 <span class="built_in">BindOnce</span>(&amp;TaskQueueImpl::ScheduleDelayedWorkTask,</span><br><span class="line">                          <span class="built_in">Unretained</span>(<span class="keyword">this</span>), std::<span class="built_in">move</span>(pending_task)),</span><br><span class="line">                 FROM_HERE, <span class="built_in">TimeDelta</span>(), Nestable::kNonNestable, task_type),</span><br><span class="line">      CurrentThread::kNotMainThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="TaskQueueImpl-ScheduleDelayedWorkTask"><a href="#TaskQueueImpl-ScheduleDelayedWorkTask" class="headerlink" title="TaskQueueImpl::ScheduleDelayedWorkTask"></a>TaskQueueImpl::ScheduleDelayedWorkTask</h6><p>如果任务延迟时间已经超时，就把他移到 delayed_incoming_queue，并立即通过 MoveReadyDelayedTasksToWorkQueue 将超时任务移到 delayed_work_queue，否则将任务移到 delayed_incoming_queue 并使用正常超时调度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueImpl::ScheduleDelayedWorkTask</span><span class="params">(Task pending_task)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(associated_thread_-&gt;thread_checker);</span><br><span class="line">  sequence_manager_-&gt;<span class="built_in">MaybeAddLeewayToTask</span>(pending_task);</span><br><span class="line">  TimeTicks now = sequence_manager_-&gt;<span class="built_in">main_thread_clock</span>()-&gt;<span class="built_in">NowTicks</span>();</span><br><span class="line">  <span class="function">LazyNow <span class="title">lazy_now</span><span class="params">(now)</span></span>;</span><br><span class="line">  <span class="comment">// A delayed task is ready to run as soon as earliest_delayed_run_time() is</span></span><br><span class="line">  <span class="comment">// reached.</span></span><br><span class="line">  <span class="keyword">if</span> (pending_task.<span class="built_in">earliest_delayed_run_time</span>() &lt;= now) &#123;</span><br><span class="line">    <span class="comment">// If |delayed_run_time| is in the past then push it onto the work queue</span></span><br><span class="line">    <span class="comment">// immediately. To ensure the right task ordering we need to temporarily</span></span><br><span class="line">    <span class="comment">// push it onto the |delayed_incoming_queue|.</span></span><br><span class="line">    pending_task.delayed_run_time = now;</span><br><span class="line">    <span class="built_in">main_thread_only</span>().delayed_incoming_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(pending_task));</span><br><span class="line">    <span class="built_in">MoveReadyDelayedTasksToWorkQueue</span>(</span><br><span class="line">        &amp;lazy_now, sequence_manager_-&gt;<span class="built_in">GetNextSequenceNumber</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If |delayed_run_time| is in the future we can queue it as normal.</span></span><br><span class="line">    <span class="built_in">PushOntoDelayedIncomingQueueFromMainThread</span>(std::<span class="built_in">move</span>(pending_task),</span><br><span class="line">                                               &amp;lazy_now, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">TraceQueueSize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####### TaskQueueImpl::MoveReadyDelayedTasksToWorkQueue</p><p>将任务从 delayed_incoming_queue 移到 delayed_work_queue</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueImpl::MoveReadyDelayedTasksToWorkQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LazyNow* lazy_now,</span></span></span><br><span class="line"><span class="params"><span class="function">    EnqueueOrder enqueue_order)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Enqueue all delayed tasks that should be running now, skipping any that</span></span><br><span class="line">  <span class="comment">// have been canceled.</span></span><br><span class="line">  <span class="function">WorkQueue::TaskPusher <span class="title">delayed_work_queue_task_pusher</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      main_thread_only().delayed_work_queue-&gt;CreateTaskPusher())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Because task destructors could have a side-effect of posting new tasks, we</span></span><br><span class="line">  <span class="comment">// move all the cancelled tasks into a temporary container before deleting</span></span><br><span class="line">  <span class="comment">// them. This is to avoid the queue from changing while iterating over it.</span></span><br><span class="line">  StackVector&lt;Task, <span class="number">8</span>&gt; tasks_to_delete;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">main_thread_only</span>().delayed_incoming_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">const</span> Task&amp; task = <span class="built_in">main_thread_only</span>().delayed_incoming_queue.<span class="built_in">top</span>();</span><br><span class="line">    <span class="built_in">CHECK</span>(task.task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Leave the top task alone if it hasn&#x27;t been canceled and it is not ready.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> is_cancelled = task.task.<span class="built_in">IsCancelled</span>();</span><br><span class="line">    <span class="keyword">if</span> (!is_cancelled &amp;&amp; task.<span class="built_in">earliest_delayed_run_time</span>() &gt; lazy_now-&gt;<span class="built_in">Now</span>())</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    Task ready_task = <span class="built_in">main_thread_only</span>().delayed_incoming_queue.<span class="built_in">take_top</span>();</span><br><span class="line">    <span class="keyword">if</span> (is_cancelled) &#123;</span><br><span class="line">      tasks_to_delete-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(ready_task));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DCHECK</span>(!ready_task.delayed_run_time.<span class="built_in">is_null</span>());</span><br><span class="line">    <span class="built_in">DCHECK</span>(!ready_task.<span class="built_in">enqueue_order_set</span>());</span><br><span class="line">    ready_task.<span class="built_in">set_enqueue_order</span>(enqueue_order);</span><br><span class="line">    <span class="built_in">ActivateDelayedFenceIfNeeded</span>(ready_task);</span><br><span class="line"></span><br><span class="line">    delayed_work_queue_task_pusher.<span class="built_in">Push</span>(std::<span class="built_in">move</span>(ready_task));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Explicitly delete tasks last.</span></span><br><span class="line">  tasks_to_delete-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">UpdateWakeUp</span>(lazy_now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######## TaskQueueImpl::UpdateWakeUp</p><p>这一步更新唤醒时间，因为之前改变了 delayed_incoming_queue</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueImpl::UpdateWakeUp</span><span class="params">(LazyNow* lazy_now)</span> </span>&#123;</span><br><span class="line">  absl::optional&lt;WakeUp&gt; wake_up = <span class="built_in">GetNextDesiredWakeUp</span>();</span><br><span class="line">...</span><br><span class="line">  <span class="built_in">SetNextWakeUp</span>(lazy_now, wake_up);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######### TaskQueueImpl::GetNextDesiredWakeUp</p><p>这里就是从 delayed_incoming_queue.top()取时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;WakeUp&gt; <span class="title">TaskQueueImpl::GetNextDesiredWakeUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note we don&#x27;t scheduled a wake-up for disabled queues.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">main_thread_only</span>().delayed_incoming_queue.<span class="built_in">empty</span>() || !<span class="built_in">IsQueueEnabled</span>())</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// High resolution is needed if the queue contains high resolution tasks and</span></span><br><span class="line">  <span class="comment">// has a priority index &lt;= kNormalPriority (precise execution time is</span></span><br><span class="line">  <span class="comment">// unnecessary for a low priority queue).</span></span><br><span class="line">  WakeUpResolution resolution =</span><br><span class="line">      <span class="built_in">has_pending_high_resolution_tasks</span>() &amp;&amp;</span><br><span class="line">              <span class="built_in">GetQueuePriority</span>() &lt;= TaskQueue::QueuePriority::kNormalPriority</span><br><span class="line">          ? WakeUpResolution::kHigh</span><br><span class="line">          : WakeUpResolution::kLow;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; top_task = <span class="built_in">main_thread_only</span>().delayed_incoming_queue.<span class="built_in">top</span>();</span><br><span class="line">  <span class="keyword">return</span> WakeUp&#123;top_task.delayed_run_time, top_task.leeway, resolution,</span><br><span class="line">                top_task.delay_policy&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######### TaskQueueImpl::SetNextWakeUp</p><p>将时间设置到 wake_up_queue</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueImpl::SetNextWakeUp</span><span class="params">(LazyNow* lazy_now,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  absl::optional&lt;WakeUp&gt; wake_up)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">main_thread_only</span>().scheduled_wake_up == wake_up)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">main_thread_only</span>().scheduled_wake_up = wake_up;</span><br><span class="line">  <span class="built_in">main_thread_only</span>().wake_up_queue-&gt;<span class="built_in">SetNextWakeUpForQueue</span>(<span class="keyword">this</span>, lazy_now,</span><br><span class="line">                                                          wake_up);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WakeUpQueue 会把时间更新到 SequenceManager</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WakeUpQueue::SetNextWakeUpForQueue</span><span class="params">(internal::TaskQueueImpl* queue,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        LazyNow* lazy_now,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        absl::optional&lt;WakeUp&gt; wake_up)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  absl::optional&lt;WakeUp&gt; previous_wake_up = <span class="built_in">GetNextDelayedWakeUp</span>();</span><br><span class="line">  absl::optional&lt;WakeUpResolution&gt; previous_queue_resolution;</span><br><span class="line">  <span class="keyword">if</span> (queue-&gt;<span class="built_in">heap_handle</span>().<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">    previous_queue_resolution =</span><br><span class="line">        wake_up_queue_.<span class="built_in">at</span>(queue-&gt;<span class="built_in">heap_handle</span>()).wake_up.resolution;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先插入wake_up</span></span><br><span class="line">  <span class="keyword">if</span> (wake_up) &#123;</span><br><span class="line">    <span class="comment">// Insert a new wake-up into the heap.</span></span><br><span class="line">    <span class="keyword">if</span> (queue-&gt;<span class="built_in">heap_handle</span>().<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">      <span class="comment">// O(log n)</span></span><br><span class="line">      wake_up_queue_.<span class="built_in">Replace</span>(queue-&gt;<span class="built_in">heap_handle</span>(), &#123;wake_up.<span class="built_in">value</span>(), queue&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// O(log n)</span></span><br><span class="line">      wake_up_queue_.<span class="built_in">insert</span>(&#123;wake_up.<span class="built_in">value</span>(), queue&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Remove a wake-up from heap if present.</span></span><br><span class="line">    <span class="keyword">if</span> (queue-&gt;<span class="built_in">heap_handle</span>().<span class="built_in">IsValid</span>())</span><br><span class="line">      wake_up_queue_.<span class="built_in">erase</span>(queue-&gt;<span class="built_in">heap_handle</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后获得最近的wake_up</span></span><br><span class="line">  absl::optional&lt;WakeUp&gt; new_wake_up = <span class="built_in">GetNextDelayedWakeUp</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (previous_queue_resolution &amp;&amp;</span><br><span class="line">      *previous_queue_resolution == WakeUpResolution::kHigh) &#123;</span><br><span class="line">    pending_high_res_wake_up_count_--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (wake_up &amp;&amp; wake_up-&gt;resolution == WakeUpResolution::kHigh)</span><br><span class="line">    pending_high_res_wake_up_count_++;</span><br><span class="line">  <span class="built_in">DCHECK_GE</span>(pending_high_res_wake_up_count_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_wake_up != previous_wake_up)</span><br><span class="line">    <span class="built_in">OnNextWakeUpChanged</span>(lazy_now, <span class="built_in">GetNextDelayedWakeUp</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里获得最近的 WakeUp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">absl::optional&lt;WakeUp&gt; <span class="title">WakeUpQueue::GetNextDelayedWakeUp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(associated_thread_-&gt;thread_checker);</span><br><span class="line">  <span class="keyword">if</span> (wake_up_queue_.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  WakeUp wake_up = wake_up_queue_.<span class="built_in">top</span>().wake_up;</span><br><span class="line">  <span class="comment">// `wake_up.resolution` is not meaningful since it may be different from</span></span><br><span class="line">  <span class="comment">// has_pending_high_resolution_tasks(). Return WakeUpResolution::kLow here to</span></span><br><span class="line">  <span class="comment">// simplify comparison between wake ups.</span></span><br><span class="line">  <span class="comment">// TODO(1153139): Drive resolution by DelayPolicy and return</span></span><br><span class="line">  <span class="comment">// has_pending_high_resolution_tasks() here.</span></span><br><span class="line">  wake_up.resolution = WakeUpResolution::kLow;</span><br><span class="line">  <span class="keyword">return</span> wake_up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 wakeup 更新到 SequenceManager</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefaultWakeUpQueue::OnNextWakeUpChanged</span><span class="params">(LazyNow* lazy_now,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             absl::optional&lt;WakeUp&gt; wake_up)</span> </span>&#123;</span><br><span class="line">  sequence_manager_-&gt;<span class="built_in">SetNextWakeUp</span>(lazy_now, wake_up);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SequenceManagerImpl::SetNextWakeUp</span><span class="params">(LazyNow* lazy_now,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        absl::optional&lt;WakeUp&gt; wake_up)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> next_wake_up = <span class="built_in">AdjustWakeUp</span>(wake_up, lazy_now);</span><br><span class="line">  <span class="keyword">if</span> (next_wake_up &amp;&amp; next_wake_up-&gt;<span class="built_in">is_immediate</span>()) &#123;</span><br><span class="line">    <span class="built_in">ScheduleWork</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    controller_-&gt;<span class="built_in">SetNextDelayedDoWork</span>(lazy_now, next_wake_up);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">absl::optional&lt;WakeUp&gt; <span class="title">SequenceManagerImpl::AdjustWakeUp</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;WakeUp&gt; wake_up,</span></span></span><br><span class="line"><span class="params"><span class="function">    LazyNow* lazy_now)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(associated_thread_-&gt;thread_checker);</span><br><span class="line">  <span class="keyword">if</span> (!wake_up)</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  <span class="comment">// Overdue work needs to be run immediately.</span></span><br><span class="line">  <span class="keyword">if</span> (lazy_now-&gt;<span class="built_in">Now</span>() &gt;= wake_up-&gt;<span class="built_in">earliest_time</span>())</span><br><span class="line">    <span class="keyword">return</span> WakeUp&#123;&#125;;</span><br><span class="line">  <span class="comment">// If |time_domain| is present, we don&#x27;t want an actual OS level delayed wake</span></span><br><span class="line">  <span class="comment">// up scheduled, so pretend we have no more work. This will result in</span></span><br><span class="line">  <span class="comment">// appearing idle and |time_domain| will decide what to do in</span></span><br><span class="line">  <span class="comment">// MaybeFastForwardToWakeUp().</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">main_thread_only</span>().time_domain)</span><br><span class="line">    <span class="keyword">return</span> absl::<span class="literal">nullopt</span>;</span><br><span class="line">  <span class="keyword">return</span> *wake_up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 next_delayed_do_work，后面的 MessagePump 会根据这个值决定 timewait 的时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadControllerWithMessagePumpImpl::SetNextDelayedDoWork</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LazyNow* lazy_now,</span></span></span><br><span class="line"><span class="params"><span class="function">    absl::optional&lt;WakeUp&gt; wake_up)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(!wake_up || !wake_up-&gt;<span class="built_in">is_immediate</span>());</span><br><span class="line">  TimeTicks run_time =</span><br><span class="line">      wake_up.<span class="built_in">has_value</span>() ? <span class="built_in">WakeUpRunTime</span>(*wake_up) : TimeTicks::<span class="built_in">Max</span>();</span><br><span class="line">  <span class="built_in">DCHECK_LT</span>(lazy_now-&gt;<span class="built_in">Now</span>(), run_time);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">main_thread_only</span>().next_delayed_do_work == run_time)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">main_thread_only</span>().next_delayed_do_work = run_time;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="PushOntoDelayedIncomingQueueFromMainThread"><a href="#PushOntoDelayedIncomingQueueFromMainThread" class="headerlink" title="PushOntoDelayedIncomingQueueFromMainThread"></a>PushOntoDelayedIncomingQueueFromMainThread</h6><p>最后再看看这个函数，这个函数在 <code>current_thread == CurrentThread::kMainThread</code> 时执行，内部其实就是把 task 放到 delayed_incoming_queue，然后更新 wake up 时间，和上面流程一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueueImpl::PushOntoDelayedIncomingQueueFromMainThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Task pending_task,</span></span></span><br><span class="line"><span class="params"><span class="function">    LazyNow* lazy_now,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> notify_task_annotator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="built_in">main_thread_only</span>().delayed_incoming_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(pending_task));</span><br><span class="line">  <span class="built_in">UpdateWakeUp</span>(lazy_now);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这篇文章从 post task 出发，分析了 post immediate task 和 delayed task 的具体流程，从该流程可以看到，post delayed task 会创建一个 immediate task 然后把 post 动作放在这个 immediate task 里面，这也是为什么四个 queue 中只有 <code>immediate_incoming_queue</code> 是在 any thread 中。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium base库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium base 库之 thread（一）</title>
      <link href="/2023/06/08/Chromium-base-%E5%BA%93%E4%B9%8B-thread%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/06/08/Chromium-base-%E5%BA%93%E4%B9%8B-thread%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>之前研究过 Chromium thread 相关内容，打算写几篇文章介绍一下这块的内容。</p><p>这篇文章先通过一个例子介绍基本的类结构关系。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>先看下面的例子（来自 <a href="https://keyou.github.io/blog/2019/06/11/Chromium-MessageLoop-and-TaskScheduler/">https://keyou.github.io/blog/2019/06/11/Chromium-MessageLoop-and-TaskScheduler/</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/logging.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/message_loop/message_loop.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/message_loop/message_loop_current.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/task/post_task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/task/single_thread_task_executor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/task/thread_pool/thread_pool_impl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/task/thread_pool/thread_pool_instance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/threading/thread_task_runner_handle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/timer/timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;hello,demo!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建消息循环</span></span><br><span class="line">  base::SingleThreadTaskExecutor main_task_executer;</span><br><span class="line">  </span><br><span class="line">  base::RunLoop run_loop;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取当前线程的 task runner，并PostTask</span></span><br><span class="line">  base::ThreadTaskRunnerHandle::<span class="built_in">Get</span>()-&gt;<span class="built_in">PostTask</span>(FROM_HERE,base::<span class="built_in">BindOnce</span>(&amp;Hello));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 启动消息循环，即使没有任务也会阻塞程序运行。当前进程中只有一个线程。</span></span><br><span class="line">  run_loop.<span class="built_in">Run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码把 main thread 变成了一个 RunLoop，main thread 会不停的从任务队列中取任务，但是由于上面只有一个线程，所以当 <code>run_loop.Run();</code> 执行后，main thread 会在执行完 Hello 函数就进入睡眠状态。</p><p>实际开发中一般不会这么写，更多的是直接启动一个 thread，然后往该 thread 中 PostTask，但是我们可以以这个例子为研究对象来分析 Chromium thread 的原理。</p><h2 id="SingleThreadTaskExecutor"><a href="#SingleThreadTaskExecutor" class="headerlink" title="SingleThreadTaskExecutor"></a>SingleThreadTaskExecutor</h2><p>第一步，先创建一个 SingleThreadTaskExecutor 类型的对象，这个类里面有一个非常重要的类型，SequenceManager，的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleThreadTaskExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::unique_ptr&lt;sequence_manager::SequenceManager&gt; sequence_manager_;</span><br><span class="line">  scoped_refptr&lt;sequence_manager::TaskQueue&gt; default_task_queue_;</span><br><span class="line">  MessagePumpType type_;</span><br><span class="line">  SimpleTaskExecutor simple_task_executor_; <span class="comment">// 以task_runner作为参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当默认构造 SingleThreadTaskExecutor 时，type 参数为 MessagePumpType::DEFAULT</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SingleThreadTaskExecutor::<span class="built_in">SingleThreadTaskExecutor</span>(MessagePumpType type = MessagePumpType::DEFAULT)</span><br><span class="line">    : <span class="built_in">SingleThreadTaskExecutor</span>(type, MessagePump::<span class="built_in">Create</span>(type)) &#123;</span><br><span class="line">  <span class="built_in">DCHECK_NE</span>(type, MessagePumpType::CUSTOM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进而调用下面的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SingleThreadTaskExecutor::<span class="built_in">SingleThreadTaskExecutor</span>(</span><br><span class="line">    MessagePumpType type,</span><br><span class="line">    std::unique_ptr&lt;MessagePump&gt; pump)</span><br><span class="line">    : <span class="built_in">sequence_manager_</span>(sequence_manager::<span class="built_in">CreateUnboundSequenceManager</span>(</span><br><span class="line">          sequence_manager::SequenceManager::Settings::<span class="built_in">Builder</span>()</span><br><span class="line">              .<span class="built_in">SetMessagePumpType</span>(type)</span><br><span class="line">              .<span class="built_in">Build</span>())),</span><br><span class="line">      <span class="built_in">default_task_queue_</span>(sequence_manager_-&gt;<span class="built_in">CreateTaskQueue</span>(</span><br><span class="line">          sequence_manager::TaskQueue::<span class="built_in">Spec</span>(<span class="string">&quot;default_tq&quot;</span>))),</span><br><span class="line">      <span class="built_in">type_</span>(type),</span><br><span class="line">      <span class="built_in">simple_task_executor_</span>(<span class="built_in">task_runner</span>()) &#123;</span><br><span class="line">  sequence_manager_-&gt;<span class="built_in">SetDefaultTaskRunner</span>(default_task_queue_-&gt;<span class="built_in">task_runner</span>());</span><br><span class="line">  sequence_manager_-&gt;<span class="built_in">BindToMessagePump</span>(std::<span class="built_in">move</span>(pump));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数里面会：</p><ul><li>创建 SequenceManager</li><li>然后从 SequenceManager 创建 TaskQueue</li><li>从 TaskQueue 中取得 task_runner，用于后续 post task</li><li>最后对 SequenceManager 进行初始化</li></ul><h3 id="创建-SequenceManager"><a href="#创建-SequenceManager" class="headerlink" title="创建 SequenceManager"></a>创建 SequenceManager</h3><p>SingleThreadTaskExecutor()中通过 sequence_manager::CreateUnboundSequenceManager 这个函数创建 SequenceManagerImpl，而 SequenceManagerImpl 继承 SequenceManager。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;SequenceManager&gt; <span class="title">CreateUnboundSequenceManager</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SequenceManager::Settings settings)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> internal::SequenceManagerImpl::<span class="built_in">CreateUnbound</span>(std::<span class="built_in">move</span>(settings));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SequenceManager::Settings 就是一些参数设置，可以暂时不管</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SequenceManager</span>::Settings &#123;</span><br><span class="line">    MessagePumpType message_loop_type = MessagePumpType::DEFAULT;</span><br><span class="line">    <span class="type">bool</span> randomised_sampling_enabled = <span class="literal">false</span>;</span><br><span class="line">    raw_ptr&lt;<span class="type">const</span> TickClock&gt; clock = DefaultTickClock::<span class="built_in">GetInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If true, add the timestamp the task got queued to the task.</span></span><br><span class="line">    <span class="type">bool</span> add_queue_time_to_tasks = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="创建-ThreadControllerWithMessagePumpImpl"><a href="#创建-ThreadControllerWithMessagePumpImpl" class="headerlink" title="创建 ThreadControllerWithMessagePumpImpl"></a>创建 ThreadControllerWithMessagePumpImpl</h4><p>CreateUnbound 里面先创建 ThreadControllerWithMessagePumpImpl，然后用他来创建 SequenceManagerImpl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;SequenceManagerImpl&gt; <span class="title">SequenceManagerImpl::CreateUnbound</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SequenceManager::Settings settings)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> thread_controller =</span><br><span class="line">      ThreadControllerWithMessagePumpImpl::<span class="built_in">CreateUnbound</span>(settings);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WrapUnique</span>(<span class="keyword">new</span> <span class="built_in">SequenceManagerImpl</span>(std::<span class="built_in">move</span>(thread_controller),</span><br><span class="line">                                            std::<span class="built_in">move</span>(settings)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadController 顾名思义就是和线程管理相关。</p><p><strong>ThreadController 内部持有 MessagePump</strong>，而 MessagePump 会反过来调用 ThreadController，ThreadController 则从 SequenceManager 中取 task，调用流程是 <code>RunLoop-&gt;ThreadController-&gt;MessagePump-&gt;ThreadController-&gt;SequenceManager</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ThreadControllerWithMessagePumpImpl&gt;</span></span><br><span class="line"><span class="function"><span class="title">ThreadControllerWithMessagePumpImpl::CreateUnbound</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SequenceManager::Settings&amp; settings)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> base::<span class="built_in">WrapUnique</span>(<span class="keyword">new</span> <span class="built_in">ThreadControllerWithMessagePumpImpl</span>(settings));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadControllerWithMessagePumpImpl::<span class="built_in">ThreadControllerWithMessagePumpImpl</span>(</span><br><span class="line">    <span class="type">const</span> SequenceManager::Settings&amp; settings)</span><br><span class="line">    : <span class="built_in">associated_thread_</span>(AssociatedThreadId::<span class="built_in">CreateUnbound</span>()),</span><br><span class="line">      <span class="built_in">work_deduplicator_</span>(associated_thread_),</span><br><span class="line">      <span class="built_in">time_source_</span>(settings.clock) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>associated_thread_</code> 是 <code>scoped_refptr&lt;AssociatedThreadId&gt; associated_thread_;</code>。</p><p><code>AssociatedThreadId</code> 类中有一个成员 <code>std::atomic&lt;PlatformThreadId&gt; thread_id_&#123;kInvalidThreadId&#125;;</code></p><p><code>AssociatedThreadId::CreateUnbound()</code> 函数返回的 <code>AssociatedThreadId</code> 里面 <code>thread_id_</code> 是 <code>kInvalidThreadId</code>，也就是无效值</p><h3 id="继续创建-SequenceManager"><a href="#继续创建-SequenceManager" class="headerlink" title="继续创建 SequenceManager"></a>继续创建 SequenceManager</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SequenceManagerImpl::<span class="built_in">SequenceManagerImpl</span>(</span><br><span class="line">    std::unique_ptr&lt;internal::ThreadController&gt; controller,</span><br><span class="line">    SequenceManager::Settings settings)</span><br><span class="line">    : <span class="built_in">associated_thread_</span>(controller-&gt;<span class="built_in">GetAssociatedThread</span>()),</span><br><span class="line">      <span class="built_in">controller_</span>(std::<span class="built_in">move</span>(controller)),</span><br><span class="line">      <span class="built_in">settings_</span>(std::<span class="built_in">move</span>(settings)),</span><br><span class="line">      <span class="built_in">metric_recording_settings_</span>(<span class="built_in">InitializeMetricRecordingSettings</span>(</span><br><span class="line">          settings_.randomised_sampling_enabled)),</span><br><span class="line">      <span class="built_in">add_queue_time_to_tasks_</span>(settings_.add_queue_time_to_tasks), <span class="comment">// bool</span></span><br><span class="line">      <span class="built_in">empty_queues_to_reload_</span>(associated_thread_),</span><br><span class="line">      <span class="built_in">memory_corruption_sentinel_</span>(kMemoryCorruptionSentinelValue),</span><br><span class="line">      <span class="built_in">main_thread_only_</span>(<span class="keyword">this</span>, associated_thread_, settings_, settings_.clock),</span><br><span class="line">      <span class="built_in">clock_</span>(settings_.clock) &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="built_in">main_thread_only</span>().selector.<span class="built_in">SetTaskQueueSelectorObserver</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">main_thread_only</span>().next_time_to_reclaim_memory =</span><br><span class="line">      <span class="built_in">main_thread_clock</span>()-&gt;<span class="built_in">NowTicks</span>() + kReclaimMemoryInterval;</span><br><span class="line"></span><br><span class="line">  controller_-&gt;<span class="built_in">SetSequencedTaskSource</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面创建 SequenceManagerImpl 中 <code>controller-&gt;GetAssociatedThread()</code> 返回的就是上面 ThreadControllerWithMessagePumpImpl 中的 <code>associated_thread_</code>。</p><p>SequenceManagerImpl 会持有 ThreadControllerWithMessagePumpImpl。</p><p>注意 <code>controller_-&gt;SetSequencedTaskSource(this);</code> 这一步会将 SequenceManagerImpl 指针设置到 ThreadControllerWithMessagePumpImpl 中，后面 ThreadControllerWithMessagePumpImpl 就能从 SequenceManagerImpl 中取任务。</p><p>SequenceManagerImpl 中有一个 main_thread_only 的数据结构，main_thread_only 的意思是他只能被执行 RunLoop::Run()的线程访问。thread 模型是这样的：thread 的线程执行 RunLoop.run()，不停的执行任务队列中的 task，其他线程则往 thread 中 post task。</p><p>接下来简要分析 SequenceManagerImpl 中重要的数据。</p><p>首先是 MainThreadOnly，SequenceManagerImpl 中有 MainThreadOnly 类型的对象，MainThreadOnly 的含义上面已经说了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MainThreadOnly</span> &#123;</span><br><span class="line">...</span><br><span class="line">    internal::TaskQueueSelector selector;</span><br><span class="line">...</span><br><span class="line">    std::unique_ptr&lt;WakeUpQueue&gt; wake_up_queue;</span><br><span class="line">    std::unique_ptr&lt;WakeUpQueue&gt; non_waking_wake_up_queue;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// List of task queues managed by this SequenceManager.</span></span><br><span class="line">    <span class="comment">// - active_queues contains queues that are still running tasks.</span></span><br><span class="line">    <span class="comment">//   Most often they are owned by relevant TaskQueues, but</span></span><br><span class="line">    <span class="comment">//   queues_to_gracefully_shutdown_ are included here too.</span></span><br><span class="line">    <span class="comment">// - queues_to_gracefully_shutdown contains queues which should be deleted</span></span><br><span class="line">    <span class="comment">//   when they become empty.</span></span><br><span class="line">    <span class="comment">// - queues_to_delete contains soon-to-be-deleted queues, because some</span></span><br><span class="line">    <span class="comment">//   internal scheduling code does not expect queues to be pulled</span></span><br><span class="line">    <span class="comment">//   from underneath.</span></span><br><span class="line"></span><br><span class="line">    std::set&lt;internal::TaskQueueImpl*&gt; active_queues;</span><br><span class="line"></span><br><span class="line">    std::map&lt;internal::TaskQueueImpl*, std::unique_ptr&lt;internal::TaskQueueImpl&gt;&gt;</span><br><span class="line">        queues_to_gracefully_shutdown;</span><br><span class="line">    std::map&lt;internal::TaskQueueImpl*, std::unique_ptr&lt;internal::TaskQueueImpl&gt;&gt;</span><br><span class="line">        queues_to_delete;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>TaskQueueSelector 用于选择 TaskQueue，一个 SequenceManager 可以管理多个 TaskQueue，当 SequenceManager 希望执行任务时，需要决定从哪个 TaskQueue 中取任务</p><p>WakeUpQueue 用于 TaskQueue 给持有 SequenceManager 的线程设置唤醒时间，当 TaskQueue 发送一个 dealyed task 时可能会往 WakeUpQueue 发送一个唤醒时间，指示 main thread 在指定时间后唤醒</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BASE_EXPORT</span> SequenceManagerImpl &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="type">const</span> std::unique_ptr&lt;internal::ThreadController&gt; controller_;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  AtomicFlagSet empty_queues_to_reload_;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SequenceManagerImpl 中持有 ThreadController，但是调用顺序却是 ThreadController 调用 SequenceManagerImpl，后面会看到 ThreadController 会被保存在 thread local storage 中被 RunLoop 类取得。</p><h3 id="从-SequenceManager-创建-TaskQueue"><a href="#从-SequenceManager-创建-TaskQueue" class="headerlink" title="从 SequenceManager 创建 TaskQueue"></a>从 SequenceManager 创建 TaskQueue</h3><p>先通过 SequenceManagerImpl::CreateTaskQueueImpl 创建 TaskQueueImpl，然后通过 TaskQueueImpl 创建 TaskQueue。TaskQueueImpl 和 TaskQueue 不是继承关系，TaskQueue 类里面有一个成员 <code>std::unique_ptr&lt;internal::TaskQueueImpl&gt; impl_;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_refptr&lt;TaskQueue&gt; <span class="title">SequenceManagerImpl::CreateTaskQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TaskQueue::Spec&amp; spec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WrapRefCounted</span>(<span class="keyword">new</span> <span class="built_in">TaskQueue</span>(<span class="built_in">CreateTaskQueueImpl</span>(spec), spec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TaskQueue::Spec 类如下，暂时不用管</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Spec</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">bool</span> should_monitor_quiescence = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> should_notify_observers = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> delayed_fence_allowed = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> non_waking = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="创建-TaskQueueImpl"><a href="#创建-TaskQueueImpl" class="headerlink" title="创建 TaskQueueImpl"></a>创建 TaskQueueImpl</h4><p>主线程通过 SequenceManagerImpl 管理 TaskQueueImpl，其他线程通过 TaskQueueImpl 往主线程 post task。</p><p>创建好 TaskQueueImpl 后会把他加到 SequenceManagerImpl 的 main_thread_only().active_queues 和 main_thread_only().selector，后面 SequenceManagerImpl 取 task 时会通过 main_thread_only().selector 从 TaskQueueImpl 中取任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;internal::TaskQueueImpl&gt;</span></span><br><span class="line"><span class="function"><span class="title">SequenceManagerImpl::CreateTaskQueueImpl</span><span class="params">(<span class="type">const</span> TaskQueue::Spec&amp; spec)</span> </span>&#123;</span><br><span class="line">  std::unique_ptr&lt;internal::TaskQueueImpl&gt; task_queue =</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;internal::TaskQueueImpl&gt;(</span><br><span class="line">          <span class="keyword">this</span>,</span><br><span class="line">          spec.non_waking ? <span class="built_in">main_thread_only</span>().non_waking_wake_up_queue.<span class="built_in">get</span>()</span><br><span class="line">                          : <span class="built_in">main_thread_only</span>().wake_up_queue.<span class="built_in">get</span>(),</span><br><span class="line">          spec);</span><br><span class="line">  <span class="built_in">main_thread_only</span>().active_queues.<span class="built_in">insert</span>(task_queue.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">main_thread_only</span>().selector.<span class="built_in">AddQueue</span>(task_queue.<span class="built_in">get</span>());</span><br><span class="line">  <span class="keyword">return</span> task_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TaskQueueImpl 有以下重要数据结构</p><p>在 MainThreadOnly 中的</p><ul><li>delayed_work_queue</li><li>immediate_work_queue</li><li>delayed_incoming_queue</li></ul><p>在 AnyThread 中的</p><ul><li>immediate_incoming_queue</li></ul><p>其他线程往 TaskQueueImpl 中 post task 时，只能送到 AnyThread 的 immediate_incoming_queue，送完之后会根据 task 类型，比如是否 delay，来通知 main thread 处理这个 task，注意这里不是执行 task，而是把 immediate_incoming_queue 中刚刚到送入的 task 移到 MainThreadOnly 中的 queue，执行 task 则有其他的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BASE_EXPORT</span> TaskQueueImpl &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">MainThreadOnly</span> &#123;</span><br><span class="line">...</span><br><span class="line">    std::unique_ptr&lt;WorkQueue&gt; delayed_work_queue;</span><br><span class="line">    std::unique_ptr&lt;WorkQueue&gt; immediate_work_queue;</span><br><span class="line">    DelayedIncomingQueue delayed_incoming_queue;</span><br><span class="line">...</span><br><span class="line">    <span class="type">bool</span> is_enabled = <span class="literal">true</span>;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// Last reported wake up, used only in UpdateWakeUp to avoid</span></span><br><span class="line">    <span class="comment">// excessive calls.</span></span><br><span class="line">    absl::optional&lt;WakeUp&gt; scheduled_wake_up;</span><br><span class="line">...</span><br><span class="line">  &#125;;</span><br><span class="line">...</span><br><span class="line">  <span class="type">const</span> raw_ptr&lt;SequenceManagerImpl&gt; sequence_manager_;</span><br><span class="line"></span><br><span class="line">  scoped_refptr&lt;AssociatedThreadId&gt; associated_thread_;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> scoped_refptr&lt;GuardedTaskPoster&gt; task_poster_;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AnyThread</span> &#123;</span><br><span class="line">...</span><br><span class="line">    TaskDeque immediate_incoming_queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// True if main_thread_only().immediate_work_queue is empty.</span></span><br><span class="line">    <span class="type">bool</span> immediate_work_queue_empty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> post_immediate_task_should_schedule_work = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> unregistered = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  &#125;;</span><br><span class="line">...</span><br><span class="line">  AtomicFlagSet::AtomicFlag empty_queues_to_reload_handle_;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从 TaskQueueImpl 构造函数可知，TaskQueueImpl 中有 SequenceManagerImpl 指针，SequenceManagerImpl 中的 WakeUpQueue，还把 SequenceManagerImpl 中的 <code>empty_queues_to_reload_</code> 设到了 <code>empty_queues_to_reload_handle_</code>（这个和 main thread 唤醒有关，后面再分析）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TaskQueueImpl::<span class="built_in">TaskQueueImpl</span>(SequenceManagerImpl* sequence_manager,</span><br><span class="line">                             WakeUpQueue* wake_up_queue,</span><br><span class="line">                             <span class="type">const</span> TaskQueue::Spec&amp; spec)</span><br><span class="line">    : <span class="built_in">name_</span>(spec.name),</span><br><span class="line">      <span class="built_in">sequence_manager_</span>(sequence_manager),</span><br><span class="line">      <span class="built_in">associated_thread_</span>(sequence_manager</span><br><span class="line">                             ? sequence_manager-&gt;<span class="built_in">associated_thread</span>()</span><br><span class="line">                             : AssociatedThreadId::<span class="built_in">CreateBound</span>()),</span><br><span class="line">      <span class="built_in">task_poster_</span>(<span class="built_in">MakeRefCounted</span>&lt;GuardedTaskPoster&gt;(<span class="keyword">this</span>)),</span><br><span class="line">      <span class="built_in">main_thread_only_</span>(<span class="keyword">this</span>, wake_up_queue),</span><br><span class="line">      <span class="built_in">empty_queues_to_reload_handle_</span>(</span><br><span class="line">          sequence_manager</span><br><span class="line">              ? sequence_manager-&gt;<span class="built_in">GetFlagToRequestReloadForEmptyQueue</span>(<span class="keyword">this</span>)</span><br><span class="line">              : AtomicFlagSet::<span class="built_in">AtomicFlag</span>()),</span><br><span class="line">      <span class="built_in">should_monitor_quiescence_</span>(spec.should_monitor_quiescence),</span><br><span class="line">      <span class="built_in">should_notify_observers_</span>(spec.should_notify_observers),</span><br><span class="line">      <span class="built_in">delayed_fence_allowed_</span>(spec.delayed_fence_allowed) &#123;</span><br><span class="line">  <span class="built_in">UpdateCrossThreadQueueStateLocked</span>();</span><br><span class="line">  <span class="comment">// SequenceManager can&#x27;t be set later, so we need to prevent task runners</span></span><br><span class="line">  <span class="comment">// from posting any tasks.</span></span><br><span class="line">  <span class="keyword">if</span> (sequence_manager_)</span><br><span class="line">    task_poster_-&gt;<span class="built_in">StartAcceptingOperations</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建-TaskQueue"><a href="#创建-TaskQueue" class="headerlink" title="创建 TaskQueue"></a>创建 TaskQueue</h4><p>创建 TaskQueueImpl 后就可以创建 TaskQueue 了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span>&#123;</span><br><span class="line">...</span><br><span class="line">  std::unique_ptr&lt;internal::TaskQueueImpl&gt; impl_;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> WeakPtr&lt;internal::SequenceManagerImpl&gt; sequence_manager_;</span><br><span class="line"></span><br><span class="line">  scoped_refptr&lt;internal::AssociatedThreadId&gt; associated_thread_;</span><br><span class="line">  scoped_refptr&lt;SingleThreadTaskRunner&gt; default_task_runner_;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TaskQueue::<span class="built_in">TaskQueue</span>(std::unique_ptr&lt;internal::TaskQueueImpl&gt; impl,</span><br><span class="line">                     <span class="type">const</span> TaskQueue::Spec&amp; spec)</span><br><span class="line">    : <span class="built_in">impl_</span>(std::<span class="built_in">move</span>(impl)),</span><br><span class="line">      <span class="built_in">sequence_manager_</span>(impl_ ? impl_-&gt;<span class="built_in">GetSequenceManagerWeakPtr</span>() : <span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">associated_thread_</span>((impl_ &amp;&amp; impl_-&gt;<span class="built_in">sequence_manager</span>())</span><br><span class="line">                             ? impl_-&gt;<span class="built_in">sequence_manager</span>()-&gt;<span class="built_in">associated_thread</span>()</span><br><span class="line">                             : <span class="built_in">MakeRefCounted</span>&lt;internal::AssociatedThreadId&gt;()),</span><br><span class="line">      <span class="built_in">default_task_runner_</span>(impl_ ? impl_-&gt;<span class="built_in">CreateTaskRunner</span>(kTaskTypeNone)</span><br><span class="line">                                 : <span class="built_in">CreateNullTaskRunner</span>()),</span><br><span class="line">      <span class="built_in">name_</span>(impl_ ? impl_-&gt;<span class="built_in">GetName</span>() : <span class="string">&quot;&quot;</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>TaskQueue 的构造函数还创建了 <code>default_task_runner_</code>，<code>default_task_runner_</code> 是其他线程和 main thread 之间通信的桥梁，其他线程通过 <code>default_task_runner_</code> 往 main thread 中 post task。<code>default_task_runner_</code> 是对 TaskQueueImpl 中的 <code>task_poster_</code> 的包装</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_refptr&lt;SingleThreadTaskRunner&gt; <span class="title">TaskQueueImpl::CreateTaskRunner</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskType task_type)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MakeRefCounted</span>&lt;TaskRunner&gt;(task_poster_, associated_thread_,</span><br><span class="line">                                    task_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TaskQueue 的 task_runner()方法返回的就是上面创建的 <code>default_task_runner_</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default task runner which doesn&#x27;t annotate tasks with a task type.</span></span><br><span class="line"><span class="function"><span class="type">const</span> scoped_refptr&lt;SingleThreadTaskRunner&gt;&amp; <span class="title">TaskQueue::task_runner</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> default_task_runner_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对-SequenceManager-进行初始化"><a href="#对-SequenceManager-进行初始化" class="headerlink" title="对 SequenceManager 进行初始化"></a>对 SequenceManager 进行初始化</h3><h4 id="SetDefaultTaskRunner"><a href="#SetDefaultTaskRunner" class="headerlink" title="SetDefaultTaskRunner"></a>SetDefaultTaskRunner</h4><p>SetDefaultTaskRunner 就是设置 main thread 的 TaskRunner，这个函数应该在 main thread 中调用，因为会使用 thread local storage</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SequenceManagerImpl::SetDefaultTaskRunner</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;SingleThreadTaskRunner&gt; task_runner)</span> </span>&#123;</span><br><span class="line">  controller_-&gt;<span class="built_in">SetDefaultTaskRunner</span>(task_runner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是把 task_runner 设给 ThreadControllerWithMessagePumpImpl，InitializeThreadTaskRunnerHandle()函数这里不会调用，因为此时 <code>associated_thread_</code> 还没有进行 bind，InitializeThreadTaskRunnerHandle 会在后面执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadControllerWithMessagePumpImpl::SetDefaultTaskRunner</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;SingleThreadTaskRunner&gt; task_runner)</span> </span>&#123;</span><br><span class="line">  base::<span class="function">internal::CheckedAutoLock <span class="title">lock</span><span class="params">(task_runner_lock_)</span></span>;</span><br><span class="line">  task_runner_ = task_runner;</span><br><span class="line">  <span class="keyword">if</span> (associated_thread_-&gt;<span class="built_in">IsBound</span>()) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(associated_thread_-&gt;<span class="built_in">IsBoundToCurrentThread</span>());</span><br><span class="line">    <span class="comment">// Thread task runner handle will be created in BindToCurrentThread().</span></span><br><span class="line">    <span class="built_in">InitializeThreadTaskRunnerHandle</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BindToMessagePump"><a href="#BindToMessagePump" class="headerlink" title="BindToMessagePump"></a>BindToMessagePump</h4><p>这里是将 MessagePump 绑定到 SequenceManager。</p><p>这里同样要求在 main thread 中执行。</p><p>之前说过，RunLoop 在调用中间通过 MessagePump 从 SequenceManager 中取任务，MessagePump 后面介绍 RunLoop 时再说</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SequenceManagerImpl::BindToMessagePump</span><span class="params">(std::unique_ptr&lt;MessagePump&gt; pump)</span> </span>&#123;</span><br><span class="line">  controller_-&gt;<span class="built_in">BindToCurrentThread</span>(std::<span class="built_in">move</span>(pump));</span><br><span class="line">  <span class="built_in">CompleteInitializationOnBoundThread</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面函数会将 <code>associated_thread_</code> 进行绑定，然后将 message_pump 移动到 ThreadController 中，此后 ThreadController 持有 message_pump，RunLoop 会先调用到 ThreadController，ThreadController 再调用到 message_pump，message_pump 又调用 ThreadController，ThreadController 再调用 SequenceManager。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadControllerWithMessagePumpImpl::BindToCurrentThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;MessagePump&gt; message_pump)</span> </span>&#123;</span><br><span class="line">  associated_thread_-&gt;<span class="built_in">BindToCurrentThread</span>();</span><br><span class="line">  pump_ = std::<span class="built_in">move</span>(message_pump);</span><br><span class="line">  work_id_provider_ = WorkIdProvider::<span class="built_in">GetForCurrentThread</span>();</span><br><span class="line">  RunLoop::<span class="built_in">RegisterDelegateForCurrentThread</span>(<span class="keyword">this</span>);</span><br><span class="line">  scoped_set_sequence_local_storage_map_for_current_thread_ = std::<span class="built_in">make_unique</span>&lt;</span><br><span class="line">      base::internal::ScopedSetSequenceLocalStorageMapForCurrentThread&gt;(</span><br><span class="line">      &amp;sequence_local_storage_map_);</span><br><span class="line">  &#123;</span><br><span class="line">    base::<span class="function">internal::CheckedAutoLock <span class="title">task_runner_lock</span><span class="params">(task_runner_lock_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (task_runner_)</span><br><span class="line">      <span class="built_in">InitializeThreadTaskRunnerHandle</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (work_deduplicator_.<span class="built_in">BindToCurrentThread</span>() ==</span><br><span class="line">      ShouldScheduleWork::kScheduleImmediate) &#123;</span><br><span class="line">    pump_-&gt;<span class="built_in">ScheduleWork</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssociatedThreadId::BindToCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO(altimin): Remove this after MessageLoopImpl is gone and</span></span><br><span class="line">  <span class="comment">// initialisation is simplified.</span></span><br><span class="line">  <span class="keyword">auto</span> current_thread_id = PlatformThread::<span class="built_in">CurrentId</span>();</span><br><span class="line">  [[maybe_unused]] <span class="keyword">auto</span> prev_thread_id =</span><br><span class="line">      thread_id_.<span class="built_in">exchange</span>(current_thread_id, std::memory_order_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面还通过 RunLoop::RegisterDelegateForCurrentThread 将当前 ThreadControllerWithMessagePumpImpl 传到一个 thread_local 的指针中。</p><p>后面创建 RunLoop 实例时会获得这个指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunLoop::RegisterDelegateForCurrentThread</span><span class="params">(Delegate* delegate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Bind |delegate| to this thread.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(!delegate-&gt;bound_);</span><br><span class="line">  <span class="built_in">DCHECK_CALLED_ON_VALID_THREAD</span>(delegate-&gt;bound_thread_checker_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// There can only be one RunLoop::Delegate per thread.</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(!<span class="built_in">GetTlsDelegate</span>().<span class="built_in">Get</span>())</span><br><span class="line">      &lt;&lt; <span class="string">&quot;Error: Multiple RunLoop::Delegates registered on the same thread.\n\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Hint: You perhaps instantiated a second &quot;</span></span><br><span class="line">         <span class="string">&quot;MessageLoop/TaskEnvironment on a thread that already had one?&quot;</span>;</span><br><span class="line">  <span class="built_in">GetTlsDelegate</span>().<span class="built_in">Set</span>(delegate);</span><br><span class="line">  delegate-&gt;bound_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 BindToMessagePump 的最后，由于 <code>task_runner_</code> 之前在 ThreadControllerWithMessagePumpImpl::SetDefaultTaskRunner 中已经被设置了，所以会执行 InitializeThreadTaskRunnerHandle()。</p><p>InitializeThreadTaskRunnerHandle()中会创建 ThreadTaskRunnerHandle，而 ThreadTaskRunnerHandle 的构造函数中会将自己保存在一个 thread_local 的变量中，将来可以在 main thread 中通过 ThreadTaskRunnerHandle::Get()获得该 ThreadTaskRunnerHandle</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadControllerWithMessagePumpImpl::InitializeThreadTaskRunnerHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Only one ThreadTaskRunnerHandle can exist at any time,</span></span><br><span class="line">  <span class="comment">// so reset the old one.</span></span><br><span class="line">  <span class="built_in">main_thread_only</span>().thread_task_runner_handle.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="built_in">main_thread_only</span>().thread_task_runner_handle =</span><br><span class="line">      std::<span class="built_in">make_unique</span>&lt;ThreadTaskRunnerHandle&gt;(task_runner_);</span><br><span class="line">  <span class="comment">// When the task runner is known, bind the power manager. Power notifications</span></span><br><span class="line">  <span class="comment">// are received through that sequence.</span></span><br><span class="line">  power_monitor_.<span class="built_in">BindToCurrentThread</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CompleteInitializationOnBoundThread"><a href="#CompleteInitializationOnBoundThread" class="headerlink" title="CompleteInitializationOnBoundThread"></a>CompleteInitializationOnBoundThread</h5><p>这里将 SequenceManagerImpl 设在一个 thread local storage 中。所以 ThreadControllerWithMessagePumpImpl 和 SequenceManagerImpl 都被保存在 thread local storage 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SequenceManagerImpl::CompleteInitializationOnBoundThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  controller_-&gt;<span class="built_in">AddNestingObserver</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">main_thread_only</span>().nesting_observer_registered_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">GetMessagePump</span>()) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!<span class="built_in">GetTLSSequenceManagerImpl</span>()-&gt;<span class="built_in">Get</span>())</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Can&#x27;t register a second SequenceManagerImpl on the same thread.&quot;</span>;</span><br><span class="line">    <span class="built_in">GetTLSSequenceManagerImpl</span>()-&gt;<span class="built_in">Set</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MessagePump* <span class="title">SequenceManagerImpl::GetMessagePump</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> controller_-&gt;<span class="built_in">GetBoundMessagePump</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">base::ThreadLocalPointer&lt;internal::SequenceManagerImpl&gt;*</span></span><br><span class="line"><span class="function"><span class="title">GetTLSSequenceManagerImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> NoDestructor&lt;ThreadLocalPointer&lt;internal::SequenceManagerImpl&gt;&gt;</span><br><span class="line">      lazy_tls_ptr;</span><br><span class="line">  <span class="keyword">return</span> lazy_tls_ptr.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这篇文章重点介绍了 SequenceManagerImpl、ThreadControllerWithMessagePumpImpl、TaskQueueImpl 的创建以及相互之间的持有关系，下篇文章分析往 TaskQueueImpl 中 post task 的过程。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium base库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记libc++ std::bind的一个bug</title>
      <link href="/2023/06/05/%E8%AE%B0libc-std-bind%E7%9A%84%E4%B8%80%E4%B8%AAbug/"/>
      <url>/2023/06/05/%E8%AE%B0libc-std-bind%E7%9A%84%E4%B8%80%E4%B8%AAbug/</url>
      
        <content type="html"><![CDATA[<p>之前在读 libc++ 的 std::bind 源码时，偶然发现了一个 bug。</p><p>先上验证代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">some_class</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span>)</span> &amp;&amp; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> &amp; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    some_class obj;</span><br><span class="line">    <span class="keyword">auto</span> tmp = std::<span class="built_in">bind</span>(obj);</span><br><span class="line">    <span class="built_in">tmp</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码用 GCC 和 Clang 编译时有不同的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ tmp.cpp -o main -stdlib=libc++</span><br><span class="line">tmp.cpp:16:5: error: no matching <span class="keyword">function</span> <span class="keyword">for</span> call to object of <span class="built_in">type</span> <span class="string">&#x27;__bind&lt;some_class &amp;&gt;&#x27;</span> </span><br><span class="line">    tmp(); </span><br><span class="line">    ^~~ </span><br><span class="line">/usr/bin/../include/c++/v1/__functional/bind.h:293:9: note: candidate template ignored: substitution failure [with _Args = &lt;&gt;]: i</span><br><span class="line">mplicit instantiation of undefined template <span class="string">&#x27;std::__bind_return&lt;some_class, std::tuple&lt;&gt;, std::tuple&lt;&gt;, false&gt;&#x27;</span> </span><br><span class="line">        operator()(_Args&amp;&amp; ...__args) </span><br><span class="line">        ^ </span><br><span class="line">/usr/bin/../include/c++/v1/__functional/bind.h:302:9: note: candidate template ignored: substitution failure [with _Args = &lt;&gt;]: i</span><br><span class="line">mplicit instantiation of undefined template <span class="string">&#x27;std::__bind_return&lt;const some_class, const std::tuple&lt;&gt;, std::tuple&lt;&gt;, false&gt;&#x27;</span> </span><br><span class="line">        operator()(_Args&amp;&amp; ...__args) const </span><br><span class="line">        ^ </span><br><span class="line">1 error generated.</span><br><span class="line">$ g++ tmp.cpp -o main <span class="comment"># works normally</span></span><br></pre></td></tr></table></figure><p>GCC 能够正常编译，Clang 会报错。</p><p>接下来就分析一下为什么 Clang 会报错。</p><p>首先请注意，上面 some_class 的 operator()()函数对于左值和右值版本有不同的函数签名，这是有意为之的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span>)</span> &amp;&amp;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> &amp;</span>;</span><br></pre></td></tr></table></figure><p>根据 bind 函数的定义，<code>auto tmp = std::bind(obj);</code> 执行时，会返回 <code>__bind</code> 类型的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Fp, <span class="keyword">class</span> ..._BoundArgs&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> </span></span><br><span class="line"><span class="function">__bind&lt;_Fp, _BoundArgs...&gt;</span></span><br><span class="line"><span class="function"><span class="title">bind</span><span class="params">(_Fp&amp;&amp; __f, _BoundArgs&amp;&amp;... __bound_args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __bind&lt;_Fp, _BoundArgs...&gt; type;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(_VSTD::forward&lt;_Fp&gt;(__f), _VSTD::forward&lt;_BoundArgs&gt;(__bound_args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>__bind</code> 类型定义了 operator()()函数，上面的 <code>tmp();</code> 就是调用了 <code>__bind</code> 类型的 operator()()函数，这里不考虑 const 版本的 operator()()函数，因为上面的 <code>tmp</code> 变量不是 const 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> __bind_return&lt;_Fd, _Td, tuple&lt;_Args&amp;&amp;...&gt; &gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(_Args&amp;&amp; ...__args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _VSTD::__apply_functor(__f_, __bound_args_, __indices(),</span><br><span class="line">                              <span class="built_in">tuple</span>&lt;_Args&amp;&amp;...&gt;(_VSTD::forward&lt;_Args&gt;(__args)...));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> __bind_return&lt;<span class="type">const</span> _Fd, <span class="type">const</span> _Td, tuple&lt;_Args&amp;&amp;...&gt; &gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(_Args&amp;&amp; ...__args)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _VSTD::__apply_functor(__f_, __bound_args_, __indices(),</span><br><span class="line">                               <span class="built_in">tuple</span>&lt;_Args&amp;&amp;...&gt;(_VSTD::forward&lt;_Args&gt;(__args)...));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 <code>operator()()</code> 函数中，有两部分需要关注，第一个是 <code>__bind_return</code>，这个模板不仅会提供返回值类型，还会对 <code>operator()()</code> 函数是否可以调用进行检查，第二个是 <code>__apply_functor</code>，这个模板做真正的函数执行，后面会看到上面 sample code 的错误就是因为这两个模板的出现了不一致。</p><p>先看 <code>__bind_return</code>，这个模板通过 <code>__is_valid_bind_return</code> 对 <code>_Fp</code> 和 <code>_BoundArgs</code> 是否可以调用进行检查</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> <span class="title class_">_BoundArgs</span>, <span class="keyword">class</span> <span class="title class_">_TupleUj</span>,</span><br><span class="line">          <span class="type">bool</span> = __is_valid_bind_return&lt;_Fp, _BoundArgs, _TupleUj&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> __bind_return;</span><br></pre></td></tr></table></figure><p><code>__is_valid_bind_return</code> 内部会通过 <code>__invokable</code> 进行检查，这里先不看 <code>__invokable</code>，只需要注意这里传给 <code>__invokable</code> 的 <code>_Fp</code> 参数是 <code>__bind</code> 里的 <code>_Fd</code> 类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._BoundArgs, <span class="keyword">class</span> <span class="title class_">_TupleUj</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_valid_bind_return</span>&lt;_Fp, tuple&lt;_BoundArgs...&gt;, _TupleUj&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = __invokable&lt;_Fp,</span><br><span class="line">                    <span class="keyword">typename</span> __mu_return&lt;_BoundArgs, _TupleUj&gt;::type...&gt;::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来再看 <code>__apply_functor</code>，注意下面形参是 <code>_Fp&amp;</code>，而实参是 <code>__bind</code> 里的 <code>__f_</code>，<code>__f_</code> 的类型是 <code>_Fd</code>，所以 <code>__f</code> 是左值引用类型，即 <code>_Fd&amp;</code>，下面传给 <code>__invoke</code> 的类型也是 <code>_Fd&amp;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> <span class="title class_">_BoundArgs</span>, <span class="type">size_t</span> ..._Indx, <span class="keyword">class</span> <span class="title class_">_Args</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="keyword">typename</span> __bind_return&lt;_Fp, _BoundArgs, _Args&gt;::type</span><br><span class="line">__apply_functor(_Fp&amp; __f, _BoundArgs&amp; __bound_args, __tuple_indices&lt;_Indx...&gt;,</span><br><span class="line">                _Args&amp;&amp; __args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _VSTD::__invoke(__f, _VSTD::__mu(_VSTD::<span class="built_in">get</span>&lt;_Indx&gt;(__bound_args), __args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再看上面的 <code>__invokable</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._Args&gt;</span><br><span class="line"><span class="keyword">using</span> __invokable = __invokable_r&lt;<span class="type">void</span>, _Fp, _Args...&gt;;</span><br></pre></td></tr></table></figure><p><code>__invokable</code> 是在 <code>__invokable_r</code> 基础上进行定义的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>, <span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__invokable_r</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = type::value;</span><br><span class="line">  <span class="keyword">using</span> type =</span><br><span class="line">  <span class="keyword">typename</span> conditional&lt;</span><br><span class="line">      _IsNotSame&lt;_Result, __nat&gt;::value,</span><br><span class="line">      <span class="keyword">typename</span> conditional&lt;</span><br><span class="line">          is_void&lt;_Ret&gt;::value,</span><br><span class="line">          true_type,</span><br><span class="line">          is_convertible&lt;_Result, _Ret&gt;</span><br><span class="line">      &gt;::type,</span><br><span class="line">      false_type</span><br><span class="line">  &gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> _Result = <span class="keyword">decltype</span>(__try_call&lt;_Fp, _Args...&gt;(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_XFp</span>, <span class="keyword">class</span> ..._XArgs&gt;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">auto</span> __try_call(<span class="type">int</span>) -&gt; <span class="keyword">decltype</span>(</span><br><span class="line">    _VSTD::__invoke(_VSTD::<span class="built_in">declval</span>&lt;_XFp&gt;(), _VSTD::<span class="built_in">declval</span>&lt;_XArgs&gt;()...));</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_XFp</span>, <span class="keyword">class</span> ..._XArgs&gt;</span><br><span class="line">  <span class="type">static</span> __nat __try_call(...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__invokable_r</code> 会对 <code>_Fp</code> 是否能接受 <code>_Args</code> 为参数进行检查。</p><p>如果可以调用，那么 <code>__invokable_r::type</code> 为 true，否则为 false，要让 <code>__invokable_r::type</code> 为 true，需要满足 <code>_Result</code> 不为 <code>__nat</code> 类型，并且要么 <code>_Ret</code> 为 void，要么 <code>_Result</code> 能够转换为 <code>_Ret</code>，也就是要求返回值有效。</p><p>要求 <code>_Result</code> 不为 <code>__nat</code> 类型，而 <code>_Result</code> 来自 <code>__try_call</code> 函数的返回值，<code>__try_call</code> 有两个版本，第一个版本接受 int 参数，第二个接受任意参数，第二个版本的返回值就是 <code>__nat</code>，而 <code>_Result</code> 的 <code>decltype</code> 里面调用 <code>__try_call</code> 的参数是 0，所以优先匹配 <code>__try_call(int)</code>，那么要求 <code>_Result</code> 不为 <code>__nat</code> 类型，就是要求 <code>__try_call(int)</code> 调用不能失败，在 <code>__try_call(int)</code> 中，进行了下面的调用检查，也是通过 <code>__invoke</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_VSTD::__invoke(_VSTD::<span class="built_in">declval</span>&lt;_XFp&gt;(), _VSTD::<span class="built_in">declval</span>&lt;_XArgs&gt;()...)</span><br></pre></td></tr></table></figure><p><code>_XFp</code>，<code>_XArgs</code> 就是 <code>_Fp</code>，<code>_Args</code></p><p>上面说过，传给 <code>__invokable</code> 的 <code>_Fp</code> 参数是 <code>__bind</code> 里的 <code>_Fd</code> 类型，而 <code>__invokable</code> 里面调用 <code>__invokable_r</code> 时使用的是自己的 <code>_Fp</code>，也就是 <code>_Fd</code> 类型，最终上面 <code>__try_call</code> 里的 <code>_XFp</code> 就是 <code>_Fd</code> 类型，但是 <code>__try_call</code> 里面在调用 <code>__invoke</code> 时，还进行了一个 declval 操作，这个模板会为输入的类型加上&amp;&amp;，那么最终上面调用 <code>__invoke</code> 时的 functor 的类型就是 <code>_Fd&amp;&amp;</code>，这和 <code>__apply_functor</code> 里的 <code>__invoke</code> 的类型不一致，<code>__apply_functor</code> 里用的是 <code>_Fd&amp;</code></p><p>分析清楚了这一点，我们就知道为什么上面的 sample code 会报错了，sample code 故意定义了形参不同的 operator()()函数，而 libc++ 的 bind 在 <code>__bind_return</code> 检查时使用的是右值的版本，而真正调用时使用的是左值版本，当右值和左值的 operator()()函数的形参不一致时，<code>__bind_return</code> 会错误的排除某些模板。比如上面 <code>tmp();</code> 语句执行时没有给 tmp 传参数，这在左值版本是允许的，而右值版本是不允许的，所以 <code>__bind_return</code> 会报错。</p><p>其实这个问题在 libc++ 中已经被注意到了。在 function 模板中有以下模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>&gt;</span><br><span class="line">  <span class="keyword">using</span> _EnableIfLValueCallable = <span class="keyword">typename</span> enable_if&lt;__callable&lt;_Fp&amp;&gt;::value&gt;::type;</span><br></pre></td></tr></table></figure><p>他明确的说了 LValue Callable，也就是左值可调用，而且显式的在后面使用了 <code>_Fp&amp;</code>。</p><p>但是在 bind 中上面说的问题依然存在，这个问题已经给 llvm 提了 issue <a href="https://github.com/llvm/llvm-project/issues/62864">https://github.com/llvm/llvm-project/issues/62864</a>。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++标准库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 标准库之 function</title>
      <link href="/2023/05/28/C-%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B-function/"/>
      <url>/2023/05/28/C-%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B-function/</url>
      
        <content type="html"><![CDATA[<p>这篇文章接着上一篇分析 function。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>function 可以把函数、可调用对象等包装为新的可调用对象。还是先看例子（来自 cppreference）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">int</span> num) : <span class="built_in">num_</span>(num) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print_add</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; num_+i &lt;&lt; <span class="string">&#x27;&lt;strong&gt;\n&lt;/strong&gt;&#x27;</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> num_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_num</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;&lt;strong&gt;\n&lt;/strong&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PrintNum</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;&lt;strong&gt;\n&lt;/strong&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// store a free function</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f_display = print_num;</span><br><span class="line">    <span class="built_in">f_display</span>(<span class="number">-9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store a lambda</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; f_display_42 = []() &#123; <span class="built_in">print_num</span>(<span class="number">42</span>); &#125;;</span><br><span class="line">    <span class="built_in">f_display_42</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store the result of a call to std::bind</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; f_display_31337 = std::<span class="built_in">bind</span>(print_num, <span class="number">31337</span>);</span><br><span class="line">    <span class="built_in">f_display_31337</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store a call to a member function</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">const</span> Foo&amp;, <span class="type">int</span>)&gt; f_add_display = &amp;Foo::print_add;</span><br><span class="line">    <span class="function"><span class="type">const</span> Foo <span class="title">foo</span><span class="params">(<span class="number">314159</span>)</span></span>;</span><br><span class="line">    <span class="built_in">f_add_display</span>(foo, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">f_add_display</span>(<span class="number">314159</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store a call to a data member accessor</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(Foo <span class="type">const</span>&amp;)&gt; f_num = &amp;Foo::num_;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num_: &quot;</span> &lt;&lt; <span class="built_in">f_num</span>(foo) &lt;&lt; <span class="string">&#x27;&lt;strong&gt;\n&lt;/strong&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store a call to a member function and object using std::placeholders::_1;</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f_add_display2 = std::<span class="built_in">bind</span>( &amp;Foo::print_add, foo, _1 );</span><br><span class="line">    <span class="built_in">f_add_display2</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store a call to a member function and object ptr</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f_add_display3 = std::<span class="built_in">bind</span>( &amp;Foo::print_add, &amp;foo, _1 );</span><br><span class="line">    <span class="built_in">f_add_display3</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// store a call to a function object</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; f_display_obj = <span class="built_in">PrintNum</span>();</span><br><span class="line">    <span class="built_in">f_display_obj</span>(<span class="number">18</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> factorial = [](<span class="type">int</span> n) &#123;</span><br><span class="line">      <span class="comment">// store a lambda object to emulate &quot;recursive lambda&quot;; aware of extra overhead</span></span><br><span class="line">      std::function&lt;<span class="built_in">int</span>(<span class="type">int</span>)&gt; fac = [&amp;](<span class="type">int</span> n)&#123; <span class="built_in">return</span> (n &lt; <span class="number">2</span>) ? <span class="number">1</span> : n*<span class="built_in">fac</span>(n<span class="number">-1</span>); &#125;;</span><br><span class="line">      <span class="comment">// note that &quot;auto fac = [&amp;](int n)&#123;...&#125;;&quot; does not work in recursive calls</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">fac</span>(n);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i&#123;<span class="number">5</span>&#125;; i != <span class="number">8</span>; ++i) &#123; </span><br><span class="line">      std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; <span class="built_in">factorial</span>(i) &lt;&lt; <span class="string">&quot;;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，function 的实例可以存储、拷贝、调用任何可以拷贝构造的可调用对象：</p><ul><li>函数（会 decay 为函数指针）</li><li>lambda 表达式返回值</li><li>bind 函数返回值</li><li>重载了调用运算符的类的实例</li><li>类成员函数指针</li><li>类成员数据指针</li></ul><p>注意如果给 function 的参数是类成员函数指针，那么调用时第一个参数必须是对象，要满足类成员函数指针的调用要求。</p><h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p>先看 function 类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>&gt; <span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> function; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> function&lt;_Rp(_ArgTypes...)&gt;</span><br><span class="line">    : <span class="keyword">public</span> __function::__maybe_derive_from_unary_function&lt;_Rp(_ArgTypes...)&gt;,</span><br><span class="line">      <span class="keyword">public</span> __function::__maybe_derive_from_binary_function&lt;_Rp(_ArgTypes...)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_ABI_OPTIMIZED_FUNCTION</span></span><br><span class="line">    <span class="keyword">typedef</span> __function::__value_func&lt;_Rp(_ArgTypes...)&gt; __func;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> __function::__policy_func&lt;_Rp(_ArgTypes...)&gt; __func;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    __func __f_;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>function 只有 <code>function&lt;_Rp(_ArgTypes...)&gt;</code> 这个特化版本是有定义的，其他都是未定义的。</p><p>function 可以使用不同的 <code>__func</code>，这里先只分析 <code>__value_func</code> 作为 backend 的情况</p><h2 id="接受模板参数的构造函数"><a href="#接受模板参数的构造函数" class="headerlink" title="接受模板参数的构造函数"></a>接受模板参数的构造函数</h2><p>function 有一个接受模板参数的构造函数，正是这个构造函数，function 才能接受函数指针、lambda 表达式返回值、bind 返回值作为参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span>... _ArgTypes&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> = _EnableIfCallable&lt;_Fp&gt;&gt;</span><br><span class="line">function&lt;_Rp(_ArgTypes...)&gt;::<span class="built_in">function</span>(_Fp __f) : __f_(_VSTD::<span class="built_in">move</span>(__f)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>注意这个构造函数参数没有带引用，所以模板类型会推断为值类型，比如输入参数是一个函数名，<code>_Fp</code> 会推断为函数指针类型，比如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">function&lt;<span class="type">void</span>()&gt; func = f;</span><br></pre></td></tr></table></figure><p>输入参数是函数名，所以 <code>_Fp</code> 推断为函数指针。由于是传值，这里要发生值的构造，但如果传的参数是右值引用，实参是值类型，那么 <code>__f</code> 会发生移动构造。在构造 <code>__f_</code> 时，把实参 <code>__f</code> 进行了 move，所以构造 <code>__f_</code> 时传的是右值引用。</p><h3 id="EnableIfCallable"><a href="#EnableIfCallable" class="headerlink" title="_EnableIfCallable"></a>_EnableIfCallable</h3><p>看看 <code>_EnableIfCallable</code> 这个条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>&gt;</span><br><span class="line"><span class="keyword">using</span> _EnableIfCallable = <span class="keyword">typename</span> enable_if&lt;__callable&lt;_Fp&gt;::value&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="type">bool</span> = _And&lt;</span><br><span class="line">    _IsNotSame&lt;<span class="type">__uncvref_t</span>&lt;_Fp&gt;, function&gt;,</span><br><span class="line">    __invokable&lt;_Fp&amp;, _ArgTypes...&gt;</span><br><span class="line">&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> __callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__callable</span>&lt;_Fp, <span class="literal">true</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = is_same&lt;<span class="type">void</span>, _Rp&gt;::value ||</span><br><span class="line">            is_convertible&lt;<span class="keyword">typename</span> __invoke_of&lt;_Fp&amp;, _ArgTypes...&gt;::type,</span><br><span class="line">                           _Rp&gt;::value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__callable</span>&lt;_Fp, <span class="literal">false</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>他要求 <code>_Fp</code> 满足：首先 <code>_Fp</code> 不是当前 function 类型，并且对于给定 <code>_ArgTypes</code>，<code>_Fp&amp;</code> 可以调用，其次要求</p><p><code>_Rp</code> 是 void，或者 <code>_Fp</code> 的返回值可转换到 <code>_Rp</code> 类型。</p><p><code>__invokable</code> 在 bind 里面已经介绍过了，这次看看 <code>__invoke_of</code>：在 <code>__invokable</code> 满足的条件下，通过 <code>__invokable_r</code> 得到返回值，<code>__invokable_r</code> 在 bind 里面也介绍了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__invoke_of</span></span><br><span class="line">    : <span class="keyword">public</span> enable_if&lt;</span><br><span class="line">        __invokable&lt;_Fp, _Args...&gt;::value,</span><br><span class="line">        <span class="keyword">typename</span> __invokable_r&lt;<span class="type">void</span>, _Fp, _Args...&gt;::_Result&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="value-func-中接受右值引用的模板构造函数"><a href="#value-func-中接受右值引用的模板构造函数" class="headerlink" title="__value_func 中接受右值引用的模板构造函数"></a>__value_func 中接受右值引用的模板构造函数</h3><p>再看 function 内部的 <code>__f_</code>，<code>__f_</code> 是 <code>__function::__value_func</code> 类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span>... _ArgTypes&gt; <span class="keyword">class</span> <span class="title class_">__value_func</span>&lt;_Rp(_ArgTypes...)&gt;</span><br><span class="line">&#123;</span><br><span class="line">    _LIBCPP_SUPPRESS_DEPRECATED_PUSH</span><br><span class="line">    <span class="keyword">typename</span> aligned_storage&lt;<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">void</span>*)&gt;::type __buf_;</span><br><span class="line">    _LIBCPP_SUPPRESS_DEPRECATED_POP</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __base&lt;_Rp(_ArgTypes...)&gt; __func;</span><br><span class="line">    __func* __f_;</span><br><span class="line"></span><br><span class="line">    _LIBCPP_NO_CFI <span class="type">static</span> __func* __as_base(<span class="type">void</span>* __p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;__func*&gt;(__p);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>function 内部构造 <code>__value_func</code> 传的是右值引用，先看接受右值引用的模板构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>,</span><br><span class="line">    <span class="keyword">class</span> = <span class="keyword">typename</span> enable_if&lt;!is_same&lt;<span class="keyword">typename</span> decay&lt;_Fp&gt;::type, __value_func&gt;::value&gt;::type&gt;</span><br><span class="line">_LIBCPP_INLINE_VISIBILITY <span class="keyword">explicit</span> __value_func(_Fp&amp;&amp; __f)</span><br><span class="line">    : __value_func(_VSTD::forward&lt;_Fp&gt;(__f), <span class="built_in">allocator</span>&lt;_Fp&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>__value_func(_Fp&amp;&amp; __f)</code> 内部调用了 <code>__value_func(_Fp&amp;&amp; __f, const _Alloc&amp; __a)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line">_LIBCPP_INLINE_VISIBILITY __value_func(_Fp&amp;&amp; __f, <span class="type">const</span> _Alloc&amp; __a)</span><br><span class="line">    : __f_(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> allocator_traits&lt;_Alloc&gt; __alloc_traits;</span><br><span class="line">    <span class="keyword">typedef</span> __function::__func&lt;_Fp, _Alloc, _Rp(_ArgTypes...)&gt; _Fun;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __rebind_alloc_helper&lt;__alloc_traits, _Fun&gt;::type</span><br><span class="line">        _FunAlloc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__function::__not_null(__f))</span><br><span class="line">    &#123;</span><br><span class="line">        _FunAlloc __af(__a);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sizeof</span>(_Fun) &lt;= <span class="built_in">sizeof</span>(__buf_) &amp;&amp;</span><br><span class="line">            is_nothrow_copy_constructible&lt;_Fp&gt;::value &amp;&amp;</span><br><span class="line">            is_nothrow_copy_constructible&lt;_FunAlloc&gt;::value)</span><br><span class="line">        &#123;</span><br><span class="line">            __f_ =</span><br><span class="line">                ::<span class="built_in">new</span> ((<span class="type">void</span>*)&amp;__buf_) _Fun(_VSTD::<span class="built_in">move</span>(__f), _Alloc(__af));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">typedef</span> __allocator_destructor&lt;_FunAlloc&gt; _Dp;</span><br><span class="line">            unique_ptr&lt;__func, _Dp&gt; __hold(__af.<span class="built_in">allocate</span>(<span class="number">1</span>), _Dp(__af, <span class="number">1</span>));</span><br><span class="line">            ::<span class="keyword">new</span> ((<span class="type">void</span>*)__hold.<span class="built_in">get</span>()) _Fun(_VSTD::<span class="built_in">move</span>(__f), _Alloc(__a));</span><br><span class="line">            __f_ = __hold.<span class="built_in">release</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面函数中，真正存储可调用对象的是 <code>__function::__func&lt;_Fp, _Alloc, _Rp(_ArgTypes...)&gt;</code> 的实例。如果 <code>__function::__func</code> 的 size 较小，就使用 <code>__value_func</code> 内部的 <code>__buf_</code>，否则就新申请内存。</p><h4 id="function-func"><a href="#function-func" class="headerlink" title="__function::__func"></a>__function::__func</h4><p><code>__function::__func&lt;_Fp, _Alloc, _Rp(_ArgTypes...)&gt;</code> 继承 <code>__function::__base&lt;_Rp(_ArgTypes...)&gt;</code>，<code>__base</code> 是虚基类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>, <span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__func</span>&lt;_Fp, _Alloc, _Rp(_ArgTypes...)&gt;</span><br><span class="line">    : <span class="keyword">public</span>  __base&lt;_Rp(_ArgTypes...)&gt;</span><br><span class="line">&#123;</span><br><span class="line">    __alloc_func&lt;_Fp, _Alloc, _Rp(_ArgTypes...)&gt; __f_;</span><br><span class="line"></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="keyword">explicit</span> __func(_Fp&amp;&amp; __f, _Alloc&amp;&amp; __a)</span><br><span class="line">        : __f_(_VSTD::<span class="built_in">move</span>(__f), _VSTD::<span class="built_in">move</span>(__a)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__function::__func</code> 内部还有 <code>__alloc_func</code>，<code>__alloc_func</code> 才是真正存储可调用对象的地方</p><h5 id="alloc-func"><a href="#alloc-func" class="headerlink" title="__alloc_func"></a>__alloc_func</h5><p>在 <code>__alloc_func</code> 内部有一个 <code>__compressed_pair</code> 来存储可调用对象和 allocator，<code>__compressed_pair</code> 之前已经介绍过了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> <span class="title class_">_Ap</span>, <span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span>... _ArgTypes&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__alloc_func</span>&lt;_Fp, _Ap, _Rp(_ArgTypes...)&gt;</span><br><span class="line">&#123;</span><br><span class="line">    __compressed_pair&lt;_Fp, _Ap&gt; __f_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE _Fp _Target;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE _Ap _Alloc;</span><br><span class="line"></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="keyword">explicit</span> __alloc_func(_Target&amp;&amp; __f, _Alloc&amp;&amp; __a)</span><br><span class="line">        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::<span class="built_in">move</span>(__f)),</span><br><span class="line">               _VSTD::forward_as_tuple(_VSTD::<span class="built_in">move</span>(__a)))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__alloc_func</code> 内部使用了 <code>__compressed_pair</code> 的 piecewise_construct 函数，使用了之前说过的 forward_as_tuple，通过他得到的 tuple 里面的类型是引用类型</p><p>通过上面的分析可知，在创建 function 对象时，最开始 function 的构造函数内由于传参是值类型，所以发生了值的构造，但是后面都是<strong>尽可能</strong>以右值引用的方式往下传参数，最后在 <code>__alloc_func</code> 内部，也就是真正保存可调用对象的地方是按值存储可调用对象的，但是构造该对象时传的是右值引用，所以会<strong>尽可能</strong>使用移动构造，把最开始 function 构造函数中创建的值的资源转移到 <code>__alloc_func</code> 的 <code>__compressed_pair</code> 的值中。</p><p>当然上面说的是最理想的情况，如果可调用对象没有定义移动语义还是会拷贝构造。</p><h2 id="function-operator"><a href="#function-operator" class="headerlink" title="function::operator()()"></a>function::operator()()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line">_Rp</span><br><span class="line">function&lt;_Rp(_ArgTypes...)&gt;::<span class="built_in">operator</span>()(_ArgTypes... __arg) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __f_(_VSTD::forward&lt;_ArgTypes&gt;(__arg)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 operator()()的参数不是模板类型，就是定义 function 时设定的模板类型，这和 bind 不一样。但是 <code>_ArgTypes</code> 中可以出现引用，比如 <code>function&lt;void(int&amp;)&gt;</code>，因为函数形参可以是引用类型</p><h3 id="value-func-operator"><a href="#value-func-operator" class="headerlink" title="__value_func::operator()()"></a>__value_func::operator()()</h3><p><code>__f_</code> 是 <code>__value_func</code> 类型，所以 function::operator()()内部调用 <code>__value_func::operator()()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span>... _ArgTypes&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__value_func</span>&lt;_Rp(_ArgTypes...)&gt;&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __base&lt;_Rp(_ArgTypes...)&gt; __func;</span><br><span class="line">__func* __f_;</span><br><span class="line"></span><br><span class="line"><span class="function">_Rp <span class="title">operator</span><span class="params">()</span><span class="params">(_ArgTypes&amp;&amp;... __args)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__f_ == <span class="number">0</span>)</span><br><span class="line">        __throw_bad_function_call();</span><br><span class="line">    <span class="keyword">return</span> (*__f_)(_VSTD::forward&lt;_ArgTypes&gt;(__args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="function-func-operator"><a href="#function-func-operator" class="headerlink" title="__function::__func::operator()()"></a>__function::__func::operator()()</h4><p><code>__f_</code> 是 <code>__base&lt;_Rp(_ArgTypes...)&gt;</code> 类型的指针，但是实际指向 <code>__function::__func</code>，<code>__function::__func</code> 继承 <code>__function::__base</code>，而 <code>__function::__func::operator()()</code> 还是参数转发，交给 <code>__alloc_func::operator()()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>, <span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__func</span>&lt;_Fp, _Alloc, _Rp(_ArgTypes...)&gt;</span><br><span class="line">    : <span class="keyword">public</span>  __base&lt;_Rp(_ArgTypes...)&gt; &#123;</span><br><span class="line"></span><br><span class="line">__alloc_func&lt;_Fp, _Alloc, _Rp(_ArgTypes...)&gt; __f_;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Fp, <span class="keyword">class</span> _Alloc, <span class="keyword">class</span> _Rp, <span class="keyword">class</span> ..._ArgTypes&gt;</span></span><br><span class="line"><span class="function">_Rp <span class="title">operator</span><span class="params">()</span><span class="params">(_ArgTypes&amp;&amp; ... __arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __f_(_VSTD::forward&lt;_ArgTypes&gt;(__arg)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="alloc-func-operator"><a href="#alloc-func-operator" class="headerlink" title="__alloc_func::operator()()"></a>__alloc_func::operator()()</h5><p><code>__alloc_func</code> 内部取出可调用对象，进行调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> <span class="title class_">_Ap</span>, <span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span>... _ArgTypes&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__alloc_func</span>&lt;_Fp, _Ap, _Rp(_ArgTypes...)&gt;</span><br><span class="line">&#123;</span><br><span class="line">    __compressed_pair&lt;_Fp, _Ap&gt; __f_;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE _Fp _Target;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE _Ap _Alloc;</span><br><span class="line"></span><br><span class="line"><span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">_Rp <span class="title">operator</span><span class="params">()</span><span class="params">(_ArgTypes&amp;&amp;... __arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __invoke_void_return_wrapper&lt;_Rp&gt; _Invoker;</span><br><span class="line">    <span class="keyword">return</span> _Invoker::__call(__f_.<span class="built_in">first</span>(),</span><br><span class="line">                            _VSTD::forward&lt;_ArgTypes&gt;(__arg)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="invoke-void-return-wrapper"><a href="#invoke-void-return-wrapper" class="headerlink" title="__invoke_void_return_wrapper"></a>__invoke_void_return_wrapper</h6><p><code>__invoke_void_return_wrapper</code> 如下，内部调用了 <code>__invoke</code>，<code>__invoke</code> 之前已经介绍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__invoke_void_return_wrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line">    <span class="type">static</span> _Ret __call(_Args&amp;&amp;... __args) &#123;</span><br><span class="line">        <span class="keyword">return</span> __invoke(_VSTD::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__invoke_void_return_wrapper</span>&lt;<span class="type">void</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> __call(_Args&amp;&amp;... __args) &#123;</span><br><span class="line">        __invoke(_VSTD::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line">function&lt;_Rp(_ArgTypes...)&gt;::<span class="built_in">function</span>(<span class="type">const</span> function&amp; __f) : __f_(__f.__f_) &#123;&#125;</span><br></pre></td></tr></table></figure><p>内部发生 <code>__value_func</code> 的拷贝构造</p><h3 id="value-func"><a href="#value-func" class="headerlink" title="__value_func"></a>__value_func</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line">__value_func(<span class="type">const</span> __value_func&amp; __f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__f.__f_ == <span class="literal">nullptr</span>)</span><br><span class="line">        __f_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">void</span>*)__f.__f_ == &amp;__f.__buf_)</span><br><span class="line">    &#123;</span><br><span class="line">        __f_ = __as_base(&amp;__buf_);</span><br><span class="line">        __f.__f_-&gt;__clone(__f_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __f_ = __f.__f_-&gt;__clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__value_func</code> 内部调用 <code>__func</code> 的 clone 函数，由于 <code>__value_func.__f_</code> 指针指向的内存可能不是动态分配的，所以这里存在两种 clone 方式，一种输入指定地址，在指定地址上构造 <code>__func</code>，另一种则是直接动态分配 <code>__func</code> 的内存，然后构造。下面很多函数都针对这个机制做了不同处理</p><h4 id="func-clone"><a href="#func-clone" class="headerlink" title="__func::__clone"></a>__func::__clone</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>, <span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line">__base&lt;_Rp(_ArgTypes...)&gt;*</span><br><span class="line">__func&lt;_Fp, _Alloc, _Rp(_ArgTypes...)&gt;::__clone() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> allocator_traits&lt;_Alloc&gt; __alloc_traits;</span><br><span class="line">    <span class="keyword">typedef</span> __rebind_alloc&lt;__alloc_traits, __func&gt; _Ap;</span><br><span class="line">    _Ap __a(__f_.__get_allocator());</span><br><span class="line">    <span class="keyword">typedef</span> __allocator_destructor&lt;_Ap&gt; _Dp;</span><br><span class="line">    unique_ptr&lt;__func, _Dp&gt; __hold(__a.<span class="built_in">allocate</span>(<span class="number">1</span>), _Dp(__a, <span class="number">1</span>));</span><br><span class="line">    ::<span class="keyword">new</span> ((<span class="type">void</span>*)__hold.<span class="built_in">get</span>()) __func(__f_.__target(), _Alloc(__a));</span><br><span class="line">    <span class="keyword">return</span> __hold.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>, <span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">__func&lt;_Fp, _Alloc, _Rp(_ArgTypes...)&gt;::__clone(__base&lt;_Rp(_ArgTypes...)&gt;* __p) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    ::<span class="keyword">new</span> ((<span class="type">void</span>*)__p) __func(__f_.__target(), __f_.__get_allocator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="alloc-func-1"><a href="#alloc-func-1" class="headerlink" title="__alloc_func"></a>__alloc_func</h5><p>真正的构造发生在 <code>__alloc_func</code> 中，因为 <code>__alloc_func</code> 有 <code>__compressed_pair</code> 真正存储可调用对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __compressed_pair&lt;_Fp, _Ap&gt; __f_;</span></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="type">const</span> _Target&amp; __target() <span class="type">const</span> &#123; <span class="keyword">return</span> __f_.<span class="built_in">first</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WIN32 APIs may define __allocator, so use __get_allocator instead.</span></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="type">const</span> _Alloc&amp; __get_allocator() <span class="type">const</span> &#123; <span class="keyword">return</span> __f_.<span class="built_in">second</span>(); &#125;</span><br></pre></td></tr></table></figure><h2 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span>... _ArgTypes&gt;</span><br><span class="line">function&lt;_Rp(_ArgTypes...)&gt;::<span class="built_in">function</span>(function&amp;&amp; __f) _NOEXCEPT</span><br><span class="line">    : __f_(_VSTD::<span class="built_in">move</span>(__f.__f_)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>__value_func</code> 的移动构造</p><h3 id="value-func-1"><a href="#value-func-1" class="headerlink" title="__value_func"></a>__value_func</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    __value_func(__value_func&amp;&amp; __f) _NOEXCEPT</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__f.__f_ == <span class="literal">nullptr</span>)</span><br><span class="line">            __f_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">void</span>*)__f.__f_ == &amp;__f.__buf_)</span><br><span class="line">        &#123;</span><br><span class="line">            __f_ = __as_base(&amp;__buf_);</span><br><span class="line">            __f.__f_-&gt;__clone(__f_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            __f_ = __f.__f_;</span><br><span class="line">            __f.__f_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>针对__f_指针是否动态分配有不同处理，如果是动态分配，直接把输入 <code>__value_func</code> 的 <code>__f_</code> 指针赋给当前 <code>__value_func</code> 的 <code>__f_</code>，否则要 clone</p><h2 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h2><p>先构造一个临时 function，然后进行 swap</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line">function&lt;_Rp(_ArgTypes...)&gt;&amp;</span><br><span class="line">function&lt;_Rp(_ArgTypes...)&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> function&amp; __f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">function</span>(__f).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面函数调用了 <code>__value_func::swap</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">function&lt;_Rp(_ArgTypes...)&gt;::<span class="built_in">swap</span>(function&amp; __f) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    __f_.<span class="built_in">swap</span>(__f.__f_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="value-func-swap"><a href="#value-func-swap" class="headerlink" title="__value_func::swap"></a>__value_func::swap</h3><p><code>__value_func</code> 内部根据 <code>__f_</code> 是否指向 <code>__buf_</code> 来做不同的处理。</p><p>最简单的情况，如果输入的 <code>__f.__f_</code> 和当前 <code>__value_func</code> 的 <code>__f_</code> 都是动态分配的，那么直接交换 <code>__f_</code> 指针，这对应下面 if 语句的最后一种情况。其他的情况则要根据 <code>__f_</code> 是否动态分配进行一些 destroy 和 clone 操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(__value_func&amp; __f)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;__f == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">void</span>*)__f_ == &amp;__buf_ &amp;&amp; (<span class="type">void</span>*)__f.__f_ == &amp;__f.__buf_)</span><br><span class="line">        &#123;</span><br><span class="line">            _LIBCPP_SUPPRESS_DEPRECATED_PUSH</span><br><span class="line">            <span class="keyword">typename</span> aligned_storage&lt;<span class="built_in">sizeof</span>(__buf_)&gt;::type __tempbuf;</span><br><span class="line">            _LIBCPP_SUPPRESS_DEPRECATED_POP</span><br><span class="line">            __func* <span class="type">__t</span> = __as_base(&amp;__tempbuf);</span><br><span class="line">            __f_-&gt;__clone(<span class="type">__t</span>);</span><br><span class="line">            __f_-&gt;<span class="built_in">destroy</span>();</span><br><span class="line">            __f_ = <span class="literal">nullptr</span>;</span><br><span class="line">            __f.__f_-&gt;__clone(__as_base(&amp;__buf_));</span><br><span class="line">            __f.__f_-&gt;<span class="built_in">destroy</span>();</span><br><span class="line">            __f.__f_ = <span class="literal">nullptr</span>;</span><br><span class="line">            __f_ = __as_base(&amp;__buf_);</span><br><span class="line">            <span class="type">__t</span>-&gt;__clone(__as_base(&amp;__f.__buf_));</span><br><span class="line">            <span class="type">__t</span>-&gt;<span class="built_in">destroy</span>();</span><br><span class="line">            __f.__f_ = __as_base(&amp;__f.__buf_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">void</span>*)__f_ == &amp;__buf_)</span><br><span class="line">        &#123;</span><br><span class="line">            __f_-&gt;__clone(__as_base(&amp;__f.__buf_));</span><br><span class="line">            __f_-&gt;<span class="built_in">destroy</span>();</span><br><span class="line">            __f_ = __f.__f_;</span><br><span class="line">            __f.__f_ = __as_base(&amp;__f.__buf_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">void</span>*)__f.__f_ == &amp;__f.__buf_)</span><br><span class="line">        &#123;</span><br><span class="line">            __f.__f_-&gt;__clone(__as_base(&amp;__buf_));</span><br><span class="line">            __f.__f_-&gt;<span class="built_in">destroy</span>();</span><br><span class="line">            __f.__f_ = __f_;</span><br><span class="line">            __f_ = __as_base(&amp;__buf_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _VSTD::<span class="built_in">swap</span>(__f_, __f.__f_);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="接受泛型参数的赋值"><a href="#接受泛型参数的赋值" class="headerlink" title="接受泛型参数的赋值"></a>接受泛型参数的赋值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span>&gt;</span><br><span class="line">function&lt;_Rp(_ArgTypes...)&gt;&amp;</span><br><span class="line">function&lt;_Rp(_ArgTypes...)&gt;::<span class="keyword">operator</span>=(_Fp&amp;&amp; __f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">function</span>(_VSTD::forward&lt;_Fp&gt;(__f)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面一样，先创建临时 function 对象，然后 swap</p><h2 id="移动赋值"><a href="#移动赋值" class="headerlink" title="移动赋值"></a>移动赋值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line">function&lt;_Rp(_ArgTypes...)&gt;&amp;</span><br><span class="line">function&lt;_Rp(_ArgTypes...)&gt;::<span class="keyword">operator</span>=(function&amp;&amp; __f) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    __f_ = _VSTD::<span class="built_in">move</span>(__f.__f_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先释放当前 <code>__value_func</code> 的资源，然后根据输入 <code>__value_func</code> 的 <code>__f_</code> 指针指向的内存是否是动态分配决定是直接接管 <code>__f_</code> 指针还是进行 clone。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    __value_func&amp; <span class="keyword">operator</span>=(__value_func&amp;&amp; __f)</span><br><span class="line">    &#123;</span><br><span class="line">        *<span class="keyword">this</span> = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (__f.__f_ == <span class="literal">nullptr</span>)</span><br><span class="line">            __f_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">void</span>*)__f.__f_ == &amp;__f.__buf_)</span><br><span class="line">        &#123;</span><br><span class="line">            __f_ = __as_base(&amp;__buf_);</span><br><span class="line">            __f.__f_-&gt;__clone(__f_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            __f_ = __f.__f_;</span><br><span class="line">            __f.__f_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 <code>__value_func</code> 中，由于存在内存优化机制，即：如果可调用对象内存较小，将直接存在 <code>__value_func</code> 内部而不额外动态分配内存。导致上面的代码针对这个机制做了很多处理，虽然看起来繁杂，但其实不难理解。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++标准库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium base 库之 Bind 和 Callback</title>
      <link href="/2023/05/23/Chromium-base-%E5%BA%93%E4%B9%8B-Bind-%E5%92%8C-Callback/"/>
      <url>/2023/05/23/Chromium-base-%E5%BA%93%E4%B9%8B-Bind-%E5%92%8C-Callback/</url>
      
        <content type="html"><![CDATA[<p>Chromium 也实现了自己的 Bind 和 Callback 机制，和标准库的 bind 和 function 有一些不同之处。</p><p>这篇文章分析 Chromium 的 Bind 和 Callback。</p><h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><p>Chromium 有两种 bind，BindOnce 和 BindRepeating，分别返回 OnceCallback 和 RepeatingCallback。Chromium 的 bind 不支持占位符，只能绑定前 n 个参数，后 m 个参数需要在 Callback 调用时传入，和标准库的 bind_front 有些类似。</p><h2 id="BindOnce"><a href="#BindOnce" class="headerlink" title="BindOnce"></a>BindOnce</h2><p>先看例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base::OnceCallback&lt;<span class="built_in">long</span>(<span class="type">int</span>, <span class="type">long</span>)&gt; cb = base::<span class="built_in">BindOnce</span>(</span><br><span class="line">    [](<span class="type">short</span> x, <span class="type">int</span> y, <span class="type">long</span> z) &#123; <span class="keyword">return</span> x * y * z; &#125;, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>上面 lambda 函数第一个参数被绑定，后两个参数需要后续调用时传入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> base::RefCounted&lt;C&gt; &#123; <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> instance = base::<span class="built_in">MakeRefCounted</span>&lt;C&gt;();</span><br><span class="line"><span class="keyword">auto</span> cb = base::<span class="built_in">BindOnce</span>(&amp;C::F, instance);</span><br><span class="line">std::<span class="built_in">move</span>(cb).<span class="built_in">Run</span>();  <span class="comment">// Identical to instance-&gt;F()</span></span><br></pre></td></tr></table></figure><p>这个例子绑定了一个类成员函数指针，当 Bind 绑定类成员函数指针时，必须要在创建时指定被绑定的对象，这和 std::bind 不一样，std::bind 可以将对象作为参数传给 operator()()函数，无需在调用 bind 时就指定对象。</p><h3 id="BindOnce-函数"><a href="#BindOnce-函数" class="headerlink" title="BindOnce 函数"></a>BindOnce 函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">inline</span> OnceCallback&lt;internal::MakeUnboundRunType&lt;Functor, Args...&gt;&gt; <span class="built_in">BindOnce</span>(</span><br><span class="line">    Functor&amp;&amp; functor,</span><br><span class="line">    Args&amp;&amp;... args) &#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(!internal::IsOnceCallback&lt;std::<span class="type">decay_t</span>&lt;Functor&gt;&gt;() ||</span><br><span class="line">                    (std::<span class="built_in">is_rvalue_reference</span>&lt;Functor&amp;&amp;&gt;() &amp;&amp;</span><br><span class="line">                     !std::is_const&lt;std::<span class="type">remove_reference_t</span>&lt;Functor&gt;&gt;()),</span><br><span class="line">                <span class="string">&quot;BindOnce requires non-const rvalue for OnceCallback binding.&quot;</span></span><br><span class="line">                <span class="string">&quot; I.e.: base::BindOnce(std::move(callback)).&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(</span><br><span class="line">      std::conjunction&lt;</span><br><span class="line">          internal::AssertBindArgIsNotBasePassed&lt;std::<span class="type">decay_t</span>&lt;Args&gt;&gt;...&gt;::value,</span><br><span class="line">      <span class="string">&quot;Use std::move() instead of base::Passed() with base::BindOnce()&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> internal::<span class="built_in">BindImpl</span>&lt;OnceCallback&gt;(std::forward&lt;Functor&gt;(functor),</span><br><span class="line">                                          std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先看第一个 static_assert 限制，他要求</p><ul><li>传入的 functor 不是 OnceCallback</li><li>或者 传入的 functor 是 OnceCallback，如果 functor 是右值引用，那么其不能是 const</li></ul><p>第二个 static_assert 要求参数不能通过 base::Passed()来传递，应使用 std::move()变为右值引用</p><h4 id="BindImpl"><a href="#BindImpl" class="headerlink" title="BindImpl"></a>BindImpl</h4><p>BindOnce 内部调用 <code>BindImpl&lt;OnceCallback&gt;</code> 来创建 OnceCallback。</p><p>BindImpl 内部有 bool 常量 kIsOnce 判断是否为 OnceCallback，这是通过模板参数为模板类型实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">CallbackT</span>,</span><br><span class="line">          <span class="keyword">typename</span> Functor,</span><br><span class="line">          <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">BindImpl</span><span class="params">(Functor&amp;&amp; functor, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> kIsOnce = IsOnceCallback&lt;CallbackT&lt;<span class="built_in">void</span>()&gt;&gt;::value;</span><br><span class="line">  <span class="keyword">using</span> Helper = BindTypeHelper&lt;Functor, Args...&gt;; <span class="comment">// 注意这里不是Args&amp;&amp;</span></span><br><span class="line">  <span class="keyword">using</span> FunctorTraits = <span class="keyword">typename</span> Helper::FunctorTraits;</span><br><span class="line">  <span class="keyword">using</span> BoundArgsList = <span class="keyword">typename</span> Helper::BoundArgsList;<span class="comment">// 就是TypeList&lt;Args...&gt;</span></span><br><span class="line">  <span class="keyword">using</span> UnwrappedArgsList = </span><br><span class="line">      MakeUnwrappedTypeList&lt;kIsOnce, FunctorTraits::is_method, Args&amp;&amp;...&gt;;</span><br><span class="line">  <span class="keyword">using</span> BoundParamsList = <span class="keyword">typename</span> Helper::BoundParamsList;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">static_assert</span>(</span><br><span class="line">      MakeFunctorTraits&lt;Functor&gt;::is_stateless,</span><br><span class="line">      <span class="string">&quot;Capturing lambdas and stateful lambdas are intentionally not supported. &quot;</span></span><br><span class="line">      <span class="string">&quot;Please use base::Bind&#123;Once,Repeating&#125; directly to bind arguments.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">static_assert</span>(</span><br><span class="line">      AssertBindArgsValidity&lt;FunctorTraits::is_method,</span><br><span class="line">                             std::make_index_sequence&lt;Helper::num_bounds&gt;,</span><br><span class="line">                             BoundArgsList, UnwrappedArgsList,</span><br><span class="line">                             BoundParamsList&gt;::ok,</span><br><span class="line">      <span class="string">&quot;The bound args need to be convertible to the target params.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> BindState = MakeBindStateType&lt;Functor, Args...&gt;;</span><br><span class="line">  <span class="keyword">using</span> UnboundRunType = MakeUnboundRunType&lt;Functor, Args...&gt;;</span><br><span class="line">  <span class="keyword">using</span> Invoker = Invoker&lt;BindState, UnboundRunType&gt;;</span><br><span class="line">  <span class="keyword">using</span> CallbackType = CallbackT&lt;UnboundRunType&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CallbackType::PolymorphicInvoke是函数指针类型</span></span><br><span class="line">  <span class="keyword">using</span> PolymorphicInvoke = <span class="keyword">typename</span> CallbackType::PolymorphicInvoke;</span><br><span class="line">  PolymorphicInvoke invoke_func; <span class="comment">// 声明一个指针</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(kIsOnce)</span> </span>&#123;</span><br><span class="line">    invoke_func = Invoker::RunOnce;  <span class="comment">// 让这个指针的值为Invoker::RunOnce</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    invoke_func = Invoker::Run;  <span class="comment">// 让这个指针的值为Invoker::Run</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> InvokeFuncStorage = BindStateBase::InvokeFuncStorage; <span class="comment">// 也是指针类型</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CallbackType</span>(BindState::<span class="built_in">Create</span>(</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;InvokeFuncStorage&gt;(invoke_func), <span class="comment">// 强制转换指针类型</span></span><br><span class="line">      std::forward&lt;Functor&gt;(functor), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="和函数参数相关的-type-trait"><a href="#和函数参数相关的-type-trait" class="headerlink" title="和函数参数相关的 type trait"></a>和函数参数相关的 type trait</h5><p>BindImpl 里面有很多和函数类型、函数参数相关的 type trait，比如 BindTypeHelper、FunctorTraits、BoundArgsList、UnwrappedArgsList、BoundParamsList。</p><p>我们先分析这些 type trait。</p><h6 id="BindTypeHelper"><a href="#BindTypeHelper" class="headerlink" title="BindTypeHelper"></a>BindTypeHelper</h6><p>BindTypeHelper 是辅助类，提供函数参数、返回值类型信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Helper = BindTypeHelper&lt;Functor, Args...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extracts necessary type info from Functor and BoundArgs.</span></span><br><span class="line"><span class="comment">// Used to implement MakeUnboundRunType, BindOnce and BindRepeating.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor, <span class="keyword">typename</span>... BoundArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BindTypeHelper</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> num_bounds = <span class="keyword">sizeof</span>...(BoundArgs);</span><br><span class="line">  <span class="keyword">using</span> FunctorTraits = MakeFunctorTraits&lt;Functor&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Example:</span></span><br><span class="line">  <span class="comment">//   When Functor is `double (Foo::*)(int, const std::string&amp;)`, and BoundArgs</span></span><br><span class="line">  <span class="comment">//   is a template pack of `Foo*` and `int16_t`:</span></span><br><span class="line">  <span class="comment">//    - RunType is `double(Foo*, int, const std::string&amp;)`,</span></span><br><span class="line">  <span class="comment">//    - ReturnType is `double`,</span></span><br><span class="line">  <span class="comment">//    - RunParamsList is `TypeList&lt;Foo*, int, const std::string&amp;&gt;`,</span></span><br><span class="line">  <span class="comment">//    - BoundParamsList is `TypeList&lt;Foo*, int&gt;`,</span></span><br><span class="line">  <span class="comment">//    - UnboundParamsList is `TypeList&lt;const std::string&amp;&gt;`,</span></span><br><span class="line">  <span class="comment">//    - BoundArgsList is `TypeList&lt;Foo*, int16_t&gt;`,</span></span><br><span class="line">  <span class="comment">//    - UnboundRunType is `double(const std::string&amp;)`.</span></span><br><span class="line">  <span class="keyword">using</span> RunType = <span class="keyword">typename</span> FunctorTraits::RunType;</span><br><span class="line">  <span class="keyword">using</span> ReturnType = ExtractReturnType&lt;RunType&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> RunParamsList = ExtractArgs&lt;RunType&gt;;</span><br><span class="line">  <span class="keyword">using</span> BoundParamsList = TakeTypeListItem&lt;num_bounds, RunParamsList&gt;;</span><br><span class="line">  <span class="keyword">using</span> UnboundParamsList = DropTypeListItem&lt;num_bounds, RunParamsList&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> BoundArgsList = TypeList&lt;BoundArgs...&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> UnboundRunType = MakeFunctionType&lt;ReturnType, UnboundParamsList&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>####### MakeFunctorTraits</p><p>BindTypeHelper 会使用 MakeFunctorTraits。</p><p>MakeFunctorTraits 先对 Functor 做了一个 decay，比如函数引用退化为函数指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor&gt;</span><br><span class="line"><span class="keyword">using</span> MakeFunctorTraits = FunctorTraits&lt;std::<span class="type">decay_t</span>&lt;Functor&gt;&gt;;</span><br></pre></td></tr></table></figure><p>######## FunctorTraits</p><p>MakeFunctorTraits 内部调用了 FunctorTraits</p><p>FunctorTraits 针对函数指针和成员函数指针等分别特化，目的就是为了取得返回类型和参数类型，注意 FunctorTraits 里面还定义了 Invoke 函数，后面发生函数调用时会使用这个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For functions</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FunctorTraits</span>&lt;<span class="built_in">R</span> (*)(Args...)&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> RunType = <span class="built_in">R</span>(Args...);</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_method = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_nullable = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_callback = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_stateless = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Function, <span class="keyword">typename</span>... RunArgs&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> R <span class="title">Invoke</span><span class="params">(Function&amp;&amp; function, RunArgs&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Function&gt;(function)(std::forward&lt;RunArgs&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// For methods.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Receiver, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FunctorTraits</span>&lt;<span class="built_in">R</span> (Receiver::*)(Args...)&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> RunType = <span class="built_in">R</span>(Receiver*, Args...);</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_method = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_nullable = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_callback = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_stateless = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Method, <span class="keyword">typename</span> ReceiverPtr, <span class="keyword">typename</span>... RunArgs&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> R <span class="title">Invoke</span><span class="params">(Method method,</span></span></span><br><span class="line"><span class="params"><span class="function">                  ReceiverPtr&amp;&amp; receiver_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                  RunArgs&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((*receiver_ptr).*method)(std::forward&lt;RunArgs&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>####### 计算参数类型</p><p>在通过 MakeFunctorTraits 取得 Functor 的 RunType 之后，会进行类型计算，比如计算当前 Functor 的参数哪些被绑定了，哪些没有被绑定，绑定时传的参数类型又是什么，具体可以看下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example:</span></span><br><span class="line">  <span class="comment">//   When Functor is `double (Foo::*)(int, const std::string&amp;)`, and BoundArgs</span></span><br><span class="line">  <span class="comment">//   is a template pack of `Foo*` and `int16_t`:</span></span><br><span class="line">  <span class="comment">//    - RunType is `double(Foo*, int, const std::string&amp;)`,</span></span><br><span class="line">  <span class="comment">//    - ReturnType is `double`,</span></span><br><span class="line">  <span class="comment">//    - RunParamsList is `TypeList&lt;Foo*, int, const std::string&amp;&gt;`,</span></span><br><span class="line">  <span class="comment">//    - BoundParamsList is `TypeList&lt;Foo*, int&gt;`,</span></span><br><span class="line">  <span class="comment">//    - UnboundParamsList is `TypeList&lt;const std::string&amp;&gt;`,</span></span><br><span class="line">  <span class="comment">//    - BoundArgsList is `TypeList&lt;Foo*, int16_t&gt;`,</span></span><br><span class="line">  <span class="comment">//    - UnboundRunType is `double(const std::string&amp;)`.</span></span><br></pre></td></tr></table></figure><h6 id="MakeUnwrappedTypeList"><a href="#MakeUnwrappedTypeList" class="headerlink" title="MakeUnwrappedTypeList"></a>MakeUnwrappedTypeList</h6><p>在 BindTypeHelper 之后，会计算输入参数的 Unwrapped Type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> is_once, <span class="type">bool</span> is_method, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> MakeUnwrappedTypeList =</span><br><span class="line">    <span class="keyword">typename</span> MakeUnwrappedTypeListImpl&lt;is_once, is_method, Args...&gt;::Type;</span><br></pre></td></tr></table></figure><p>如果是类成员函数指针，会对输入的 Receiver 做额外处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transforms |Args| into `Unwrapped` types, and packs them into a TypeList.</span></span><br><span class="line"><span class="comment">// If |is_method| is true, tries to dereference the first argument to support</span></span><br><span class="line"><span class="comment">// smart pointers.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> is_once, <span class="type">bool</span> is_method, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MakeUnwrappedTypeListImpl</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> Type = TypeList&lt;TransformToUnwrappedType&lt;is_once, Args&gt;...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Performs special handling for this pointers.</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">//   int* -&gt; int*,</span></span><br><span class="line"><span class="comment">//   std::unique_ptr&lt;int&gt; -&gt; int*.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> is_once, <span class="keyword">typename</span> Receiver, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MakeUnwrappedTypeListImpl</span>&lt;is_once, <span class="literal">true</span>, Receiver, Args...&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> ReceiverStorageType =</span><br><span class="line">      <span class="keyword">typename</span> MethodReceiverStorageType&lt;std::<span class="type">decay_t</span>&lt;Receiver&gt;&gt;::Type;</span><br><span class="line">  <span class="keyword">using</span> UnwrappedReceiver =</span><br><span class="line">      TransformToUnwrappedType&lt;is_once, ReceiverStorageType&gt;;</span><br><span class="line">  <span class="keyword">using</span> Type = TypeList&lt;<span class="keyword">decltype</span>(&amp;*std::<span class="built_in">declval</span>&lt;UnwrappedReceiver&gt;()),</span><br><span class="line">                        TransformToUnwrappedType&lt;is_once, Args&gt;...&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>####### TransformToUnwrappedType</p><p>先看 TransformToUnwrappedType 如何对非 Receiver 参数进行 Unwrap。</p><p>从下面的注释可以知道，TransformToUnwrappedType 主要是把输入的引用类型根据 is_once 条件进行合适的转换。注意 BindImpl 中 MakeUnwrappedTypeList 传递的是 Args&amp;&amp;，也就是模板参数一定是引用类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transform |T| into `Unwrapped` type, which is passed to the target function.</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">//   In is_once == true case,</span></span><br><span class="line"><span class="comment">//     `int&amp;&amp;` -&gt; `int&amp;&amp;`,</span></span><br><span class="line"><span class="comment">//     `const int&amp;` -&gt; `int&amp;&amp;`,</span></span><br><span class="line"><span class="comment">//     `OwnedWrapper&lt;int&gt;&amp;` -&gt; `int*&amp;&amp;`.</span></span><br><span class="line"><span class="comment">//   In is_once == false case,</span></span><br><span class="line"><span class="comment">//     `int&amp;&amp;` -&gt; `const int&amp;`,</span></span><br><span class="line"><span class="comment">//     `const int&amp;` -&gt; `const int&amp;`,</span></span><br><span class="line"><span class="comment">//     `OwnedWrapper&lt;int&gt;&amp;` -&gt; `int* const &amp;`.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> is_once, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> TransformToUnwrappedType =</span><br><span class="line">    <span class="keyword">typename</span> TransformToUnwrappedTypeImpl&lt;is_once, T&gt;::Unwrapped;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> is_once, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TransformToUnwrappedTypeImpl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TransformToUnwrappedTypeImpl</span>&lt;<span class="literal">true</span>, T&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> StoredType = std::<span class="type">decay_t</span>&lt;T&gt;; <span class="comment">// 参数的存储类型</span></span><br><span class="line">  <span class="keyword">using</span> ForwardType = StoredType&amp;&amp;;</span><br><span class="line">  <span class="keyword">using</span> Unwrapped = <span class="keyword">decltype</span>(<span class="built_in">Unwrap</span>(std::<span class="built_in">declval</span>&lt;ForwardType&gt;()));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TransformToUnwrappedTypeImpl</span>&lt;<span class="literal">false</span>, T&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> StoredType = std::<span class="type">decay_t</span>&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> ForwardType = <span class="type">const</span> StoredType&amp;;</span><br><span class="line">  <span class="keyword">using</span> Unwrapped = <span class="keyword">decltype</span>(<span class="built_in">Unwrap</span>(std::<span class="built_in">declval</span>&lt;ForwardType&gt;()));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">Unwrap</span><span class="params">(T&amp;&amp; o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Unwrapper&lt;T&gt;::<span class="built_in">Unwrap</span>(std::forward&lt;T&gt;(o));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Unwrapper = BindUnwrapTraits&lt;std::<span class="type">decay_t</span>&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BindUnwrapTraits</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> T&amp;&amp; <span class="title">Unwrap</span><span class="params">(T&amp;&amp; o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;T&gt;(o);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BindUnwrapTraits 有很多不同的特化，都是针对 UnretainedWrapper 这些包装类型，这里先不考虑这些类型，那么 BindUnwrapTraits 对于非 Wrapper 类型其实就是参数的转发，没有对参数类型做任何修改，即 TransformToUnwrappedTypeImpl 里的 Unwrapped 类型对于非 Wrapper 类型就是 ForwardType，这和前面注释的内容刚好对上。</p><p>####### MethodReceiverStorageType</p><p>这部分放在下面介绍。</p><h6 id="AssertBindArgsValidity"><a href="#AssertBindArgsValidity" class="headerlink" title="AssertBindArgsValidity"></a>AssertBindArgsValidity</h6><p>再看看检查条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Takes three same-length TypeLists, and applies AssertConstructible for each</span></span><br><span class="line"><span class="comment">// triples.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> is_method,</span><br><span class="line">          <span class="keyword">typename</span> Index,</span><br><span class="line">          <span class="keyword">typename</span> Args,</span><br><span class="line">          <span class="keyword">typename</span> UnwrappedTypeList,</span><br><span class="line">          <span class="keyword">typename</span> ParamsList&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AssertBindArgsValidity</span>;</span><br></pre></td></tr></table></figure><ul><li>Args 就是 BindImpl 函数推断得到的模板参数类型（注意没有加&amp;&amp;）</li><li>UnwrappedTypeList 就是将来存储 bind 输入的参数时传的参数</li><li>ParamsList 就是 Functor 的形参</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> is_method,</span><br><span class="line">          <span class="type">size_t</span>... Ns,</span><br><span class="line">          <span class="keyword">typename</span>... Args,</span><br><span class="line">          <span class="keyword">typename</span>... Unwrapped,</span><br><span class="line">          <span class="keyword">typename</span>... Params&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AssertBindArgsValidity</span>&lt;is_method,</span><br><span class="line">                              std::index_sequence&lt;Ns...&gt;,</span><br><span class="line">                              TypeList&lt;Args...&gt;,</span><br><span class="line">                              TypeList&lt;Unwrapped...&gt;,</span><br><span class="line">                              TypeList&lt;Params...&gt;&gt;</span><br><span class="line">    : AssertConstructible&lt;Ns,</span><br><span class="line">                          is_method,</span><br><span class="line">                          Args,</span><br><span class="line">                          std::<span class="type">decay_t</span>&lt;Args&gt;, <span class="comment">// decay之后作为存储类型</span></span><br><span class="line">                          Unwrapped,</span><br><span class="line">                          Params&gt;... &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AssertBindArgsValidity 内部对每个绑定参数进行 AssertConstructible 检查</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> i,</span><br><span class="line">          <span class="type">bool</span> is_method,</span><br><span class="line">          <span class="keyword">typename</span> Arg,</span><br><span class="line">          <span class="keyword">typename</span> Storage,</span><br><span class="line">          <span class="keyword">typename</span> Unwrapped,</span><br><span class="line">          <span class="keyword">typename</span> Param&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AssertConstructible</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体的检查条件就不一一分析，这里只分析两个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(</span><br><span class="line">      BindArgument&lt;i&gt;::<span class="keyword">template</span> ForwardedAs&lt;Unwrapped&gt;::</span><br><span class="line">          <span class="keyword">template</span> ToParamWithType&lt;Param&gt;::kCanBeForwardedToBoundFunctor,</span><br><span class="line">      <span class="string">&quot;Type mismatch between bound argument and bound functor&#x27;s parameter.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardingType&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ForwardedAs</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctorParamType&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ToParamWithType</span> &#123;</span><br><span class="line">      <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> kNotARawPtr = !IsRawPtrV&lt;FunctorParamType&gt;;</span><br><span class="line"></span><br><span class="line">      <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> kCanBeForwardedToBoundFunctor =</span><br><span class="line">          std::is_constructible_v&lt;FunctorParamType, ForwardingType&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>这个条件要求 Unwrapped 类型（就是形参）能构造 Param（也就是实参）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(</span><br><span class="line">      BindArgument&lt;i&gt;::<span class="keyword">template</span> BoundAs&lt;Arg&gt;::<span class="keyword">template</span> StoredAs&lt;</span><br><span class="line">          Storage&gt;::kBindArgumentCanBeCaptured,</span><br><span class="line">      <span class="string">&quot;Cannot capture argument: is the argument copyable or movable?&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BoundAsType&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">BoundAs</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> StorageType&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StoredAs</span> &#123;</span><br><span class="line">      <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> kBindArgumentCanBeCaptured =</span><br><span class="line">          std::is_constructible_v&lt;StorageType, BoundAsType&gt;;</span><br><span class="line">      <span class="comment">// Note that this intentionally drops the const qualifier from</span></span><br><span class="line">      <span class="comment">// `BoundAsType`, to test if it *could* have been successfully bound if</span></span><br><span class="line">      <span class="comment">// `std::move()` had been used.</span></span><br><span class="line">      <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> kMoveOnlyTypeMustUseStdMove =</span><br><span class="line">          kBindArgumentCanBeCaptured ||</span><br><span class="line">          !std::is_constructible_v&lt;StorageType, std::<span class="type">decay_t</span>&lt;BoundAsType&gt;&amp;&amp;&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>这个条件要求 BoundAsType 能构造 StorageType。刚开始有点不理解，BoundAsType 是 BindImpl 推断的参数类型不加&amp;&amp;，后来发现 is_constructible 条件要求 <code>T obj(std::declval&lt;Args&gt;()...);</code>，而 declval 会在 Args 后加&amp;&amp;，所以 BoundAsType 不需要额外的&amp;&amp;。</p><h5 id="MakeBindStateType"><a href="#MakeBindStateType" class="headerlink" title="MakeBindStateType"></a>MakeBindStateType</h5><p>介绍完基本的函数类型的 type trait。接下来看看 Bind 是如何存储参数的。参数存储在 BindState，我们通过 MakeBindStateType 创建 BindState 类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor, <span class="keyword">typename</span>... BoundArgs&gt;</span><br><span class="line"><span class="keyword">using</span> MakeBindStateType =</span><br><span class="line">    <span class="keyword">typename</span> MakeBindStateTypeImpl&lt;MakeFunctorTraits&lt;Functor&gt;::is_method,</span><br><span class="line">                                   Functor,</span><br><span class="line">                                   BoundArgs...&gt;::Type;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> is_method, <span class="keyword">typename</span> Functor, <span class="keyword">typename</span>... BoundArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MakeBindStateTypeImpl</span>;</span><br></pre></td></tr></table></figure><p>MakeBindStateTypeImpl 有不同的特化：</p><ul><li>如果 Functor 不是成员函数，那么不允许：参数是裸指针，并且指针指向类型继承 RefCounted</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor, <span class="keyword">typename</span>... BoundArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MakeBindStateTypeImpl</span>&lt;<span class="literal">false</span>, Functor, BoundArgs...&gt; &#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(!HasRefCountedTypeAsRawPtr&lt;std::<span class="type">decay_t</span>&lt;BoundArgs&gt;...&gt;::value,</span><br><span class="line">                <span class="string">&quot;A parameter is a refcounted type and needs scoped_refptr.&quot;</span>);</span><br><span class="line">  <span class="keyword">using</span> Type = BindState&lt;std::<span class="type">decay_t</span>&lt;Functor&gt;, MakeStorageType&lt;BoundArgs&gt;...&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果 Functor 是成员函数，但是没有绑定任何参数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MakeBindStateTypeImpl</span>&lt;<span class="literal">true</span>, Functor&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> Type = BindState&lt;std::<span class="type">decay_t</span>&lt;Functor&gt;&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果 Functor 是成员函数，而且绑定了 Receiver</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor, <span class="keyword">typename</span> Receiver, <span class="keyword">typename</span>... BoundArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MakeBindStateTypeImpl</span>&lt;<span class="literal">true</span>, Functor, Receiver, BoundArgs...&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> DecayedReceiver = std::<span class="type">decay_t</span>&lt;Receiver&gt;;</span><br><span class="line">  <span class="keyword">using</span> ReceiverStorageType =</span><br><span class="line">      <span class="keyword">typename</span> MethodReceiverStorageType&lt;DecayedReceiver&gt;::Type;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Type = BindState&lt;std::<span class="type">decay_t</span>&lt;Functor&gt;,</span><br><span class="line">                         ReceiverStorageType,</span><br><span class="line">                         MakeStorageType&lt;BoundArgs&gt;...&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MakeBindStateTypeImpl 会先创建参数的存储类型，然后用这些存储类型去创建 BindState。之前 std::bind 里面创建存储类型用的是 decay，而这里则稍微有些不同</p><h6 id="MakeStorageType"><a href="#MakeStorageType" class="headerlink" title="MakeStorageType"></a>MakeStorageType</h6><p>创建非 Receiver 参数的存储类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MakeStorageType = <span class="keyword">typename</span> StorageTraits&lt;std::<span class="type">decay_t</span>&lt;T&gt;&gt;::Type;</span><br></pre></td></tr></table></figure><p>会对 T 是指针类型的情况进行特殊处理，如果是裸指针，用 UnretainedWrapper 来存储，所以参数尽量不要使用裸指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StorageTraits</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For T*, store as UnretainedWrapper&lt;T&gt; for safety, as it internally uses</span></span><br><span class="line"><span class="comment">// raw_ptr&lt;T&gt; (when possible).</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StorageTraits</span>&lt;T*&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> Type = UnretainedWrapper&lt;T, unretained_traits::MayNotDangle&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For raw_ptr&lt;T&gt;, store as UnretainedWrapper&lt;T&gt; for safety. This may seem</span></span><br><span class="line"><span class="comment">// contradictory, but this ensures guaranteed protection for the pointer even</span></span><br><span class="line"><span class="comment">// during execution of callbacks with parameters of type raw_ptr&lt;T&gt;.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StorageTraits</span>&lt;raw_ptr&lt;T, I&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> Type = UnretainedWrapper&lt;T, unretained_traits::MayNotDangle&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unwrap std::reference_wrapper and store it in a custom wrapper so that</span></span><br><span class="line"><span class="comment">// references are also protected with raw_ptr&lt;T&gt;.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StorageTraits</span>&lt;std::reference_wrapper&lt;T&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> Type = UnretainedRefWrapper&lt;T, unretained_traits::MayNotDangle&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="MethodReceiverStorageType"><a href="#MethodReceiverStorageType" class="headerlink" title="MethodReceiverStorageType"></a>MethodReceiverStorageType</h6><p>如果 Receiver 是指针，会使用 scoped_refptr 来存储，所以如果不想这样处理，需要 <code>base::UnRetained</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodReceiverStorageType converts the current receiver type to its stored</span></span><br><span class="line"><span class="comment">// type. For instance, it converts pointers to `scoped_refptr`, and wraps</span></span><br><span class="line"><span class="comment">// `UnretainedRefWrapper` to make it compliant with the internal callback</span></span><br><span class="line"><span class="comment">// invocation mechanism.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MethodReceiverStorageType</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> Type =</span><br><span class="line">      std::<span class="type">conditional_t</span>&lt;IsPointerV&lt;T&gt;, scoped_refptr&lt;RemovePointerT&lt;T&gt;&gt;, T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Trait, <span class="type">bool</span> b&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MethodReceiverStorageType</span>&lt;UnretainedRefWrapper&lt;T, Trait, b&gt;&gt; &#123;</span><br><span class="line">  <span class="comment">// We can&#x27;t use UnretainedRefWrapper as a receiver directly (see</span></span><br><span class="line">  <span class="comment">// UnretainedRefWrapperReceiver for why).</span></span><br><span class="line">  <span class="keyword">using</span> Type = UnretainedRefWrapperReceiver&lt;T, Trait, b&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPointer</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPointer</span>&lt;T*&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPointer</span>&lt;raw_ptr&lt;T, I&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">bool</span> IsPointerV = IsPointer&lt;T&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemovePointer</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemovePointer</span>&lt;T*&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemovePointer</span>&lt;raw_ptr&lt;T, I&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemovePointerT = <span class="keyword">typename</span> RemovePointer&lt;T&gt;::type;</span><br></pre></td></tr></table></figure><h6 id="BindState"><a href="#BindState" class="headerlink" title="BindState"></a>BindState</h6><p>再看 BindState 类型。这里的 Functor、BoundArgs 是上一步 MakeBindStateType 中通过 MakeStorageType、MethodReceiverStorageType 创建得到的</p><p>从下面可以看到 BindState 内部也是通过 tuple 来存储参数的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor, <span class="keyword">typename</span>... BoundArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BindState</span> <span class="keyword">final</span> : BindStateBase &#123;</span><br><span class="line">  Functor functor_;</span><br><span class="line">  std::tuple&lt;BoundArgs...&gt; bound_args_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> IsCancellable = std::bool_constant&lt;</span><br><span class="line">      CallbackCancellationTraits&lt;Functor,</span><br><span class="line">                                 std::tuple&lt;BoundArgs...&gt;&gt;::is_cancellable&gt;;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardFunctor, <span class="keyword">typename</span>... ForwardBoundArgs&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> BindState* <span class="title">Create</span><span class="params">(BindStateBase::InvokeFuncStorage invoke_func,</span></span></span><br><span class="line"><span class="params"><span class="function">                           ForwardFunctor&amp;&amp; functor,</span></span></span><br><span class="line"><span class="params"><span class="function">                           ForwardBoundArgs&amp;&amp;... bound_args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ban ref counted receivers that were not yet fully constructed to avoid</span></span><br><span class="line">    <span class="comment">// a common pattern of racy situation.</span></span><br><span class="line">    <span class="built_in">BanUnconstructedRefCountedReceiver</span>&lt;ForwardFunctor&gt;(bound_args...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IsCancellable is std::false_type if</span></span><br><span class="line">    <span class="comment">// CallbackCancellationTraits&lt;&gt;::IsCancelled returns always false.</span></span><br><span class="line">    <span class="comment">// Otherwise, it&#x27;s std::true_type.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BindState</span>(IsCancellable&#123;&#125;, invoke_func,</span><br><span class="line">                         std::forward&lt;ForwardFunctor&gt;(functor),</span><br><span class="line">                         std::forward&lt;ForwardBoundArgs&gt;(bound_args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardFunctor, <span class="keyword">typename</span>... ForwardBoundArgs&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">BindState</span><span class="params">(std::true_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                     BindStateBase::InvokeFuncStorage invoke_func,</span></span></span><br><span class="line"><span class="params"><span class="function">                     ForwardFunctor&amp;&amp; functor,</span></span></span><br><span class="line"><span class="params"><span class="function">                     ForwardBoundArgs&amp;&amp;... bound_args)</span></span></span><br><span class="line"><span class="function">      : BindStateBase(invoke_func,</span></span><br><span class="line"><span class="function">                      &amp;Destroy,</span></span><br><span class="line"><span class="function">                      &amp;QueryCancellationTraits&lt;BindState&gt;),</span></span><br><span class="line"><span class="function">        functor_(std::forward&lt;ForwardFunctor&gt;(functor)),</span></span><br><span class="line"><span class="function">        bound_args_(std::forward&lt;ForwardBoundArgs&gt;(bound_args)...) &#123;</span></span><br><span class="line">    <span class="comment">// We check the validity of nested callbacks (e.g., Bind(callback, ...)) in</span></span><br><span class="line">    <span class="comment">// release builds to avoid null pointers from ending up in posted tasks,</span></span><br><span class="line">    <span class="comment">// causing hard-to-diagnose crashes. Ideally we&#x27;d do this for all functors</span></span><br><span class="line">    <span class="comment">// here, but that would have a large binary size impact.</span></span><br><span class="line">    <span class="keyword">if</span> (is_nested_callback) &#123;</span><br><span class="line">      <span class="built_in">CHECK</span>(!<span class="built_in">IsNull</span>(functor_));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DCHECK</span>(!<span class="built_in">IsNull</span>(functor_));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BindState::Create 函数内部调用 BindState 的构造函数，在构造函数里面把 functor 和 bound_args 存在 <code>functor_</code> 和 <code>bound_args_</code> 中，同时把 invoke_func 存在父类 BindStateBase 中</p><p>####### BindStateBase</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BASE_EXPORT</span> BindStateBase</span><br><span class="line">    : <span class="keyword">public</span> RefCountedThreadSafe&lt;BindStateBase, BindStateBaseRefCountTraits&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> InvokeFuncStorage = <span class="built_in">void</span> (*)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  InvokeFuncStorage polymorphic_invoke_;</span><br><span class="line">  <span class="built_in">void</span> (*destructor_)(<span class="type">const</span> BindStateBase*);</span><br><span class="line">  <span class="built_in">bool</span> (*query_cancellation_traits_)(<span class="type">const</span> BindStateBase*,</span><br><span class="line">                                     CancellationQueryMode mode);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="MakeUnboundRunType"><a href="#MakeUnboundRunType" class="headerlink" title="MakeUnboundRunType"></a>MakeUnboundRunType</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a RunType of bound functor.</span></span><br><span class="line"><span class="comment">// E.g. MakeUnboundRunType&lt;R(A, B, C), A, B&gt; is evaluated to R(C).</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor, <span class="keyword">typename</span>... BoundArgs&gt;</span><br><span class="line"><span class="keyword">using</span> MakeUnboundRunType =</span><br><span class="line">    <span class="keyword">typename</span> BindTypeHelper&lt;Functor, BoundArgs...&gt;::UnboundRunType;</span><br></pre></td></tr></table></figure><p>里面调用了 BindTypeHelper，上面已经介绍过了。</p><h5 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h5><p>再看看 Invoker。Invoker 里面有 RunOnce 和 Run 函数。上面创建 BindState 时会把 <code>Run/RunOnce</code> 的函数指针传给 BindState</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> StorageType, <span class="keyword">typename</span> UnboundRunType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Invoker</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StorageType就是BindState</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> StorageType, <span class="keyword">typename</span> R, <span class="keyword">typename</span>... UnboundArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Invoker</span>&lt;StorageType, <span class="built_in">R</span>(UnboundArgs...)&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> R <span class="title">RunOnce</span><span class="params">(BindStateBase* base,</span></span></span><br><span class="line"><span class="params"><span class="function">                   PassingType&lt;UnboundArgs&gt;... unbound_args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Local references to make debugger stepping easier. If in a debugger,</span></span><br><span class="line">    <span class="comment">// you really want to warp ahead and step through the</span></span><br><span class="line">    <span class="comment">// InvokeHelper&lt;&gt;::MakeItSo() call below.</span></span><br><span class="line">    StorageType* storage = <span class="built_in">static_cast</span>&lt;StorageType*&gt;(base);</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> num_bound_args =</span><br><span class="line">        std::tuple_size_v&lt;<span class="keyword">decltype</span>(storage-&gt;bound_args_)&gt;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RunImpl</span>(std::<span class="built_in">move</span>(storage-&gt;functor_),</span><br><span class="line">                   std::<span class="built_in">move</span>(storage-&gt;bound_args_),</span><br><span class="line">                   std::<span class="built_in">make_index_sequence</span>&lt;num_bound_args&gt;(),</span><br><span class="line">                   std::forward&lt;UnboundArgs&gt;(unbound_args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunOnce和Run的区别在于RunOnce会把functor_和bound_args_进行move</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> R <span class="title">Run</span><span class="params">(BindStateBase* base, PassingType&lt;UnboundArgs&gt;... unbound_args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Local references to make debugger stepping easier. If in a debugger,</span></span><br><span class="line">    <span class="comment">// you really want to warp ahead and step through the</span></span><br><span class="line">    <span class="comment">// InvokeHelper&lt;&gt;::MakeItSo() call below.</span></span><br><span class="line">    <span class="type">const</span> StorageType* storage = <span class="built_in">static_cast</span>&lt;StorageType*&gt;(base);</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> num_bound_args =</span><br><span class="line">        std::tuple_size_v&lt;<span class="keyword">decltype</span>(storage-&gt;bound_args_)&gt;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RunImpl</span>(storage-&gt;functor_, storage-&gt;bound_args_,</span><br><span class="line">                   std::<span class="built_in">make_index_sequence</span>&lt;num_bound_args&gt;(),</span><br><span class="line">                   std::forward&lt;UnboundArgs&gt;(unbound_args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>PassingType 如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> PassingType = std::<span class="type">conditional_t</span>&lt;std::is_scalar_v&lt;T&gt;, T, T&amp;&amp;&gt;;</span><br></pre></td></tr></table></figure><p>RunOnce 和 Run 都调用了 RunImpl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StorageType就是BindState</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> StorageType, <span class="keyword">typename</span> R, <span class="keyword">typename</span>... UnboundArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Invoker</span>&lt;StorageType, <span class="built_in">R</span>(UnboundArgs...)&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor, <span class="keyword">typename</span> BoundArgsTuple, <span class="type">size_t</span>... indices&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">inline</span> R <span class="title">RunImpl</span><span class="params">(Functor&amp;&amp; functor,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BoundArgsTuple&amp;&amp; bound,</span></span></span><br><span class="line"><span class="params"><span class="function">                          std::index_sequence&lt;indices...&gt; seq,</span></span></span><br><span class="line"><span class="params"><span class="function">                          UnboundArgs&amp;&amp;... unbound_args)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_method = MakeFunctorTraits&lt;Functor&gt;::is_method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> DecayedArgsTuple = std::<span class="type">decay_t</span>&lt;BoundArgsTuple&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_weak_call =</span><br><span class="line">        IsWeakMethod&lt;is_method,</span><br><span class="line">                     std::<span class="type">tuple_element_t</span>&lt;indices, DecayedArgsTuple&gt;...&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> InvokeHelper&lt;is_weak_call, R, indices...&gt;::<span class="built_in">MakeItSo</span>(</span><br><span class="line">        std::forward&lt;Functor&gt;(functor), std::forward&lt;BoundArgsTuple&gt;(bound),</span><br><span class="line">        std::forward&lt;UnboundArgs&gt;(unbound_args)...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>RunImpl 会根据当前绑定的 Receiver 是否是 WeakPtr 进行不同的调用</p><h6 id="IsWeakMethod"><a href="#IsWeakMethod" class="headerlink" title="IsWeakMethod"></a>IsWeakMethod</h6><p>RunImpl 先通过 IsWeakMethod 判断 Receiver 是否是 WeakPtr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IsWeakMethod is a helper that determine if we are binding a WeakPtr&lt;&gt; to a</span></span><br><span class="line"><span class="comment">// method.  It is used internally by Bind() to select the correct</span></span><br><span class="line"><span class="comment">// InvokeHelper that will no-op itself in the event the WeakPtr&lt;&gt; for</span></span><br><span class="line"><span class="comment">// the target object is invalidated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The first argument should be the type of the object that will be received by</span></span><br><span class="line"><span class="comment">// the method.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> is_method, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsWeakMethod</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsWeakMethod</span>&lt;<span class="literal">true</span>, T, Args...&gt; : IsWeakReceiver&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsWeakReceiver</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsWeakReceiver</span>&lt;std::reference_wrapper&lt;T&gt;&gt; : IsWeakReceiver&lt;T&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsWeakReceiver</span>&lt;WeakPtr&lt;T&gt;&gt; : std::true_type &#123;&#125;;</span><br></pre></td></tr></table></figure><h6 id="InvokeHelper"><a href="#InvokeHelper" class="headerlink" title="InvokeHelper"></a>InvokeHelper</h6><p>然后调用 InvokeHelper。InvokeHelper 根据是否是 weak_call 做不同处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> is_weak_call, <span class="keyword">typename</span> ReturnType, <span class="type">size_t</span>... indices&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InvokeHelper</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="type">size_t</span>... indices&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InvokeHelper</span>&lt;<span class="literal">false</span>, ReturnType, indices...&gt; &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor, <span class="keyword">typename</span> BoundArgsTuple, <span class="keyword">typename</span>... RunArgs&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">inline</span> ReturnType <span class="title">MakeItSo</span><span class="params">(Functor&amp;&amp; functor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    BoundArgsTuple&amp;&amp; bound,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    RunArgs&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Traits = MakeFunctorTraits&lt;Functor&gt;;</span><br><span class="line">    <span class="keyword">return</span> Traits::<span class="built_in">Invoke</span>(</span><br><span class="line">        std::forward&lt;Functor&gt;(functor),</span><br><span class="line">        <span class="built_in">Unwrap</span>(std::<span class="built_in">get</span>&lt;indices&gt;(std::forward&lt;BoundArgsTuple&gt;(bound)))...,</span><br><span class="line">        std::forward&lt;RunArgs&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果不是 weak_call，那么直接使用 <code>MakeFunctorTraits&lt;Functor&gt;::Invoke</code>。</p><p>注意这里从存储参数的 tuple 中取参数时，是直接先从 tuple 中 get，然后 Unwrap，所以这里的返回值要么是&amp;要么是&amp;&amp;。但是 AssertBindArgsValidity 中检查参数时如果是 OnceCallback，那么检查的参数是&amp;&amp;，如果是 RepeatingCallback，检查的参数是 const&amp;，所以虽然这里调用时取参数不带 const，但是下面这种定义还是不允许（AssertBindArgsValidity 检查会不通过）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">base::RepeatingCallback&lt;<span class="built_in">long</span>(<span class="type">int</span>, <span class="type">long</span>)&gt; cb = base::<span class="built_in">BindRepeating</span>(</span><br><span class="line">    [](<span class="type">int</span>&amp; x, <span class="type">int</span> y, <span class="type">long</span> z) &#123; <span class="keyword">return</span> x * y * z; &#125;, i); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RepeatingCallback中只能是</span></span><br><span class="line">base::RepeatingCallback&lt;<span class="built_in">long</span>(<span class="type">int</span>, <span class="type">long</span>)&gt; cb = base::<span class="built_in">BindRepeating</span>(</span><br><span class="line">    [](<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">int</span> y, <span class="type">long</span> z) &#123; <span class="keyword">return</span> x * y * z; &#125;, i);</span><br></pre></td></tr></table></figure><p>接下来看看是 weak_call 的情况下，InvokeHelper 如何调用。</p><p>可以看到，先判断 Receiver 的 WeakPtr 是否还有效，只有在有效的情况下才进行调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType, <span class="type">size_t</span>... indices&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InvokeHelper</span>&lt;<span class="literal">true</span>, ReturnType, indices...&gt; &#123;</span><br><span class="line">  <span class="comment">// WeakCalls are only supported for functions with a void return type.</span></span><br><span class="line">  <span class="comment">// Otherwise, the function result would be undefined if the WeakPtr&lt;&gt;</span></span><br><span class="line">  <span class="comment">// is invalidated.</span></span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_void_v&lt;ReturnType&gt;,</span><br><span class="line">                <span class="string">&quot;weak_ptrs can only bind to methods without return values&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor, <span class="keyword">typename</span> BoundArgsTuple, <span class="keyword">typename</span>... RunArgs&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">MakeItSo</span><span class="params">(Functor&amp;&amp; functor,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BoundArgsTuple&amp;&amp; bound,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RunArgs&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(bound))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">using</span> Traits = MakeFunctorTraits&lt;Functor&gt;;</span><br><span class="line">    Traits::<span class="built_in">Invoke</span>(</span><br><span class="line">        std::forward&lt;Functor&gt;(functor),</span><br><span class="line">        <span class="built_in">Unwrap</span>(std::<span class="built_in">get</span>&lt;indices&gt;(std::forward&lt;BoundArgsTuple&gt;(bound)))...,</span><br><span class="line">        std::forward&lt;RunArgs&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="创建-OnceCallback"><a href="#创建-OnceCallback" class="headerlink" title="创建 OnceCallback"></a>创建 OnceCallback</h5><p>BindImpl 函数的最后就是创建 OnceCallback。</p><p>先通过 BindState::Create 函数创建一个 BindState 对象并返回他的指针，然后通过该指针创建 OnceCallback 对象。</p><p>OnceCallback 类结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TRIVIAL_ABI</span> OnceCallback&lt;<span class="built_in">R</span>(Args...)&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> ResultType = R;</span><br><span class="line">  <span class="keyword">using</span> RunType = <span class="built_in">R</span>(Args...);</span><br><span class="line">  <span class="keyword">using</span> PolymorphicInvoke = <span class="built_in">R</span> (*)(internal::BindStateBase*,</span><br><span class="line">                                  internal::PassingType&lt;Args&gt;...);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">OnceCallback</span>(OnceCallback&amp;&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">  OnceCallback&amp; <span class="keyword">operator</span>=(OnceCallback&amp;&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Internal constructor for `base::BindOnce()`.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">OnceCallback</span><span class="params">(internal::BindStateBase* bind_state)</span></span></span><br><span class="line"><span class="function">      : holder_(bind_state) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">R <span class="title">Run</span><span class="params">(Args... args)</span> <span class="type">const</span>&amp; </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!<span class="built_in">sizeof</span>(*<span class="keyword">this</span>),</span><br><span class="line">                  <span class="string">&quot;OnceCallback::Run() may only be invoked on a non-const &quot;</span></span><br><span class="line">                  <span class="string">&quot;rvalue, i.e. std::move(callback).Run().&quot;</span>);</span><br><span class="line">    <span class="built_in">NOTREACHED</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">R <span class="title">Run</span><span class="params">(Args... args)</span> &amp;&amp; </span>&#123;</span><br><span class="line">    <span class="comment">// Move the callback instance into a local variable before the invocation,</span></span><br><span class="line">    <span class="comment">// that ensures the internal state is cleared after the invocation.</span></span><br><span class="line">    <span class="comment">// It&#x27;s not safe to touch |this| after the invocation, since running the</span></span><br><span class="line">    <span class="comment">// bound function may destroy |this|.</span></span><br><span class="line">    internal::BindStateHolder holder = std::<span class="built_in">move</span>(holder_);</span><br><span class="line">    PolymorphicInvoke f = <span class="comment">// 强制转换函数指针</span></span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;PolymorphicInvoke&gt;(holder.<span class="built_in">polymorphic_invoke</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(holder.<span class="built_in">bind_state</span>().<span class="built_in">get</span>(), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  internal::BindStateHolder holder_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>OnceCallback 的构造函数接受 BindStateBase 指针，而 BindState 就是 BindStateBase 的子类。</p><p>在 OnceCallback 内部，BindStateHolder 会存储构造函数输入的 BindState 指针，看看这个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BASE_EXPORT</span> TRIVIAL_ABI BindStateHolder &#123;</span><br><span class="line">  <span class="keyword">using</span> InvokeFuncStorage = BindStateBase::InvokeFuncStorage;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">BindStateHolder</span>(BindStateBase* bind_state)</span><br><span class="line">    : <span class="built_in">bind_state_</span>(<span class="built_in">AdoptRef</span>(bind_state)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">InvokeFuncStorage <span class="title">polymorphic_invoke</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bind_state_-&gt;polymorphic_invoke_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">explicit</span> <span class="title">BindStateHolder</span><span class="params">(BindStateBase* bind_state)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> scoped_refptr&lt;BindStateBase&gt;&amp; <span class="title">bind_state</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bind_state_; &#125;</span><br><span class="line"></span><br><span class="line">  scoped_refptr&lt;BindStateBase&gt; bind_state_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BindStateHolder 内部通过 scoped_refptr<BindStateBase>来管理 BindState 指针。BindStateHolder 可以拷贝和移动，因为他会用在 OnceCallback 和 RepeatingCallback 中。</p><p>再回到 OnceCallback 的 Run 函数，其只有右值版本，左值版本不允许使用。Run 内部就是调用 BindState 的 polymorphic_invoke 函数指针发起调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">R <span class="title">Run</span><span class="params">(Args... args)</span> &amp;&amp; </span>&#123;</span><br><span class="line">    <span class="comment">// Move the callback instance into a local variable before the invocation,</span></span><br><span class="line">    <span class="comment">// that ensures the internal state is cleared after the invocation.</span></span><br><span class="line">    <span class="comment">// It&#x27;s not safe to touch |this| after the invocation, since running the</span></span><br><span class="line">    <span class="comment">// bound function may destroy |this|.</span></span><br><span class="line">    internal::BindStateHolder holder = std::<span class="built_in">move</span>(holder_);</span><br><span class="line">    PolymorphicInvoke f = <span class="comment">// 强制转换函数指针</span></span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;PolymorphicInvoke&gt;(holder.<span class="built_in">polymorphic_invoke</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(holder.<span class="built_in">bind_state</span>().<span class="built_in">get</span>(), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面在创建 BindState 时会传给 BindState 一个 invoke 指针，这个指针根据是 OnceCallback 还是 RepeatingCallback 会分别为 Invoker::RunOnce、Invoker::Run，这两个函数上面 Invoker 已经介绍。</p><p>总的来说，Chromium 的 Bind 和标准库的 bind_front 比较类似，而 Callback 和 std::function 则有不小的差别，Callback 只能由 Bind 创建，无法接受其他可调用对象为参数，相对 std::function 来说要简单一些。</p><p>参考资料：</p><p><a href="https://chromium.googlesource.com/chromium/src/+/HEAD/docs/callback.md">https://chromium.googlesource.com/chromium/src/+/HEAD/docs/callback.md</a></p><p><a href="https://blog.csdn.net/Luoshengyang/article/details/46747797">https://blog.csdn.net/Luoshengyang/article/details/46747797</a></p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium base库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium base 库之 WeakPtr</title>
      <link href="/2023/05/20/Chromium-base-%E5%BA%93%E4%B9%8B-WeakPtr/"/>
      <url>/2023/05/20/Chromium-base-%E5%BA%93%E4%B9%8B-WeakPtr/</url>
      
        <content type="html"><![CDATA[<p>这篇文章接着上一篇继续分析 Chromium 的 WeakPtr。</p><p><img src="/images/Chromium-base-%E5%BA%93%E4%B9%8B-WeakPtr/SOHabgpvFoD0ySxDpkvcuHxOn1g.jpg"></p><h2 id="WeakPtr"><a href="#WeakPtr" class="headerlink" title="WeakPtr"></a>WeakPtr</h2><p>Chromium 没有像标准库一样把强弱指针关联起来，而是把两者分开。一个被 scoped_refptr 管理的对象可以把自己的指针包装成 WeakPtr 给其他对象使用，其他对象拿到 WeakPtr 后可以根据 WeakPtr 判断其指向的对象是否还存活，从而避免访问一个不存在的对象。</p><p>先通过一个例子看看如何使用 WeakPtr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">WeakPtrFactory&lt;A&gt; weak_factory_&#123;<span class="keyword">this</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">WeakPtr&lt;A&gt; b = a.weak_factory_.<span class="built_in">GetWeakPtr</span>();</span><br></pre></td></tr></table></figure><p>让 A 内部持有 WeakPtrFactory，然后通过这个 WeakPtrFactory 产生 WeakPtr。当 WeakPtrFactory 析构时，会使由他产生的 WeakPtr 失效</p><h2 id="WeakPtrFactory"><a href="#WeakPtrFactory" class="headerlink" title="WeakPtrFactory"></a>WeakPtrFactory</h2><p>Chromium 通过 WeakPtrFactory 产生 WeakPtr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeakPtrFactory</span> : <span class="keyword">public</span> internal::WeakPtrFactoryBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">WeakPtrFactory</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">      : WeakPtrFactoryBase(reinterpret_cast&lt;uintptr_t&gt;(ptr)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">WeakPtr&lt;T&gt; <span class="title">GetWeakPtr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WeakPtr</span>&lt;T&gt;(weak_reference_owner_.<span class="built_in">GetRef</span>(),</span><br><span class="line">                      <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(ptr_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">InvalidateWeakPtrs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(ptr_);</span><br><span class="line">    weak_reference_owner_.<span class="built_in">Invalidate</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call this method to determine if any weak pointers exist.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">HasWeakPtrs</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(ptr_);</span><br><span class="line">    <span class="keyword">return</span> weak_reference_owner_.<span class="built_in">HasRefs</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="WeakPtrFactoryBase"><a href="#WeakPtrFactoryBase" class="headerlink" title="WeakPtrFactoryBase"></a>WeakPtrFactoryBase</h3><p>WeakPtrFactory 自身没有数据成员，他把任务交给了父类 WeakPtrFactoryBase</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BASE_EXPORT</span> WeakPtrFactoryBase &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">WeakPtrFactoryBase</span>(<span class="type">uintptr_t</span> ptr): <span class="built_in">ptr_</span>(ptr) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">WeakPtrFactoryBase</span>()&#123;</span><br><span class="line">    ptr_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  internal::WeakReferenceOwner weak_reference_owner_;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="WeakReferenceOwner"><a href="#WeakReferenceOwner" class="headerlink" title="WeakReferenceOwner"></a>WeakReferenceOwner</h4><p>WeakPtrFactoryBase 内部持有 WeakReferenceOwner 类型的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BASE_EXPORT</span> WeakReferenceOwner &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">WeakReferenceOwner</span>():</span><br><span class="line">    <span class="built_in">flag_</span>(<span class="built_in">MakeRefCounted</span>&lt;WeakReference::Flag&gt;()) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">WeakReferenceOwner</span>()&#123;</span><br><span class="line">    flag_-&gt;<span class="built_in">Invalidate</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">WeakReference <span class="title">GetRef</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WeakReference</span>(flag_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">HasRefs</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> !flag_-&gt;<span class="built_in">HasOneRef</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag_-&gt;<span class="built_in">Invalidate</span>();</span><br><span class="line">    flag_ = <span class="built_in">MakeRefCounted</span>&lt;WeakReference::Flag&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  scoped_refptr&lt;WeakReference::Flag&gt; flag_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>WeakReferenceOwner 持有 <code>scoped_refptr&lt;WeakReference::Flag&gt;</code> 类型的对象。</p><p>WeakReferenceOwner 可以通过 GetRef 方法得到 WeakReference。其得到的 WeakReference 里的 <code>scoped_refptr&lt;WeakReference::Flag&gt;</code> 成员，和 WeakReferenceOwner 共享同一个 <code>WeakReference::Flag</code> 对象。</p><h5 id="WeakReference"><a href="#WeakReference" class="headerlink" title="WeakReference"></a>WeakReference</h5><p>看到这里就很清楚了：WeakPtrFactory 和由他创建的 WeakPtr 共享一个 <code>WeakReference::Flag</code>，当 WeakPtrFactory 析构时会这个 Flag 失效，从而其他 WeakPtr 能够知道 WeakPtrFactory 已经失效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BASE_EXPORT</span> TRIVIAL_ABI WeakReference &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Although Flag is bound to a specific SequencedTaskRunner, it may be</span></span><br><span class="line">  <span class="comment">// deleted from another via base::WeakPtr::~WeakPtr().</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">BASE_EXPORT</span> Flag : <span class="keyword">public</span> RefCountedThreadSafe&lt;Flag&gt; &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Flag</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      invalidated_.<span class="built_in">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      <span class="comment">// WeakPtrs must be checked on the same sequenced thread.</span></span><br><span class="line">      <span class="built_in">DCHECK_CALLED_ON_VALID_SEQUENCE</span>(sequence_checker_);</span><br><span class="line">      <span class="keyword">return</span> !invalidated_.<span class="built_in">IsSet</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">MaybeValid</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !invalidated_.<span class="built_in">IsSet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">base</span>::RefCountedThreadSafe&lt;Flag&gt;;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Flag</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SEQUENCE_CHECKER</span>(sequence_checker_);</span><br><span class="line">    AtomicFlag invalidated_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WeakReference</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">WeakReference</span><span class="params">(<span class="type">const</span> scoped_refptr&lt;Flag&gt;&amp; flag)</span> : flag_(flag) &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">WeakReference</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WeakReference</span>(WeakReference&amp;&amp; other) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">WeakReference</span>(<span class="type">const</span> WeakReference&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  WeakReference&amp; <span class="keyword">operator</span>=(WeakReference&amp;&amp; other) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">  WeakReference&amp; <span class="keyword">operator</span>=(<span class="type">const</span> WeakReference&amp; other) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flag_ &amp;&amp; flag_-&gt;<span class="built_in">IsValid</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">MaybeValid</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flag_ &amp;&amp; flag_-&gt;<span class="built_in">MaybeValid</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  scoped_refptr&lt;<span class="type">const</span> Flag&gt; flag_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建-WeakPtr"><a href="#创建-WeakPtr" class="headerlink" title="创建 WeakPtr"></a>创建 WeakPtr</h2><p>最后看看由 WeakPtrFactory 创建 WeakPtr：通过 <code>weak_reference_owner_</code> 得到 WeakReference</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeakPtrFactory</span> : <span class="keyword">public</span> internal::WeakPtrFactoryBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">WeakPtrFactory</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">      : WeakPtrFactoryBase(reinterpret_cast&lt;uintptr_t&gt;(ptr)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">WeakPtr&lt;T&gt; <span class="title">GetWeakPtr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">WeakPtr</span>&lt;T&gt;(weak_reference_owner_.<span class="built_in">GetRef</span>(),</span><br><span class="line">                      <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(ptr_));</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后把 WeakReference 传给 WeakPtr 的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TRIVIAL_ABI</span> WeakPtr : <span class="keyword">public</span> internal::WeakPtrBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">WasInvalidated</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_ &amp;&amp; !ref_.<span class="built_in">IsValid</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">MaybeValid</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ref_.<span class="built_in">MaybeValid</span>(); &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">WeakPtr</span>(<span class="type">const</span> internal::WeakReference&amp; ref, T* ptr)</span><br><span class="line">      : <span class="built_in">WeakPtrBase</span>(ref, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="WeakPtrBase"><a href="#WeakPtrBase" class="headerlink" title="WeakPtrBase"></a>WeakPtrBase</h3><p>WeakPtr 继承 WeakPtrBase</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BASE_EXPORT</span> TRIVIAL_ABI WeakPtrBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">WeakPtrBase</span>() : <span class="built_in">ptr_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">WeakPtrBase</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">WeakPtrBase</span>(<span class="type">const</span> WeakPtrBase&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">WeakPtrBase</span>(WeakPtrBase&amp;&amp; other) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">  WeakPtrBase&amp; <span class="keyword">operator</span>=(<span class="type">const</span> WeakPtrBase&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  WeakPtrBase&amp; <span class="keyword">operator</span>=(WeakPtrBase&amp;&amp; other) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ref_ = internal::<span class="built_in">WeakReference</span>();</span><br><span class="line">    ptr_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">WeakPtrBase</span>(<span class="type">const</span> WeakReference&amp; ref, <span class="type">uintptr_t</span> ptr)</span><br><span class="line">      : <span class="built_in">ref_</span>(ref), <span class="built_in">ptr_</span>(ptr) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  WeakReference ref_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This pointer is only valid when ref_.is_valid() is true.  Otherwise, its</span></span><br><span class="line">  <span class="comment">// value is undefined (as opposed to nullptr).</span></span><br><span class="line">  <span class="type">uintptr_t</span> ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>WeakPtrBase 内部持有 WeakReference 实例，而 WeakReference 内部有 <code>scoped_refptr&lt;Flag&gt;</code>，和 WeakPtrFactory 里面的是同一个。</p><p>总的来说，Chromium 的智能指针比标准库智能指针要稍微简单一些，但是独具匠心，将强弱引用分开实现。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium base库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium base 库之 scoped_refptr</title>
      <link href="/2023/05/20/Chromium-base-%E5%BA%93%E4%B9%8B-scoped-refptr/"/>
      <url>/2023/05/20/Chromium-base-%E5%BA%93%E4%B9%8B-scoped-refptr/</url>
      
        <content type="html"><![CDATA[<p>之前做过小半年的 Chromium 多媒体项目，对 Chromium 的智能指针比较好奇，这篇文章分析一下 Chromium 的智能指针。</p><p>Chromium 主要有 scoped_refptr、WeakPtr 两种智能指针，我们先看 scoped_refptr。</p><h2 id="scoped-refptr"><a href="#scoped-refptr" class="headerlink" title="scoped_refptr"></a>scoped_refptr</h2><p>scoped_refptr 类似 shared_ptr，也是共享指针。先看一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyFoo</span> : <span class="keyword">public</span> RefCounted&lt;MyFoo&gt; &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">RefCounted</span>&lt;MyFoo&gt;;  <span class="comment">// Allow destruction by RefCounted&lt;&gt;.</span></span><br><span class="line">    ~<span class="built_in">MyFoo</span>();                        <span class="comment">// Destructor must be private/protected.</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    scoped_refptr&lt;MyFoo&gt; foo = <span class="built_in">MakeRefCounted</span>&lt;MyFoo&gt;();</span><br><span class="line">    foo-&gt;<span class="built_in">Method</span>(param);</span><br><span class="line">    <span class="comment">// |foo| is released when this function returns</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由例子可知，使用 scoped_refptr 管理的类需要继承 RefCounted<T>，这和标准库不一样，标准库只有在需要使用 shared_from_this()时需要继承 enable_shared_from_this，其他情况是无需继承的。</p><p>scoped_refptr 定义如下，他只有一个成员数据，指向被管理对象的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TRIVIAL_ABI</span> scoped_refptr &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T element_type;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">scoped_refptr</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow implicit construction from nullptr.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">scoped_refptr</span><span class="params">(std::<span class="type">nullptr_t</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  T* ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="接受裸指针的构造函数"><a href="#接受裸指针的构造函数" class="headerlink" title="接受裸指针的构造函数"></a>接受裸指针的构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constructs from a raw pointer. Note that this constructor allows implicit</span></span><br><span class="line">  <span class="comment">// conversion from T* to scoped_refptr&lt;T&gt; which is strongly discouraged. If</span></span><br><span class="line">  <span class="comment">// you are creating a new ref-counted object please use</span></span><br><span class="line">  <span class="comment">// base::MakeRefCounted&lt;T&gt;() or base::WrapRefCounted&lt;T&gt;(). Otherwise you</span></span><br><span class="line">  <span class="comment">// should move or copy construct from an existing scoped_refptr&lt;T&gt; to the</span></span><br><span class="line">  <span class="comment">// ref-counted object.</span></span><br><span class="line">  <span class="built_in">scoped_refptr</span>(T* p) : <span class="built_in">ptr_</span>(p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr_)</span><br><span class="line">      <span class="built_in">AddRef</span>(ptr_);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>AddRef</code> 是静态函数，会调用 T 类型的 <code>AddRef</code> 函数增加引用计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> scoped_refptr&lt;T&gt;::<span class="built_in">AddRef</span>(T* ptr) &#123;</span><br><span class="line">  base::subtle::<span class="built_in">AssertRefCountBaseMatches</span>(ptr, ptr);</span><br><span class="line">  ptr-&gt;<span class="built_in">AddRef</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AssertRefCountBaseMatches 会检查输入的指针指向的类是否继承 RefCounted 类，以及当前类和 RefCounted 的模板参数类型是否是父子类关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">AssertRefCountBaseMatches</span><span class="params">(<span class="type">const</span> T*, <span class="type">const</span> RefCounted&lt;U, V&gt;*)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_base_of_v&lt;U, T&gt;,</span><br><span class="line">                <span class="string">&quot;T implements RefCounted&lt;U&gt;, but U is not a base of T.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">AssertRefCountBaseMatches</span><span class="params">(<span class="type">const</span> T*,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> RefCountedThreadSafe&lt;U, V&gt;*)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(</span><br><span class="line">      std::is_base_of_v&lt;U, T&gt;,</span><br><span class="line">      <span class="string">&quot;T implements RefCountedThreadSafe&lt;U&gt;, but U is not a base of T.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝-x2F-移动构造"><a href="#拷贝-x2F-移动构造" class="headerlink" title="拷贝&#x2F;移动构造"></a>拷贝&#x2F;移动构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy constructor. This is required in addition to the copy conversion</span></span><br><span class="line">  <span class="comment">// constructor below.</span></span><br><span class="line">  <span class="built_in">scoped_refptr</span>(<span class="type">const</span> scoped_refptr&amp; r) : <span class="built_in">scoped_refptr</span>(r.ptr_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy conversion constructor.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U,</span><br><span class="line">            <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">                std::is_convertible&lt;U*, T*&gt;::value&gt;::type&gt;</span><br><span class="line">  <span class="built_in">scoped_refptr</span>(<span class="type">const</span> scoped_refptr&lt;U&gt;&amp; r) : <span class="built_in">scoped_refptr</span>(r.ptr_) &#123;&#125;</span><br></pre></td></tr></table></figure><p>拷贝构造函数内部会委托给接受裸指针的构造函数，同样会调用 AddRef。</p><p>接受泛型 scoped_refptr 的拷贝构造函数需要满足 is_convertible 条件，比如父类-子类，才生效，内部也是委托给接受裸指针的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move constructor. This is required in addition to the move conversion</span></span><br><span class="line">  <span class="comment">// constructor below.</span></span><br><span class="line">  <span class="built_in">scoped_refptr</span>(scoped_refptr&amp;&amp; r) <span class="keyword">noexcept</span> : <span class="built_in">ptr_</span>(r.ptr_) &#123; r.ptr_ = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Move conversion constructor.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U,</span><br><span class="line">            <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">                std::is_convertible&lt;U*, T*&gt;::value&gt;::type&gt;</span><br><span class="line">  <span class="built_in">scoped_refptr</span>(scoped_refptr&lt;U&gt;&amp;&amp; r) <span class="keyword">noexcept</span> : <span class="built_in">ptr_</span>(r.ptr_) &#123;</span><br><span class="line">    r.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">scoped_refptr</span>() &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!base::subtle::<span class="built_in">IsRefCountPreferenceOverridden</span>(</span><br><span class="line">                      <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="literal">nullptr</span>), <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="literal">nullptr</span>)),</span><br><span class="line">                  <span class="string">&quot;It&#x27;s unsafe to override the ref count preference.&quot;</span></span><br><span class="line">                  <span class="string">&quot; Please remove REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE&quot;</span></span><br><span class="line">                  <span class="string">&quot; from subclasses.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr_)</span><br><span class="line">      <span class="built_in">Release</span>(ptr_);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>析构函数则是调用静态的 Release 函数，Release 内部调用被管理对象的 Release 方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> scoped_refptr&lt;T&gt;::<span class="built_in">Release</span>(T* ptr) &#123;</span><br><span class="line">  base::subtle::<span class="built_in">AssertRefCountBaseMatches</span>(ptr, ptr);</span><br><span class="line">  ptr-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IsRefCountPreferenceOverridden 则是检查 RefCountPreference 是否被子类修改，RefCountPreference 控制引用计数是从 0 开始计算还是从 1 开始计算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">IsRefCountPreferenceOverridden</span><span class="params">(<span class="type">const</span> T*,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> RefCounted&lt;U, V&gt;*)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !std::is_same&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(T::kRefCountPreference)&gt;,</span><br><span class="line">                       std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(U::kRefCountPreference)&gt;&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重置-x2F-释放"><a href="#重置-x2F-释放" class="headerlink" title="重置&#x2F;释放"></a>重置&#x2F;释放</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sets managed object to null and releases reference to the previous managed</span></span><br><span class="line">  <span class="comment">// object, if it existed.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123; <span class="built_in">scoped_refptr</span>().<span class="built_in">swap</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the owned pointer (if any), releasing ownership to the caller. The</span></span><br><span class="line">  <span class="comment">// caller is responsible for managing the lifetime of the reference.</span></span><br><span class="line">  [[nodiscard]] <span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      T* ptr = ptr_;</span><br><span class="line">      ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="RefCountedThreadSafe"><a href="#RefCountedThreadSafe" class="headerlink" title="RefCountedThreadSafe"></a>RefCountedThreadSafe</h3><p>上面关于引用计数的 Release、AddRef 方法都是在 RefCounted 基类中定义。</p><p>除了 RefCounted，还有另一个类 RefCountedThreadSafe。这两个类作用是一样的，但是 RefCountedThreadSafe 是线程安全的，所以这里只分析 RefCountedThreadSafe。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Traits = DefaultRefCountedThreadSafeTraits&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> RefCountedThreadSafe : <span class="keyword">public</span> subtle::RefCountedThreadSafeBase &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// 默认的kRefCountPreference是kStartRefCountFromZeroTag，也就是引用计数从0开始</span></span><br><span class="line"> <span class="comment">// 用户可以在T类型中定义T::kRefCountPreference设置想要的RefCountPreference</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> subtle::StartRefCountFromZeroTag kRefCountPreference =</span><br><span class="line">      subtle::kStartRefCountFromZeroTag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">T继承RefCountedThreadSafe&lt;T&gt;，如果T中没有定义kRefCountPreference，</span></span><br><span class="line"><span class="comment">那么T::kRefCountPreference就是RefCountedThreadSafe中的kRefCountPreference，</span></span><br><span class="line"><span class="comment">如果T定义了kRefCountPreference，那么这里会使用用户自己希望的RefCountPreference</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">RefCountedThreadSafe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      : subtle::RefCountedThreadSafeBase(T::kRefCountPreference) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承RefCountedThreadSafe的类不能发生拷贝构造和拷贝赋值</span></span><br><span class="line"><span class="comment">// 只能通过scoped_refptr进行共享</span></span><br><span class="line">  <span class="built_in">RefCountedThreadSafe</span>(<span class="type">const</span> RefCountedThreadSafe&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  RefCountedThreadSafe&amp; <span class="keyword">operator</span>=(<span class="type">const</span> RefCountedThreadSafe&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddRef</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="built_in">AddRefImpl</span>(T::kRefCountPreference); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subtle::RefCountedThreadSafeBase::<span class="built_in">Release</span>()) &#123;</span><br><span class="line">      <span class="built_in">ANALYZER_SKIP_THIS_PATH</span>();</span><br><span class="line">      Traits::<span class="built_in">Destruct</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> T*&gt;(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ~<span class="built_in">RefCountedThreadSafe</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">DefaultRefCountedThreadSafeTraits</span>&lt;T&gt;;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DeleteInternal</span><span class="params">(<span class="type">const</span> U* x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddRefImpl</span><span class="params">(subtle::StartRefCountFromZeroTag)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    subtle::RefCountedThreadSafeBase::<span class="built_in">AddRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddRefImpl</span><span class="params">(subtle::StartRefCountFromOneTag)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    subtle::RefCountedThreadSafeBase::<span class="built_in">AddRefWithCheck</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重点看一下 AddRef 和 Release。</p><p>AddRef 根据 <code>T::kRefCountPreference</code> 决定使用父类 RefCountedThreadSafeBase 的 AddRef 还是 AddRefWithCheck</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddRef</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="built_in">AddRefImpl</span>(T::kRefCountPreference); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddRefImpl</span><span class="params">(subtle::StartRefCountFromZeroTag)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    subtle::RefCountedThreadSafeBase::<span class="built_in">AddRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddRefImpl</span><span class="params">(subtle::StartRefCountFromOneTag)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    subtle::RefCountedThreadSafeBase::<span class="built_in">AddRefWithCheck</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Release 会调用父类 RefCountedThreadSafeBase 的 Release，根据返回结果决定是否 Destruct。注意到这里析构时的指针类型被强转为 T，所以不能像 shared_ptr 一样正确析构子类，也就是 T 类型必须是虚析构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subtle::RefCountedThreadSafeBase::<span class="built_in">Release</span>()) &#123;</span><br><span class="line">      <span class="built_in">ANALYZER_SKIP_THIS_PATH</span>();</span><br><span class="line">      Traits::<span class="built_in">Destruct</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> T*&gt;(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="RefCountedThreadSafeBase"><a href="#RefCountedThreadSafeBase" class="headerlink" title="RefCountedThreadSafeBase"></a>RefCountedThreadSafeBase</h3><p>接下来看看 RefCountedThreadSafeBase 类。RefCountedThreadSafeBase 这个基类比较简单，只有一个引用计数以及增加、减小引用计数的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BASE_EXPORT</span> RefCountedThreadSafeBase &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RefCountedThreadSafeBase</span>(<span class="type">const</span> RefCountedThreadSafeBase&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  RefCountedThreadSafeBase&amp; <span class="keyword">operator</span>=(<span class="type">const</span> RefCountedThreadSafeBase&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">HasOneRef</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ref_count_.<span class="built_in">IsOne</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">HasAtLeastOneRef</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !ref_count_.<span class="built_in">IsZero</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line"> <span class="comment">//如果RefCountedThreadSafe使用默认的kRefCountPreference</span></span><br><span class="line"> <span class="comment">//那么RefCountedThreadSafeBase的ref_count_会初始化为0</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="title">RefCountedThreadSafeBase</span><span class="params">(StartRefCountFromZeroTag)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="title">RefCountedThreadSafeBase</span><span class="params">(StartRefCountFromOneTag)</span></span></span><br><span class="line"><span class="function">      : ref_count_(<span class="number">1</span>) &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Release</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ReleaseImpl</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddRef</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="built_in">AddRefImpl</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddRefWithCheck</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="built_in">AddRefWithCheckImpl</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ALWAYS_INLINE <span class="type">void</span> <span class="title">AddRefImpl</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    ref_count_.<span class="built_in">Increment</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ALWAYS_INLINE <span class="type">void</span> <span class="title">AddRefWithCheckImpl</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CHECK_GT</span>(ref_count_.<span class="built_in">Increment</span>(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ALWAYS_INLINE <span class="type">bool</span> <span class="title">ReleaseImpl</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ref_count_.<span class="built_in">Decrement</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutable</span> AtomicRefCount ref_count_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先看 AddRef。RefCountedThreadSafe 会根据 kRefCountPreference 来决定是调用父类的 AddRef 还是 AddRefWithCheck</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddRef</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="built_in">AddRefImpl</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddRefWithCheck</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="built_in">AddRefWithCheckImpl</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ALWAYS_INLINE <span class="type">void</span> <span class="title">AddRefImpl</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    ref_count_.<span class="built_in">Increment</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ALWAYS_INLINE <span class="type">void</span> <span class="title">AddRefWithCheckImpl</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CHECK_GT</span>(ref_count_.<span class="built_in">Increment</span>(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>再看 Release。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Release</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ReleaseImpl</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ALWAYS_INLINE <span class="type">bool</span> <span class="title">ReleaseImpl</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ref_count_.<span class="built_in">Decrement</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意 ReleaseImpl 里面没有区分引用计数从 0 开始还是从 1 开始，都是检查 Decrement 之后 <code>ref_count_</code> 是否减少至 0。所以如果引用计数从 0 开始，还需要在创建时额外进行 AddRef 操作。</p><p>在上面接受裸指针的 scoped_refptr 的构造函数中总会进行 AddRef 操作，此时如果是从 0 开始，那么引用计数变为 1，没有问题，但是如果引用计数配置了从 1 开始，那么直接使用接受裸指针的 scoped_refptr 的构造函数得到的 scoped_refptr 的引用为 2，Release 操作就会出现问题。</p><p>chromium 建议使用 MakeRefCounted 来创建 scoped_refptr，他内部使用 AdoptRefIfNeeded 会根据 T::kRefCountPreference 决定是否 AddRef</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">scoped_refptr&lt;T&gt; <span class="title">MakeRefCounted</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">  T* obj = <span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  <span class="keyword">return</span> subtle::<span class="built_in">AdoptRefIfNeeded</span>(obj, T::kRefCountPreference);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> subtle &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">scoped_refptr&lt;T&gt; <span class="title">AdoptRefIfNeeded</span><span class="params">(T* obj, StartRefCountFromZeroTag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">scoped_refptr</span>&lt;T&gt;(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">scoped_refptr&lt;T&gt; <span class="title">AdoptRefIfNeeded</span><span class="params">(T* obj, StartRefCountFromOneTag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AdoptRef</span>(obj); <span class="comment">// 没有进行AddRef操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">scoped_refptr&lt;T&gt; <span class="title">AdoptRef</span><span class="params">(T* obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> Tag = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(T::kRefCountPreference)&gt;;</span><br><span class="line">  <span class="built_in">static_assert</span>(std::is_same&lt;subtle::StartRefCountFromOneTag, Tag&gt;::value,</span><br><span class="line">                <span class="string">&quot;Use AdoptRef only if the reference count starts from one.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  obj-&gt;<span class="built_in">Adopted</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">scoped_refptr</span>&lt;T&gt;(obj, subtle::kAdoptRefTag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，scoped_refptr 更像一个弱化版的 shared_ptr，scoped_refptr 没有和 WeakPtr 一起配合使用，所以他的引用计数就是简单的自增、自减，没有 compare and swap 操作。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Chromium base库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 标准库之 tuple</title>
      <link href="/2023/05/20/C-%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B-tuple/"/>
      <url>/2023/05/20/C-%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B-tuple/</url>
      
        <content type="html"><![CDATA[<h1 id="C-标准库之-tuple"><a href="#C-标准库之-tuple" class="headerlink" title="C++ 标准库之 tuple"></a>C++ 标准库之 tuple</h1><p>这篇文章分析一下 tuple，tuple 和之前分析的 <code>__compressed_pair</code> 类似，但也有自己的特殊之处。</p><p>tuple 内部把具体存储对象的工作交给了 <code>__tuple_impl</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Tp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> tuple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __tuple_impl&lt;<span class="keyword">typename</span> __make_tuple_indices&lt;<span class="keyword">sizeof</span>...(_Tp)&gt;::type, _Tp...&gt; _BaseT;</span><br><span class="line"></span><br><span class="line">    _BaseT __base_;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__tuple_impl</code> 比较有意思，如果其第一个模板参数是 <code>__tuple_indices</code> 类型，那么有以下部分特化。在这个特化中，每一个 <code>_Tp</code> 都对应一个 <code>__tuple_leaf</code>，而 <code>__tuple_impl</code> 会继承所有的 <code>__tuple_leaf</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Indx</span>, <span class="keyword">class</span> ..._Tp&gt; <span class="keyword">struct</span> <span class="title class_">__tuple_impl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> ..._Indx, <span class="keyword">class</span> ..._Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIBCPP_DECLSPEC_EMPTY_BASES</span> __tuple_impl&lt;__tuple_indices&lt;_Indx...&gt;, _Tp...&gt;</span><br><span class="line">    : <span class="keyword">public</span> __tuple_leaf&lt;_Indx, _Tp&gt;...</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="make-tuple-indices"><a href="#make-tuple-indices" class="headerlink" title="__make_tuple_indices"></a>__make_tuple_indices</h2><p>先看 <code>__make_tuple_indices</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ep, <span class="type">size_t</span> _Sp = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> __make_tuple_indices</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(_Sp &lt;= _Ep, <span class="string">&quot;__make_tuple_indices input error&quot;</span>);</span><br><span class="line">    <span class="keyword">typedef</span> __make_indices_imp&lt;_Ep, _Sp&gt; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__make_tuple_indices</code> 内部使用 <code>__make_indices_imp</code>，它会创建从 <code>_Sp</code> 开始到 <code>_Ep</code> 的整数序列（就是 <code>[_Sp,_Ep)</code> 左闭右开）。有的编译器内部提供了这样的接口，但我们来看看如何不借助编译器实现这个功能，还是稍微有些复杂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ep, <span class="type">size_t</span> _Sp&gt;</span><br><span class="line"><span class="keyword">using</span> __make_indices_imp =</span><br><span class="line">    <span class="keyword">typename</span> __detail::__make&lt;_Ep - _Sp&gt;::type::<span class="keyword">template</span> __to_tuple_indices&lt;_Sp&gt;;</span><br></pre></td></tr></table></figure><p>在 <code>__detail</code> 命名空间下有一个 <code>__make</code> 模板类，它里面有一个 type 类型，type 类型中有一个模板类 <code>__to_tuple_indices</code>，这就是为什么 <code>__to_tuple_indices</code> 前面有个 template。这是上面语句的含义。</p><p><code>__make</code> 继承 <code>__parity</code> 类中的 <code>__pmake</code> 模板类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> _Np&gt; <span class="keyword">struct</span> <span class="title class_">__make</span> : __parity&lt;_Np % <span class="number">8</span>&gt;::<span class="keyword">template</span> __pmake&lt;_Np&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面给 <code>__parity</code> 的模板参数为 <code>_Np % 8</code>，所以 <code>__parity</code> 的模板参数一定小于 8，下面就是 <code>__parity</code> 全部的特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__parity</span>&lt;<span class="number">0</span>&gt; &#123; <span class="keyword">template</span>&lt;<span class="type">size_t</span> _Np&gt; <span class="keyword">struct</span> <span class="title class_">__pmake</span> : __repeat&lt;<span class="keyword">typename</span> __make&lt;_Np / <span class="number">8</span>&gt;::type&gt; &#123;&#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__parity</span>&lt;<span class="number">1</span>&gt; &#123; <span class="keyword">template</span>&lt;<span class="type">size_t</span> _Np&gt; <span class="keyword">struct</span> <span class="title class_">__pmake</span> : __repeat&lt;<span class="keyword">typename</span> __make&lt;_Np / <span class="number">8</span>&gt;::type, _Np - <span class="number">1</span>&gt; &#123;&#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__parity</span>&lt;<span class="number">2</span>&gt; &#123; <span class="keyword">template</span>&lt;<span class="type">size_t</span> _Np&gt; <span class="keyword">struct</span> <span class="title class_">__pmake</span> : __repeat&lt;<span class="keyword">typename</span> __make&lt;_Np / <span class="number">8</span>&gt;::type, _Np - <span class="number">2</span>, _Np - <span class="number">1</span>&gt; &#123;&#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__parity</span>&lt;<span class="number">3</span>&gt; &#123; <span class="keyword">template</span>&lt;<span class="type">size_t</span> _Np&gt; <span class="keyword">struct</span> <span class="title class_">__pmake</span> : __repeat&lt;<span class="keyword">typename</span> __make&lt;_Np / <span class="number">8</span>&gt;::type, _Np - <span class="number">3</span>, _Np - <span class="number">2</span>, _Np - <span class="number">1</span>&gt; &#123;&#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__parity</span>&lt;<span class="number">4</span>&gt; &#123; <span class="keyword">template</span>&lt;<span class="type">size_t</span> _Np&gt; <span class="keyword">struct</span> <span class="title class_">__pmake</span> : __repeat&lt;<span class="keyword">typename</span> __make&lt;_Np / <span class="number">8</span>&gt;::type, _Np - <span class="number">4</span>, _Np - <span class="number">3</span>, _Np - <span class="number">2</span>, _Np - <span class="number">1</span>&gt; &#123;&#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__parity</span>&lt;<span class="number">5</span>&gt; &#123; <span class="keyword">template</span>&lt;<span class="type">size_t</span> _Np&gt; <span class="keyword">struct</span> <span class="title class_">__pmake</span> : __repeat&lt;<span class="keyword">typename</span> __make&lt;_Np / <span class="number">8</span>&gt;::type, _Np - <span class="number">5</span>, _Np - <span class="number">4</span>, _Np - <span class="number">3</span>, _Np - <span class="number">2</span>, _Np - <span class="number">1</span>&gt; &#123;&#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__parity</span>&lt;<span class="number">6</span>&gt; &#123; <span class="keyword">template</span>&lt;<span class="type">size_t</span> _Np&gt; <span class="keyword">struct</span> <span class="title class_">__pmake</span> : __repeat&lt;<span class="keyword">typename</span> __make&lt;_Np / <span class="number">8</span>&gt;::type, _Np - <span class="number">6</span>, _Np - <span class="number">5</span>, _Np - <span class="number">4</span>, _Np - <span class="number">3</span>, _Np - <span class="number">2</span>, _Np - <span class="number">1</span>&gt; &#123;&#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__parity</span>&lt;<span class="number">7</span>&gt; &#123; <span class="keyword">template</span>&lt;<span class="type">size_t</span> _Np&gt; <span class="keyword">struct</span> <span class="title class_">__pmake</span> : __repeat&lt;<span class="keyword">typename</span> __make&lt;_Np / <span class="number">8</span>&gt;::type, _Np - <span class="number">7</span>, _Np - <span class="number">6</span>, _Np - <span class="number">5</span>, _Np - <span class="number">4</span>, _Np - <span class="number">3</span>, _Np - <span class="number">2</span>, _Np - <span class="number">1</span>&gt; &#123;&#125;; &#125;;</span><br></pre></td></tr></table></figure><p><code>__pmake</code> 又继承 <code>__repeat</code>，而给 <code>__repeat</code> 的模板参数又来自 <code>__make</code>，但是这一次给 <code>__make</code> 的模板参数是 <code>_Np / 8</code>，<code>__make</code> 对于 0 到 7 有以下特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__make</span>&lt;<span class="number">0</span>&gt; &#123; <span class="keyword">typedef</span> __integer_sequence&lt;<span class="type">size_t</span>&gt; type; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__make</span>&lt;<span class="number">1</span>&gt; &#123; <span class="keyword">typedef</span> __integer_sequence&lt;<span class="type">size_t</span>, <span class="number">0</span>&gt; type; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__make</span>&lt;<span class="number">2</span>&gt; &#123; <span class="keyword">typedef</span> __integer_sequence&lt;<span class="type">size_t</span>, <span class="number">0</span>, <span class="number">1</span>&gt; type; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__make</span>&lt;<span class="number">3</span>&gt; &#123; <span class="keyword">typedef</span> __integer_sequence&lt;<span class="type">size_t</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&gt; type; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__make</span>&lt;<span class="number">4</span>&gt; &#123; <span class="keyword">typedef</span> __integer_sequence&lt;<span class="type">size_t</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt; type; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__make</span>&lt;<span class="number">5</span>&gt; &#123; <span class="keyword">typedef</span> __integer_sequence&lt;<span class="type">size_t</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&gt; type; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__make</span>&lt;<span class="number">6</span>&gt; &#123; <span class="keyword">typedef</span> __integer_sequence&lt;<span class="type">size_t</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt; type; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__make</span>&lt;<span class="number">7</span>&gt; &#123; <span class="keyword">typedef</span> __integer_sequence&lt;<span class="type">size_t</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&gt; type; &#125;;</span><br></pre></td></tr></table></figure><p>再看 <code>__repeat</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="type">size_t</span> ..._Extra&gt; <span class="keyword">struct</span> <span class="title class_">__repeat</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Tp ..._Np, <span class="type">size_t</span> ..._Extra&gt; <span class="keyword">struct</span> <span class="title class_">__repeat</span>&lt;__integer_sequence&lt;_Tp, _Np...&gt;, _Extra...&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE __integer_sequence&lt;_Tp,</span><br><span class="line">                           _Np...,</span><br><span class="line">                           <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           <span class="number">2</span> * <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           <span class="number">3</span> * <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           <span class="number">4</span> * <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           <span class="number">5</span> * <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           <span class="number">6</span> * <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           <span class="number">7</span> * <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           _Extra...&gt; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面可以知道，他把整数分成整除 8 的部分和余数，对于余数，直接在 <code>__repeat</code> 构造时指明，对于整除的部分，在 <code>__repeat</code> 内部进行计算。</p><p>比如现在想得到 0-17 的整数序列，那么 <code>_Np</code> 就是 18，0-15 是在 <code>__repeat</code> 里面计算得到，而 16、17 则是直接在创建 <code>__repeat</code> 时就确定，对于 18，会使用下面的 <code>__parity</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__parity</span>&lt;<span class="number">2</span>&gt; &#123; <span class="keyword">template</span>&lt;<span class="type">size_t</span> _Np&gt; <span class="keyword">struct</span> <span class="title class_">__pmake</span> : __repeat&lt;<span class="keyword">typename</span> __make&lt;_Np / <span class="number">8</span>&gt;::type, _Np - <span class="number">2</span>, _Np - <span class="number">1</span>&gt; &#123;&#125;; &#125;;</span><br></pre></td></tr></table></figure><p>对于 <code>__repeat</code>，<code>_Np</code> 就是 <code>0, 1</code>，<code>_Extra</code> 就是 <code>16, 17</code>，代入下面，就是 <code>0, 1, 2, ..., 17</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Tp ..._Np, <span class="type">size_t</span> ..._Extra&gt; <span class="keyword">struct</span> <span class="title class_">__repeat</span>&lt;__integer_sequence&lt;_Tp, _Np...&gt;, _Extra...&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE __integer_sequence&lt;_Tp,</span><br><span class="line">                           _Np...,</span><br><span class="line">                           <span class="keyword">sizeof</span>...(_Np) + _Np...,    <span class="comment">// sizeof...(_Np) 就是 2</span></span><br><span class="line">                           <span class="number">2</span> * <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           <span class="number">3</span> * <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           <span class="number">4</span> * <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           <span class="number">5</span> * <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           <span class="number">6</span> * <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           <span class="number">7</span> * <span class="keyword">sizeof</span>...(_Np) + _Np...,</span><br><span class="line">                           _Extra...&gt; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是注意通过这种方法算出来最大只能是 64，因为 <code>__repeat</code> 里面算整数部分只算了 0-7 的倍数。</p><p>再回到上面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ep, <span class="type">size_t</span> _Sp&gt;</span><br><span class="line"><span class="keyword">using</span> __make_indices_imp =</span><br><span class="line">    <span class="keyword">typename</span> __detail::__make&lt;_Ep - _Sp&gt;::type::<span class="keyword">template</span> __to_tuple_indices&lt;_Sp&gt;;</span><br></pre></td></tr></table></figure><p>那么 <code>__detail::__make&lt;_Ep - _Sp&gt;::type</code> 就是 <code>__repeat</code> 中的 <code>__integer_sequence</code>，对该 <code>__integer_sequence</code> 再调用 <code>__to_tuple_indices</code> 就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>...&gt; <span class="keyword">struct</span> <span class="title class_">__tuple_indices</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_IdxType</span>, _IdxType... _Values&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__integer_sequence</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_OIdxType</span>, _OIdxType...&gt; <span class="keyword">class</span> <span class="title class_">_ToIndexSeq</span>, <span class="keyword">class</span> <span class="title class_">_ToIndexType</span>&gt;</span><br><span class="line">  <span class="keyword">using</span> __convert = _ToIndexSeq&lt;_ToIndexType, _Values...&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="type">size_t</span> _Sp&gt;</span><br><span class="line">  <span class="keyword">using</span> __to_tuple_indices = __tuple_indices&lt;(_Values + _Sp)...&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>回到 tuple，接下来通过分析它的成员函数来理解它内部的原理</p><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>也有 explicit、implicit 的版本，检查方法和 pair 一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>, _EnableIf&lt;</span><br><span class="line">    _CheckArgsConstructor&lt;_Dummy&gt;::__enable_implicit_default()</span><br><span class="line">, <span class="type">void</span>*&gt; = <span class="literal">nullptr</span>&gt;</span><br><span class="line">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span><br><span class="line"><span class="built_in">tuple</span>()</span><br><span class="line">    _NOEXCEPT_(__all&lt;is_nothrow_default_constructible&lt;_Tp&gt;::value...&gt;::value) &#123;&#125;</span><br></pre></td></tr></table></figure><p>下面的 <code>__all</code> 就是要求所有的 <code>_Tp</code> 都满足。<code>__is_implicitly_default_constructible</code> 以及 implicit&#x2F;explicit 的区别在 pair 中已经介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dummy</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_CheckArgsConstructor</span>&lt;<span class="literal">true</span>, _Dummy&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="type">int</span>&amp;...&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> __enable_implicit_default() &#123;</span><br><span class="line">       <span class="keyword">return</span> __all&lt;__is_implicitly_default_constructible&lt;_Tp&gt;::value... &gt;::value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="type">int</span>&amp;...&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> __enable_explicit_default() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            __all&lt;is_default_constructible&lt;_Tp&gt;::value...&gt;::value &amp;&amp;</span><br><span class="line">            !__enable_implicit_default&lt; &gt;();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="接受-const-左值引用参数的构造函数"><a href="#接受-const-左值引用参数的构造函数" class="headerlink" title="接受 const 左值引用参数的构造函数"></a>接受 const 左值引用参数的构造函数</h3><p>也有 implicit&#x2F;explicit 版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">          <span class="keyword">typename</span> enable_if</span><br><span class="line">                  &lt;</span><br><span class="line">                     _CheckArgsConstructor&lt;</span><br><span class="line">                        _Dummy</span><br><span class="line">                     &gt;::<span class="keyword">template</span> __enable_implicit&lt;_Tp <span class="type">const</span>&amp;...&gt;(),</span><br><span class="line">                     <span class="type">bool</span></span><br><span class="line">                  &gt;::type = <span class="literal">false</span></span><br><span class="line">    &gt;</span><br><span class="line">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line"><span class="built_in">tuple</span>(<span class="type">const</span> _Tp&amp; ... <span class="type">__t</span>) _NOEXCEPT_((__all&lt;is_nothrow_copy_constructible&lt;_Tp&gt;::value...&gt;::value))</span><br><span class="line">    : __base_(<span class="keyword">typename</span> __make_tuple_indices&lt;<span class="keyword">sizeof</span>...(_Tp)&gt;::<span class="built_in">type</span>(),</span><br><span class="line">            <span class="keyword">typename</span> __make_tuple_types&lt;tuple, <span class="keyword">sizeof</span>...(_Tp)&gt;::<span class="built_in">type</span>(),</span><br><span class="line">            <span class="keyword">typename</span> __make_tuple_indices&lt;<span class="number">0</span>&gt;::<span class="built_in">type</span>(),</span><br><span class="line">            <span class="keyword">typename</span> __make_tuple_types&lt;tuple, <span class="number">0</span>&gt;::<span class="built_in">type</span>(),</span><br><span class="line">            <span class="type">__t</span>...</span><br><span class="line">           ) &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面调用 <code>__base_()</code> 时，分成两个 tuple，这是为了允许只给部分元素传参数，让其他元素默认初始化。但上面其实要求所有元素都传参数，因为 <code>__base_</code> 的参数的第二个 tuple 的 size 是 0，下面会看到允许部分参数为空的构造函数。</p><p>看看检查条件。由于允许参数默认初始化，所以下面 <code>__make_tuple_types</code> 构造参数时只使用传参的部分。具体的检查条件和 pair 差不多：explicit 和 implicit 都要求 constructible，implicit 还额外要求 convertible。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dummy</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_CheckArgsConstructor</span>&lt;<span class="literal">true</span>, _Dummy&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> __enable_explicit() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            __tuple_constructible&lt;</span><br><span class="line">                tuple&lt;_Args...&gt;,</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_types&lt;tuple, <span class="comment">// 从当前tuple中取类型</span></span><br><span class="line">                         <span class="keyword">sizeof</span>...(_Args) &lt; <span class="keyword">sizeof</span>...(_Tp) ?</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Args) :</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Tp)&gt;::type  <span class="comment">// 构造参数时只构造传参的部分</span></span><br><span class="line">            &gt;::value &amp;&amp;</span><br><span class="line">            !__tuple_convertible&lt;</span><br><span class="line">                tuple&lt;_Args...&gt;,</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_types&lt;tuple,</span><br><span class="line">                         <span class="keyword">sizeof</span>...(_Args) &lt; <span class="keyword">sizeof</span>...(_Tp) ?</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Args) :</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Tp)&gt;::type</span><br><span class="line">            &gt;::value &amp;&amp;</span><br><span class="line">            __all_default_constructible&lt;</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_types&lt;tuple, <span class="keyword">sizeof</span>...(_Tp),</span><br><span class="line">                         <span class="keyword">sizeof</span>...(_Args) &lt; <span class="keyword">sizeof</span>...(_Tp) ?</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Args) :</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Tp)&gt;::type</span><br><span class="line">            &gt;::value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> __enable_implicit() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">           __tuple_constructible&lt;</span><br><span class="line">                tuple&lt;_Args...&gt;,</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_types&lt;tuple,</span><br><span class="line">                         <span class="keyword">sizeof</span>...(_Args) &lt; <span class="keyword">sizeof</span>...(_Tp) ?</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Args) :</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Tp)&gt;::type</span><br><span class="line">            &gt;::value &amp;&amp;</span><br><span class="line">            __tuple_convertible&lt;</span><br><span class="line">                tuple&lt;_Args...&gt;,</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_types&lt;tuple,</span><br><span class="line">                         <span class="keyword">sizeof</span>...(_Args) &lt; <span class="keyword">sizeof</span>...(_Tp) ?</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Args) :</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Tp)&gt;::type</span><br><span class="line">            &gt;::value &amp;&amp;</span><br><span class="line">            __all_default_constructible&lt;</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_types&lt;tuple, <span class="keyword">sizeof</span>...(_Tp),</span><br><span class="line">                         <span class="keyword">sizeof</span>...(_Args) &lt; <span class="keyword">sizeof</span>...(_Tp) ?</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Args) :</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Tp)&gt;::type</span><br><span class="line">            &gt;::value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="make-tuple-types"><a href="#make-tuple-types" class="headerlink" title="__make_tuple_types"></a>__make_tuple_types</h4><p>就是取得 <code>_Tp</code> 从 <code>_Sp</code> 到 <code>_Ep</code> 索引处的 type，将他们组成 <code>__tuple_types</code>。先对 <code>_Tp</code> 去除 const&#x2F;volatile 和引用，后续再通过 <code>__apply_quals</code> 将 <code>_Tp</code> 的这些属性应用到它里面的 type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="type">size_t</span> _Ep = tuple_size&lt;<span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type&gt;::value,</span><br><span class="line">          <span class="type">size_t</span> _Sp = <span class="number">0</span>,</span><br><span class="line">          <span class="type">bool</span> _SameSize = (_Ep == tuple_size&lt;<span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type&gt;::value)&gt;</span><br><span class="line"><span class="keyword">struct</span> __make_tuple_types</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(_Sp &lt;= _Ep, <span class="string">&quot;__make_tuple_types input error&quot;</span>);</span><br><span class="line">    <span class="keyword">using</span> _RawTp = <span class="keyword">typename</span> remove_cv&lt;<span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type&gt;::type;</span><br><span class="line">    <span class="keyword">using</span> _Maker = __make_tuple_types_flat&lt;_RawTp, <span class="keyword">typename</span> __make_tuple_indices&lt;_Ep, _Sp&gt;::type&gt;;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> _Maker::<span class="keyword">template</span> __apply_quals&lt;_Tp&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span> <span class="title class_">_Tuple</span>, <span class="keyword">class</span> ..._Types, <span class="type">size_t</span> ..._Idx&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__make_tuple_types_flat</span>&lt;_Tuple&lt;_Types...&gt;, __tuple_indices&lt;_Idx...&gt;&gt; &#123;</span><br><span class="line">  <span class="comment">// Specialization for pair, tuple, and __tuple_types</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_ApplyFn</span> = <span class="type">__apply_cv_t</span>&lt;_Tp&gt;&gt;</span><br><span class="line">  <span class="keyword">using</span> __apply_quals _LIBCPP_NODEBUG_TYPE = __tuple_types&lt;</span><br><span class="line">      <span class="keyword">typename</span> _ApplyFn::<span class="keyword">template</span> __apply&lt;__type_pack_element&lt;_Idx, _Types...&gt;&gt;...</span><br><span class="line">    &gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__make_tuple_types_flat</code> 会根据 <code>_Idx</code> 来对 <code>_Types</code> 进行索引，并将其组装成 <code>__tuple_types</code>。</p><h5 id="type-pack-element"><a href="#type-pack-element" class="headerlink" title="__type_pack_element"></a>__type_pack_element</h5><p>先看 <code>__type_pack_element</code>，这个模板从 <code>_Types</code> 中根据 <code>_Idx</code> 索引来取类型，<code>__type_pack_element&lt;_Idx, _Types...&gt;</code> 就相当于 <code>_Types[_Idx]</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Tp&gt; <span class="keyword">struct</span> <span class="title class_">__tuple_types</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> __indexer_detail &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Idx, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__indexed</span> &#123; <span class="keyword">using</span> type _LIBCPP_NODEBUG_TYPE = _Tp; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Types</span>, <span class="keyword">class</span> <span class="title class_">_Indexes</span>&gt; <span class="keyword">struct</span> <span class="title class_">__indexer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Types, <span class="type">size_t</span> ..._Idx&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__indexer</span>&lt;__tuple_types&lt;_Types...&gt;, __tuple_indices&lt;_Idx...&gt;&gt;</span><br><span class="line">    : __indexed&lt;_Idx, _Types&gt;...</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Idx, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line">__indexed&lt;_Idx, _Tp&gt; __at_index(__indexed&lt;_Idx, _Tp&gt; <span class="type">const</span>&amp;);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace __indexer_detail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Idx, <span class="keyword">class</span> ..._Types&gt;</span><br><span class="line"><span class="keyword">using</span> __type_pack_element _LIBCPP_NODEBUG_TYPE = <span class="keyword">typename</span> <span class="keyword">decltype</span>(</span><br><span class="line">    __indexer_detail::__at_index&lt;_Idx&gt;(</span><br><span class="line">        __indexer_detail::__indexer&lt;</span><br><span class="line">            __tuple_types&lt;_Types...&gt;,</span><br><span class="line">            <span class="keyword">typename</span> __make_tuple_indices&lt;<span class="keyword">sizeof</span>...(_Types)&gt;::type</span><br><span class="line">        &gt;&#123;&#125;)</span><br><span class="line">  )::type;</span><br></pre></td></tr></table></figure><p><code>__type_pack_element</code> 比较巧妙，通过 decltype 以及子类向父类转换的方式取得指定索引的 type，<code>__indexer</code> 继承所有的 <code>__indexed</code>。<code>__at_index</code> 函数的形参是指定 <code>index</code> 的 <code>__indexed</code>，而传给它的实参则是继承所有 <code>__indexed</code> 的 <code>__indexer</code>，通过子类向父类转换，就能取得指定 <code>index</code> 的 <code>__indexed</code>。</p><p>除了这种方法，经典的 TypeList 也能取得指定索引处的 type，这里不继续展开。</p><p>在 <code>__make_tuple_types_flat</code> 中还对取得的类型应用了属性，比如传给 <code>__make_tuple_types</code> 的是 <code>const tuple&lt;int, float&gt;</code>，那么 <code>__type_pack_element</code> 得到的是 <code>int, float</code>，还需要增加 tuple 自身的 const 属性，即最终得到的是 <code>const int, const float</code></p><h4 id="tuple-constructible"><a href="#tuple-constructible" class="headerlink" title="__tuple_constructible"></a>__tuple_constructible</h4><p>这个模板就是检查由输入参数能否 construct 当前 tuple，<code>_Tp</code> 就是输入参数类型的 tuple，<code>_Up</code> 就是 tuple 自身的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Up</span>, <span class="type">bool</span> = __tuple_like&lt;<span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type&gt;::value,</span><br><span class="line">                                <span class="type">bool</span> = __tuple_like&lt;_Up&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> __tuple_constructible</span><br><span class="line">    : <span class="keyword">public</span> false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Up</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__tuple_constructible</span>&lt;_Tp, _Up, <span class="literal">true</span>, <span class="literal">true</span>&gt;</span><br><span class="line">    : <span class="keyword">public</span> __tuple_sfinae_base::__constructible&lt;</span><br><span class="line">      <span class="keyword">typename</span> __make_tuple_types&lt;_Tp&gt;::type</span><br><span class="line">    , <span class="keyword">typename</span> __make_tuple_types&lt;_Up&gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__tuple_sfinae_base</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>, <span class="keyword">class</span>...&gt; <span class="keyword">class</span> <span class="title class_">_Trait</span>,</span><br><span class="line">            <span class="keyword">class</span> ..._LArgs, <span class="keyword">class</span> ..._RArgs&gt;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">auto</span> __do_test(__tuple_types&lt;_LArgs...&gt;, __tuple_types&lt;_RArgs...&gt;)</span><br><span class="line">    -&gt; __all&lt;<span class="keyword">typename</span> enable_if&lt;_Trait&lt;_LArgs, _RArgs&gt;::value, <span class="type">bool</span>&gt;::type&#123;<span class="literal">true</span>&#125;...&gt;;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>...&gt; <span class="keyword">class</span>&gt;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">auto</span> __do_test(...) -&gt; false_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_FromArgs</span>, <span class="keyword">class</span> <span class="title class_">_ToArgs</span>&gt;</span><br><span class="line">  <span class="keyword">using</span> __constructible = <span class="keyword">decltype</span>(__do_test&lt;is_constructible&gt;(_ToArgs&#123;&#125;, _FromArgs&#123;&#125;));</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_FromArgs</span>, <span class="keyword">class</span> <span class="title class_">_ToArgs</span>&gt;</span><br><span class="line">  <span class="keyword">using</span> __convertible = <span class="keyword">decltype</span>(__do_test&lt;is_convertible&gt;(_FromArgs&#123;&#125;, _ToArgs&#123;&#125;));</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_FromArgs</span>, <span class="keyword">class</span> <span class="title class_">_ToArgs</span>&gt;</span><br><span class="line">  <span class="keyword">using</span> __assignable = <span class="keyword">decltype</span>(__do_test&lt;is_assignable&gt;(_ToArgs&#123;&#125;, _FromArgs&#123;&#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面其实就是检查每一个输入类型能否 construct tuple 中的类型</p><p><code>__tuple_convertible</code> 和 <code>__tuple_constructible</code> 差不多，最终都是调用到 <code>__tuple_sfinae_base</code>，这里不再啰嗦</p><p>最后再看看 <code>_CheckArgsConstructor</code> 中的 <code>__all_default_constructible</code>。把它单独拿出来，是因为它的 <code>__make_tuple_types</code> 的起始索引是 <code>sizeof...(_Args)</code>，也就是跳过了传了参数的类型，只检查没有传参的类型是否是 default_constructible，这和上面说的允许部分传参一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dummy</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_CheckArgsConstructor</span>&lt;<span class="literal">true</span>, _Dummy&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> __enable_explicit() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            ... &amp;&amp;</span><br><span class="line">            __all_default_constructible&lt;</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_types&lt;tuple, <span class="keyword">sizeof</span>...(_Tp),</span><br><span class="line">                         <span class="keyword">sizeof</span>...(_Args) &lt; <span class="keyword">sizeof</span>...(_Tp) ?</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Args) :</span><br><span class="line">                             <span class="keyword">sizeof</span>...(_Tp)&gt;::type</span><br><span class="line">            &gt;::value;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="接受右值引用参数的构造函数"><a href="#接受右值引用参数的构造函数" class="headerlink" title="接受右值引用参数的构造函数"></a>接受右值引用参数的构造函数</h3><p>这个构造函数和上面的类似，只是接受的参数是右值类型。而且该函数中允许只对部分参数进行初始化。也有 implicit&#x2F;explicit 版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Up,</span><br><span class="line">          <span class="type">bool</span> _PackIsTuple = _PackExpandsToThisTuple&lt;_Up...&gt;::value,</span><br><span class="line">          <span class="keyword">typename</span> enable_if</span><br><span class="line">                  &lt;</span><br><span class="line">                     _CheckArgsConstructor&lt;</span><br><span class="line">                         <span class="keyword">sizeof</span>...(_Up) == <span class="keyword">sizeof</span>...(_Tp)</span><br><span class="line">                         &amp;&amp; !_PackIsTuple</span><br><span class="line">                     &gt;::<span class="keyword">template</span> __enable_implicit&lt;_Up...&gt;() ||</span><br><span class="line">                    _CheckArgsConstructor&lt;</span><br><span class="line">                        _EnableImplicitReducedArityExtension</span><br><span class="line">                        &amp;&amp; <span class="keyword">sizeof</span>...(_Up) &lt; <span class="keyword">sizeof</span>...(_Tp)</span><br><span class="line">                        &amp;&amp; !_PackIsTuple</span><br><span class="line">                     &gt;::<span class="keyword">template</span> __enable_implicit&lt;_Up...&gt;(),</span><br><span class="line">                     <span class="type">bool</span></span><br><span class="line">                  &gt;::type = <span class="literal">false</span></span><br><span class="line">         &gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line">    <span class="built_in">tuple</span>(_Up&amp;&amp;... __u)</span><br><span class="line">        _NOEXCEPT_((</span><br><span class="line">            is_nothrow_constructible&lt;_BaseT,</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_indices&lt;<span class="keyword">sizeof</span>...(_Up)&gt;::type,</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_types&lt;tuple, <span class="keyword">sizeof</span>...(_Up)&gt;::type,</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_indices&lt;<span class="keyword">sizeof</span>...(_Tp), <span class="keyword">sizeof</span>...(_Up)&gt;::type,</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_types&lt;tuple, <span class="keyword">sizeof</span>...(_Tp), <span class="keyword">sizeof</span>...(_Up)&gt;::type,</span><br><span class="line">                _Up...</span><br><span class="line">            &gt;::value</span><br><span class="line">        ))</span><br><span class="line">        : __base_(<span class="keyword">typename</span> __make_tuple_indices&lt;<span class="keyword">sizeof</span>...(_Up)&gt;::<span class="built_in">type</span>(),</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_types&lt;tuple, <span class="keyword">sizeof</span>...(_Up)&gt;::<span class="built_in">type</span>(),</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_indices&lt;<span class="keyword">sizeof</span>...(_Tp), <span class="keyword">sizeof</span>...(_Up)&gt;::<span class="built_in">type</span>(),</span><br><span class="line">                <span class="keyword">typename</span> __make_tuple_types&lt;tuple, <span class="keyword">sizeof</span>...(_Tp), <span class="keyword">sizeof</span>...(_Up)&gt;::<span class="built_in">type</span>(),</span><br><span class="line">                _VSTD::forward&lt;_Up&gt;(__u)...) &#123;&#125;</span><br></pre></td></tr></table></figure><p>函数体部分比较好理解，还是来看看条件检查部分。<code>_PackExpandsToThisTuple</code> 检查输入的类型是否是当前 tuple。所以上面的构造函数是不允许输入类型为当前 tuple。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_PackExpandsToThisTuple</span> : false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Arg</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_PackExpandsToThisTuple</span>&lt;_Arg&gt;</span><br><span class="line">        : is_same&lt;<span class="keyword">typename</span> __uncvref&lt;_Arg&gt;::type, tuple&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的检查条件分两种情况：如果输入参数个数等于 tuple 参数，正常检查；如果输入参数小于 tuple 参数，还要检查 <code>_EnableImplicitReducedArityExtension</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_LIBCPP_ENABLE_TUPLE_IMPLICIT_REDUCED_ARITY_EXTENSION)</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> _EnableImplicitReducedArityExtension = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> _EnableImplicitReducedArityExtension = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>其他的检查条件也是在 <code>_CheckArgsConstructor</code> 类中，和接受 const 左值引用参数的构造函数中是一样的</p><h3 id="接受-tuple-类型的构造函数"><a href="#接受-tuple-类型的构造函数" class="headerlink" title="接受 tuple 类型的构造函数"></a>接受 tuple 类型的构造函数</h3><p>这里的 tuple 内部可以是其他类型。也有 explicit&#x2F;implicit 版本。下面是接受左值&#x2F;右值的 implicit 版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tuple</span>, _EnableImplicitTupleLikeConstructor&lt;_Tuple, <span class="literal">true</span>&gt; = <span class="literal">false</span>&gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line">    <span class="built_in">tuple</span>(_Tuple&amp;&amp; <span class="type">__t</span>) _NOEXCEPT_((is_nothrow_constructible&lt;_BaseT, _Tuple&gt;::value))</span><br><span class="line">        : __base_(_VSTD::forward&lt;_Tuple&gt;(<span class="type">__t</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tuple, _EnableImplicitTupleLikeConstructor&lt;<span class="type">const</span> _Tuple&amp;, <span class="literal">false</span>&gt; = <span class="literal">false</span>&gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line">    <span class="built_in">tuple</span>(<span class="type">const</span> _Tuple&amp; <span class="type">__t</span>) _NOEXCEPT_((is_nothrow_constructible&lt;_BaseT, <span class="type">const</span> _Tuple&amp;&gt;::value))</span><br><span class="line">        : __base_(<span class="type">__t</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>两个检查条件。都不允许输入的 <code>_Tuple</code> 和当前 tuple 类型一样，因为这种场景应该由拷贝&#x2F;移动构造来定义。并且还要求输入的 tuple 的元素个数和当前 tuple 一致（<code>__tuple_like_with_size</code> 就是检查这个）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tuple</span>, <span class="type">bool</span> _DisableIfLValue&gt;</span><br><span class="line">    <span class="keyword">using</span> _EnableImplicitTupleLikeConstructor = _EnableIf&lt;</span><br><span class="line">                         _CheckTupleLikeConstructor&lt;</span><br><span class="line">                             __tuple_like_with_size&lt;_Tuple, <span class="keyword">sizeof</span>...(_Tp)&gt;::value</span><br><span class="line">                             &amp;&amp; !_PackExpandsToThisTuple&lt;_Tuple&gt;::value</span><br><span class="line">                             &amp;&amp; (!is_lvalue_reference&lt;_Tuple&gt;::value || !_DisableIfLValue)</span><br><span class="line">                         &gt;::<span class="keyword">template</span> __enable_implicit&lt;_Tuple&gt;(),</span><br><span class="line">                         <span class="type">bool</span></span><br><span class="line">                      &gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tuple</span>, <span class="type">bool</span> _DisableIfLValue&gt;</span><br><span class="line">    <span class="keyword">using</span> _EnableExplicitTupleLikeConstructor = _EnableIf&lt;</span><br><span class="line">                         _CheckTupleLikeConstructor&lt;</span><br><span class="line">                             __tuple_like_with_size&lt;_Tuple, <span class="keyword">sizeof</span>...(_Tp)&gt;::value</span><br><span class="line">                             &amp;&amp; !_PackExpandsToThisTuple&lt;_Tuple&gt;::value</span><br><span class="line">                             &amp;&amp; (!is_lvalue_reference&lt;_Tuple&gt;::value || !_DisableIfLValue)</span><br><span class="line">                         &gt;::<span class="keyword">template</span> __enable_explicit&lt;_Tuple&gt;(),</span><br><span class="line">                         <span class="type">bool</span></span><br><span class="line">                      &gt;;</span><br></pre></td></tr></table></figure><p>上面条件还检查了输入的 <code>_Tuple</code> 是否是左值引用。在下面这个构造函数中要求推断的 <code>_Tuple</code> 不能是引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tuple</span>, _EnableImplicitTupleLikeConstructor&lt;_Tuple, <span class="literal">true</span>&gt; = <span class="literal">false</span>&gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line">    <span class="built_in">tuple</span>(_Tuple&amp;&amp; <span class="type">__t</span>) _NOEXCEPT_((is_nothrow_constructible&lt;_BaseT, _Tuple&gt;::value))</span><br><span class="line">        : __base_(_VSTD::forward&lt;_Tuple&gt;(<span class="type">__t</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果这里 <code>_Tuple</code> 被推断为引用，那么说明输入参数是左值，按理来说左值参数应该优先使用下面的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tuple</span>, _EnableImplicitTupleLikeConstructor&lt;<span class="type">const</span> _Tuple&amp;, <span class="literal">false</span>&gt; = <span class="literal">false</span>&gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line">    <span class="built_in">tuple</span>(<span class="type">const</span> _Tuple&amp; <span class="type">__t</span>) _NOEXCEPT_((is_nothrow_constructible&lt;_BaseT, <span class="type">const</span> _Tuple&amp;&gt;::value))</span><br><span class="line">        : __base_(<span class="type">__t</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>接下来检查就到了 <code>_CheckTupleLikeConstructor</code>，它对于 <code>sizeof...(_Tp) == 1</code> 有不同特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _MaybeEnable,</span><br><span class="line">          <span class="type">bool</span> = <span class="keyword">sizeof</span>...(_Tp) == <span class="number">1</span>,</span><br><span class="line">          <span class="keyword">class</span> _Dummy = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> _CheckTupleLikeConstructor : __check_tuple_constructor_fail &#123;&#125;;</span><br></pre></td></tr></table></figure><p>如果 <code>sizeof...(_Tp)</code> 大于 1，那么检查方法和之前一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Dummy</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_CheckTupleLikeConstructor</span>&lt;<span class="literal">true</span>, <span class="literal">false</span>, _Dummy&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tuple</span>&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> __enable_implicit() &#123;</span><br><span class="line">        <span class="keyword">return</span> __tuple_constructible&lt;_Tuple, tuple&gt;::value</span><br><span class="line">            &amp;&amp; __tuple_convertible&lt;_Tuple, tuple&gt;::value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tuple</span>&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> __enable_explicit() &#123;</span><br><span class="line">        <span class="keyword">return</span> __tuple_constructible&lt;_Tuple, tuple&gt;::value</span><br><span class="line">           &amp;&amp; !__tuple_convertible&lt;_Tuple, tuple&gt;::value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="拷贝-x2F-移动赋值函数"><a href="#拷贝-x2F-移动赋值函数" class="headerlink" title="拷贝&#x2F;移动赋值函数"></a>拷贝&#x2F;移动赋值函数</h3><p>这里是接受和自身相同 tuple 类型的赋值函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line">tuple&amp; <span class="keyword">operator</span>=(<span class="keyword">typename</span> conditional&lt;_CanCopyAssign::value, tuple, __nat&gt;::type <span class="type">const</span>&amp; <span class="type">__t</span>)</span><br><span class="line">    _NOEXCEPT_((__all&lt;is_nothrow_copy_assignable&lt;_Tp&gt;::value...&gt;::value))</span><br><span class="line">&#123;</span><br><span class="line">    __base_.<span class="keyword">operator</span>=(<span class="type">__t</span>.__base_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line">tuple&amp; <span class="keyword">operator</span>=(<span class="keyword">typename</span> conditional&lt;_CanMoveAssign::value, tuple, __nat&gt;::type&amp;&amp; <span class="type">__t</span>)</span><br><span class="line">    _NOEXCEPT_((__all&lt;is_nothrow_move_assignable&lt;_Tp&gt;::value...&gt;::value))</span><br><span class="line">&#123;</span><br><span class="line">    __base_.<span class="keyword">operator</span>=(<span class="built_in">static_cast</span>&lt;_BaseT&amp;&amp;&gt;(<span class="type">__t</span>.__base_));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_CanCopyAssign</code> 条件和 <code>_CanMoveAssign</code> 条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> _CanCopyAssign = __all&lt;is_copy_assignable&lt;_Tp&gt;::value...&gt;;</span><br><span class="line"><span class="keyword">using</span> _CanMoveAssign = __all&lt;is_move_assignable&lt;_Tp&gt;::value...&gt;;</span><br></pre></td></tr></table></figure><h3 id="接受泛型-tuple-的赋值函数"><a href="#接受泛型-tuple-的赋值函数" class="headerlink" title="接受泛型 tuple 的赋值函数"></a>接受泛型 tuple 的赋值函数</h3><p>该赋值函数可以接受和自身 tuple 类型不同的泛型 tuple 参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tuple</span>,</span><br><span class="line">          <span class="keyword">class</span> = <span class="keyword">typename</span> enable_if</span><br><span class="line">                  &lt;</span><br><span class="line">                     __tuple_assignable&lt;_Tuple, tuple&gt;::value</span><br><span class="line">                  &gt;::type</span><br><span class="line">         &gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    tuple&amp;</span><br><span class="line">    <span class="keyword">operator</span>=(_Tuple&amp;&amp; <span class="type">__t</span>) _NOEXCEPT_((is_nothrow_assignable&lt;_BaseT&amp;, _Tuple&gt;::value))</span><br><span class="line">    &#123;</span><br><span class="line">        __base_.<span class="keyword">operator</span>=(_VSTD::forward&lt;_Tuple&gt;(<span class="type">__t</span>));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>__tuple_assignable</code> 条件。<code>_Tp</code> 是输入参数，<code>_Up</code> 是自身 tuple</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Up</span>, <span class="type">bool</span> = __tuple_like&lt;<span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type&gt;::value,</span><br><span class="line">                                <span class="type">bool</span> = __tuple_like&lt;_Up&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> __tuple_assignable</span><br><span class="line">    : <span class="keyword">public</span> false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Up</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__tuple_assignable</span>&lt;_Tp, _Up, <span class="literal">true</span>, <span class="literal">true</span>&gt;</span><br><span class="line">    : <span class="keyword">public</span> __tuple_sfinae_base::__assignable&lt;</span><br><span class="line">      <span class="keyword">typename</span> __make_tuple_types&lt;_Tp&gt;::type</span><br><span class="line">    , <span class="keyword">typename</span> __make_tuple_types&lt;_Up&amp;&gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面条件最终会走到 <code>__tuple_sfinae_base</code> 中对每个 type 进行 is_assignable 判断。但是有一个问题，为什么上面是 <code>_Up&amp;</code>，为什么要加一个引号？</p><p>这是因为 is_assignable 是进行如下判断，如果下面的表达式有意义，那么就是 assignable。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">declval</span>&lt;T&gt;() = std::<span class="built_in">declval</span>&lt;U&gt;()</span><br></pre></td></tr></table></figure><p>declval 之前写过一篇文章介绍过，它相当于给 T 加上&amp;&amp;，得到一个 T&amp;&amp;类型的临时值，这个临时值会根据 T 的类型是将亡值或者左值引用。</p><p>举个例子分析一下为什么要 <code>_Up&amp;</code>。</p><p>假设在上面的赋值函数中，传的是 <code>tuple&lt;int, int&gt;</code> 的左值，那么 <code>_Tuple</code> 就是 <code>tuple&lt;int, int&gt;&amp;</code>，如果当前 tuple 是 <code>tuple&lt;double, int&gt;</code>，那么上面 <code>__tuple_assignable</code> 的 <code>_Tp</code> 就是 <code>tuple&lt;int, int&gt;&amp;</code>，<code>_Up</code> 就是 <code>tuple&lt;double, int&gt;</code>。</p><p>如果不 <code>_Up&amp;</code>，那么最终判断的就是 <code>std::declval&lt;double&gt;() = std::declval&lt;int&amp;&gt;()</code>，这里 <code>int&amp;</code> 是因为 <code>__make_tuple_types</code> 会把 tuple 自身的属性附加到得到的类型上，比如 <code>__make_tuple_types&lt;tuple&lt;int, int&gt;const&amp;&gt;</code> 会得到 <code>&lt;int const&amp;, int const&amp;&gt;</code>。上面式子展开就是 <code>double&amp;&amp; = int&amp;</code>，给一个将亡值赋左值是不行的，只有左值才能被赋值，所以这里加了引号，加了引号之后折叠之后就是左值引用。</p><p>再看看为什么 constructible 时不用加&amp;。constructible 的判断条件是这个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">obj</span><span class="params">(std::declval&lt;Args&gt;()...)</span></span>;</span><br></pre></td></tr></table></figure><p>加了引号之后反而会出错，比如使用下面 接受右值引用参数的构造函数 创建 <code>tuple&lt;int, int&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">tuple</span>(_Up&amp;&amp;... __u);</span><br></pre></td></tr></table></figure><p>语句可以是 <code>tuple&lt;int, int&gt; a(1, 1);</code></p><p>输入一个临时值，那么 <code>_Up</code> 被推断为 int，那么下面的 <code>_Tp</code> 和 <code>_Up</code> 都是 int</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Up</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__tuple_constructible</span>&lt;_Tp, _Up, <span class="literal">true</span>, <span class="literal">true</span>&gt;</span><br><span class="line">    : <span class="keyword">public</span> __tuple_sfinae_base::__constructible&lt;</span><br><span class="line">      <span class="keyword">typename</span> __make_tuple_types&lt;_Tp&gt;::type</span><br><span class="line">    , <span class="keyword">typename</span> __make_tuple_types&lt;_Up&gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p>如果是 <code>_Up&amp;</code>，<code>T obj(std::declval&lt;Args&gt;()...);</code> 就是 <code>int &amp;obj(int&amp;&amp;);</code>，左值引用是无法接受将亡值参数的。</p><h2 id="tuple-impl"><a href="#tuple-impl" class="headerlink" title="__tuple_impl"></a>__tuple_impl</h2><p>接下来回到 <code>__tuple_impl</code>。这里就比较简单了，因为没有 tuple 中的检查，基本上就是参数的转发。</p><h3 id="默认构造函数-1"><a href="#默认构造函数-1" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>什么也不做，全部调用默认初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line">_LIBCPP_CONSTEXPR __tuple_impl()</span><br><span class="line">    _NOEXCEPT_(__all&lt;is_nothrow_default_constructible&lt;_Tp&gt;::value...&gt;::value) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="类似-emplace-的逐元素构造"><a href="#类似-emplace-的逐元素构造" class="headerlink" title="类似 emplace 的逐元素构造"></a>类似 emplace 的逐元素构造</h3><p>该构造函数有两组 <code>__tuple_indices</code> 和 <code>__tuple_types</code>，允许只传递部分参数，其他参数采用默认初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> ..._Uf, <span class="keyword">class</span> ..._Tf,</span><br><span class="line">          <span class="type">size_t</span> ..._Ul, <span class="keyword">class</span> ..._Tl, <span class="keyword">class</span> ..._Up&gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line">    <span class="keyword">explicit</span></span><br><span class="line">    __tuple_impl(__tuple_indices&lt;_Uf...&gt;, __tuple_types&lt;_Tf...&gt;,</span><br><span class="line">                 __tuple_indices&lt;_Ul...&gt;, __tuple_types&lt;_Tl...&gt;,</span><br><span class="line">                 _Up&amp;&amp;... __u)</span><br><span class="line">                 _NOEXCEPT_((__all&lt;is_nothrow_constructible&lt;_Tf, _Up&gt;::value...&gt;::value &amp;&amp;</span><br><span class="line">                             __all&lt;is_nothrow_default_constructible&lt;_Tl&gt;::value...&gt;::value)) :</span><br><span class="line">        __tuple_leaf&lt;_Uf, _Tf&gt;(_VSTD::forward&lt;_Up&gt;(__u))...,</span><br><span class="line">        __tuple_leaf&lt;_Ul, _Tl&gt;()...</span><br><span class="line">        &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="接受泛型-tuple-的构造函数"><a href="#接受泛型-tuple-的构造函数" class="headerlink" title="接受泛型 tuple 的构造函数"></a>接受泛型 tuple 的构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tuple</span>,</span><br><span class="line">          <span class="keyword">class</span> = <span class="keyword">typename</span> enable_if</span><br><span class="line">                  &lt;</span><br><span class="line">                     __tuple_constructible&lt;_Tuple, tuple&lt;_Tp...&gt; &gt;::value</span><br><span class="line">                  &gt;::type</span><br><span class="line">         &gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line">    __tuple_impl(_Tuple&amp;&amp; <span class="type">__t</span>) _NOEXCEPT_((__all&lt;is_nothrow_constructible&lt;_Tp, <span class="keyword">typename</span> tuple_element&lt;_Indx,</span><br><span class="line">                                   <span class="keyword">typename</span> __make_tuple_types&lt;_Tuple&gt;::type&gt;::type&gt;::value...&gt;::value))</span><br><span class="line">        : __tuple_leaf&lt;_Indx, _Tp&gt;(_VSTD::forward&lt;<span class="keyword">typename</span> tuple_element&lt;_Indx,</span><br><span class="line">                                   <span class="keyword">typename</span> __make_tuple_types&lt;_Tuple&gt;::type&gt;::type&gt;(_VSTD::<span class="built_in">get</span>&lt;_Indx&gt;(<span class="type">__t</span>)))...</span><br><span class="line">        &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>__tuple_constructible</code> 之前已经介绍过。<code>_Tuple</code> 根据输入参数是左值还是右值可能会推断为值和引用，比如 <code>tuple&lt;int, int&gt;</code> 或者 <code>tuple&lt;int, int&gt;&amp;</code>，这会影响到 <code>__tuple_constructible</code>（因为 <code>__make_tuple_types</code> 会把 tuple 自身的属性加到 tuple 内部的 type 上）。</p><h4 id="tuple-element"><a href="#tuple-element" class="headerlink" title="tuple_element"></a>tuple_element</h4><p>tuple_element 也会把输入的 tuple 上的属性加到取得的 type 中，下面的特化说明了这一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt; <span class="keyword">struct</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> tuple_element;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> tuple_element&lt;_Ip, <span class="type">const</span> _Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE <span class="keyword">typename</span> add_const&lt;<span class="keyword">typename</span> tuple_element&lt;_Ip, _Tp&gt;::type&gt;::type type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> tuple_element&lt;_Ip, <span class="keyword">volatile</span> _Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE <span class="keyword">typename</span> add_volatile&lt;<span class="keyword">typename</span> tuple_element&lt;_Ip, _Tp&gt;::type&gt;::type type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> tuple_element&lt;_Ip, <span class="type">const</span> <span class="keyword">volatile</span> _Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE <span class="keyword">typename</span> add_cv&lt;<span class="keyword">typename</span> tuple_element&lt;_Ip, _Tp&gt;::type&gt;::type type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果输入的是 <code>__tuple_types</code>，那么使用下面的特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> ..._Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> tuple_element&lt;_Ip, __tuple_types&lt;_Types...&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(_Ip &lt; <span class="keyword">sizeof</span>...(_Types), <span class="string">&quot;tuple_element index out of range&quot;</span>);</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE __type_pack_element&lt;_Ip, _Types...&gt; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果输入的是 tuple，先转成 <code>__tuple_types</code>，然后使用上面的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> ..._Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> tuple_element&lt;_Ip, tuple&lt;_Tp...&gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE <span class="keyword">typename</span> tuple_element&lt;_Ip, __tuple_types&lt;_Tp...&gt; &gt;::type type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以最终获取 tuple 还是通过 <code>__type_pack_element</code></p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>可以通过 get 获得指定索引处的元素。get 的结果和下面这些条件有关</p><ul><li>输入的 tuple 是否有 const 修饰</li><li>输入的 tuple 是左值还是右值</li><li>以及 tuple 内部的类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> ..._Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14</span><br><span class="line"><span class="keyword">typename</span> tuple_element&lt;_Ip, tuple&lt;_Tp...&gt; &gt;::<span class="function">type&amp;</span></span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(tuple&lt;_Tp...&gt;&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG <span class="keyword">typename</span> tuple_element&lt;_Ip, tuple&lt;_Tp...&gt; &gt;::type type;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;__tuple_leaf&lt;_Ip, type&gt;&amp;&gt;(<span class="type">__t</span>.__base_).<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> ..._Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14</span><br><span class="line"><span class="type">const</span> <span class="keyword">typename</span> tuple_element&lt;_Ip, tuple&lt;_Tp...&gt; &gt;::<span class="function">type&amp;</span></span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(<span class="type">const</span> tuple&lt;_Tp...&gt;&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG <span class="keyword">typename</span> tuple_element&lt;_Ip, tuple&lt;_Tp...&gt; &gt;::type type;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="type">const</span> __tuple_leaf&lt;_Ip, type&gt;&amp;&gt;(<span class="type">__t</span>.__base_).<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> ..._Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14</span><br><span class="line"><span class="keyword">typename</span> tuple_element&lt;_Ip, tuple&lt;_Tp...&gt; &gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(tuple&lt;_Tp...&gt;&amp;&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG <span class="keyword">typename</span> tuple_element&lt;_Ip, tuple&lt;_Tp...&gt; &gt;::type type;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;type&amp;&amp;&gt;(</span><br><span class="line">             <span class="keyword">static_cast</span>&lt;__tuple_leaf&lt;_Ip, type&gt;&amp;&amp;&gt;(<span class="type">__t</span>.__base_).<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> ..._Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14</span><br><span class="line"><span class="type">const</span> <span class="keyword">typename</span> tuple_element&lt;_Ip, tuple&lt;_Tp...&gt; &gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(<span class="type">const</span> tuple&lt;_Tp...&gt;&amp;&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG <span class="keyword">typename</span> tuple_element&lt;_Ip, tuple&lt;_Tp...&gt; &gt;::type type;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> type&amp;&amp;&gt;(</span><br><span class="line">             <span class="keyword">static_cast</span>&lt;<span class="type">const</span> __tuple_leaf&lt;_Ip, type&gt;&amp;&amp;&gt;(<span class="type">__t</span>.__base_).<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接受泛型-tuple-的赋值"><a href="#接受泛型-tuple-的赋值" class="headerlink" title="接受泛型 tuple 的赋值"></a>接受泛型 tuple 的赋值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tuple</span>&gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="keyword">typename</span> enable_if</span><br><span class="line">    &lt;</span><br><span class="line">        __tuple_assignable&lt;_Tuple, tuple&lt;_Tp...&gt; &gt;::value,</span><br><span class="line">        __tuple_impl&amp;</span><br><span class="line">    &gt;::type</span><br><span class="line">    <span class="keyword">operator</span>=(_Tuple&amp;&amp; <span class="type">__t</span>) _NOEXCEPT_((__all&lt;is_nothrow_assignable&lt;_Tp&amp;, <span class="keyword">typename</span> tuple_element&lt;_Indx,</span><br><span class="line">                                   <span class="keyword">typename</span> __make_tuple_types&lt;_Tuple&gt;::type&gt;::type&gt;::value...&gt;::value))</span><br><span class="line">    &#123;</span><br><span class="line">        __swallow(__tuple_leaf&lt;_Indx, _Tp&gt;::<span class="keyword">operator</span>=(_VSTD::forward&lt;<span class="keyword">typename</span> tuple_element&lt;_Indx,</span><br><span class="line">                                   <span class="keyword">typename</span> __make_tuple_types&lt;_Tuple&gt;::type&gt;::type&gt;(_VSTD::<span class="built_in">get</span>&lt;_Indx&gt;(<span class="type">__t</span>)))...);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>内部调用父类 <code>__tuple_leaf</code> 的 <code>operator=()</code>，<code>__swallow</code> 就是空函数，用于接受展开后的计算结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Tp&gt;</span><br><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="type">void</span> __swallow(_Tp&amp;&amp;...) _NOEXCEPT &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="接受-tuple-impl-的赋值函数"><a href="#接受-tuple-impl-的赋值函数" class="headerlink" title="接受__tuple_impl 的赋值函数"></a>接受__tuple_impl 的赋值函数</h3><p>基本上都是参数转发过程。</p><p>const 左值直接 static_cast；而右值则根据 <code>_Tp</code> 进行转发，如果 <code>_Tp</code> 是值，那么得到将亡值，如果是引用，将得到左值引用，这是为了考虑 <code>_Tp</code> 为引用的场景</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line">__tuple_impl&amp;</span><br><span class="line"><span class="keyword">operator</span>=(<span class="type">const</span> __tuple_impl&amp; <span class="type">__t</span>) _NOEXCEPT_((__all&lt;is_nothrow_copy_assignable&lt;_Tp&gt;::value...&gt;::value))</span><br><span class="line">&#123;</span><br><span class="line">    __swallow(__tuple_leaf&lt;_Indx, _Tp&gt;::<span class="keyword">operator</span>=(<span class="keyword">static_cast</span>&lt;<span class="type">const</span> __tuple_leaf&lt;_Indx, _Tp&gt;&amp;&gt;(<span class="type">__t</span>).<span class="built_in">get</span>())...);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line">__tuple_impl&amp;</span><br><span class="line"><span class="keyword">operator</span>=(__tuple_impl&amp;&amp; <span class="type">__t</span>) _NOEXCEPT_((__all&lt;is_nothrow_move_assignable&lt;_Tp&gt;::value...&gt;::value))</span><br><span class="line">&#123;</span><br><span class="line">    __swallow(__tuple_leaf&lt;_Indx, _Tp&gt;::<span class="keyword">operator</span>=(_VSTD::forward&lt;_Tp&gt;(<span class="keyword">static_cast</span>&lt;__tuple_leaf&lt;_Indx, _Tp&gt;&amp;&gt;(<span class="type">__t</span>).<span class="built_in">get</span>()))...);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里 <code>static_cast&lt;__tuple_leaf&lt;_Indx, _Tp&gt;&amp;&gt;(__t).get()</code>，先将 <code>__t</code> 进行 <code>static_cast</code>，然后再 get，这个没有关系，因为 forward 是根据 <code>_Tp</code> 来决定得到什么类型的值，比如 <code>_Tp</code> 是值，forward 得到将亡值，如果 <code>_Tp</code> 是引用，forward 得到左值引用</p><h2 id="tuple-leaf"><a href="#tuple-leaf" class="headerlink" title="__tuple_leaf"></a>__tuple_leaf</h2><p>再看 <code>__tuple_leaf</code>，他和之前的 compressed_pair 一样会做空基类优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> <span class="title class_">_Hp</span>,</span><br><span class="line">          <span class="type">bool</span>=is_empty&lt;_Hp&gt;::value &amp;&amp; !__libcpp_is_final&lt;_Hp&gt;::value</span><br><span class="line">         &gt; <span class="comment">// 也是检查is_empty和is_final这两个条件</span></span><br><span class="line"><span class="keyword">class</span> __tuple_leaf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> <span class="title class_">_Hp</span>, <span class="type">bool</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__tuple_leaf</span> <span class="comment">// 基类非空</span></span><br><span class="line">&#123;</span><br><span class="line">    _Hp __value_;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> <span class="title class_">_Hp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__tuple_leaf</span>&lt;_Ip, _Hp, <span class="literal">true</span>&gt;</span><br><span class="line">    : <span class="keyword">private</span> _Hp  <span class="comment">// 基类为空</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着看看相关函数。</p><p>默认构造。这里没有检查 <code>_Hp</code> 是否是 default_constructible，因为上层做了检查</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()</span><br><span class="line">         _NOEXCEPT_(is_nothrow_default_constructible&lt;_Hp&gt;::value) : __value_()</span><br><span class="line">   &#123;<span class="built_in">static_assert</span>(!is_reference&lt;_Hp&gt;::value,</span><br><span class="line">          <span class="string">&quot;Attempted to default construct a reference element in a tuple&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><p>接受一个参数的构造函数。要求 <code>_Tp</code> 不能是当前 <code>__tuple_leaf</code> 类型，以及由 <code>_Tp</code> 可以构造 <code>_Hp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>,</span><br><span class="line">          <span class="keyword">class</span> = _EnableIf&lt;</span><br><span class="line">              _And&lt;</span><br><span class="line">                  _IsNotSame&lt;<span class="type">__uncvref_t</span>&lt;_Tp&gt;, __tuple_leaf&gt;,</span><br><span class="line">                  is_constructible&lt;_Hp, _Tp&gt;</span><br><span class="line">                &gt;::value</span><br><span class="line">            &gt;</span><br><span class="line">        &gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line">    <span class="keyword">explicit</span> __tuple_leaf(_Tp&amp;&amp; <span class="type">__t</span>) _NOEXCEPT_((is_nothrow_constructible&lt;_Hp, _Tp&gt;::value))</span><br><span class="line">        : __value_(_VSTD::forward&lt;_Tp&gt;(<span class="type">__t</span>))</span><br><span class="line">    &#123;<span class="built_in">static_assert</span>(__can_bind_reference&lt;_Tp&amp;&amp;&gt;(),</span><br><span class="line">   <span class="string">&quot;Attempted construction of reference element binds to a temporary whose lifetime has ended&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><p>接受一个参数的赋值运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    __tuple_leaf&amp;</span><br><span class="line">    <span class="keyword">operator</span>=(_Tp&amp;&amp; <span class="type">__t</span>) _NOEXCEPT_((is_nothrow_assignable&lt;_Hp&amp;, _Tp&gt;::value))</span><br><span class="line">    &#123;</span><br><span class="line">        __value_ = _VSTD::forward&lt;_Tp&gt;(<span class="type">__t</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="make-tuple"><a href="#make-tuple" class="headerlink" title="make_tuple"></a>make_tuple</h2><p>和 pair 一样对参数进行了 <code>__unwrap_ref_decay</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line">tuple&lt;<span class="keyword">typename</span> __unwrap_ref_decay&lt;_Tp&gt;::type...&gt;</span><br><span class="line"><span class="built_in">make_tuple</span>(_Tp&amp;&amp;... <span class="type">__t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tuple&lt;<span class="keyword">typename</span> __unwrap_ref_decay&lt;_Tp&gt;::type...&gt;(_VSTD::forward&lt;_Tp&gt;(<span class="type">__t</span>)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="forward-as-tuple"><a href="#forward-as-tuple" class="headerlink" title="forward_as_tuple"></a>forward_as_tuple</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span></span><br><span class="line"><span class="function">tuple&lt;_Tp&amp;&amp;...&gt;</span></span><br><span class="line"><span class="function"><span class="title">forward_as_tuple</span><span class="params">(_Tp&amp;&amp;... <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>&lt;_Tp&amp;&amp;...&gt;(_VSTD::forward&lt;_Tp&gt;(<span class="type">__t</span>)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数比较有意思，它创建的 tuple 的模板参数是引用类型，比如 <code>tuple&lt;int&amp;,int&amp;&amp;&gt;</code>。让 tuple 内部为引用一般用在参数的组装和转发，比如之前 pair 和 <code>__compressed_pair</code> 的 piecewise_construct 里的 tuple 参数的模板参数通常为引用。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++标准库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 标准库之 pair</title>
      <link href="/2023/05/17/C-%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B-pair/"/>
      <url>/2023/05/17/C-%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B-pair/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍一下 pair。</p><p>pair 的结构比较简单，有两个成员数据分别代表第一个和第二个成员。pair 没有像 <code>__compressed_pair</code> 一样采用空基类优化策略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_T1</span>, <span class="keyword">class</span> <span class="title class_">_T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> pair</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> _T2 second_type;</span><br><span class="line"></span><br><span class="line">    _T1 first;</span><br><span class="line">    _T2 second;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pair 没有 first()、second()函数，但可以直接访问 first、second 成员</p><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p>默认构造函数生效的条件是要求 <code>_CheckArgsDep&lt;_Dummy&gt;::__enable_explicit_default()</code> 条件为 true。这在模板编程中很常见，模板函数经常会对参数施加限制，如果参数不满足要求那么这个模板就会被排除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>, _EnableB&lt;</span><br><span class="line">        _CheckArgsDep&lt;_Dummy&gt;::__enable_explicit_default()</span><br><span class="line">&gt; = <span class="literal">false</span>&gt;</span><br><span class="line"><span class="keyword">explicit</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span><br><span class="line"><span class="built_in">pair</span>() _NOEXCEPT_(is_nothrow_default_constructible&lt;first_type&gt;::value &amp;&amp;</span><br><span class="line">                  is_nothrow_default_constructible&lt;second_type&gt;::value)</span><br><span class="line">    : <span class="built_in">first</span>(), <span class="built_in">second</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>接下来就看看这个条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _MaybeEnable&gt;</span><br><span class="line"><span class="keyword">using</span> _CheckArgsDep _LIBCPP_NODEBUG_TYPE = <span class="keyword">typename</span> conditional&lt;</span><br><span class="line">  _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail&gt;::type;</span><br></pre></td></tr></table></figure><p>默认条件下 <code>_Dummy</code> 为 true，所以 <code>_MaybeEnable</code> 为 true，那么根据 conditional 的语义，<code>_CheckArgsDep&lt;_Dummy&gt;</code> 就是 <code>_CheckArgs</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_CheckArgs</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="type">int</span>&amp;...&gt;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> __enable_explicit_default() &#123;</span><br><span class="line">      <span class="keyword">return</span> is_default_constructible&lt;_T1&gt;::value</span><br><span class="line">          &amp;&amp; is_default_constructible&lt;_T2&gt;::value</span><br><span class="line">          &amp;&amp; !__enable_implicit_default&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="type">int</span>&amp;...&gt;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> __enable_implicit_default() &#123;</span><br><span class="line">      <span class="keyword">return</span> __is_implicitly_default_constructible&lt;_T1&gt;::value</span><br><span class="line">          &amp;&amp; __is_implicitly_default_constructible&lt;_T2&gt;::value;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__enable_explicit_default</code> 要求 <code>_T1</code> 和 <code>_T2</code> 都是可以默认构造，这个很好理解，因为没有输入参数，所以只能默认构造。<code>__enable_explicit_default</code> 还要求 <code>!__enable_implicit_default</code>。<code>__enable_implicit_default</code> 又检查 <code>__is_implicitly_default_constructible</code></p><p><code>__is_implicitly_default_constructible</code> 检查两个条件：<code>_Tp</code> 要能 default_constructible，以及 <code>_Tp const&amp; tmp = &#123;&#125;</code> 合理的，只有这两个条件都满足 <code>__is_implicitly_default_constructible</code> 才返回 true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="type">void</span> __test_implicit_default_constructible(_Tp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> = <span class="type">void</span>, <span class="type">bool</span> = is_default_constructible&lt;_Tp&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> __is_implicitly_default_constructible</span><br><span class="line">    : false_type</span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_implicitly_default_constructible</span>&lt;_Tp, <span class="keyword">decltype</span>(__test_implicit_default_constructible&lt;_Tp <span class="type">const</span>&amp;&gt;(&#123;&#125;)), <span class="literal">true</span>&gt;</span><br><span class="line">    : true_type</span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_implicitly_default_constructible</span>&lt;_Tp, <span class="keyword">decltype</span>(__test_implicit_default_constructible&lt;_Tp <span class="type">const</span>&amp;&gt;(&#123;&#125;)), <span class="literal">false</span>&gt;</span><br><span class="line">    : false_type</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure><p>默认构造函数还有一个允许 implicit 转换的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>, _EnableB&lt;</span><br><span class="line">        _CheckArgsDep&lt;_Dummy&gt;::__enable_implicit_default()</span><br><span class="line">&gt; = <span class="literal">false</span>&gt;</span><br><span class="line">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span><br><span class="line"><span class="built_in">pair</span>() _NOEXCEPT_(is_nothrow_default_constructible&lt;first_type&gt;::value &amp;&amp;</span><br><span class="line">                  is_nothrow_default_constructible&lt;second_type&gt;::value)</span><br><span class="line">    : <span class="built_in">first</span>(), <span class="built_in">second</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个模板函数检查的条件是上面说过的 <code>__enable_implicit_default</code>。</p><p>可以发现，implicit 的构造和 explicit 的构造是互斥的，二者只能出现一个，因为 <code>__enable_implicit_default</code> 和 <code>__enable_explicit_default</code> 是互斥的。</p><p>这种定义 implicit&#x2F;explicit 两个版本的构造函数在很多标准库中都有出现，至于为什么这样做在下面解释。</p><h2 id="接受两个参数的拷贝构造"><a href="#接受两个参数的拷贝构造" class="headerlink" title="接受两个参数的拷贝构造"></a>接受两个参数的拷贝构造</h2><p>也有 explicit 和 implicit 的版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>, _EnableB&lt;</span><br><span class="line">         _CheckArgsDep&lt;_Dummy&gt;::<span class="keyword">template</span> __enable_explicit&lt;_T1 <span class="type">const</span>&amp;, _T2 <span class="type">const</span>&amp;&gt;()</span><br><span class="line">&gt; = <span class="literal">false</span>&gt;</span><br><span class="line">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line"><span class="keyword">explicit</span> <span class="built_in">pair</span>(_T1 <span class="type">const</span>&amp; __t1, _T2 <span class="type">const</span>&amp; __t2)</span><br><span class="line">    _NOEXCEPT_(is_nothrow_copy_constructible&lt;first_type&gt;::value &amp;&amp;</span><br><span class="line">               is_nothrow_copy_constructible&lt;second_type&gt;::value)</span><br><span class="line">    : <span class="built_in">first</span>(__t1), <span class="built_in">second</span>(__t2) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个函数检查 <code>__enable_explicit</code> 条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_CheckArgs</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_U1</span>, <span class="keyword">class</span> <span class="title class_">_U2</span>&gt;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> __enable_explicit() &#123;</span><br><span class="line">      <span class="keyword">return</span> is_constructible&lt;first_type, _U1&gt;::value</span><br><span class="line">          &amp;&amp; is_constructible&lt;second_type, _U2&gt;::value</span><br><span class="line">          &amp;&amp; (!is_convertible&lt;_U1, first_type&gt;::value</span><br><span class="line">              || !is_convertible&lt;_U2, second_type&gt;::value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_U1</span>, <span class="keyword">class</span> <span class="title class_">_U2</span>&gt;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> __enable_implicit() &#123;</span><br><span class="line">      <span class="keyword">return</span> is_constructible&lt;first_type, _U1&gt;::value</span><br><span class="line">          &amp;&amp; is_constructible&lt;second_type, _U2&gt;::value</span><br><span class="line">          &amp;&amp; is_convertible&lt;_U1, first_type&gt;::value</span><br><span class="line">          &amp;&amp; is_convertible&lt;_U2, second_type&gt;::value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个条件除了要求 <code>_U1</code> 能以括号初始化 <code>_U1 b; first_type a(b);</code> 构造 first_type，还要求 <code>_U1</code> 不能以&#x3D;初始化 <code>_U1 b; first_type a = b;</code> 构造 first_type。</p><p>而 <code>__enable_implicit</code> 则要求 <code>_U1</code> 能以括号初始化 <code>_U1 b; first_type a(b);</code> 构造 first_type，以及 <code>_U1</code> 能以&#x3D;初始化 <code>_U1 b; first_type a = b;</code> 构造 first_type。</p><p>个人猜测之所以这样设计，是为了保持括号初始化的一致：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F a, b;</span><br><span class="line">pair&lt;T, T&gt; c = &#123; a, b &#125;;</span><br></pre></td></tr></table></figure><p>当 pair 使用上面的 <code>=&#123;...&#125;</code> 初始化时，如果构造函数是 explicit 的，那么此构造函数是无法访问的。</p><p>而上面模板函数根据 <code>is_convertible&lt;_U1, first_type&gt;</code> 和 <code>is_convertible&lt;_U2, second_type&gt;</code> 这两个条件决定是使用 implict 还是 explicit 版本：当 <code>_U1、_U2</code> 允许&#x3D;初始化时使用 implict，否则时用 explicit。</p><p>这背后的逻辑是，如果 pair 内部的元素不支持&#x3D;初始化，那么 pair 就不应该支持 <code>=&#123;...&#125;</code> 初始化。</p><p>参见：<a href="https://en.cppreference.com/w/cpp/language/explicit">https://en.cppreference.com/w/cpp/language/explicit</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://en.cppreference.com/w/cpp/types/is_convertible</span><br></pre></td></tr></table></figure><h2 id="接受两个参数的移动构造"><a href="#接受两个参数的移动构造" class="headerlink" title="接受两个参数的移动构造"></a>接受两个参数的移动构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_U1</span>, <span class="keyword">class</span> <span class="title class_">_U2</span>, _EnableB&lt;</span><br><span class="line">         _CheckArgs::<span class="keyword">template</span> __enable_explicit&lt;_U1, _U2&gt;()</span><br><span class="line">&gt; = <span class="literal">false</span>&gt;</span><br><span class="line">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line"><span class="keyword">explicit</span> <span class="built_in">pair</span>(_U1&amp;&amp; __u1, _U2&amp;&amp; __u2)</span><br><span class="line">    _NOEXCEPT_((is_nothrow_constructible&lt;first_type, _U1&gt;::value &amp;&amp;</span><br><span class="line">                is_nothrow_constructible&lt;second_type, _U2&gt;::value))</span><br><span class="line">    : <span class="built_in">first</span>(_VSTD::forward&lt;_U1&gt;(__u1)), <span class="built_in">second</span>(_VSTD::forward&lt;_U2&gt;(__u2)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>和上面一样，也有 implicit 和 explicit 版本，具体细节就不多赘述。</p><h2 id="接受泛型-pair-的构造函数"><a href="#接受泛型-pair-的构造函数" class="headerlink" title="接受泛型 pair 的构造函数"></a>接受泛型 pair 的构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_U1</span>, <span class="keyword">class</span> <span class="title class_">_U2</span>, _EnableB&lt;</span><br><span class="line">            _CheckArgs::<span class="keyword">template</span> __enable_explicit&lt;_U1 <span class="type">const</span>&amp;, _U2 <span class="type">const</span>&amp;&gt;()</span><br><span class="line">    &gt; = <span class="literal">false</span>&gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">pair</span>(pair&lt;_U1, _U2&gt; <span class="type">const</span>&amp; __p)</span><br><span class="line">        _NOEXCEPT_((is_nothrow_constructible&lt;first_type, _U1 <span class="type">const</span>&amp;&gt;::value &amp;&amp;</span><br><span class="line">                    is_nothrow_constructible&lt;second_type, _U2 <span class="type">const</span>&amp;&gt;::value))</span><br><span class="line">        : <span class="built_in">first</span>(__p.first), <span class="built_in">second</span>(__p.second) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> _U1, <span class="keyword">class</span> _U2, _EnableB&lt;</span><br><span class="line">            _CheckArgs::<span class="keyword">template</span> __enable_explicit&lt;_U1, _U2&gt;()</span><br><span class="line">    &gt; = <span class="literal">false</span>&gt;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">pair</span>(pair&lt;_U1, _U2&gt;&amp;&amp;__p)</span><br><span class="line">        _NOEXCEPT_((is_nothrow_constructible&lt;first_type, _U1&amp;&amp;&gt;::value &amp;&amp;</span><br><span class="line">                    is_nothrow_constructible&lt;second_type, _U2&amp;&amp;&gt;::value))</span><br><span class="line">        : <span class="built_in">first</span>(_VSTD::forward&lt;_U1&gt;(__p.first)), <span class="built_in">second</span>(_VSTD::forward&lt;_U2&gt;(__p.second)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>有拷贝构造和移动构造两个版本。</p><p>为什么接受右值的版本，forward 时使用 <code>_U1</code> 为参数？而没有考虑 <code>__p</code> 是左值引用还是右值引用</p><p>因为当 <code>_U1</code> 为值类型（比如 int、char）时，<code>forward&lt;_U1&gt;</code> 会得到右值引用，当 <code>_U1</code> 为左值引用类型（比如 int&amp;），<code>forward&lt;_U1&gt;</code> 得到左值引用，刚好符合当前参数 <code>__p</code> 的右值语义：如果 <code>__p</code> 里面是值，那么应该传它的右值引用从而发生移动，如果 <code>__p</code> 里面是引用，那么此时即便是右值语义，也应该传递引用</p><h2 id="逐元素构造"><a href="#逐元素构造" class="headerlink" title="逐元素构造"></a>逐元素构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Args1, <span class="keyword">class</span>... _Args2&gt;</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    <span class="title">pair</span><span class="params">(<span class="type">piecewise_construct_t</span> __pc,</span></span></span><br><span class="line"><span class="params"><span class="function">         tuple&lt;_Args1...&gt; __first_args, tuple&lt;_Args2...&gt; __second_args)</span></span></span><br><span class="line"><span class="function">        _<span class="title">NOEXCEPT_</span><span class="params">((is_nothrow_constructible&lt;first_type, _Args1...&gt;::value &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">                    is_nothrow_constructible&lt;second_type, _Args2...&gt;::value))</span></span></span><br><span class="line"><span class="function">        : pair(__pc, __first_args, __second_args,</span></span><br><span class="line"><span class="function">                typename __make_tuple_indices&lt;sizeof...(_Args1)&gt;::type(),</span></span><br><span class="line"><span class="function">                typename __make_tuple_indices&lt;sizeof...(_Args2) &gt;::type()) &#123;</span>&#125;</span><br></pre></td></tr></table></figure><p>为什么这里没有像 <code>__compressed_pair</code> 一样对 <code>__first_args</code>、<code>__second_args</code> 使用 move 进行传递？因为形参是引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_T1</span>, <span class="keyword">class</span> <span class="title class_">_T2</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Args1, <span class="keyword">class</span>... _Args2, <span class="type">size_t</span> ..._I1, <span class="type">size_t</span> ..._I2&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">pair&lt;_T1, _T2&gt;::<span class="built_in">pair</span>(<span class="type">piecewise_construct_t</span>,</span><br><span class="line">                     tuple&lt;_Args1...&gt;&amp; __first_args, tuple&lt;_Args2...&gt;&amp; __second_args,</span><br><span class="line">                     __tuple_indices&lt;_I1...&gt;, __tuple_indices&lt;_I2...&gt;)</span><br><span class="line">    :  <span class="built_in">first</span>(_VSTD::forward&lt;_Args1&gt;(_VSTD::<span class="built_in">get</span>&lt;_I1&gt;( __first_args))...),</span><br><span class="line">      <span class="built_in">second</span>(_VSTD::forward&lt;_Args2&gt;(_VSTD::<span class="built_in">get</span>&lt;_I2&gt;(__second_args))...)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拷贝赋值和移动赋值"><a href="#拷贝赋值和移动赋值" class="headerlink" title="拷贝赋值和移动赋值"></a>拷贝赋值和移动赋值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line">pair&amp; <span class="keyword">operator</span>=(<span class="keyword">typename</span> conditional&lt;</span><br><span class="line">                    is_copy_assignable&lt;first_type&gt;::value &amp;&amp;</span><br><span class="line">                    is_copy_assignable&lt;second_type&gt;::value,</span><br><span class="line">                pair, __nat&gt;::type <span class="type">const</span>&amp; __p)</span><br><span class="line">    _NOEXCEPT_(is_nothrow_copy_assignable&lt;first_type&gt;::value &amp;&amp;</span><br><span class="line">               is_nothrow_copy_assignable&lt;second_type&gt;::value)</span><br><span class="line">&#123;</span><br><span class="line">    first = __p.first;</span><br><span class="line">    second = __p.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line">pair&amp; <span class="keyword">operator</span>=(<span class="keyword">typename</span> conditional&lt;</span><br><span class="line">                    is_move_assignable&lt;first_type&gt;::value &amp;&amp;</span><br><span class="line">                    is_move_assignable&lt;second_type&gt;::value,</span><br><span class="line">                pair, __nat&gt;::type&amp;&amp; __p)</span><br><span class="line">    _NOEXCEPT_(is_nothrow_move_assignable&lt;first_type&gt;::value &amp;&amp;</span><br><span class="line">               is_nothrow_move_assignable&lt;second_type&gt;::value)</span><br><span class="line">&#123;</span><br><span class="line">    first = _VSTD::forward&lt;first_type&gt;(__p.first);</span><br><span class="line">    second = _VSTD::forward&lt;second_type&gt;(__p.second);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也有一些条件检查，比如 copy_assignable、move_assignable，只有满足这些条件，相应的模板才能出现。</p><p>此外赋值没有接受泛型 pair 的版本，但有接受 tuple 的版本</p><h2 id="make-pair"><a href="#make-pair" class="headerlink" title="make_pair"></a>make_pair</h2><p>最后看看 make_pair，其实就是用输入的参数创建 pair，只不过 pair 的模板参数为 <code>typename __unwrap_ref_decay&lt;_T1&gt;::type</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_T1</span>, <span class="keyword">class</span> <span class="title class_">_T2</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line">pair&lt;<span class="keyword">typename</span> __unwrap_ref_decay&lt;_T1&gt;::type, <span class="keyword">typename</span> __unwrap_ref_decay&lt;_T2&gt;::type&gt;</span><br><span class="line"><span class="built_in">make_pair</span>(_T1&amp;&amp; __t1, _T2&amp;&amp; __t2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pair&lt;<span class="keyword">typename</span> __unwrap_ref_decay&lt;_T1&gt;::type, <span class="keyword">typename</span> __unwrap_ref_decay&lt;_T2&gt;::type&gt;</span><br><span class="line">               (_VSTD::forward&lt;_T1&gt;(__t1), _VSTD::forward&lt;_T2&gt;(__t2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unwrap_ref_decay</span></span><br><span class="line">    : __unwrap_reference&lt;<span class="keyword">typename</span> decay&lt;_Tp&gt;::type&gt;</span><br><span class="line">&#123; &#125;;</span><br></pre></td></tr></table></figure><p><code>__unwrap_ref_decay</code> 先对 <code>_Tp</code> 进行 decay，然后进行 <code>__unwrap_reference</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unwrap_reference</span> &#123; <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE _Tp type; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unwrap_reference</span>&lt;reference_wrapper&lt;_Tp&gt; &gt; &#123; <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE _Tp&amp; type; &#125;;</span><br></pre></td></tr></table></figure><p><code>__unwrap_reference</code> 对于 <code>reference_wrapper&lt;_Tp&gt;</code> 会得到 <code>_Tp&amp;</code></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++标准库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 标准库之 bind</title>
      <link href="/2023/05/17/C-%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B-bind/"/>
      <url>/2023/05/17/C-%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B-bind/</url>
      
        <content type="html"><![CDATA[<p>这篇文章分析一下 bind。</p><h2 id="函数类型、函数指针、函数引用"><a href="#函数类型、函数指针、函数引用" class="headerlink" title="函数类型、函数指针、函数引用"></a>函数类型、函数指针、函数引用</h2><p>在具体分析 bind 之前，先了解函数类型、函数指针和函数引用的区别。</p><p>函数类型可以认为是由函数的返回值、参数构成的一组描述符。</p><p>可以通过 typedef、decltype 得到函数类型，但是无法创建函数类型的变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(f) d = f; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然不能定义函数类型的变量，但是可以定义函数类型的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(f)* d = &amp;f; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(f)* l = f; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数类型的指针存储的就是函数的地址，这很好理解。<code>decltype(f)* l = f;</code> 这条语句是因为 C++ 允许函数类型自动转为函数指针（就像数组自动转为指向数组首元素的指针）。</p><p>除了定义函数指针，还能像下面这样定义函数引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(f)&amp; d = f; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用可以认为是常量指针，上面代码可以按照下面去理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> T = <span class="built_in">void</span>();</span><br><span class="line">    T*<span class="type">const</span> d = f; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的也可以定义函数类型的右值引用。</p><h3 id="函数名自动转换为指针"><a href="#函数名自动转换为指针" class="headerlink" title="函数名自动转换为指针"></a>函数名自动转换为指针</h3><p>函数名就像汇编语言中的标号，所以他其实对应一个地址，但是这个地址不是变量，没有保存在内存中，是编译时概念。必要时可以把函数名转成地址，这时就可以使用函数名向函数指针的转换，最典型的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functype* f = funcname;</span><br></pre></td></tr></table></figure><p>函数名在某些情况下会转换为函数指针，比如上面的赋值语句，当赋值语句左侧是函数指针类型时右侧如果是函数名，则会自动退化为函数指针。但是如果赋值语句的左侧是引用绑定，则不会发生这种转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> T = <span class="built_in">void</span>();</span><br><span class="line"></span><br><span class="line">T* m = f; <span class="comment">// 发生函数名向指针的转换</span></span><br><span class="line"></span><br><span class="line">T&amp; d = f; <span class="comment">// f不会转换为指针</span></span><br></pre></td></tr></table></figure><p>这和数组类型是一样的。</p><p>此外当遇到模板函数时，当没有最匹配的类型时，也可以使用函数向函数名转换，但仅限于不带引用的模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fu</span><span class="params">(T t)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hi</span><span class="params">(<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fu</span>(hi);</span><br></pre></td></tr></table></figure><p>这里 T 被推断为函数指针类型，hi 会执行函数向函数指针的转换。一个类似的情况，就是数组作为参数时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fu</span><span class="params">(T t)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">fu</span>(a);</span><br></pre></td></tr></table></figure><p>这里 T 被推断为 int*，a 也执行数组向指针的转换</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>bind 能把一个可调用对象和参数绑定在一起，得到一个新的可调用对象。配合占位符，这个新的可调用对象还可以再接受参数，bind 在函数式编程中有很重要的作用。</p><p>bind 可以绑定以下对象：</p><ul><li>函数对象（实现了 operator()的对象）</li><li>函数指针（pointer to function）</li><li>函数引用（reference to function）</li><li>成员函数指针（pointer to member function）</li><li>成员数据指针（pointer to data member）</li></ul><p>bind 在定义变量时需要完全确定所有的函数参数，但是可以通过占位符来提供调用时参数的重新输入。新版本的 bind_front、bind_back 支持返回的可调用对象可以接受可变长参数，并且该变长参数会插到 bind 时参数的 front 或者 back。</p><p>先看几个例子。这个例子把所有参数都绑定了，返回的 g 是一个 closure</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>, <span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bind</span>(f, <span class="number">1</span>, <span class="number">1.2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">g</span>();</span><br></pre></td></tr></table></figure><p>下面的例子使用了占位符，返回的 h 还可以接受其他参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>, <span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> h = <span class="built_in">bind</span>(f, <span class="number">1</span>, _1, _2);</span><br><span class="line"><span class="built_in">h</span>(<span class="number">1.3</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>更多的例子和用法参考 cppreference。接下来的分析以这个最简单的例子进行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bind</span>(f, <span class="number">1</span>, <span class="number">1.2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">g</span>();</span><br></pre></td></tr></table></figure><h3 id="bind-1"><a href="#bind-1" class="headerlink" title="bind"></a>bind</h3><p>在看源码之前我们可以猜测：bind 最终要做的就是保存函数指针和参数，所以 bind 返回的对象中肯定有地方存储这些信息。</p><p>bind 函数如下，他创建并返回一个 <code>__bind&lt;_Fp, _BoundArgs...&gt;</code> 类型的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Fp, <span class="keyword">class</span> ..._BoundArgs&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> </span></span><br><span class="line"><span class="function">__bind&lt;_Fp, _BoundArgs...&gt;</span></span><br><span class="line"><span class="function"><span class="title">bind</span><span class="params">(_Fp&amp;&amp; __f, _BoundArgs&amp;&amp;... __bound_args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __bind&lt;_Fp, _BoundArgs...&gt; type;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(_VSTD::forward&lt;_Fp&gt;(__f), _VSTD::forward&lt;_BoundArgs&gt;(__bound_args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bind-2"><a href="#bind-2" class="headerlink" title="__bind"></a>__bind</h4><p><code>__bind</code> 类型如下，他里面有 <code>__f_</code> 和 <code>__bound_args_</code> 分别存储可调用对象和参数，而且使用 tuple 来存储参数。但是注意 <code>_Fd</code> 和 <code>_Td</code> 都是经过 decay 的，比如如果 <code>_Fp</code> 是函数引用，那么 <code>_Fd</code> 就是函数指针。经过 decay 之后 <code>__bind</code> 内部都是存储的值类型，除非使用 std::ref 对引用进行包装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._BoundArgs&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__bind</span></span><br><span class="line">    : <span class="keyword">public</span> __weak_result_type&lt;<span class="keyword">typename</span> decay&lt;_Fp&gt;::type&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> decay&lt;_Fp&gt;::type _Fd;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;<span class="keyword">typename</span> decay&lt;_BoundArgs&gt;::type...&gt; _Td;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Fd __f_;</span><br><span class="line">    _Td __bound_args_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __make_tuple_indices&lt;<span class="keyword">sizeof</span>...(_BoundArgs)&gt;::type __indices;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>再看 <code>__bind</code> 的构造函数，这个函数是一个模板函数，接受可调用对象和参数，但他们的类型不需要和 <code>_Fd</code>、<code>_Td</code> 一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Gp</span>, <span class="keyword">class</span> ..._BA,</span><br><span class="line">          <span class="keyword">class</span> = <span class="keyword">typename</span> enable_if</span><br><span class="line">                           &lt;</span><br><span class="line">                              is_constructible&lt;_Fd, _Gp&gt;::value &amp;&amp;</span><br><span class="line">                              !is_same&lt;<span class="keyword">typename</span> remove_reference&lt;_Gp&gt;::type,</span><br><span class="line">                                       __bind&gt;::value</span><br><span class="line">                           &gt;::type&gt;</span><br><span class="line">  <span class="keyword">explicit</span> __bind(_Gp&amp;&amp; __f, _BA&amp;&amp; ...__bound_args)</span><br><span class="line">    : __f_(_VSTD::forward&lt;_Gp&gt;(__f)),</span><br><span class="line">      __bound_args_(_VSTD::forward&lt;_BA&gt;(__bound_args)...) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个函数就是参数的转发，把输入的 <code>__f</code> 和 <code>__bound_args</code> forward 到 <code>__f_</code> 和 <code>__bound_args_</code>。检查条件要求 <code>_Gp</code> 能构造 <code>_Fd</code>，以及 <code>_Gp</code> 不是当前 <code>__bind</code> 类型</p><h5 id="operator"><a href="#operator" class="headerlink" title="operator()"></a>operator()</h5><p>再看函数调用运算符（先不管 const 版本）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> __bind_return&lt;_Fd, _Td, tuple&lt;_Args&amp;&amp;...&gt; &gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(_Args&amp;&amp; ...__args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _VSTD::__apply_functor(__f_, __bound_args_, __indices(),</span><br><span class="line">                              <span class="built_in">tuple</span>&lt;_Args&amp;&amp;...&gt;(_VSTD::forward&lt;_Args&gt;(__args)...));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> __bind_return&lt;<span class="type">const</span> _Fd, <span class="type">const</span> _Td, tuple&lt;_Args&amp;&amp;...&gt; &gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(_Args&amp;&amp; ...__args)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _VSTD::__apply_functor(__f_, __bound_args_, __indices(),</span><br><span class="line">                               <span class="built_in">tuple</span>&lt;_Args&amp;&amp;...&gt;(_VSTD::forward&lt;_Args&gt;(__args)...));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="bind-return"><a href="#bind-return" class="headerlink" title="__bind_return"></a>__bind_return</h6><p>先看返回类型 <code>__bind_return</code>，他会检查函数调用的合法性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> <span class="title class_">_BoundArgs</span>, <span class="keyword">class</span> <span class="title class_">_TupleUj</span>,</span><br><span class="line">          <span class="type">bool</span> = __is_valid_bind_return&lt;_Fp, _BoundArgs, _TupleUj&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> __bind_return;</span><br></pre></td></tr></table></figure><p>####### __is_valid_bind_return</p><p><code>__is_valid_bind_return</code> 会进行参数的校验（先不看带 const 的特化的版本）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._BoundArgs, <span class="keyword">class</span> <span class="title class_">_TupleUj</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_valid_bind_return</span>&lt;_Fp, tuple&lt;_BoundArgs...&gt;, _TupleUj&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = __invokable&lt;_Fp,</span><br><span class="line">                    <span class="keyword">typename</span> __mu_return&lt;_BoundArgs, _TupleUj&gt;::type...&gt;::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__is_valid_bind_return</code> 会使用 <code>__invokable</code> 对可调用对象的类型 <code>_Fp</code>，以及通过 <code>__mu_return</code> 得到的参数类型进行可调用检查。</p><p>######## __mu_return</p><p>先看 <code>__mu_return</code>。<code>_BoundArgs</code> 就是绑定的参数的类型，<code>_TupleUj</code> 就是输入参数的类型，我们知道，bind 支持占位符调用，所以 <code>__mu_return</code> 需要正确的把 <code>_TupleUj</code> 插入 <code>_BoundArgs</code> 中的占位符，看看他是怎么做到这一点的。</p><p><code>__mu_return</code> 继承 <code>__mu_return_impl</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ti</span>, <span class="keyword">class</span> <span class="title class_">_TupleUj</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__mu_return</span></span><br><span class="line">    : <span class="keyword">public</span> __mu_return_impl&lt;_Ti,</span><br><span class="line">                              __is_reference_wrapper&lt;_Ti&gt;::value,</span><br><span class="line">                              is_bind_expression&lt;_Ti&gt;::value,</span><br><span class="line">                              <span class="number">0</span> &lt; is_placeholder&lt;_Ti&gt;::value &amp;&amp;</span><br><span class="line">                              is_placeholder&lt;_Ti&gt;::value &lt;= tuple_size&lt;_TupleUj&gt;::value,</span><br><span class="line">                              _TupleUj&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 <code>__mu_return_impl</code> 有 3 个条件，根据这三个条件，有不同的特化</p><ul><li><code>__is_reference_wrapper</code> 判断 <code>_Ti</code> 是否经过 std::ref 包装</li><li>is_bind_expression 判断 <code>_Ti</code> 是否是 <code>__bind</code> 或者 <code>__bind_r</code> 类型</li><li>第三个条件比较重要，判断 <code>_Ti</code> 是否是有效的占位符类型</li></ul><p>如果上面三个条件全为 false，那么 type 就是 <code>_Ti&amp;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ti</span>, <span class="keyword">class</span> <span class="title class_">_TupleUj</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__mu_return_impl</span>&lt;_Ti, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, _TupleUj&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Ti&amp; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果上面三个条件只有最后一个条件为 true，那么 type 如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ti</span>, <span class="keyword">class</span> <span class="title class_">_TupleUj</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__mu_return_impl</span>&lt;_Ti, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>, _TupleUj&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> tuple_element&lt;is_placeholder&lt;_Ti&gt;::value - <span class="number">1</span>,</span><br><span class="line">                                   _TupleUj&gt;::type&amp;&amp; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面的特化，就实现了：如果调用 bind 时绑定的参数 <code>_BoundArgs</code> 里的 type 不是占位符类型，那么返回该 type 的左值引用，如果是占位符，就根据该占位符标识的位置从调用时的参数列表中取参数类型（tuple_element 在之前 tuple 中已经介绍了）</p><p>接下来看看 <code>placeholder</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt; <span class="keyword">struct</span> <span class="title class_">__is_placeholder</span> : <span class="keyword">public</span> integral_constant&lt;<span class="type">int</span>, <span class="number">0</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> _Np&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__is_placeholder</span>&lt;placeholders::__ph&lt;_Np&gt; &gt;</span><br><span class="line">    : <span class="keyword">public</span> integral_constant&lt;<span class="type">int</span>, _Np&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt; <span class="keyword">struct</span> <span class="title class_">is_placeholder</span></span><br><span class="line">    : <span class="keyword">public</span> __is_placeholder&lt;<span class="keyword">typename</span> remove_cv&lt;_Tp&gt;::type&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>根据上面的模板，如果 <code>_Tp</code> 不是 <code>placeholders::__ph</code> 类型，<code>is_placeholder&lt;_Tp&gt;</code> 里的 value 来自父类 <code>__is_placeholder</code> 类的父类 <code>integral_constant&lt;int, 0&gt;</code>，在 <code>integral_constant&lt;int, 0&gt;</code> 内部定义了 value 为 0，所以 <code>is_placeholder&lt;_Tp&gt;::value</code> 对于非 placeholder 类型就是 0。</p><p>如果 <code>_Tp</code> 是 <code>placeholders::__ph</code> 类型，那么 <code>is_placeholder&lt;_Tp&gt;</code> 中的 value 来自父类 <code>integral_constant&lt;int, _Np&gt;</code>，<code>_Np</code> 取决于是 <code>placeholders::__ph&lt;1&gt;</code>、<code>placeholders::__ph&lt;2&gt;</code>、<code>placeholders::__ph&lt;3&gt;</code> 等等</p><p>而 <code>placeholders::_1</code>、<code>placeholders::_2</code> 的定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> placeholders</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> _Np&gt; <span class="keyword">struct</span> <span class="title class_">__ph</span> &#123;&#125;;</span><br><span class="line"><span class="comment">/* _LIBCPP_INLINE_VAR */</span> <span class="keyword">constexpr</span> __ph&lt;<span class="number">1</span>&gt;   _1&#123;&#125;;</span><br><span class="line"><span class="comment">/* _LIBCPP_INLINE_VAR */</span> <span class="keyword">constexpr</span> __ph&lt;<span class="number">2</span>&gt;   _2&#123;&#125;;</span><br><span class="line"><span class="comment">/* _LIBCPP_INLINE_VAR */</span> <span class="keyword">constexpr</span> __ph&lt;<span class="number">3</span>&gt;   _3&#123;&#125;;</span><br><span class="line"><span class="comment">/* _LIBCPP_INLINE_VAR */</span> <span class="keyword">constexpr</span> __ph&lt;<span class="number">4</span>&gt;   _4&#123;&#125;;</span><br><span class="line"><span class="comment">/* _LIBCPP_INLINE_VAR */</span> <span class="keyword">constexpr</span> __ph&lt;<span class="number">5</span>&gt;   _5&#123;&#125;;</span><br><span class="line"><span class="comment">/* _LIBCPP_INLINE_VAR */</span> <span class="keyword">constexpr</span> __ph&lt;<span class="number">6</span>&gt;   _6&#123;&#125;;</span><br><span class="line"><span class="comment">/* _LIBCPP_INLINE_VAR */</span> <span class="keyword">constexpr</span> __ph&lt;<span class="number">7</span>&gt;   _7&#123;&#125;;</span><br><span class="line"><span class="comment">/* _LIBCPP_INLINE_VAR */</span> <span class="keyword">constexpr</span> __ph&lt;<span class="number">8</span>&gt;   _8&#123;&#125;;</span><br><span class="line"><span class="comment">/* _LIBCPP_INLINE_VAR */</span> <span class="keyword">constexpr</span> __ph&lt;<span class="number">9</span>&gt;   _9&#123;&#125;;</span><br><span class="line"><span class="comment">/* _LIBCPP_INLINE_VAR */</span> <span class="keyword">constexpr</span> __ph&lt;<span class="number">10</span>&gt; _10&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// placeholders</span></span><br></pre></td></tr></table></figure><p>######## __invokable</p><p>通过 <code>__mu_return</code> 得到 type 信息后通过 <code>__invokable</code> 检查可调用对象是否能正确接受这些 type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._Args&gt;</span><br><span class="line"><span class="keyword">using</span> __invokable = __invokable_r&lt;<span class="type">void</span>, _Fp, _Args...&gt;;</span><br></pre></td></tr></table></figure><p><code>__invokable_r</code> 如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>, <span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__invokable_r</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = type::value;</span><br><span class="line">  <span class="keyword">using</span> type =</span><br><span class="line">  <span class="keyword">typename</span> conditional&lt;</span><br><span class="line">      _IsNotSame&lt;_Result, __nat&gt;::value,</span><br><span class="line">      <span class="keyword">typename</span> conditional&lt;</span><br><span class="line">          is_void&lt;_Ret&gt;::value,</span><br><span class="line">          true_type,</span><br><span class="line">          is_convertible&lt;_Result, _Ret&gt;</span><br><span class="line">      &gt;::type,</span><br><span class="line">      false_type</span><br><span class="line">  &gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> _Result = <span class="keyword">decltype</span>(__try_call&lt;_Fp, _Args...&gt;(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_XFp</span>, <span class="keyword">class</span> ..._XArgs&gt;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">auto</span> __try_call(<span class="type">int</span>) -&gt; <span class="keyword">decltype</span>(</span><br><span class="line">    _VSTD::__invoke(_VSTD::<span class="built_in">declval</span>&lt;_XFp&gt;(), _VSTD::<span class="built_in">declval</span>&lt;_XArgs&gt;()...));</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_XFp</span>, <span class="keyword">class</span> ..._XArgs&gt;</span><br><span class="line">  <span class="type">static</span> __nat __try_call(...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据 conditional，<code>__invokable_r::type</code> 为 true_type 需要</p><ul><li><code>_IsNotSame&lt;_Result, __nat&gt;::value</code> 为 true，<code>is_void&lt;_Ret&gt;::value</code> 为 true</li><li>或者 <code>_IsNotSame&lt;_Result, __nat&gt;::value</code> 为 true，<code>is_convertible&lt;_Result, _Ret&gt;</code> 为 true</li></ul><p>而 <code>_IsNotSame&lt;_Result, __nat&gt;::value</code> 为 true 要求 <code>_Result</code> 不为 <code>__nat</code>，而 <code>_Result</code> 来自 <code>__try_call</code> 函数的返回值</p><p><code>__try_call</code> 有两个版本，第一个版本接受 int 参数，第二个版本接受变长参数，只有第一个版本失败时才会考虑第二个版本。第二个版本的 <code>__try_call</code> 的返回类型就是 <code>__nat</code>，所以上面 <code>_IsNotSame&lt;_Result, __nat&gt;::value</code> 为 true 就是要求 <code>__try_call</code> 的第一个版本不能失败。<code>__try_call</code> 的第一个版本内部调用了 <code>__invoke</code> 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">auto</span> __try_call(<span class="type">int</span>) -&gt; <span class="keyword">decltype</span>(</span><br><span class="line">    _VSTD::__invoke(_VSTD::<span class="built_in">declval</span>&lt;_XFp&gt;(), _VSTD::<span class="built_in">declval</span>&lt;_XArgs&gt;()...));</span><br></pre></td></tr></table></figure><p><code>__invoke</code> 会根据第一个参数的类型，比如函数指针、类成员函数指针进行特化。以最简单的函数指针为例，<code>__invoke</code> 如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._Args&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">auto</span> __invoke(_Fp&amp;&amp; __f, _Args&amp;&amp; ...__args)</span><br><span class="line">_LIBCPP_INVOKE_RETURN(_VSTD::forward&lt;_Fp&gt;(__f)(_VSTD::forward&lt;_Args&gt;(__args)...))</span><br></pre></td></tr></table></figure><p><code>_LIBCPP_INVOKE_RETURN</code> 宏定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _LIBCPP_INVOKE_RETURN(...) \</span></span><br><span class="line"><span class="meta">    noexcept(noexcept(__VA_ARGS__)) -&gt; decltype(__VA_ARGS__) \</span></span><br><span class="line"><span class="meta">    &#123; return __VA_ARGS__; &#125;</span></span><br></pre></td></tr></table></figure><p>展开就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._Args&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="keyword">auto</span></span><br><span class="line">__invoke(_Fp&amp;&amp; __f, _Args&amp;&amp; ...__args)</span><br><span class="line">    <span class="built_in">noexcept</span>(<span class="built_in">noexcept</span>(_VSTD::forward&lt;_Fp&gt;(__f)(_VSTD::forward&lt;_Args&gt;(__args)...)) -&gt; <span class="keyword">decltype</span>(_VSTD::forward&lt;_Fp&gt;(__f)(_VSTD::forward&lt;_Args&gt;(__args)...) </span><br><span class="line">    &#123; <span class="keyword">return</span> _VSTD::forward&lt;_Fp&gt;(__f)(_VSTD::forward&lt;_Args&gt;(__args)...; &#125;</span><br></pre></td></tr></table></figure><h6 id="apply-functor"><a href="#apply-functor" class="headerlink" title="__apply_functor"></a>__apply_functor</h6><p>进行检查后就可以实际调用可调用对象了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line"><span class="keyword">typename</span> __bind_return&lt;_Fd, _Td, tuple&lt;_Args&amp;&amp;...&gt; &gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">operator</span><span class="params">()</span><span class="params">(_Args&amp;&amp; ...__args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _VSTD::__apply_functor(__f_, __bound_args_, __indices(),</span><br><span class="line">                          <span class="built_in">tuple</span>&lt;_Args&amp;&amp;...&gt;(_VSTD::forward&lt;_Args&gt;(__args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面 <code>__args</code> 的打包和转发，<code>__apply_functor</code> 的 tuple 参数里面是引用类型，因为该 tuple 仅仅用于参数转发，和之前 forward_as_tuple 一样。</p><p>可以看到这里和上面检查都使用了 <code>__invoke</code>，只不过上面检查是在 decltype 中进行 <code>__invoke</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> <span class="title class_">_BoundArgs</span>, <span class="type">size_t</span> ..._Indx, <span class="keyword">class</span> <span class="title class_">_Args</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="keyword">typename</span> __bind_return&lt;_Fp, _BoundArgs, _Args&gt;::type</span><br><span class="line">__apply_functor(_Fp&amp; __f, _BoundArgs&amp; __bound_args, __tuple_indices&lt;_Indx...&gt;,</span><br><span class="line">                _Args&amp;&amp; __args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _VSTD::__invoke(__f, _VSTD::__mu(_VSTD::<span class="built_in">get</span>&lt;_Indx&gt;(__bound_args), __args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有一点我不理解，在上面 <code>__is_valid_bind_return</code> 中，最终传给 <code>__invoke</code> 的是 <code>declval&lt;_Fp&gt;()</code>，其得到 <code>_Fp&amp;&amp;</code>，而这里得到的是 <code>_Fp&amp;</code>，两者不一致，如果 <code>_Fp</code> 定义了左值和右值版本的 operator()()函数，那这里是否会有问题？</p><p>测试了一下，如下的代码在使用 g++ 和 clang++ 编译时，clang++ 会报错，g++ 不会，看来确实是个 bug</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">some_class</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span>)</span> &amp;&amp; </span>&#123;</span><br><span class="line">        <span class="comment">// static_assert(false, &quot;failed in void operator()() &amp;&amp;&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> &amp; </span>&#123;</span><br><span class="line">        <span class="comment">// static_assert(false, &quot;failed in void operator()() &amp;&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    some_class obj;</span><br><span class="line">    <span class="keyword">auto</span> tmp = std::<span class="built_in">bind</span>(obj);</span><br><span class="line">    <span class="built_in">tmp</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clang++ tmp.cpp -o main -stdlib=libc++</span></span><br><span class="line"><span class="comment">// 报错：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tmp.cpp:16:5: error: no matching function for call to object of type &#x27;__bind&lt;some_class &amp;&gt;&#x27; </span></span><br><span class="line"><span class="comment">    tmp(); </span></span><br><span class="line"><span class="comment">    ^~~ </span></span><br><span class="line"><span class="comment">/usr/bin/../include/c++/v1/__functional/bind.h:293:9: note: candidate template ignored: substitution failure [with _Args = &lt;&gt;]: i</span></span><br><span class="line"><span class="comment">mplicit instantiation of undefined template &#x27;std::__bind_return&lt;some_class, std::tuple&lt;&gt;, std::tuple&lt;&gt;, false&gt;&#x27; </span></span><br><span class="line"><span class="comment">        operator()(_Args&amp;&amp; ...__args) </span></span><br><span class="line"><span class="comment">        ^ </span></span><br><span class="line"><span class="comment">/usr/bin/../include/c++/v1/__functional/bind.h:302:9: note: candidate template ignored: substitution failure [with _Args = &lt;&gt;]: i</span></span><br><span class="line"><span class="comment">mplicit instantiation of undefined template &#x27;std::__bind_return&lt;const some_class, const std::tuple&lt;&gt;, std::tuple&lt;&gt;, false&gt;&#x27; </span></span><br><span class="line"><span class="comment">        operator()(_Args&amp;&amp; ...__args) const </span></span><br><span class="line"><span class="comment">        ^ </span></span><br><span class="line"><span class="comment">1 error generated.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// g++ tmp.cpp -o main // 不会报错</span></span><br></pre></td></tr></table></figure><p>####### __mu</p><p><code>__mu</code> 和上面 <code>__mu_return</code> 类似，也是把 bind 时的参数和调用时的参数进行组装。<code>__mu(_VSTD::get&lt;_Indx&gt;(__bound_args), __args)...</code> 是针对 <code>__bound_args</code> 中的每一个参数和 <code>__args</code> 都做一个 <code>__mu(...)</code>，目的是根据占位符把绑定的参数和输入的参数进行重新排列</p><p>先看 get 从已绑定参数的 tuple 中取元素得到的类型是什么。由于上面 <code>__apply_functor(..., _BoundArgs``&amp;`` __bound_args, ...);</code> 中指定了引用，所以 <code>__bound_args</code> 也是左值引用，那么 get 会返回左值引用，因为下面返回类型最后加了&amp;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> _Ip, <span class="keyword">class</span> ..._Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11</span><br><span class="line"><span class="keyword">typename</span> tuple_element&lt;_Ip, tuple&lt;_Tp...&gt; &gt;::<span class="function">type&amp;</span></span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(tuple&lt;_Tp...&gt;&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE <span class="keyword">typename</span> tuple_element&lt;_Ip, tuple&lt;_Tp...&gt; &gt;::type type;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;__tuple_leaf&lt;_Ip, type&gt;&amp;&gt;(<span class="type">__t</span>.__base_).<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看 <code>__mu</code>。对于非 placeholder，<code>__mu</code> 会返回 <code>_Ti&amp;</code>。所以从 bind 内部已经绑定的参数 tuple 中取对象总是取左值引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ti</span>, <span class="keyword">class</span> <span class="title class_">_Uj</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="keyword">typename</span> enable_if</span><br><span class="line">&lt;</span><br><span class="line">    !is_bind_expression&lt;_Ti&gt;::value &amp;&amp;</span><br><span class="line">    is_placeholder&lt;_Ti&gt;::value == <span class="number">0</span> &amp;&amp;</span><br><span class="line">    !__is_reference_wrapper&lt;_Ti&gt;::value,</span><br><span class="line">    _Ti&amp;</span><br><span class="line">&gt;::type</span><br><span class="line">__mu(_Ti&amp; __ti, _Uj&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __ti;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于调用时的参数包的传递是完美转发的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> IsPh, <span class="keyword">class</span> <span class="title class_">_Ti</span>, <span class="keyword">class</span> <span class="title class_">_Uj</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__mu_return2</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ti</span>, <span class="keyword">class</span> <span class="title class_">_Uj</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__mu_return2</span>&lt;<span class="literal">true</span>, _Ti, _Uj&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> tuple_element&lt;is_placeholder&lt;_Ti&gt;::value - <span class="number">1</span>, _Uj&gt;::type type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ti</span>, <span class="keyword">class</span> <span class="title class_">_Uj</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="keyword">typename</span> enable_if</span><br><span class="line">&lt;</span><br><span class="line">    <span class="number">0</span> &lt; is_placeholder&lt;_Ti&gt;::value,</span><br><span class="line">    <span class="keyword">typename</span> __mu_return2&lt;<span class="number">0</span> &lt; is_placeholder&lt;_Ti&gt;::value, _Ti, _Uj&gt;::type</span><br><span class="line">&gt;::type</span><br><span class="line">__mu(_Ti&amp;, _Uj&amp; __uj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> _Indx = is_placeholder&lt;_Ti&gt;::value - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> _VSTD::forward&lt;<span class="keyword">typename</span> tuple_element&lt;_Indx, _Uj&gt;::type&gt;(_VSTD::<span class="built_in">get</span>&lt;_Indx&gt;(__uj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在最开始 operator()()中创建 tuple 的时候 tuple 的模板参数是引用类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line"><span class="keyword">typename</span> __bind_return&lt;_Fd, _Td, tuple&lt;_Args&amp;&amp;...&gt; &gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">operator</span><span class="params">()</span><span class="params">(_Args&amp;&amp; ...__args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _VSTD::__apply_functor(__f_, __bound_args_, __indices(),</span><br><span class="line">                          <span class="built_in">tuple</span>&lt;_Args&amp;&amp;...&gt;(_VSTD::forward&lt;_Args&gt;(__args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forward 的时候能根据 tuple 中的类型正确决定该得到将亡值还是左值。比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(string&amp; a,string&amp;&amp; b)</span></span>&#123;</span><br><span class="line">    string c = b;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string lu = <span class="string">&quot;hello lu&quot;</span>;</span><br><span class="line">    string lk = <span class="string">&quot;hello lk&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> q = <span class="built_in">bind</span>(f, lu, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">q</span>(std::<span class="built_in">move</span>(lk)); <span class="comment">// ok</span></span><br><span class="line">    <span class="comment">//q(lk); // error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，bind 的参数在最后组装阶段只取左值引用（reference_wrapper 另说），调用时传递的参数包会进行完美转发。</p><p>参考资料：</p><p><a href="https://blog.csdn.net/xiaoyaohuqijun/article/details/48771071">https://blog.csdn.net/xiaoyaohuqijun/article/details/48771071</a></p><p><a href="https://www.cnblogs.com/qicosmos/p/3723388.html">https://www.cnblogs.com/qicosmos/p/3723388.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/66301236">https://zhuanlan.zhihu.com/p/66301236</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++标准库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg 之 IO 模块</title>
      <link href="/2023/05/10/ffmpeg-%E4%B9%8B-IO-%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/05/10/ffmpeg-%E4%B9%8B-IO-%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>这篇文章总结一下 ffmpeg 中常见的 IO 函数。</p><h1 id="avio-open2"><a href="#avio-open2" class="headerlink" title="avio_open2"></a>avio_open2</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avio_open2</span><span class="params">(AVIOContext **s, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> AVIOInterruptCB *int_cb<span class="comment">/*NULL*/</span>, AVDictionary **options<span class="comment">/*NULL*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ffio_open_whitelist</span>(s, filename, flags, int_cb, options, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ffio-open-whitelist"><a href="#ffio-open-whitelist" class="headerlink" title="ffio_open_whitelist"></a>ffio_open_whitelist</h2><p>这个函数先初始化 URLContext，然后初始化 AVIOContext</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ffio_open_whitelist</span><span class="params">(AVIOContext **s, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> AVIOInterruptCB *int_cb<span class="comment">/*NULL*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                         AVDictionary **options<span class="comment">/*NULL*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> <span class="type">char</span> *whitelist<span class="comment">/*NULL*/</span>, <span class="type">const</span> <span class="type">char</span> *blacklist<span class="comment">/*NULL*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    URLContext *h;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    *s = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">ffurl_open_whitelist</span>(&amp;h, filename, flags, int_cb, options, whitelist, blacklist, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    err = <span class="built_in">ffio_fdopen</span>(s, h);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ffurl_close</span>(h);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ffurl-open-whitelist"><a href="#ffurl-open-whitelist" class="headerlink" title="ffurl_open_whitelist"></a>ffurl_open_whitelist</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ffurl_open_whitelist</span><span class="params">(URLContext **puc, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> AVIOInterruptCB *int_cb<span class="comment">/*NULL*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                         AVDictionary **options<span class="comment">/*NULL*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> <span class="type">char</span> *whitelist<span class="comment">/*NULL*/</span>, <span class="type">const</span> <span class="type">char</span>* blacklist<span class="comment">/*NULL*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                         URLContext *parent<span class="comment">/*NULL*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVDictionary *tmp_opts = <span class="literal">NULL</span>;</span><br><span class="line">    AVDictionaryEntry *e;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">ffurl_alloc</span>(puc, filename, flags, int_cb);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        ret = <span class="built_in">av_opt_copy</span>(*puc, parent);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp;</span><br><span class="line">        (ret = <span class="built_in">av_opt_set_dict</span>(*puc, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; (*puc)-&gt;prot-&gt;priv_data_class &amp;&amp;</span><br><span class="line">        (ret = <span class="built_in">av_opt_set_dict</span>((*puc)-&gt;priv_data, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!options)</span><br><span class="line">        options = &amp;tmp_opts;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert0</span>(!whitelist ||</span><br><span class="line">               !(e=<span class="built_in">av_dict_get</span>(*options, <span class="string">&quot;protocol_whitelist&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) ||</span><br><span class="line">               !<span class="built_in">strcmp</span>(whitelist, e-&gt;value));</span><br><span class="line">    <span class="built_in">av_assert0</span>(!blacklist ||</span><br><span class="line">               !(e=<span class="built_in">av_dict_get</span>(*options, <span class="string">&quot;protocol_blacklist&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) ||</span><br><span class="line">               !<span class="built_in">strcmp</span>(blacklist, e-&gt;value));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_dict_set</span>(options, <span class="string">&quot;protocol_whitelist&quot;</span>, whitelist, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_dict_set</span>(options, <span class="string">&quot;protocol_blacklist&quot;</span>, blacklist, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_opt_set_dict</span>(*puc, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">ffurl_connect</span>(*puc, options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">ffurl_closep</span>(puc);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ffurl-alloc"><a href="#ffurl-alloc" class="headerlink" title="ffurl_alloc"></a>ffurl_alloc</h4><p>先通过 url_find_protocol 查找协议，比如 file、http、ftp。然后创建 URLContext</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ffurl_alloc</span><span class="params">(URLContext **puc, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> AVIOInterruptCB *int_cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> URLProtocol *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">url_find_protocol</span>(filename);</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">url_alloc_for_protocol</span>(puc, p, filename, flags, int_cb);</span><br><span class="line"></span><br><span class="line">    *puc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> AVERROR_PROTOCOL_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="url-find-protocol"><a href="#url-find-protocol" class="headerlink" title="url_find_protocol"></a>url_find_protocol</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> URL_SCHEME_CHARS                        \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>                \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>                \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;0123456789+-.&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">URLProtocol</span> *<span class="built_in">url_find_protocol</span>(<span class="type">const</span> <span class="type">char</span> *filename)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> URLProtocol **protocols;</span><br><span class="line">    <span class="type">char</span> proto_str[<span class="number">128</span>], proto_nested[<span class="number">128</span>], *ptr;</span><br><span class="line">    <span class="type">size_t</span> proto_len = <span class="built_in">strspn</span>(filename, URL_SCHEME_CHARS);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filename[proto_len] != <span class="string">&#x27;:&#x27;</span> &amp;&amp;</span><br><span class="line">        (<span class="built_in">strncmp</span>(filename, <span class="string">&quot;subfile,&quot;</span>, <span class="number">8</span>) || !<span class="built_in">strchr</span>(filename + proto_len + <span class="number">1</span>, <span class="string">&#x27;:&#x27;</span>)) ||</span><br><span class="line">        <span class="built_in">is_dos_path</span>(filename))</span><br><span class="line">        <span class="built_in">strcpy</span>(proto_str, <span class="string">&quot;file&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">av_strlcpy</span>(proto_str, filename,</span><br><span class="line">                   <span class="built_in">FFMIN</span>(proto_len + <span class="number">1</span>, <span class="built_in">sizeof</span>(proto_str)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_strlcpy</span>(proto_nested, proto_str, <span class="built_in">sizeof</span>(proto_nested));</span><br><span class="line">    <span class="keyword">if</span> ((ptr = <span class="built_in">strchr</span>(proto_nested, <span class="string">&#x27;+&#x27;</span>)))</span><br><span class="line">        *ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    protocols = <span class="built_in">ffurl_get_protocols</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!protocols)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; protocols[i]; i++) &#123;</span><br><span class="line">            <span class="type">const</span> URLProtocol *up = protocols[i];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(proto_str, up-&gt;name)) &#123;</span><br><span class="line">            <span class="built_in">av_freep</span>(&amp;protocols);</span><br><span class="line">            <span class="keyword">return</span> up;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (up-&gt;flags &amp; URL_PROTOCOL_FLAG_NESTED_SCHEME &amp;&amp;</span><br><span class="line">            !<span class="built_in">strcmp</span>(proto_nested, up-&gt;name)) &#123;</span><br><span class="line">            <span class="built_in">av_freep</span>(&amp;protocols);</span><br><span class="line">            <span class="keyword">return</span> up;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">av_freep</span>(&amp;protocols);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">av_strstart</span>(filename, <span class="string">&quot;https:&quot;</span>, <span class="literal">NULL</span>) || <span class="built_in">av_strstart</span>(filename, <span class="string">&quot;tls:&quot;</span>, <span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;https protocol not found, recompile FFmpeg with &quot;</span></span><br><span class="line">                                     <span class="string">&quot;openssl, gnutls or securetransport enabled.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="url-alloc-for-protocol"><a href="#url-alloc-for-protocol" class="headerlink" title="url_alloc_for_protocol"></a>url_alloc_for_protocol</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">url_alloc_for_protocol</span><span class="params">(URLContext **puc, <span class="type">const</span> URLProtocol *up,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> AVIOInterruptCB *int_cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    URLContext *uc;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_NETWORK</span></span><br><span class="line">    <span class="keyword">if</span> (up-&gt;flags &amp; URL_PROTOCOL_FLAG_NETWORK &amp;&amp; !<span class="built_in">ff_network_init</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EIO);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; AVIO_FLAG_READ) &amp;&amp; !up-&gt;url_read) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;Impossible to open the &#x27;%s&#x27; protocol for reading\n&quot;</span>, up-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EIO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; AVIO_FLAG_WRITE) &amp;&amp; !up-&gt;url_write) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;Impossible to open the &#x27;%s&#x27; protocol for writing\n&quot;</span>, up-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EIO);</span><br><span class="line">    &#125;</span><br><span class="line">    uc = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(URLContext) + <span class="built_in">strlen</span>(filename) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!uc) &#123;</span><br><span class="line">        err = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    uc-&gt;av_class = &amp;ffurl_context_class;</span><br><span class="line">    uc-&gt;filename = (<span class="type">char</span> *)&amp;uc[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(uc-&gt;filename, filename);</span><br><span class="line">    uc-&gt;prot            = up;</span><br><span class="line">    uc-&gt;flags           = flags;</span><br><span class="line">    uc-&gt;is_streamed     = <span class="number">0</span>; <span class="comment">/* default = not streamed */</span></span><br><span class="line">    uc-&gt;max_packet_size = <span class="number">0</span>; <span class="comment">/* default: stream file */</span></span><br><span class="line">    <span class="keyword">if</span> (up-&gt;priv_data_size) &#123;</span><br><span class="line">        uc-&gt;priv_data = <span class="built_in">av_mallocz</span>(up-&gt;priv_data_size);</span><br><span class="line">        <span class="keyword">if</span> (!uc-&gt;priv_data) &#123;</span><br><span class="line">            err = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (up-&gt;priv_data_class) &#123;</span><br><span class="line">            <span class="type">char</span> *start;</span><br><span class="line">            *(<span class="type">const</span> AVClass **)uc-&gt;priv_data = up-&gt;priv_data_class;</span><br><span class="line">            <span class="built_in">av_opt_set_defaults</span>(uc-&gt;priv_data);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">av_strstart</span>(uc-&gt;filename, up-&gt;name, (<span class="type">const</span> <span class="type">char</span>**)&amp;start) &amp;&amp; *start == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> ret= <span class="number">0</span>;</span><br><span class="line">                <span class="type">char</span> *p= start;</span><br><span class="line">                <span class="type">char</span> sep= *++p;</span><br><span class="line">                <span class="type">char</span> *key, *val;</span><br><span class="line">                p++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(up-&gt;name, <span class="string">&quot;subfile&quot;</span>))</span><br><span class="line">                    ret = <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(ret &gt;= <span class="number">0</span> &amp;&amp; (key= <span class="built_in">strchr</span>(p, sep)) &amp;&amp; p&lt;key &amp;&amp; (val = <span class="built_in">strchr</span>(key+<span class="number">1</span>, sep)))&#123;</span><br><span class="line">                    *val= *key= <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(p, <span class="string">&quot;start&quot;</span>) &amp;&amp; <span class="built_in">strcmp</span>(p, <span class="string">&quot;end&quot;</span>)) &#123;</span><br><span class="line">                        ret = AVERROR_OPTION_NOT_FOUND;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        ret= <span class="built_in">av_opt_set</span>(uc-&gt;priv_data, p, key+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ret == AVERROR_OPTION_NOT_FOUND)</span><br><span class="line">                        <span class="built_in">av_log</span>(uc, AV_LOG_ERROR, <span class="string">&quot;Key &#x27;%s&#x27; not found.\n&quot;</span>, p);</span><br><span class="line">                    *val= *key= sep;</span><br><span class="line">                    p= val+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ret&lt;<span class="number">0</span> || p!=key)&#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(uc, AV_LOG_ERROR, <span class="string">&quot;Error parsing options string %s\n&quot;</span>, start);</span><br><span class="line">                    <span class="built_in">av_freep</span>(&amp;uc-&gt;priv_data);</span><br><span class="line">                    <span class="built_in">av_freep</span>(&amp;uc);</span><br><span class="line">                    err = <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">                    <span class="keyword">goto</span> fail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memmove</span>(start, key+<span class="number">1</span>, <span class="built_in">strlen</span>(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (int_cb)</span><br><span class="line">        uc-&gt;interrupt_callback = *int_cb;</span><br><span class="line"></span><br><span class="line">    *puc = uc;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    *puc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (uc)</span><br><span class="line">        <span class="built_in">av_freep</span>(&amp;uc-&gt;priv_data);</span><br><span class="line">    <span class="built_in">av_freep</span>(&amp;uc);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_NETWORK</span></span><br><span class="line">    <span class="keyword">if</span> (up-&gt;flags &amp; URL_PROTOCOL_FLAG_NETWORK)</span><br><span class="line">        <span class="built_in">ff_network_close</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ffurl-connect"><a href="#ffurl-connect" class="headerlink" title="ffurl_connect"></a>ffurl_connect</h4><p>这一步会调用 URLProtocol 上的 url_open2 或者 url_open 函数进行连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ffurl_connect</span><span class="params">(URLContext *uc, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    AVDictionary *tmp_opts = <span class="literal">NULL</span>;</span><br><span class="line">    AVDictionaryEntry *e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!options)</span><br><span class="line">        options = &amp;tmp_opts;</span><br><span class="line">...</span><br><span class="line">    err =</span><br><span class="line">        uc-&gt;prot-&gt;url_open2 ? uc-&gt;prot-&gt;<span class="built_in">url_open2</span>(uc,</span><br><span class="line">                                                  uc-&gt;filename,</span><br><span class="line">                                                  uc-&gt;flags,</span><br><span class="line">                                                  options) :</span><br><span class="line">        uc-&gt;prot-&gt;<span class="built_in">url_open</span>(uc, uc-&gt;filename, uc-&gt;flags);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_dict_set</span>(options, <span class="string">&quot;protocol_whitelist&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">av_dict_set</span>(options, <span class="string">&quot;protocol_blacklist&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    uc-&gt;is_connected = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* We must be careful here as ffurl_seek() could be slow,</span></span><br><span class="line"><span class="comment">     * for example for http */</span></span><br><span class="line">    <span class="keyword">if</span> ((uc-&gt;flags &amp; AVIO_FLAG_WRITE) || !<span class="built_in">strcmp</span>(uc-&gt;prot-&gt;name, <span class="string">&quot;file&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> (!uc-&gt;is_streamed &amp;&amp; <span class="built_in">ffurl_seek</span>(uc, <span class="number">0</span>, SEEK_SET) &lt; <span class="number">0</span>)</span><br><span class="line">            uc-&gt;is_streamed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如 file 协议的 open 就是调用系统的 open 来打开文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ff_file_open</span><span class="params">(URLContext *h, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileContext *c = h-&gt;priv_data;</span><br><span class="line">    <span class="type">int</span> access;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_strstart</span>(filename, <span class="string">&quot;file:&quot;</span>, &amp;filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AVIO_FLAG_WRITE &amp;&amp; flags &amp; AVIO_FLAG_READ) &#123;</span><br><span class="line">        access = O_CREAT | O_RDWR;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;trunc)</span><br><span class="line">            access |= O_TRUNC;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; AVIO_FLAG_WRITE) &#123;</span><br><span class="line">        access = O_CREAT | O_WRONLY;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;trunc)</span><br><span class="line">            access |= O_TRUNC;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        access = O_RDONLY;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> O_BINARY</span></span><br><span class="line">    access |= O_BINARY;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    fd = <span class="built_in">avpriv_open</span>(filename, access, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(errno);</span><br><span class="line">    c-&gt;fd = fd;</span><br><span class="line"></span><br><span class="line">    h-&gt;is_streamed = !<span class="built_in">fstat</span>(fd, &amp;st) &amp;&amp; <span class="built_in">S_ISFIFO</span>(st.st_mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Buffer writes more than the default 32k to improve throughput especially</span></span><br><span class="line"><span class="comment">     * with networked file systems */</span></span><br><span class="line">    <span class="keyword">if</span> (!h-&gt;is_streamed &amp;&amp; flags &amp; AVIO_FLAG_WRITE)</span><br><span class="line">        h-&gt;min_packet_size = h-&gt;max_packet_size = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;seekable &gt;= <span class="number">0</span>)</span><br><span class="line">        h-&gt;is_streamed = !c-&gt;seekable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ffio-fdopen"><a href="#ffio-fdopen" class="headerlink" title="ffio_fdopen"></a>ffio_fdopen</h3><p>在创建 URLContext 后是创建 AVIOContext。URLContext 是不带缓存的，而 AVIOContext 是带缓存的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ffio_fdopen</span><span class="params">(AVIOContext **s, URLContext *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *buffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> buffer_size, max_packet_size;</span><br><span class="line"></span><br><span class="line">    max_packet_size = h-&gt;max_packet_size;</span><br><span class="line">    <span class="keyword">if</span> (max_packet_size) &#123;</span><br><span class="line">        buffer_size = max_packet_size; <span class="comment">/* no need to bufferize more than one packet */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer_size = IO_BUFFER_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(h-&gt;flags &amp; AVIO_FLAG_WRITE) &amp;&amp; h-&gt;is_streamed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer_size &gt; INT_MAX/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        buffer_size *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = <span class="built_in">av_malloc</span>(buffer_size);</span><br><span class="line">    <span class="keyword">if</span> (!buffer)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line"></span><br><span class="line">    *s = <span class="built_in">avio_alloc_context</span>(buffer, buffer_size, h-&gt;flags &amp; AVIO_FLAG_WRITE, h,</span><br><span class="line">                            (<span class="built_in">int</span> (*)(<span class="type">void</span> *, <span class="type">uint8_t</span> *, <span class="type">int</span>))  ffurl_read,</span><br><span class="line">                            (<span class="built_in">int</span> (*)(<span class="type">void</span> *, <span class="type">uint8_t</span> *, <span class="type">int</span>))  ffurl_write,</span><br><span class="line">                            (<span class="built_in">int64_t</span> (*)(<span class="type">void</span> *, <span class="type">int64_t</span>, <span class="type">int</span>))ffurl_seek);</span><br><span class="line">...</span><br><span class="line">    (*s)-&gt;direct = h-&gt;flags &amp; AVIO_FLAG_DIRECT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// h-&gt;is_streamed为0表示可以seek，为1表示不可以seek</span></span><br><span class="line">    (*s)-&gt;seekable = h-&gt;is_streamed ? <span class="number">0</span> : AVIO_SEEKABLE_NORMAL;</span><br><span class="line">    (*s)-&gt;max_packet_size = max_packet_size;</span><br><span class="line">    (*s)-&gt;min_packet_size = h-&gt;min_packet_size;</span><br><span class="line">    <span class="keyword">if</span>(h-&gt;prot) &#123;</span><br><span class="line">        (*s)-&gt;read_pause = (<span class="built_in">int</span> (*)(<span class="type">void</span> *, <span class="type">int</span>))h-&gt;prot-&gt;url_read_pause;</span><br><span class="line">        (*s)-&gt;read_seek  =</span><br><span class="line">            (<span class="built_in">int64_t</span> (*)(<span class="type">void</span> *, <span class="type">int</span>, <span class="type">int64_t</span>, <span class="type">int</span>))h-&gt;prot-&gt;url_read_seek;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h-&gt;prot-&gt;url_read_seek)</span><br><span class="line">            (*s)-&gt;seekable |= AVIO_SEEKABLE_TIME;</span><br><span class="line">    &#125;</span><br><span class="line">    ((FFIOContext*)(*s))-&gt;short_seek_get = (<span class="built_in">int</span> (*)(<span class="type">void</span> *))ffurl_get_short_seek;</span><br><span class="line">    (*s)-&gt;av_class = &amp;ff_avio_class;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="avio-alloc-context"><a href="#avio-alloc-context" class="headerlink" title="avio_alloc_context"></a>avio_alloc_context</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVIOContext *<span class="title">avio_alloc_context</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">unsigned</span> <span class="type">char</span> *buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> buffer_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> write_flag,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">void</span> *opaque,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> (*read_packet)(<span class="type">void</span> *opaque, <span class="type">uint8_t</span> *buf, <span class="type">int</span> buf_size),</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> (*write_packet)(<span class="type">void</span> *opaque, <span class="type">uint8_t</span> *buf, <span class="type">int</span> buf_size),</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int64_t</span> (*seek)(<span class="type">void</span> *opaque, <span class="type">int64_t</span> offset, <span class="type">int</span> whence))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFIOContext *s = <span class="built_in">av_malloc</span>(<span class="built_in">sizeof</span>(*s));</span><br><span class="line">    <span class="keyword">if</span> (!s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">ffio_init_context</span>(s, buffer, buffer_size, write_flag, opaque,</span><br><span class="line">                  read_packet, write_packet, seek);</span><br><span class="line">    <span class="keyword">return</span> &amp;s-&gt;pub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ffio-init-context"><a href="#ffio-init-context" class="headerlink" title="ffio_init_context"></a>ffio_init_context</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ffio_init_context</span><span class="params">(FFIOContext *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">unsigned</span> <span class="type">char</span> *buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> buffer_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> write_flag,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">void</span> *opaque,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> (*read_packet)(<span class="type">void</span> *opaque, <span class="type">uint8_t</span> *buf, <span class="type">int</span> buf_size),</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int</span> (*write_packet)(<span class="type">void</span> *opaque, <span class="type">uint8_t</span> *buf, <span class="type">int</span> buf_size),</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">int64_t</span> (*seek)(<span class="type">void</span> *opaque, <span class="type">int64_t</span> offset, <span class="type">int</span> whence))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVIOContext *<span class="type">const</span> s = &amp;ctx-&gt;pub;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ctx, <span class="number">0</span>, <span class="built_in">sizeof</span>(*ctx));</span><br><span class="line"></span><br><span class="line">    s-&gt;buffer      = buffer;</span><br><span class="line">    &lt;u&gt;ctx-&gt;orig_buffer_size&lt;/u&gt; =</span><br><span class="line">    s-&gt;buffer_size = buffer_size;</span><br><span class="line">    s-&gt;&lt;u&gt;buf_ptr&lt;/u&gt;     = buffer;</span><br><span class="line">    s-&gt;buf_ptr_max = buffer;</span><br><span class="line">    s-&gt;opaque      = opaque;</span><br><span class="line">    s-&gt;direct      = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">url_resetbuf</span>(s, write_flag ? AVIO_FLAG_WRITE : AVIO_FLAG_READ);</span><br><span class="line"></span><br><span class="line">    &lt;u&gt;s-&gt;write_packet    = write_packet;&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;s-&gt;read_packet     = read_packet;&lt;/u&gt;</span><br><span class="line">    s-&gt;seek            = seek;</span><br><span class="line">    s-&gt;pos             = <span class="number">0</span>;</span><br><span class="line">    s-&gt;eof_reached     = <span class="number">0</span>;</span><br><span class="line">    s-&gt;error           = <span class="number">0</span>;</span><br><span class="line">    s-&gt;seekable        = seek ? AVIO_SEEKABLE_NORMAL : <span class="number">0</span>;</span><br><span class="line">    s-&gt;min_packet_size = <span class="number">0</span>;</span><br><span class="line">    s-&gt;max_packet_size = <span class="number">0</span>;</span><br><span class="line">    s-&gt;update_checksum = <span class="literal">NULL</span>;</span><br><span class="line">    ctx-&gt;short_seek_threshold = SHORT_SEEK_THRESHOLD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!read_packet &amp;&amp; !write_flag) &#123;</span><br><span class="line">        s-&gt;pos     = buffer_size;</span><br><span class="line">        s-&gt;buf_end = s-&gt;buffer + buffer_size;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;read_pause = <span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;read_seek  = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    s-&gt;write_data_type       = <span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;ignore_boundary_point = <span class="number">0</span>;</span><br><span class="line">    ctx-&gt;current_type        = AVIO_DATA_MARKER_UNKNOWN;</span><br><span class="line">    ctx-&gt;last_time           = AV_NOPTS_VALUE;</span><br><span class="line">    ctx-&gt;short_seek_get      = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_AVIOCONTEXT_WRITTEN</span></span><br><span class="line">FF_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line">    s-&gt;written               = <span class="number">0</span>;</span><br><span class="line">FF_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="avio-read"><a href="#avio-read" class="headerlink" title="avio_read"></a>avio_read</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avio_read</span><span class="params">(AVIOContext *s, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len, size1;</span><br><span class="line"></span><br><span class="line">    size1 = size;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        len = <span class="built_in">FFMIN</span>(&lt;u&gt;s-&gt;buf_end - s-&gt;buf_ptr&lt;/u&gt;, size);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || s-&gt;write_flag) &#123;</span><br><span class="line">            <span class="keyword">if</span>((s-&gt;direct || size &gt; s-&gt;buffer_size) &amp;&amp; !s-&gt;update_checksum &amp;&amp; s-&gt;read_packet) &#123;</span><br><span class="line">                <span class="comment">// bypass the buffer and read data directly into buf</span></span><br><span class="line">                len = &lt;u&gt;<span class="built_in">read_packet_wrapper</span>&lt;/u&gt;(s, buf, size);</span><br><span class="line">                <span class="keyword">if</span> (len == AVERROR_EOF) &#123;</span><br><span class="line">                    <span class="comment">/* do not modify buffer if EOF reached so that a seek back can</span></span><br><span class="line"><span class="comment">                    be done without rereading data */</span></span><br><span class="line">                    s-&gt;eof_reached = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    s-&gt;eof_reached = <span class="number">1</span>;</span><br><span class="line">                    s-&gt;error= len;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s-&gt;pos += len;</span><br><span class="line">                    <span class="built_in">ffiocontext</span>(s)-&gt;bytes_read += len;</span><br><span class="line">                    s-&gt;bytes_read = <span class="built_in">ffiocontext</span>(s)-&gt;bytes_read;</span><br><span class="line">                    size -= len;</span><br><span class="line">                    buf += len;</span><br><span class="line">                    <span class="comment">// reset the buffer</span></span><br><span class="line">                    s-&gt;buf_ptr = s-&gt;buffer;</span><br><span class="line">                    s-&gt;buf_end = s-&gt;buffer<span class="comment">/* + len*/</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fill_buffer</span>(s);</span><br><span class="line">                len = s-&gt;buf_end - s-&gt;buf_ptr;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(buf, s-&gt;buf_ptr, len);</span><br><span class="line">            buf += len;</span><br><span class="line">            s-&gt;buf_ptr += len;</span><br><span class="line">            size -= len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size1 == size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;error)      <span class="keyword">return</span> s-&gt;error;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">avio_feof</span>(s))  <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size1 - size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fill-buffer"><a href="#fill-buffer" class="headerlink" title="fill_buffer"></a>fill_buffer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fill_buffer</span><span class="params">(AVIOContext *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFIOContext *<span class="type">const</span> ctx = (FFIOContext *)s;</span><br><span class="line">    <span class="type">int</span> max_buffer_size = s-&gt;max_packet_size ?</span><br><span class="line">                          s-&gt;max_packet_size : IO_BUFFER_SIZE;</span><br><span class="line">    <span class="type">uint8_t</span> *dst        = s-&gt;buf_end - s-&gt;buffer + max_buffer_size &lt;= s-&gt;buffer_size ?</span><br><span class="line">                          s-&gt;buf_end : s-&gt;buffer;</span><br><span class="line">    <span class="type">int</span> len             = s-&gt;buffer_size - (dst - s-&gt;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* can&#x27;t fill the buffer without read_packet, just set EOF if appropriate */</span></span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;read_packet &amp;&amp; s-&gt;buf_ptr &gt;= s-&gt;buf_end)</span><br><span class="line">        s-&gt;eof_reached = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* no need to do anything if EOF already reached */</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;eof_reached)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;update_checksum &amp;&amp; dst == s-&gt;buffer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;buf_end &gt; s-&gt;checksum_ptr)</span><br><span class="line">            s-&gt;checksum = s-&gt;<span class="built_in">update_checksum</span>(s-&gt;checksum, s-&gt;checksum_ptr,</span><br><span class="line">                                             s-&gt;buf_end - s-&gt;checksum_ptr);</span><br><span class="line">        s-&gt;checksum_ptr = s-&gt;buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make buffer smaller in case it ended up large after probing */</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;read_packet &amp;&amp; ctx-&gt;orig_buffer_size &amp;&amp;</span><br><span class="line">        s-&gt;buffer_size &gt; ctx-&gt;orig_buffer_size  &amp;&amp; len &gt;= ctx-&gt;orig_buffer_size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dst == s-&gt;buffer &amp;&amp; s-&gt;buf_ptr != dst) &#123;</span><br><span class="line">            <span class="type">int</span> ret = <span class="built_in">set_buf_size</span>(s, ctx-&gt;orig_buffer_size);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_WARNING, <span class="string">&quot;Failed to decrease buffer size\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            s-&gt;checksum_ptr = dst = s-&gt;buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        len = ctx-&gt;orig_buffer_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">read_packet_wrapper</span>(s, dst, len);</span><br><span class="line">    <span class="keyword">if</span> (len == AVERROR_EOF) &#123;</span><br><span class="line">        <span class="comment">/* do not modify buffer if EOF reached so that a seek back can</span></span><br><span class="line"><span class="comment">           be done without rereading data */</span></span><br><span class="line">        s-&gt;eof_reached = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        s-&gt;eof_reached = <span class="number">1</span>;</span><br><span class="line">        s-&gt;error= len;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s-&gt;pos += len;</span><br><span class="line">        s-&gt;buf_ptr = dst;</span><br><span class="line">        s-&gt;buf_end = dst + len;</span><br><span class="line">        <span class="built_in">ffiocontext</span>(s)-&gt;bytes_read += len;</span><br><span class="line">        s-&gt;bytes_read = <span class="built_in">ffiocontext</span>(s)-&gt;bytes_read;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-packet-wrapper"><a href="#read-packet-wrapper" class="headerlink" title="read_packet_wrapper"></a>read_packet_wrapper</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">read_packet_wrapper</span><span class="params">(AVIOContext *s, <span class="type">uint8_t</span> *buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;read_packet)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    ret = s-&gt;<span class="built_in">read_packet</span>(s-&gt;opaque, buf, size);</span><br><span class="line">    <span class="built_in">av_assert2</span>(ret || s-&gt;max_packet_size);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read_packet 就是上面 ffio_fdopen 中的 ffurl_read，<code>s-&gt;opaque</code> 就是 AVIOContext 关联的 URLContext</p><h4 id="ffurl-read"><a href="#ffurl-read" class="headerlink" title="ffurl_read"></a>ffurl_read</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ffurl_read</span><span class="params">(URLContext *h, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(h-&gt;flags &amp; AVIO_FLAG_READ))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EIO);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">retry_transfer_wrapper</span>(h, buf, size, <span class="number">1</span>, &lt;u&gt;h-&gt;prot-&gt;url_read&lt;/u&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="retry-transfer-wrapper"><a href="#retry-transfer-wrapper" class="headerlink" title="retry_transfer_wrapper"></a>retry_transfer_wrapper</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">retry_transfer_wrapper</span><span class="params">(URLContext *h, <span class="type">uint8_t</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int</span> size, <span class="type">int</span> size_min,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int</span> (*transfer_func)(URLContext *h,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                              <span class="type">uint8_t</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                              <span class="type">int</span> size))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret, len;</span><br><span class="line">    <span class="type">int</span> fast_retries = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int64_t</span> wait_since = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt; size_min) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&lt;u&gt;<span class="built_in">ff_check_interrupt</span>&lt;/u&gt;(&amp;h-&gt;interrupt_callback))</span><br><span class="line">            <span class="keyword">return</span> AVERROR_EXIT;</span><br><span class="line">        ret = <span class="built_in">transfer_func</span>(h, buf + len, size - len);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EINTR))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;flags &amp; AVIO_FLAG_NONBLOCK)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN)) &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (fast_retries) &#123;</span><br><span class="line">                fast_retries--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (h-&gt;rw_timeout) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!wait_since)</span><br><span class="line">                        wait_since = <span class="built_in">av_gettime_relative</span>();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">av_gettime_relative</span>() &gt; wait_since + h-&gt;rw_timeout)</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EIO);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">av_usleep</span>(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == AVERROR_EOF)</span><br><span class="line">            <span class="built_in">return</span> (len &gt; <span class="number">0</span>) ? len : AVERROR_EOF;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            fast_retries = <span class="built_in">FFMAX</span>(fast_retries, <span class="number">2</span>);</span><br><span class="line">            wait_since = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len += ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="avio-write"><a href="#avio-write" class="headerlink" title="avio_write"></a>avio_write</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">avio_write</span><span class="params">(AVIOContext *s, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;direct &amp;&amp; !s-&gt;update_checksum) &#123;</span><br><span class="line">        &lt;u&gt;<span class="built_in">avio_flush</span>&lt;/u&gt;(s);</span><br><span class="line">        <span class="built_in">writeout</span>(s, buf, size);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">FFMIN</span>(s-&gt;buf_end - s-&gt;buf_ptr, size);</span><br><span class="line">        <span class="built_in">memcpy</span>(s-&gt;buf_ptr, buf, len);</span><br><span class="line">        s-&gt;buf_ptr += len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (&lt;u&gt;s-&gt;buf_ptr &gt;= s-&gt;buf_end&lt;/u&gt;)</span><br><span class="line">            <span class="built_in">flush_buffer</span>(s);</span><br><span class="line"></span><br><span class="line">        buf += len;</span><br><span class="line">        size -= len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avio-flush"><a href="#avio-flush" class="headerlink" title="avio_flush"></a>avio_flush</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">avio_flush</span><span class="params">(AVIOContext *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">// flush的时候可能会多写一些内容，所以这里再seek回去</span></span><br><span class="line">    <span class="type">int</span> seekback = s-&gt;write_flag ? <span class="built_in">FFMIN</span>(<span class="number">0</span>, s-&gt;buf_ptr - s-&gt;buf_ptr_max) : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">flush_buffer</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (seekback)</span><br><span class="line">        <span class="built_in">avio_seek</span>(s, seekback, SEEK_CUR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flush-buffer"><a href="#flush-buffer" class="headerlink" title="flush_buffer"></a>flush_buffer</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">flush_buffer</span><span class="params">(AVIOContext *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;buf_ptr_max = <span class="built_in">FFMAX</span>(s-&gt;buf_ptr, s-&gt;buf_ptr_max);</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;write_flag &amp;&amp; s-&gt;buf_ptr_max &gt; s-&gt;buffer) &#123;</span><br><span class="line">        <span class="built_in">writeout</span>(s, s-&gt;buffer, s-&gt;buf_ptr_max - s-&gt;buffer);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;update_checksum) &#123;</span><br><span class="line">            s-&gt;checksum     = s-&gt;<span class="built_in">update_checksum</span>(s-&gt;checksum, s-&gt;checksum_ptr,</span><br><span class="line">                                                 s-&gt;buf_ptr_max - s-&gt;checksum_ptr);</span><br><span class="line">            s-&gt;checksum_ptr = s-&gt;buffer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;buf_ptr = s-&gt;buf_ptr_max = s-&gt;buffer;</span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;write_flag)</span><br><span class="line">        s-&gt;buf_end = s-&gt;buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="writeout"><a href="#writeout" class="headerlink" title="writeout"></a>writeout</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">writeout</span><span class="params">(AVIOContext *s, <span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFIOContext *<span class="type">const</span> ctx = <span class="built_in">ffiocontext</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;error) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;write_data_type)</span><br><span class="line">            ret = s-&gt;<span class="built_in">write_data_type</span>(s-&gt;opaque, (<span class="type">uint8_t</span> *)data,</span><br><span class="line">                                     len,</span><br><span class="line">                                     ctx-&gt;current_type,</span><br><span class="line">                                     ctx-&gt;last_time);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;write_packet)</span><br><span class="line">            ret = s-&gt;<span class="built_in">write_packet</span>(s-&gt;opaque, (<span class="type">uint8_t</span> *)data, len);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            s-&gt;error = ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx-&gt;bytes_written += len;</span><br><span class="line">            s-&gt;bytes_written = ctx-&gt;bytes_written;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s-&gt;pos + len &gt; ctx-&gt;written_output_size) &#123;</span><br><span class="line">                ctx-&gt;written_output_size = s-&gt;pos + len;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_AVIOCONTEXT_WRITTEN</span></span><br><span class="line">FF_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line">                s-&gt;written = ctx-&gt;written_output_size;</span><br><span class="line">FF_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;current_type == AVIO_DATA_MARKER_SYNC_POINT ||</span><br><span class="line">        ctx-&gt;current_type == AVIO_DATA_MARKER_BOUNDARY_POINT) &#123;</span><br><span class="line">        ctx-&gt;current_type = AVIO_DATA_MARKER_UNKNOWN;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx-&gt;last_time = AV_NOPTS_VALUE;</span><br><span class="line">    ctx-&gt;writeout_count++;</span><br><span class="line">    s-&gt;pos += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>write_packet 就是 ffurl_write</p><h5 id="ffurl-write"><a href="#ffurl-write" class="headerlink" title="ffurl_write"></a>ffurl_write</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ffurl_write</span><span class="params">(URLContext *h, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(h-&gt;flags &amp; AVIO_FLAG_WRITE))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EIO);</span><br><span class="line">    <span class="comment">/* avoid sending too big packets */</span></span><br><span class="line">    <span class="keyword">if</span> (h-&gt;max_packet_size &amp;&amp; size &gt; h-&gt;max_packet_size)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EIO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">retry_transfer_wrapper</span>(h, (<span class="type">unsigned</span> <span class="type">char</span> *)buf, size, size,</span><br><span class="line">                                  (<span class="built_in">int</span> (*)(<span class="keyword">struct</span> URLContext *, <span class="type">uint8_t</span> *, <span class="type">int</span>))</span><br><span class="line">                                  h-&gt;prot-&gt;url_write);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg 之 demuxer/decoder 相关 api (三)</title>
      <link href="/2023/05/10/ffmpeg-%E4%B9%8B-demuxer-decoder-%E7%9B%B8%E5%85%B3-api-%E4%B8%89/"/>
      <url>/2023/05/10/ffmpeg-%E4%B9%8B-demuxer-decoder-%E7%9B%B8%E5%85%B3-api-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>avformat_find_stream_info 函数最复杂，后面基本上就好理解了。</p><h2 id="av-find-best-stream"><a href="#av-find-best-stream" class="headerlink" title="av_find_best_stream"></a>av_find_best_stream</h2><ul><li>type 表示想要的是 audio 还是 video stream</li><li>wanted_stream_nb  想要的 stream 的序号</li><li>related_stream  设置此项表示返回的 stream 要和 related_stream 相关联，比如都处于同一个 AVProgram</li><li>decoder_ret 返回该 stream 的 AVCodec</li></ul><p>如果设置了 related_stream，优先在这个 stream 对应的 program 中查找，如果没找到，则在全体 stream 中查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_find_best_stream</span><span class="params">(AVFormatContext *ic, <span class="keyword">enum</span> AVMediaType type,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> wanted_stream_nb, <span class="type">int</span> related_stream,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> AVCodec **decoder_ret, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nb_streams = ic-&gt;nb_streams;</span><br><span class="line">    <span class="type">int</span> ret = AVERROR_STREAM_NOT_FOUND;</span><br><span class="line">    <span class="type">int</span> best_count = <span class="number">-1</span>, best_multiframe = <span class="number">-1</span>, best_disposition = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> count, multiframe, disposition;</span><br><span class="line">    <span class="type">int64_t</span> best_bitrate = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int64_t</span> bitrate;</span><br><span class="line">    <span class="type">unsigned</span> *program = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> AVCodec *decoder = <span class="literal">NULL</span>, *best_decoder = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (related_stream &gt;= <span class="number">0</span> &amp;&amp; wanted_stream_nb &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        AVProgram *p = <span class="built_in">av_find_program_from_stream</span>(ic, <span class="literal">NULL</span>, related_stream);</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            program    = p-&gt;stream_index;</span><br><span class="line">            nb_streams = p-&gt;nb_stream_indexes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; nb_streams; i++) &#123;</span><br><span class="line">        <span class="type">int</span> real_stream_index = program ? program[i] : i;</span><br><span class="line">        AVStream *st          = ic-&gt;streams[real_stream_index];</span><br><span class="line">        AVCodecParameters *par = st-&gt;codecpar;</span><br><span class="line">        <span class="keyword">if</span> (par-&gt;codec_type != type)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (wanted_stream_nb &gt;= <span class="number">0</span> &amp;&amp; real_stream_index != wanted_stream_nb)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == AVMEDIA_TYPE_AUDIO &amp;&amp; !(par-&gt;ch_layout.nb_channels &amp;&amp; par-&gt;sample_rate))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (decoder_ret) &#123;</span><br><span class="line">            decoder = <span class="built_in">ff_find_decoder</span>(ic, st, par-&gt;codec_id);</span><br><span class="line">            <span class="keyword">if</span> (!decoder) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                    ret = AVERROR_DECODER_NOT_FOUND;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        disposition = !(st-&gt;disposition &amp; (AV_DISPOSITION_HEARING_IMPAIRED | AV_DISPOSITION_VISUAL_IMPAIRED))</span><br><span class="line">                      + !! (st-&gt;disposition &amp; AV_DISPOSITION_DEFAULT);</span><br><span class="line">        count = <span class="built_in">ffstream</span>(st)-&gt;codec_info_nb_frames;</span><br><span class="line">        bitrate = par-&gt;bit_rate;</span><br><span class="line">        multiframe = <span class="built_in">FFMIN</span>(<span class="number">5</span>, count);</span><br><span class="line">        <span class="keyword">if</span> ((best_disposition &gt;  disposition) ||</span><br><span class="line">            (best_disposition == disposition &amp;&amp; best_multiframe &gt;  multiframe) ||</span><br><span class="line">            (best_disposition == disposition &amp;&amp; best_multiframe == multiframe &amp;&amp; best_bitrate &gt;  bitrate) ||</span><br><span class="line">            (best_disposition == disposition &amp;&amp; best_multiframe == multiframe &amp;&amp; best_bitrate == bitrate &amp;&amp; best_count &gt;= count))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        best_disposition = disposition;</span><br><span class="line">        best_count   = count;</span><br><span class="line">        best_bitrate = bitrate;</span><br><span class="line">        best_multiframe = multiframe;</span><br><span class="line">        ret          = real_stream_index;</span><br><span class="line">        best_decoder = decoder;</span><br><span class="line">        <span class="keyword">if</span> (program &amp;&amp; i == nb_streams - <span class="number">1</span> &amp;&amp; ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            program    = <span class="literal">NULL</span>;</span><br><span class="line">            nb_streams = ic-&gt;nb_streams;</span><br><span class="line">            <span class="comment">/* no related stream found, try again with everything */</span></span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (decoder_ret)</span><br><span class="line">        *decoder_ret = best_decoder;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avcodec-receive-frame"><a href="#avcodec-receive-frame" class="headerlink" title="avcodec_receive_frame"></a>avcodec_receive_frame</h2><p>优先返回 avci-&gt;buffer_frame，如果 avci-&gt;buffer_frame 为空，调用 decode_receive_frame_internal 进行解码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> attribute_align_arg <span class="title">avcodec_receive_frame</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecInternal *avci = avctx-&gt;internal;</span><br><span class="line">    <span class="type">int</span> ret, changed;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">avcodec_is_open</span>(avctx) || !<span class="built_in">av_codec_is_decoder</span>(avctx-&gt;codec))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avci-&gt;buffer_frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">av_frame_move_ref</span>(frame, avci-&gt;buffer_frame);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="built_in">decode_receive_frame_internal</span>(avctx, frame);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">        &lt;u&gt;ret = <span class="built_in">apply_cropping</span>(avctx, frame);&lt;/u&gt;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avctx-&gt;frame_number++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;flags &amp; AV_CODEC_FLAG_DROPCHANGED) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avcodec-send-packet"><a href="#avcodec-send-packet" class="headerlink" title="avcodec_send_packet"></a>avcodec_send_packet</h2><p>和 avcodec_send_frame 一样，avcodec_send_packet 也是先将输入的 avpkt 引用到 <code>avci-&gt;buffer_pkt</code>，然后再把 buffer_pkt 送到 <code>avci-&gt;bsf</code>，最后如果 buffer_frame 为空，尝试解码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> attribute_align_arg <span class="title">avcodec_send_packet</span><span class="params">(AVCodecContext *avctx, <span class="type">const</span> AVPacket *avpkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecInternal *avci = avctx-&gt;internal;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">avcodec_is_open</span>(avctx) || !<span class="built_in">av_codec_is_decoder</span>(avctx-&gt;codec))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;internal-&gt;draining)</span><br><span class="line">        <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avpkt &amp;&amp; !avpkt-&gt;size &amp;&amp; avpkt-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_packet_unref</span>(avci-&gt;buffer_pkt);</span><br><span class="line">    <span class="keyword">if</span> (avpkt &amp;&amp; (avpkt-&gt;data || avpkt-&gt;side_data_elems)) &#123;</span><br><span class="line">        ret = <span class="built_in">av_packet_ref</span>(avci-&gt;buffer_pkt, avpkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_bsf_send_packet</span>(avci-&gt;bsf, avci-&gt;buffer_pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_packet_unref</span>(avci-&gt;buffer_pkt);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!avci-&gt;buffer_frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        ret = <span class="built_in">decode_receive_frame_internal</span>(avctx, avci-&gt;buffer_frame);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != <span class="built_in">AVERROR</span>(EAGAIN) &amp;&amp; ret != AVERROR_EOF)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="av-bsf-send-packet"><a href="#av-bsf-send-packet" class="headerlink" title="av_bsf_send_packet"></a>av_bsf_send_packet</h3><p>这一步是将 buffer_pkt 送到 bitstream filter 中，经过 bitstream filter 后再解码。</p><p>这里没有调用 bitstream filter 对 packet 进行处理，真正处理是在下面 decode_receive_frame_internal 时从 bitstream filter 取数据时会进行 bitstream 滤波处理。</p><p>这一步其实是把 <code>avci-&gt;buffer_pkt</code> 转移到 <code>bsfi-&gt;buffer_pkt</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_bsf_send_packet</span><span class="params">(AVBSFContext *ctx, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFBSFContext *<span class="type">const</span> bsfi = <span class="built_in">ffbsfcontext</span>(ctx);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pkt || <span class="built_in">IS_EMPTY</span>(pkt)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt)</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">        &lt;u&gt;bsfi-&gt;eof = <span class="number">1</span>;&lt;/u&gt;</span><br><span class="line">        &lt;u&gt;<span class="keyword">return</span> <span class="number">0</span>;&lt;/u&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bsfi-&gt;eof) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(ctx, AV_LOG_ERROR, <span class="string">&quot;A non-NULL packet sent after an EOF.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IS_EMPTY</span>(bsfi-&gt;buffer_pkt))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EAGAIN);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_packet_make_refcounted</span>(pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="built_in">av_packet_move_ref</span>(bsfi-&gt;buffer_pkt, pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="decode-receive-frame-internal"><a href="#decode-receive-frame-internal" class="headerlink" title="decode_receive_frame_internal"></a>decode_receive_frame_internal</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">decode_receive_frame_internal</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecInternal *avci = avctx-&gt;internal;</span><br><span class="line">    <span class="type">const</span> FFCodec *<span class="type">const</span> codec = <span class="built_in">ffcodec</span>(avctx-&gt;codec);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert0</span>(!frame-&gt;buf[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (codec-&gt;cb_type == FF_CODEC_CB_TYPE_RECEIVE_FRAME) &#123;</span><br><span class="line">        ret = codec-&gt;cb.<span class="built_in">receive_frame</span>(avctx, frame);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(avci-&gt;last_pkt_props);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        ret = <span class="built_in">decode_simple_receive_frame</span>(avctx, frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == AVERROR_EOF)</span><br><span class="line">        avci-&gt;draining_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(codec-&gt;caps_internal &amp; FF_CODEC_CAP_SETS_FRAME_PROPS) &amp;&amp;</span><br><span class="line">        <span class="built_in">IS_EMPTY</span>(avci-&gt;last_pkt_props)) &#123;</span><br><span class="line">        <span class="comment">// May fail if the FIFO is empty.</span></span><br><span class="line">        <span class="built_in">av_fifo_read</span>(avci-&gt;pkt_props, avci-&gt;last_pkt_props, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        frame-&gt;best_effort_timestamp = <span class="built_in">guess_correct_pts</span>(avctx,</span><br><span class="line">                                                         frame-&gt;pts,</span><br><span class="line">                                                         frame-&gt;pkt_dts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* the only case where decode data is not set should be decoders</span></span><br><span class="line"><span class="comment">         * that do not call ff_get_buffer() */</span></span><br><span class="line">        <span class="built_in">av_assert0</span>((frame-&gt;private_ref &amp;&amp; frame-&gt;private_ref-&gt;size == <span class="built_in">sizeof</span>(FrameDecodeData)) ||</span><br><span class="line">                   !(avctx-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_DR1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;private_ref) &#123;</span><br><span class="line">            FrameDecodeData *fdd = (FrameDecodeData*)frame-&gt;private_ref-&gt;data;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fdd-&gt;post_process) &#123;</span><br><span class="line">                ret = fdd-&gt;<span class="built_in">post_process</span>(avctx, frame);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">                    <span class="keyword">return</span> ret;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free the per-frame decode data */</span></span><br><span class="line">    <span class="built_in">av_buffer_unref</span>(&amp;frame-&gt;private_ref);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="decode-simple-receive-frame"><a href="#decode-simple-receive-frame" class="headerlink" title="decode_simple_receive_frame"></a>decode_simple_receive_frame</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">decode_simple_receive_frame</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int64_t</span> discarded_samples = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (discarded_samples &gt; avctx-&gt;max_samples)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EAGAIN);</span><br><span class="line">        ret = <span class="built_in">decode_simple_internal</span>(avctx, frame, &amp;discarded_samples);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="decode-simple-internal"><a href="#decode-simple-internal" class="headerlink" title="decode_simple_internal"></a>decode_simple_internal</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">decode_simple_internal</span><span class="params">(AVCodecContext *avctx, AVFrame *frame, <span class="type">int64_t</span> *discarded_samples)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecInternal   *avci = avctx-&gt;internal;</span><br><span class="line">    AVPacket     *<span class="type">const</span> pkt = avci-&gt;in_pkt;</span><br><span class="line">    <span class="type">const</span> FFCodec *<span class="type">const</span> codec = <span class="built_in">ffcodec</span>(avctx-&gt;codec);</span><br><span class="line">    <span class="type">int</span> got_frame, actual_got_frame;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pkt-&gt;data &amp;&amp; !avci-&gt;draining) &#123;</span><br><span class="line">        <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">        ret = <span class="built_in">ff_decode_get_packet</span>(avctx, pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != AVERROR_EOF)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some codecs (at least wma lossless) will crash when feeding drain packets</span></span><br><span class="line">    <span class="comment">// after EOF was signaled.</span></span><br><span class="line">    <span class="keyword">if</span> (avci-&gt;draining_done)</span><br><span class="line">        <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pkt-&gt;data &amp;&amp;</span><br><span class="line">        !(avctx-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_DELAY ||</span><br><span class="line">          avctx-&gt;active_thread_type &amp; FF_THREAD_FRAME))</span><br><span class="line">        <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line"></span><br><span class="line">    got_frame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAVE_THREADS &amp;&amp; avctx-&gt;active_thread_type &amp; FF_THREAD_FRAME) &#123;</span><br><span class="line">        ret = <span class="built_in">ff_thread_decode_frame</span>(avctx, frame, &amp;got_frame, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = codec-&gt;cb.<span class="built_in">decode</span>(avctx, frame, &amp;got_frame, pkt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(codec-&gt;caps_internal &amp; FF_CODEC_CAP_SETS_PKT_DTS))</span><br><span class="line">            frame-&gt;pkt_dts = pkt-&gt;dts;</span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec-&gt;type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!avctx-&gt;has_b_frames)</span><br><span class="line">                frame-&gt;pkt_pos = pkt-&gt;pos;</span><br><span class="line">            <span class="comment">//FIXME these should be under if(!avctx-&gt;has_b_frames)</span></span><br><span class="line">            <span class="comment">/* get_buffer is supposed to set frame parameters */</span></span><br><span class="line">            <span class="keyword">if</span> (!(avctx-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_DR1)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!frame-&gt;sample_aspect_ratio.num)  frame-&gt;sample_aspect_ratio = avctx-&gt;sample_aspect_ratio;</span><br><span class="line">                <span class="keyword">if</span> (!frame-&gt;width)                    frame-&gt;width               = avctx-&gt;width;</span><br><span class="line">                <span class="keyword">if</span> (!frame-&gt;height)                   frame-&gt;height              = avctx-&gt;height;</span><br><span class="line">                <span class="keyword">if</span> (frame-&gt;format == AV_PIX_FMT_NONE) frame-&gt;format              = avctx-&gt;pix_fmt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">emms_c</span>();</span><br><span class="line">    actual_got_frame = got_frame;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;codec-&gt;type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;flags &amp; AV_FRAME_FLAG_DISCARD)</span><br><span class="line">            got_frame = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (avctx-&gt;codec-&gt;type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> *side;</span><br><span class="line">        <span class="type">size_t</span> side_size;</span><br><span class="line">        <span class="type">uint32_t</span> discard_padding = <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint8_t</span> skip_reason = <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint8_t</span> discard_reason = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span> &amp;&amp; got_frame) &#123;</span><br><span class="line">            <span class="keyword">if</span> (frame-&gt;format == AV_SAMPLE_FMT_NONE)</span><br><span class="line">                frame-&gt;format = avctx-&gt;sample_fmt;</span><br><span class="line">            <span class="keyword">if</span> (!frame-&gt;ch_layout.nb_channels) &#123;</span><br><span class="line">                <span class="type">int</span> ret2 = <span class="built_in">av_channel_layout_copy</span>(&amp;frame-&gt;ch_layout, &amp;avctx-&gt;ch_layout);</span><br><span class="line">                <span class="keyword">if</span> (ret2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ret = ret2;</span><br><span class="line">                    got_frame = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!frame-&gt;sample_rate)</span><br><span class="line">                frame-&gt;sample_rate = avctx-&gt;sample_rate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        side= <span class="built_in">av_packet_get_side_data</span>(avci-&gt;last_pkt_props, AV_PKT_DATA_SKIP_SAMPLES, &amp;side_size);</span><br><span class="line">        <span class="keyword">if</span>(side &amp;&amp; side_size&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">            avci-&gt;skip_samples = <span class="built_in">AV_RL32</span>(side) * avci-&gt;skip_samples_multiplier;</span><br><span class="line">            avci-&gt;skip_samples = <span class="built_in">FFMAX</span>(<span class="number">0</span>, avci-&gt;skip_samples);</span><br><span class="line">            discard_padding = <span class="built_in">AV_RL32</span>(side + <span class="number">4</span>);</span><br><span class="line">            <span class="built_in">av_log</span>(avctx, AV_LOG_DEBUG, <span class="string">&quot;skip %d / discard %d samples due to side data\n&quot;</span>,</span><br><span class="line">                   avci-&gt;skip_samples, (<span class="type">int</span>)discard_padding);</span><br><span class="line">            skip_reason = <span class="built_in">AV_RL8</span>(side + <span class="number">8</span>);</span><br><span class="line">            discard_reason = <span class="built_in">AV_RL8</span>(side + <span class="number">9</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((frame-&gt;flags &amp; AV_FRAME_FLAG_DISCARD) &amp;&amp; got_frame &amp;&amp;</span><br><span class="line">            !(avctx-&gt;flags2 &amp; AV_CODEC_FLAG2_SKIP_MANUAL)) &#123;</span><br><span class="line">            avci-&gt;skip_samples = <span class="built_in">FFMAX</span>(<span class="number">0</span>, avci-&gt;skip_samples - frame-&gt;nb_samples);</span><br><span class="line">            got_frame = <span class="number">0</span>;</span><br><span class="line">            *discarded_samples += frame-&gt;nb_samples;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (avci-&gt;skip_samples &gt; <span class="number">0</span> &amp;&amp; got_frame &amp;&amp;</span><br><span class="line">            !(avctx-&gt;flags2 &amp; AV_CODEC_FLAG2_SKIP_MANUAL)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(frame-&gt;nb_samples &lt;= avci-&gt;skip_samples)&#123;</span><br><span class="line">                got_frame = <span class="number">0</span>;</span><br><span class="line">                *discarded_samples += frame-&gt;nb_samples;</span><br><span class="line">                avci-&gt;skip_samples -= frame-&gt;nb_samples;</span><br><span class="line">                <span class="built_in">av_log</span>(avctx, AV_LOG_DEBUG, <span class="string">&quot;skip whole frame, skip left: %d\n&quot;</span>,</span><br><span class="line">                       avci-&gt;skip_samples);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">av_samples_copy</span>(frame-&gt;extended_data, frame-&gt;extended_data, <span class="number">0</span>, avci-&gt;skip_samples,</span><br><span class="line">                                frame-&gt;nb_samples - avci-&gt;skip_samples, avctx-&gt;ch_layout.nb_channels, frame-&gt;format);</span><br><span class="line">                <span class="keyword">if</span>(avctx-&gt;pkt_timebase.num &amp;&amp; avctx-&gt;sample_rate) &#123;</span><br><span class="line">                    <span class="type">int64_t</span> diff_ts = <span class="built_in">av_rescale_q</span>(avci-&gt;skip_samples,</span><br><span class="line">                                                   (AVRational)&#123;<span class="number">1</span>, avctx-&gt;sample_rate&#125;,</span><br><span class="line">                                                   avctx-&gt;pkt_timebase);</span><br><span class="line">                    <span class="keyword">if</span>(frame-&gt;pts!=AV_NOPTS_VALUE)</span><br><span class="line">                        frame-&gt;pts += diff_ts;</span><br><span class="line">                    <span class="keyword">if</span>(frame-&gt;pkt_dts!=AV_NOPTS_VALUE)</span><br><span class="line">                        frame-&gt;pkt_dts += diff_ts;</span><br><span class="line">                    <span class="keyword">if</span> (frame-&gt;pkt_duration &gt;= diff_ts)</span><br><span class="line">                        frame-&gt;pkt_duration -= diff_ts;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(avctx, AV_LOG_WARNING, <span class="string">&quot;Could not update timestamps for skipped samples.\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">av_log</span>(avctx, AV_LOG_DEBUG, <span class="string">&quot;skip %d/%d samples\n&quot;</span>,</span><br><span class="line">                       avci-&gt;skip_samples, frame-&gt;nb_samples);</span><br><span class="line">                *discarded_samples += avci-&gt;skip_samples;</span><br><span class="line">                frame-&gt;nb_samples -= avci-&gt;skip_samples;</span><br><span class="line">                avci-&gt;skip_samples = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (discard_padding &gt; <span class="number">0</span> &amp;&amp; discard_padding &lt;= frame-&gt;nb_samples &amp;&amp; got_frame &amp;&amp;</span><br><span class="line">            !(avctx-&gt;flags2 &amp; AV_CODEC_FLAG2_SKIP_MANUAL)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (discard_padding == frame-&gt;nb_samples) &#123;</span><br><span class="line">                *discarded_samples += frame-&gt;nb_samples;</span><br><span class="line">                got_frame = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(avctx-&gt;pkt_timebase.num &amp;&amp; avctx-&gt;sample_rate) &#123;</span><br><span class="line">                    <span class="type">int64_t</span> diff_ts = <span class="built_in">av_rescale_q</span>(frame-&gt;nb_samples - discard_padding,</span><br><span class="line">                                                   (AVRational)&#123;<span class="number">1</span>, avctx-&gt;sample_rate&#125;,</span><br><span class="line">                                                   avctx-&gt;pkt_timebase);</span><br><span class="line">                    frame-&gt;pkt_duration = diff_ts;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(avctx, AV_LOG_WARNING, <span class="string">&quot;Could not update timestamps for discarded samples.\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">av_log</span>(avctx, AV_LOG_DEBUG, <span class="string">&quot;discard %d/%d samples\n&quot;</span>,</span><br><span class="line">                       (<span class="type">int</span>)discard_padding, frame-&gt;nb_samples);</span><br><span class="line">                frame-&gt;nb_samples -= discard_padding;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((avctx-&gt;flags2 &amp; AV_CODEC_FLAG2_SKIP_MANUAL) &amp;&amp; got_frame) &#123;</span><br><span class="line">            AVFrameSideData *fside = <span class="built_in">av_frame_new_side_data</span>(frame, AV_FRAME_DATA_SKIP_SAMPLES, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (fside) &#123;</span><br><span class="line">                <span class="built_in">AV_WL32</span>(fside-&gt;data, avci-&gt;skip_samples);</span><br><span class="line">                <span class="built_in">AV_WL32</span>(fside-&gt;data + <span class="number">4</span>, discard_padding);</span><br><span class="line">                <span class="built_in">AV_WL8</span>(fside-&gt;data + <span class="number">8</span>, skip_reason);</span><br><span class="line">                <span class="built_in">AV_WL8</span>(fside-&gt;data + <span class="number">9</span>, discard_reason);</span><br><span class="line">                avci-&gt;skip_samples = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;codec-&gt;type == AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">        !avci-&gt;showed_multi_packet_warning &amp;&amp;</span><br><span class="line">        ret &gt;= <span class="number">0</span> &amp;&amp; ret != pkt-&gt;size &amp;&amp; !(avctx-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_SUBFRAMES)) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(avctx, AV_LOG_WARNING, <span class="string">&quot;Multiple frames in a packet.\n&quot;</span>);</span><br><span class="line">        avci-&gt;showed_multi_packet_warning = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!got_frame)</span><br><span class="line">        <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_FLAG_TRUNCATED</span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span> &amp;&amp; avctx-&gt;codec-&gt;type == AVMEDIA_TYPE_VIDEO &amp;&amp; !(avctx-&gt;flags &amp; AV_CODEC_FLAG_TRUNCATED))</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span> &amp;&amp; avctx-&gt;codec-&gt;type == AVMEDIA_TYPE_VIDEO)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        ret = pkt-&gt;size;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_AVCTX_TIMEBASE</span></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;framerate.num &gt; <span class="number">0</span> &amp;&amp; avctx-&gt;framerate.den &gt; <span class="number">0</span>)</span><br><span class="line">        avctx-&gt;time_base = <span class="built_in">av_inv_q</span>(<span class="built_in">av_mul_q</span>(avctx-&gt;framerate, (AVRational)&#123;avctx-&gt;ticks_per_frame, <span class="number">1</span>&#125;));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do not stop draining when actual_got_frame != 0 or ret &lt; 0 */</span></span><br><span class="line">    <span class="comment">/* got_frame == 0 but actual_got_frame != 0 when frame is discarded */</span></span><br><span class="line">    <span class="keyword">if</span> (avci-&gt;draining &amp;&amp; !actual_got_frame) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* prevent infinite loop if a decoder wrongly always return error on draining */</span></span><br><span class="line">            <span class="comment">/* reasonable nb_errors_max = maximum b frames + thread count */</span></span><br><span class="line">            <span class="type">int</span> nb_errors_max = <span class="number">20</span> + (HAVE_THREADS &amp;&amp; avctx-&gt;active_thread_type &amp; FF_THREAD_FRAME ?</span><br><span class="line">                                avctx-&gt;thread_count : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (avci-&gt;nb_draining_errors++ &gt;= nb_errors_max) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(avctx, AV_LOG_ERROR, <span class="string">&quot;Too many errors when draining, this is a bug. &quot;</span></span><br><span class="line">                       <span class="string">&quot;Stop draining and force EOF.\n&quot;</span>);</span><br><span class="line">                avci-&gt;draining_done = <span class="number">1</span>;</span><br><span class="line">                ret = AVERROR_BUG;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            avci-&gt;draining_done = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= pkt-&gt;size || ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">        <span class="built_in">av_packet_unref</span>(avci-&gt;last_pkt_props);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> consumed = ret;</span><br><span class="line"></span><br><span class="line">        pkt-&gt;data                += consumed;</span><br><span class="line">        pkt-&gt;size                -= consumed;</span><br><span class="line">        pkt-&gt;pts                  = AV_NOPTS_VALUE;</span><br><span class="line">        pkt-&gt;dts                  = AV_NOPTS_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (!(codec-&gt;caps_internal &amp; FF_CODEC_CAP_SETS_FRAME_PROPS)) &#123;</span><br><span class="line">            avci-&gt;last_pkt_props-&gt;size -= consumed; <span class="comment">// See extract_packet_props() comment.</span></span><br><span class="line">            avci-&gt;last_pkt_props-&gt;pts = AV_NOPTS_VALUE;</span><br><span class="line">            avci-&gt;last_pkt_props-&gt;dts = AV_NOPTS_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (got_frame)</span><br><span class="line">        <span class="built_in">av_assert0</span>(frame-&gt;buf[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret &lt; <span class="number">0</span> ? ret : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="ff-decode-get-packet"><a href="#ff-decode-get-packet" class="headerlink" title="ff_decode_get_packet"></a>ff_decode_get_packet</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_bsf_receive_packet</span><span class="params">(AVBSFContext *ctx, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ff_bsf</span>(ctx-&gt;filter)-&gt;<span class="built_in">filter</span>(ctx, pkt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_decode_get_packet</span><span class="params">(AVCodecContext *avctx, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecInternal *avci = avctx-&gt;internal;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avci-&gt;draining)</span><br><span class="line">        <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_bsf_receive_packet</span>(avci-&gt;bsf, pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret == AVERROR_EOF)</span><br><span class="line">        avci-&gt;draining = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">ffcodec</span>(avctx-&gt;codec)-&gt;caps_internal &amp; FF_CODEC_CAP_SETS_FRAME_PROPS)) &#123;</span><br><span class="line">        ret = <span class="built_in">extract_packet_props</span>(avctx-&gt;internal, pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">apply_param_change</span>(avctx, pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">finish:</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="av-read-frame"><a href="#av-read-frame" class="headerlink" title="av_read_frame"></a>av_read_frame</h2><p>再看看这个函数。可以看到，优先从 packet_buffer 中取数据，这个就是之前 find_stream_info 时如果没有 AVFMT_FLAG_NOBUFFER 这个 flag，会把读取的数据存到 packet_buffer。当 packet_buffer 没有缓存时，也是调用 read_frame_internal 读取数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> genpts = s-&gt;flags &amp; AVFMT_FLAG_GENPTS;</span><br><span class="line">    <span class="type">int</span> eof = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    AVStream *st;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!genpts) &#123;</span><br><span class="line">        ret = si-&gt;packet_buffer.head</span><br><span class="line">              ? <span class="built_in">avpriv_packet_list_get</span>(&amp;si-&gt;packet_buffer, pkt)</span><br><span class="line">              : <span class="built_in">read_frame_internal</span>(s, pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">goto</span> return_packet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        PacketListEntry *pktl = si-&gt;packet_buffer.head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pktl) &#123;</span><br><span class="line">            AVPacket *next_pkt = &amp;pktl-&gt;pkt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next_pkt-&gt;dts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                <span class="type">int</span> wrap_bits = s-&gt;streams[next_pkt-&gt;stream_index]-&gt;pts_wrap_bits;</span><br><span class="line">                <span class="comment">// last dts seen for this stream. if any of packets following</span></span><br><span class="line">                <span class="comment">// current one had no dts, we will set this to AV_NOPTS_VALUE.</span></span><br><span class="line">                <span class="type">int64_t</span> last_dts = next_pkt-&gt;dts;</span><br><span class="line">                <span class="built_in">av_assert2</span>(wrap_bits &lt;= <span class="number">64</span>);</span><br><span class="line">                <span class="keyword">while</span> (pktl &amp;&amp; next_pkt-&gt;pts == AV_NOPTS_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pktl-&gt;pkt.stream_index == next_pkt-&gt;stream_index &amp;&amp;</span><br><span class="line">                        <span class="built_in">av_compare_mod</span>(next_pkt-&gt;dts, pktl-&gt;pkt.dts, <span class="number">2ULL</span> &lt;&lt; (wrap_bits - <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">av_compare_mod</span>(pktl-&gt;pkt.pts, pktl-&gt;pkt.dts, <span class="number">2ULL</span> &lt;&lt; (wrap_bits - <span class="number">1</span>))) &#123;</span><br><span class="line">                            <span class="comment">// not B-frame</span></span><br><span class="line">                            next_pkt-&gt;pts = pktl-&gt;pkt.dts;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (last_dts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                            <span class="comment">// Once last dts was set to AV_NOPTS_VALUE, we don&#x27;t change it.</span></span><br><span class="line">                            last_dts = pktl-&gt;pkt.dts;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pktl = pktl-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (eof &amp;&amp; next_pkt-&gt;pts == AV_NOPTS_VALUE &amp;&amp; last_dts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                    <span class="comment">// Fixing the last reference frame had none pts issue (For MXF etc).</span></span><br><span class="line">                    <span class="comment">// We only do this when</span></span><br><span class="line">                    <span class="comment">// 1. eof.</span></span><br><span class="line">                    <span class="comment">// 2. we are not able to resolve a pts value for current packet.</span></span><br><span class="line">                    <span class="comment">// 3. the packets for this stream at the end of the files had valid dts.</span></span><br><span class="line">                    next_pkt-&gt;pts = last_dts + next_pkt-&gt;duration;</span><br><span class="line">                &#125;</span><br><span class="line">                pktl = si-&gt;packet_buffer.head;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* read packet from packet buffer, if there is data */</span></span><br><span class="line">            st = s-&gt;streams[next_pkt-&gt;stream_index];</span><br><span class="line">            <span class="keyword">if</span> (!(next_pkt-&gt;pts == AV_NOPTS_VALUE &amp;&amp; st-&gt;discard &lt; AVDISCARD_ALL &amp;&amp;</span><br><span class="line">                  next_pkt-&gt;dts != AV_NOPTS_VALUE &amp;&amp; !eof)) &#123;</span><br><span class="line">                ret = <span class="built_in">avpriv_packet_list_get</span>(&amp;si-&gt;packet_buffer, pkt);</span><br><span class="line">                <span class="keyword">goto</span> return_packet;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">read_frame_internal</span>(s, pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pktl &amp;&amp; ret != <span class="built_in">AVERROR</span>(EAGAIN)) &#123;</span><br><span class="line">                eof = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">avpriv_packet_list_put</span>(&amp;si-&gt;packet_buffer,</span><br><span class="line">                                     pkt, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">return_packet:</span><br><span class="line">    st = s-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">    <span class="keyword">if</span> ((s-&gt;iformat-&gt;flags &amp; AVFMT_GENERIC_INDEX) &amp;&amp; pkt-&gt;flags &amp; AV_PKT_FLAG_KEY) &#123;</span><br><span class="line">        <span class="built_in">ff_reduce_index</span>(s, st-&gt;index);</span><br><span class="line">        <span class="built_in">av_add_index_entry</span>(st, pkt-&gt;pos, pkt-&gt;dts, <span class="number">0</span>, <span class="number">0</span>, AVINDEX_KEYFRAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_relative</span>(pkt-&gt;dts))</span><br><span class="line">        pkt-&gt;dts -= RELATIVE_TS_BASE;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_relative</span>(pkt-&gt;pts))</span><br><span class="line">        pkt-&gt;pts -= RELATIVE_TS_BASE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是官方的 demux_decode.c 例子的关键步骤，基本和上面例子用到的 API 是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> AVCodecContext *video_dec_ctx = <span class="literal">NULL</span>, *audio_dec_ctx;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *src_filename = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">avformat_open_input</span>(&amp;fmt_ctx, src_filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">avformat_find_stream_info</span>(fmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============</span></span><br><span class="line"><span class="type">int</span> ret, stream_index;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">AVMediaType</span> type;</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">av_find_best_stream</span>(fmt_ctx, type, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">stream_index = ret;</span><br><span class="line">AVStream *st = fmt_ctx-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> AVCodec *dec = <span class="built_in">avcodec_find_decoder</span>(st-&gt;codecpar-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">AVCodecContext *dec_ctx = <span class="built_in">avcodec_alloc_context3</span>(dec);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avcodec_parameters_to_context</span>(dec_ctx, st-&gt;codecpar)</span><br><span class="line"></span><br><span class="line"><span class="built_in">avcodec_open2</span>(dec_ctx, dec, <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">// ==============</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">av_read_frame</span>(fmt_ctx, pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;stream_index == video_stream_idx) &#123;</span><br><span class="line">        ret = <span class="built_in">avcodec_send_packet</span>(dec_ctx, pkt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ret = <span class="built_in">avcodec_receive_frame</span>(dec, frame);</span><br><span class="line">            ...</span><br><span class="line">            <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == audio_stream_idx) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">avcodec_free_context</span>(&amp;video_dec_ctx);</span><br><span class="line"><span class="built_in">avcodec_free_context</span>(&amp;audio_dec_ctx);</span><br><span class="line"><span class="built_in">avformat_close_input</span>(&amp;fmt_ctx);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg 之 demuxer/decoder 相关 api (二)</title>
      <link href="/2023/05/10/ffmpeg-%E4%B9%8B-demuxer-decoder-%E7%9B%B8%E5%85%B3-api-%E4%BA%8C/"/>
      <url>/2023/05/10/ffmpeg-%E4%B9%8B-demuxer-decoder-%E7%9B%B8%E5%85%B3-api-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>这篇文章接着上篇继续介绍 demuxer&#x2F;decoder 相关的函数。</p><h2 id="avformat-find-stream-info"><a href="#avformat-find-stream-info" class="headerlink" title="avformat_find_stream_info"></a>avformat_find_stream_info</h2><p>这个函数从输入源中读取数据来确定 stream 信息，这个函数对那些没有头部的格式比如 MPEG 比较有用。</p><p>和 av_probe_input_buffer2 不一样，这个函数读取的数据只有在没有 AVFMT_FLAG_NOBUFFER 这个 flag 时不会被消耗掉，后续的 read 还会返回这些数据，debug 发现 MP4 格式的 video 数据会缓存下来，audio 数据不会。</p><p>这个函数比较长，分段来看看。</p><h3 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h3><p>这一部分主要是对已经有的 stream 进行初始化，之前 s-&gt;iformat-&gt;read_header 时可能会创建 stream，在这里会尝试对已经创建的 stream 中的 AVCodecContext 进行 avcodec_open2。在 avcodec_open2 之前，会通过 avcodec_parameters_to_context 把 stream 中的参数拷贝到 AVCodecContext 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(ic);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int64_t</span> read_size;</span><br><span class="line">    AVPacket *pkt1 = si-&gt;pkt;</span><br><span class="line">    <span class="type">int64_t</span> old_offset  = <span class="built_in">avio_tell</span>(ic-&gt;pb);</span><br><span class="line">    <span class="comment">// new streams might appear, no options for those</span></span><br><span class="line">    <span class="type">int</span> orig_nb_streams = ic-&gt;nb_streams;</span><br><span class="line">    <span class="type">int</span> flush_codecs;</span><br><span class="line">    <span class="type">int64_t</span> max_analyze_duration = ic-&gt;max_analyze_duration;</span><br><span class="line">    <span class="type">int64_t</span> max_stream_analyze_duration;</span><br><span class="line">    <span class="type">int64_t</span> max_subtitle_analyze_duration;</span><br><span class="line">    <span class="type">int64_t</span> probesize = ic-&gt;probesize;</span><br><span class="line">    <span class="type">int</span> eof_reached = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *missing_streams = <span class="built_in">av_opt_ptr</span>(ic-&gt;iformat-&gt;priv_class, ic-&gt;priv_data, <span class="string">&quot;missing_streams&quot;</span>);</span><br><span class="line"></span><br><span class="line">    flush_codecs = probesize &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_opt_set_int</span>(ic, <span class="string">&quot;skip_clear&quot;</span>, <span class="number">1</span>, AV_OPT_SEARCH_CHILDREN);</span><br><span class="line"></span><br><span class="line">    max_stream_analyze_duration = max_analyze_duration;</span><br><span class="line">    max_subtitle_analyze_duration = max_analyze_duration;</span><br><span class="line">    <span class="keyword">if</span> (!max_analyze_duration) &#123;</span><br><span class="line">        max_stream_analyze_duration =</span><br><span class="line">        max_analyze_duration        = <span class="number">5</span>*AV_TIME_BASE;</span><br><span class="line">        max_subtitle_analyze_duration = <span class="number">30</span>*AV_TIME_BASE;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="type">const</span> AVCodec *codec;</span><br><span class="line">        AVDictionary *thread_opt = <span class="literal">NULL</span>;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        AVCodecContext *<span class="type">const</span> avctx = sti-&gt;avctx;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||</span><br><span class="line">            st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line"><span class="comment">/*            if (!st-&gt;time_base.num)</span></span><br><span class="line"><span class="comment">                st-&gt;time_base = */</span></span><br><span class="line">            <span class="keyword">if</span> (!avctx-&gt;time_base.num)</span><br><span class="line">                avctx-&gt;time_base = st-&gt;time_base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* check if the caller has overridden the codec id */</span></span><br><span class="line">        <span class="comment">// only for the split stuff</span></span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;parser &amp;&amp; !(ic-&gt;flags &amp; AVFMT_FLAG_NOPARSE) &amp;&amp; sti-&gt;request_probe &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sti-&gt;parser = <span class="built_in">av_parser_init</span>(st-&gt;codecpar-&gt;codec_id);</span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;parser) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sti-&gt;need_parsing == AVSTREAM_PARSE_HEADERS) &#123;</span><br><span class="line">                    sti-&gt;parser-&gt;flags |= PARSER_FLAG_COMPLETE_FRAMES;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sti-&gt;need_parsing == AVSTREAM_PARSE_FULL_RAW) &#123;</span><br><span class="line">                    sti-&gt;parser-&gt;flags |= PARSER_FLAG_USE_CODEC_TS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sti-&gt;need_parsing) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(ic, AV_LOG_VERBOSE, <span class="string">&quot;parser not found for codec &quot;</span></span><br><span class="line">                       <span class="string">&quot;%s, packets or times may be invalid.\n&quot;</span>,</span><br><span class="line">                       <span class="built_in">avcodec_get_name</span>(st-&gt;codecpar-&gt;codec_id));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">avcodec_parameters_to_context</span>(avctx, st-&gt;codecpar);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> find_stream_info_err;</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;request_probe &lt;= <span class="number">0</span>)</span><br><span class="line">            sti-&gt;avctx_inited = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        codec = <span class="built_in">find_probe_decoder</span>(ic, st, st-&gt;codecpar-&gt;codec_id);</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// Try to just open decoders, in case this is enough to get parameters.</span></span><br><span class="line">        <span class="comment">// Also ensure that subtitle_header is properly set.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">has_codec_parameters</span>(st, <span class="literal">NULL</span>) &amp;&amp; sti-&gt;request_probe &lt;= <span class="number">0</span> ||</span><br><span class="line">            st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (codec &amp;&amp; !avctx-&gt;codec)</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(avctx, codec, options ? &amp;options[i] : &amp;thread_opt) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">av_log</span>(ic, AV_LOG_WARNING,</span><br><span class="line">                           <span class="string">&quot;Failed to open codec in %s\n&quot;</span>,__FUNCTION__);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!options)</span><br><span class="line">            <span class="built_in">av_dict_free</span>(&amp;thread_opt);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="has-codec-parameters"><a href="#has-codec-parameters" class="headerlink" title="has_codec_parameters"></a>has_codec_parameters</h4><p>对 stream 上的 AVCodecContext 进行一些检查</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">has_codec_parameters</span><span class="params">(<span class="type">const</span> AVStream *st, <span class="type">const</span> <span class="type">char</span> **errmsg_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FFStream *<span class="type">const</span> sti = <span class="built_in">cffstream</span>(st);</span><br><span class="line">    <span class="type">const</span> AVCodecContext *<span class="type">const</span> avctx = sti-&gt;avctx;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAIL(errmsg) do &#123;                                         \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (errmsg_ptr)                                           \</span></span><br><span class="line"><span class="meta">            *errmsg_ptr = errmsg;                                 \</span></span><br><span class="line"><span class="meta">        return 0;                                                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (   avctx-&gt;codec_id == AV_CODEC_ID_NONE</span><br><span class="line">        &amp;&amp; avctx-&gt;codec_type != AVMEDIA_TYPE_DATA)</span><br><span class="line">        <span class="built_in">FAIL</span>(<span class="string">&quot;unknown codec&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (avctx-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">        <span class="keyword">if</span> (!avctx-&gt;frame_size &amp;&amp; <span class="built_in">determinable_frame_size</span>(avctx))</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified frame size&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;info-&gt;found_decoder &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            avctx-&gt;sample_fmt == AV_SAMPLE_FMT_NONE)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified sample format&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!avctx-&gt;sample_rate)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified sample rate&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!avctx-&gt;ch_layout.nb_channels)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified number of channels&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;info-&gt;found_decoder &gt;= <span class="number">0</span> &amp;&amp; !sti-&gt;nb_decoded_frames &amp;&amp; avctx-&gt;codec_id == AV_CODEC_ID_DTS)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;no decodable DTS frames&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">        <span class="keyword">if</span> (!avctx-&gt;width)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified size&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;info-&gt;found_decoder &gt;= <span class="number">0</span> &amp;&amp; avctx-&gt;pix_fmt == AV_PIX_FMT_NONE)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified pixel format&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_id == AV_CODEC_ID_RV30 || st-&gt;codecpar-&gt;codec_id == AV_CODEC_ID_RV40)</span><br><span class="line">            <span class="keyword">if</span> (!st-&gt;sample_aspect_ratio.num &amp;&amp; !st-&gt;codecpar-&gt;sample_aspect_ratio.num &amp;&amp; !sti-&gt;codec_info_nb_frames)</span><br><span class="line">                <span class="built_in">FAIL</span>(<span class="string">&quot;no frame in rv30/40 and no sar&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec_id == AV_CODEC_ID_HDMV_PGS_SUBTITLE &amp;&amp; !avctx-&gt;width)</span><br><span class="line">            <span class="built_in">FAIL</span>(<span class="string">&quot;unspecified size&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_DATA:</span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec_id == AV_CODEC_ID_NONE) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="find-probe-decoder"><a href="#find-probe-decoder" class="headerlink" title="find_probe_decoder"></a>find_probe_decoder</h4><p>通过 find_probe_decoder 找到当前 stream 对应的 codec 信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> AVCodec *<span class="title">find_probe_decoder</span><span class="params">(AVFormatContext *s, <span class="type">const</span> AVStream *st,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="keyword">enum</span> AVCodecID codec_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVCodec *codec;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_H264_DECODER</span></span><br><span class="line">    <span class="comment">/* Other parts of the code assume this decoder to be used for h264,</span></span><br><span class="line"><span class="comment">     * so force it if possible. */</span></span><br><span class="line">    <span class="keyword">if</span> (codec_id == AV_CODEC_ID_H264)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">avcodec_find_decoder_by_name</span>(<span class="string">&quot;h264&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    codec = <span class="built_in">ff_find_decoder</span>(s, st, codec_id);</span><br><span class="line">    <span class="keyword">if</span> (!codec)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (codec-&gt;capabilities &amp; AV_CODEC_CAP_AVOID_PROBING) &#123;</span><br><span class="line">        <span class="type">const</span> AVCodec *probe_codec = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">void</span> *iter = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> ((probe_codec = <span class="built_in">av_codec_iterate</span>(&amp;iter))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (probe_codec-&gt;id == codec-&gt;id &amp;&amp;</span><br><span class="line">                    <span class="built_in">av_codec_is_decoder</span>(probe_codec) &amp;&amp;</span><br><span class="line">                    !(probe_codec-&gt;capabilities &amp; (AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_EXPERIMENTAL))) &#123;</span><br><span class="line">                <span class="keyword">return</span> probe_codec;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> codec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择 codec 会优先从 AVFormatContext 中选，其次会考虑 stream 上的 codecpar 中的 codec_id</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVCodec *<span class="title">ff_find_decoder</span><span class="params">(AVFormatContext *s, <span class="type">const</span> AVStream *st,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">enum</span> AVCodecID codec_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (st-&gt;codecpar-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;video_codec)    <span class="keyword">return</span> s-&gt;video_codec;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;audio_codec)    <span class="keyword">return</span> s-&gt;audio_codec;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;subtitle_codec) <span class="keyword">return</span> s-&gt;subtitle_codec;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">avcodec_find_decoder</span>(codec_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h3><p>上面部分没有涉及从数据源读取数据，这部分代码则是尝试读取一定的数据来探测 stream、codec 等信息。</p><p>有一个 for 循环，这个循环会在读取到指定大小的数据后或者已经分析完所有 stream 后退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    read_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">const</span> AVPacket *pkt;</span><br><span class="line">        AVStream *st;</span><br><span class="line">        FFStream *sti;</span><br><span class="line">        AVCodecContext *avctx;</span><br><span class="line">        <span class="type">int</span> analyzed_all_streams;</span><br><span class="line">        <span class="type">unsigned</span> i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ff_check_interrupt</span>(&amp;ic-&gt;interrupt_callback)) &#123;</span><br><span class="line">            ret = AVERROR_EXIT;</span><br><span class="line">            <span class="built_in">av_log</span>(ic, AV_LOG_DEBUG, <span class="string">&quot;interrupted\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        这个循环会遍历每个stream，并检查它的参数，如果发现它的参数需要进一步调整，</span><br><span class="line">        或者遇到第一个还没有被初始化的stream时退出，在后续的逻辑中会尝试进行probe</span><br><span class="line">        来获得关于这个stream的更多信息</span><br><span class="line">        <span class="comment">/* check if one codec still needs to be handled */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">            AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">            FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">            <span class="type">int</span> fps_analyze_framecount = <span class="number">20</span>;</span><br><span class="line">            <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">has_codec_parameters</span>(st, <span class="literal">NULL</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/* If the timebase is coarse (like the usual millisecond precision</span></span><br><span class="line"><span class="comment">             * of mkv), we need to analyze more frames to reliably arrive at</span></span><br><span class="line"><span class="comment">             * the correct fps. */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">av_q2d</span>(st-&gt;time_base) &gt; <span class="number">0.0005</span>)</span><br><span class="line">                fps_analyze_framecount *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">tb_unreliable</span>(sti-&gt;avctx))</span><br><span class="line">                fps_analyze_framecount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ic-&gt;fps_probe_size &gt;= <span class="number">0</span>)</span><br><span class="line">                fps_analyze_framecount = ic-&gt;fps_probe_size;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)</span><br><span class="line">                fps_analyze_framecount = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* variable fps and no guess at the real fps */</span></span><br><span class="line">            count = (ic-&gt;iformat-&gt;flags &amp; AVFMT_NOTIMESTAMPS) ?</span><br><span class="line">                       sti-&gt;info-&gt;codec_info_duration_fields/<span class="number">2</span> :</span><br><span class="line">                       sti-&gt;info-&gt;duration_count;</span><br><span class="line">            <span class="keyword">if</span> (!(st-&gt;r_frame_rate.num &amp;&amp; st-&gt;avg_frame_rate.num) &amp;&amp;</span><br><span class="line">                st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; fps_analyze_framecount)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Look at the first 3 frames if there is evidence of frame delay</span></span><br><span class="line">            <span class="comment">// but the decoder delay is not set.</span></span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;info-&gt;frame_delay_evidence &amp;&amp; count &lt; <span class="number">2</span> &amp;&amp; sti-&gt;avctx-&gt;has_b_frames == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!sti-&gt;avctx-&gt;extradata &amp;&amp;</span><br><span class="line">                (!sti-&gt;extract_extradata.inited || sti-&gt;extract_extradata.bsf) &amp;&amp;</span><br><span class="line">                <span class="built_in">extract_extradata_check</span>(st))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;first_dts == AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                !(ic-&gt;iformat-&gt;flags &amp; AVFMT_NOTIMESTAMPS) &amp;&amp;</span><br><span class="line">                sti-&gt;codec_info_nb_frames &lt; ((st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC) ? <span class="number">1</span> : ic-&gt;max_ts_probe) &amp;&amp;</span><br><span class="line">                (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||</span><br><span class="line">                 st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        analyzed_all_streams = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!missing_streams || !*missing_streams)</span><br><span class="line">            <span class="keyword">if</span> (i == ic-&gt;nb_streams) &#123;</span><br><span class="line">                analyzed_all_streams = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/* <span class="doctag">NOTE:</span> If the format has no header, then we need to read some</span></span><br><span class="line"><span class="comment">                 * packets to get most of the streams, so we cannot stop here. */</span></span><br><span class="line">                <span class="keyword">if</span> (!(ic-&gt;ctx_flags &amp; AVFMTCTX_NOHEADER)) &#123;</span><br><span class="line">                    <span class="comment">/* If we found the info for all the codecs, we can stop. */</span></span><br><span class="line">                    ret = count;</span><br><span class="line">                    <span class="built_in">av_log</span>(ic, AV_LOG_DEBUG, <span class="string">&quot;All info found\n&quot;</span>);</span><br><span class="line">                    flush_codecs = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">/* We did not get all the codec info, but we read too much data. */</span></span><br><span class="line">        <span class="keyword">if</span> (read_size &gt;= probesize) &#123;</span><br><span class="line">            ret = count;</span><br><span class="line">            <span class="built_in">av_log</span>(ic, AV_LOG_DEBUG,</span><br><span class="line">                   <span class="string">&quot;Probe buffer size limit of %&quot;</span>PRId64<span class="string">&quot; bytes reached\n&quot;</span>, probesize);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">                AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">                FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">                <span class="keyword">if</span> (!st-&gt;r_frame_rate.num &amp;&amp;</span><br><span class="line">                    sti-&gt;info-&gt;duration_count &lt;= <span class="number">1</span> &amp;&amp;</span><br><span class="line">                    st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp;</span><br><span class="line">                    <span class="built_in">strcmp</span>(ic-&gt;iformat-&gt;name, <span class="string">&quot;image2&quot;</span>))</span><br><span class="line">                    <span class="built_in">av_log</span>(ic, AV_LOG_WARNING,</span><br><span class="line">                           <span class="string">&quot;Stream #%d: not enough frames to estimate rate; &quot;</span></span><br><span class="line">                           <span class="string">&quot;consider increasing probesize\n&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// read_frame_internal里面会把request_probe变为-1后才返回</span></span><br><span class="line">        <span class="comment">/* <span class="doctag">NOTE:</span> A new stream can be added there if no header in file</span></span><br><span class="line"><span class="comment">         * (AVFMTCTX_NOHEADER). */</span></span><br><span class="line">        ret = <span class="built_in">read_frame_internal</span>(ic, pkt1);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* EOF or error*/</span></span><br><span class="line">            eof_reached = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)) &#123;</span><br><span class="line">            有buffer</span><br><span class="line">            ret = <span class="built_in">avpriv_packet_list_put</span>(&amp;si-&gt;packet_buffer,</span><br><span class="line">                                         pkt1, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> unref_then_goto_end;</span><br><span class="line"></span><br><span class="line">            pkt = &amp;si-&gt;packet_buffer.tail-&gt;pkt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pkt = pkt1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st  = ic-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">        sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        <span class="keyword">if</span> (!(st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC))</span><br><span class="line">            read_size += pkt-&gt;size;</span><br><span class="line"></span><br><span class="line">        avctx = sti-&gt;avctx;</span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;avctx_inited) &#123;</span><br><span class="line">            ret = <span class="built_in">avcodec_parameters_to_context</span>(avctx, st-&gt;codecpar);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> unref_then_goto_end;</span><br><span class="line">            sti-&gt;avctx_inited = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;dts != AV_NOPTS_VALUE &amp;&amp; sti-&gt;codec_info_nb_frames &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* check for non-increasing dts */</span></span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;info-&gt;fps_last_dts != AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                sti-&gt;info-&gt;fps_last_dts &gt;= pkt-&gt;dts) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(ic, AV_LOG_DEBUG,</span><br><span class="line">                       <span class="string">&quot;Non-increasing DTS in stream %d: packet %d with DTS &quot;</span></span><br><span class="line">                       <span class="string">&quot;%&quot;</span>PRId64<span class="string">&quot;, packet %d with DTS %&quot;</span>PRId64<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                       st-&gt;index, sti-&gt;info-&gt;fps_last_dts_idx,</span><br><span class="line">                       sti-&gt;info-&gt;fps_last_dts, sti-&gt;codec_info_nb_frames,</span><br><span class="line">                       pkt-&gt;dts);</span><br><span class="line">                sti-&gt;info-&gt;fps_first_dts =</span><br><span class="line">                sti-&gt;info-&gt;fps_last_dts  = AV_NOPTS_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Check for a discontinuity in dts. If the difference in dts</span></span><br><span class="line"><span class="comment">             * is more than 1000 times the average packet duration in the</span></span><br><span class="line"><span class="comment">             * sequence, we treat it as a discontinuity. */</span></span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;info-&gt;fps_last_dts != AV_NOPTS_VALUE &amp;&amp;</span><br><span class="line">                sti-&gt;info-&gt;fps_last_dts_idx &gt; sti-&gt;info-&gt;fps_first_dts_idx &amp;&amp;</span><br><span class="line">                (pkt-&gt;dts - (<span class="type">uint64_t</span>)sti-&gt;info-&gt;fps_last_dts) / <span class="number">1000</span> &gt;</span><br><span class="line">                (sti-&gt;info-&gt;fps_last_dts     - (<span class="type">uint64_t</span>)sti-&gt;info-&gt;fps_first_dts) /</span><br><span class="line">                (sti-&gt;info-&gt;fps_last_dts_idx - sti-&gt;info-&gt;fps_first_dts_idx)) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(ic, AV_LOG_WARNING,</span><br><span class="line">                       <span class="string">&quot;DTS discontinuity in stream %d: packet %d with DTS &quot;</span></span><br><span class="line">                       <span class="string">&quot;%&quot;</span>PRId64<span class="string">&quot;, packet %d with DTS %&quot;</span>PRId64<span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                       st-&gt;index, sti-&gt;info-&gt;fps_last_dts_idx,</span><br><span class="line">                       sti-&gt;info-&gt;fps_last_dts, sti-&gt;codec_info_nb_frames,</span><br><span class="line">                       pkt-&gt;dts);</span><br><span class="line">                sti-&gt;info-&gt;fps_first_dts =</span><br><span class="line">                sti-&gt;info-&gt;fps_last_dts  = AV_NOPTS_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* update stored dts values */</span></span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;info-&gt;fps_first_dts == AV_NOPTS_VALUE) &#123;</span><br><span class="line">                sti-&gt;info-&gt;fps_first_dts     = pkt-&gt;dts;</span><br><span class="line">                sti-&gt;info-&gt;fps_first_dts_idx = sti-&gt;codec_info_nb_frames;</span><br><span class="line">            &#125;</span><br><span class="line">            sti-&gt;info-&gt;fps_last_dts     = pkt-&gt;dts;</span><br><span class="line">            sti-&gt;info-&gt;fps_last_dts_idx = sti-&gt;codec_info_nb_frames;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;codec_info_nb_frames &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int64_t</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int64_t</span> limit;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (st-&gt;time_base.den &gt; <span class="number">0</span>)</span><br><span class="line">                t = <span class="built_in">av_rescale_q</span>(sti-&gt;info-&gt;codec_info_duration, st-&gt;time_base, AV_TIME_BASE_Q);</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;avg_frame_rate.num &gt; <span class="number">0</span>)</span><br><span class="line">                t = <span class="built_in">FFMAX</span>(t, <span class="built_in">av_rescale_q</span>(sti-&gt;codec_info_nb_frames, <span class="built_in">av_inv_q</span>(st-&gt;avg_frame_rate), AV_TIME_BASE_Q));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (   t == <span class="number">0</span></span><br><span class="line">                &amp;&amp; sti-&gt;codec_info_nb_frames &gt; <span class="number">30</span></span><br><span class="line">                &amp;&amp; sti-&gt;info-&gt;fps_first_dts != AV_NOPTS_VALUE</span><br><span class="line">                &amp;&amp; sti-&gt;info-&gt;fps_last_dts  != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                <span class="type">int64_t</span> dur = <span class="built_in">av_sat_sub64</span>(sti-&gt;info-&gt;fps_last_dts, sti-&gt;info-&gt;fps_first_dts);</span><br><span class="line">                t = <span class="built_in">FFMAX</span>(t, <span class="built_in">av_rescale_q</span>(dur, st-&gt;time_base, AV_TIME_BASE_Q));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (analyzed_all_streams)                                limit = max_analyze_duration;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) limit = max_subtitle_analyze_duration;</span><br><span class="line">            <span class="keyword">else</span>                                                     limit = max_stream_analyze_duration;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t &gt;= limit) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(ic, AV_LOG_VERBOSE, <span class="string">&quot;max_analyze_duration %&quot;</span>PRId64<span class="string">&quot; reached at %&quot;</span>PRId64<span class="string">&quot; microseconds st:%d\n&quot;</span>,</span><br><span class="line">                       limit,</span><br><span class="line">                       t, pkt-&gt;stream_index);</span><br><span class="line">                <span class="keyword">if</span> (ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)</span><br><span class="line">                    <span class="built_in">av_packet_unref</span>(pkt1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pkt-&gt;duration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE &amp;&amp; pkt-&gt;pts != AV_NOPTS_VALUE &amp;&amp; st-&gt;start_time != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;pts &gt;= st-&gt;start_time</span><br><span class="line">                    &amp;&amp; (<span class="type">uint64_t</span>)pkt-&gt;pts - st-&gt;start_time &lt; INT64_MAX</span><br><span class="line">                ) &#123;</span><br><span class="line">                    sti-&gt;info-&gt;codec_info_duration = <span class="built_in">FFMIN</span>(pkt-&gt;pts - st-&gt;start_time, sti-&gt;info-&gt;codec_info_duration + pkt-&gt;duration);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    sti-&gt;info-&gt;codec_info_duration += pkt-&gt;duration;</span><br><span class="line">                sti-&gt;info-&gt;codec_info_duration_fields += sti-&gt;parser &amp;&amp; sti-&gt;need_parsing &amp;&amp; avctx-&gt;ticks_per_frame == <span class="number">2</span></span><br><span class="line">                                                         ? sti-&gt;parser-&gt;repeat_pict + <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_R_FRAME_RATE</span></span><br><span class="line">            <span class="built_in">ff_rfps_add_frame</span>(ic, st, pkt-&gt;dts);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (pkt-&gt;dts != pkt-&gt;pts &amp;&amp; pkt-&gt;dts != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">                sti-&gt;info-&gt;frame_delay_evidence = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;avctx-&gt;extradata) &#123;</span><br><span class="line">            ret = <span class="built_in">extract_extradata</span>(si, st, pkt);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> unref_then_goto_end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If still no information, we try to open the codec and to</span></span><br><span class="line"><span class="comment">         * decompress the frame. We try to avoid that in most cases as</span></span><br><span class="line"><span class="comment">         * it takes longer and uses more memory. For MPEG-4, we need to</span></span><br><span class="line"><span class="comment">         * decompress for QuickTime.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If AV_CODEC_CAP_CHANNEL_CONF is set this will force decoding of at</span></span><br><span class="line"><span class="comment">         * least one frame of codec data, this makes sure the codec initializes</span></span><br><span class="line"><span class="comment">         * the channel configuration and does not only trust the values from</span></span><br><span class="line"><span class="comment">         * the container. */</span></span><br><span class="line">        <span class="built_in">try_decode_frame</span>(ic, st, pkt,</span><br><span class="line">                         (options &amp;&amp; i &lt; orig_nb_streams) ? &amp;options[i] : <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(pkt1);</span><br><span class="line"></span><br><span class="line">        sti-&gt;codec_info_nb_frames++;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="read-frame-internal"><a href="#read-frame-internal" class="headerlink" title="read_frame_internal"></a>read_frame_internal</h4><p>当需要进行 probe 时，调用 read_frame_internal 读取数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">read_frame_internal</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    <span class="type">int</span> ret, got_packet = <span class="number">0</span>;</span><br><span class="line">    AVDictionary *metadata = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!got_packet &amp;&amp; !si-&gt;parse_queue.head) &#123;</span><br><span class="line">        AVStream *st;</span><br><span class="line">        FFStream *sti;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read next packet */</span></span><br><span class="line">        ret = <span class="built_in">ff_read_packet</span>(s, pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        st  = s-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">        sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">        st-&gt;event_flags |= AVSTREAM_EVENT_FLAG_NEW_PACKETS;</span><br><span class="line"></span><br><span class="line">        ff_read_packet里面可能会设置need_context_update，</span><br><span class="line">        因为read_packet中可能创建新的stream</span><br><span class="line">        <span class="comment">/* update context if required */</span></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;need_context_update) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">avcodec_is_open</span>(sti-&gt;avctx)) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_DEBUG, <span class="string">&quot;Demuxer context update while decoder is open, closing and trying to re-open\n&quot;</span>);</span><br><span class="line">                <span class="built_in">avcodec_close</span>(sti-&gt;avctx);</span><br><span class="line">                sti-&gt;info-&gt;found_decoder = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* close parser, because it depends on the codec */</span></span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;parser &amp;&amp; sti-&gt;avctx-&gt;codec_id != st-&gt;codecpar-&gt;codec_id) &#123;</span><br><span class="line">                <span class="built_in">av_parser_close</span>(sti-&gt;parser);</span><br><span class="line">                sti-&gt;parser = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">avcodec_parameters_to_context</span>(sti-&gt;avctx, st-&gt;codecpar);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sti-&gt;need_context_update = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;need_parsing &amp;&amp; !sti-&gt;parser &amp;&amp; !(s-&gt;flags &amp; AVFMT_FLAG_NOPARSE)) &#123;</span><br><span class="line">            sti-&gt;parser = <span class="built_in">av_parser_init</span>(st-&gt;codecpar-&gt;codec_id);</span><br><span class="line">            <span class="keyword">if</span> (!sti-&gt;parser) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_VERBOSE, <span class="string">&quot;parser not found for codec &quot;</span></span><br><span class="line">                       <span class="string">&quot;%s, packets or times may be invalid.\n&quot;</span>,</span><br><span class="line">                       <span class="built_in">avcodec_get_name</span>(st-&gt;codecpar-&gt;codec_id));</span><br><span class="line">                <span class="comment">/* no parser available: just output the raw packets */</span></span><br><span class="line">                &lt;u&gt;sti-&gt;need_parsing = AVSTREAM_PARSE_NONE;&lt;/u&gt;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sti-&gt;need_parsing == AVSTREAM_PARSE_HEADERS)</span><br><span class="line">                sti-&gt;parser-&gt;flags |= PARSER_FLAG_COMPLETE_FRAMES;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sti-&gt;need_parsing == AVSTREAM_PARSE_FULL_ONCE)</span><br><span class="line">                sti-&gt;parser-&gt;flags |= PARSER_FLAG_ONCE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sti-&gt;need_parsing == AVSTREAM_PARSE_FULL_RAW)</span><br><span class="line">                sti-&gt;parser-&gt;flags |= PARSER_FLAG_USE_CODEC_TS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;need_parsing || !sti-&gt;parser) &#123;</span><br><span class="line">            <span class="comment">/* no parsing needed: we just output the packet as is */</span></span><br><span class="line">            <span class="built_in">compute_pkt_fields</span>(s, st, <span class="literal">NULL</span>, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);</span><br><span class="line">            <span class="keyword">if</span> ((s-&gt;iformat-&gt;flags &amp; AVFMT_GENERIC_INDEX) &amp;&amp;</span><br><span class="line">                (pkt-&gt;flags &amp; AV_PKT_FLAG_KEY) &amp;&amp; pkt-&gt;dts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                <span class="built_in">ff_reduce_index</span>(s, st-&gt;index);</span><br><span class="line">                <span class="built_in">av_add_index_entry</span>(st, pkt-&gt;pos, pkt-&gt;dts,</span><br><span class="line">                                   <span class="number">0</span>, <span class="number">0</span>, AVINDEX_KEYFRAME);</span><br><span class="line">            &#125;</span><br><span class="line">            got_packet = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (st-&gt;discard &lt; AVDISCARD_ALL) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">parse_packet</span>(s, pkt, pkt-&gt;stream_index, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            st-&gt;codecpar-&gt;sample_rate = sti-&gt;avctx-&gt;sample_rate;</span><br><span class="line">            st-&gt;codecpar-&gt;bit_rate = sti-&gt;avctx-&gt;bit_rate;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">av_channel_layout_copy</span>(&amp;st-&gt;codecpar-&gt;ch_layout, &amp;sti-&gt;avctx-&gt;ch_layout);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            st-&gt;codecpar-&gt;codec_id = sti-&gt;avctx-&gt;codec_id;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* free packet */</span></span><br><span class="line">            <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;flags &amp; AV_PKT_FLAG_KEY)</span><br><span class="line">            sti-&gt;skip_to_keyframe = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;skip_to_keyframe) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">            got_packet = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!got_packet &amp;&amp; si-&gt;parse_queue.head)</span><br><span class="line">        ret = <span class="built_in">avpriv_packet_list_get</span>(&amp;si-&gt;parse_queue, pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = s-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        <span class="type">int</span> discard_padding = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;first_discard_sample &amp;&amp; pkt-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">            <span class="type">int64_t</span> pts = pkt-&gt;pts - (<span class="built_in">is_relative</span>(pkt-&gt;pts) ? RELATIVE_TS_BASE : <span class="number">0</span>);</span><br><span class="line">            <span class="type">int64_t</span> sample = <span class="built_in">ts_to_samples</span>(st, pts);</span><br><span class="line">            <span class="type">int64_t</span> duration = <span class="built_in">ts_to_samples</span>(st, pkt-&gt;duration);</span><br><span class="line">            <span class="type">int64_t</span> end_sample = sample + duration;</span><br><span class="line">            <span class="keyword">if</span> (duration &gt; <span class="number">0</span> &amp;&amp; end_sample &gt;= sti-&gt;first_discard_sample &amp;&amp;</span><br><span class="line">                sample &lt; sti-&gt;last_discard_sample)</span><br><span class="line">                discard_padding = <span class="built_in">FFMIN</span>(end_sample - sti-&gt;first_discard_sample, duration);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;start_skip_samples &amp;&amp; (pkt-&gt;pts == <span class="number">0</span> || pkt-&gt;pts == RELATIVE_TS_BASE))</span><br><span class="line">            sti-&gt;skip_samples = sti-&gt;start_skip_samples;</span><br><span class="line">        sti-&gt;skip_samples = <span class="built_in">FFMAX</span>(<span class="number">0</span>, sti-&gt;skip_samples);</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;skip_samples || discard_padding) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> *p = <span class="built_in">av_packet_new_side_data</span>(pkt, AV_PKT_DATA_SKIP_SAMPLES, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                <span class="built_in">AV_WL32</span>(p, sti-&gt;skip_samples);</span><br><span class="line">                <span class="built_in">AV_WL32</span>(p + <span class="number">4</span>, discard_padding);</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_DEBUG, <span class="string">&quot;demuxer injecting skip %u / discard %u\n&quot;</span>,</span><br><span class="line">                       (<span class="type">unsigned</span>)sti-&gt;skip_samples, (<span class="type">unsigned</span>)discard_padding);</span><br><span class="line">            &#125;</span><br><span class="line">            sti-&gt;skip_samples = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;inject_global_side_data) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; st-&gt;nb_side_data; i++) &#123;</span><br><span class="line">                <span class="type">const</span> AVPacketSideData *<span class="type">const</span> src_sd = &amp;st-&gt;side_data[i];</span><br><span class="line">                <span class="type">uint8_t</span> *dst_data;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">av_packet_get_side_data</span>(pkt, src_sd-&gt;type, <span class="literal">NULL</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                dst_data = <span class="built_in">av_packet_new_side_data</span>(pkt, src_sd-&gt;type, src_sd-&gt;size);</span><br><span class="line">                <span class="keyword">if</span> (!dst_data) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(s, AV_LOG_WARNING, <span class="string">&quot;Could not inject global side data\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(dst_data, src_sd-&gt;data, src_sd-&gt;size);</span><br><span class="line">            &#125;</span><br><span class="line">            sti-&gt;inject_global_side_data = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A demuxer might have returned EOF because of an IO error, let&#x27;s</span></span><br><span class="line"><span class="comment">     * propagate this back to the user. */</span></span><br><span class="line">    <span class="keyword">if</span> (ret == AVERROR_EOF &amp;&amp; s-&gt;pb &amp;&amp; s-&gt;pb-&gt;error &lt; <span class="number">0</span> &amp;&amp; s-&gt;pb-&gt;error != <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">        ret = s-&gt;pb-&gt;error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ff-read-packet"><a href="#ff-read-packet" class="headerlink" title="ff_read_packet"></a>ff_read_packet</h5><p>这个函数会不停的 s-&gt;iformat-&gt;read_packet，同时尝试 probe_codec，直到 probe_codec 把 <code>ffstream(st)-&gt;request_probe </code> 变为 <code>&lt;=0</code> 后，才会返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_read_packet</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        PacketListEntry *pktl = si-&gt;raw_packet_buffer.head;</span><br><span class="line">        AVStream *st;</span><br><span class="line">        FFStream *sti;</span><br><span class="line">        <span class="type">const</span> AVPacket *pkt1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pktl) &#123;</span><br><span class="line">            AVStream *<span class="type">const</span> st = s-&gt;streams[pktl-&gt;pkt.stream_index];</span><br><span class="line">            <span class="keyword">if</span> (si-&gt;raw_packet_buffer_size &gt;= s-&gt;probesize)</span><br><span class="line">                <span class="keyword">if</span> ((err = <span class="built_in">probe_codec</span>(s, st, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ffstream</span>(st)-&gt;request_probe &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">avpriv_packet_list_get</span>(&amp;si-&gt;raw_packet_buffer, pkt);</span><br><span class="line">                si-&gt;raw_packet_buffer_size -= pkt-&gt;size;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = s-&gt;iformat-&gt;<span class="built_in">read_packet</span>(s, pkt);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Some demuxers return FFERROR_REDO when they consume</span></span><br><span class="line"><span class="comment">               data and discard it (ignored streams, junk, extradata).</span></span><br><span class="line"><span class="comment">               We must re-call the demuxer to get the real packet. */</span></span><br><span class="line">            <span class="keyword">if</span> (err == FFERROR_REDO)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!pktl || err == <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">                AVStream *<span class="type">const</span> st  = s-&gt;streams[i];</span><br><span class="line">                FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">                <span class="keyword">if</span> (sti-&gt;probe_packets || sti-&gt;request_probe &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> ((err = <span class="built_in">probe_codec</span>(s, st, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">                <span class="built_in">av_assert0</span>(sti-&gt;request_probe &lt;= <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">av_packet_make_refcounted</span>(pkt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">av_assert0</span>(pkt-&gt;stream_index &lt; (<span class="type">unsigned</span>)s-&gt;nb_streams &amp;&amp;</span><br><span class="line">                   <span class="string">&quot;Invalid stream index.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        st  = s-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">        sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">update_wrap_reference</span>(s, st, pkt-&gt;stream_index, pkt) &amp;&amp; sti-&gt;pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET) &#123;</span><br><span class="line">            <span class="comment">// correct first time stamps to negative values</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">is_relative</span>(sti-&gt;first_dts))</span><br><span class="line">                sti-&gt;first_dts = <span class="built_in">wrap_timestamp</span>(st, sti-&gt;first_dts);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">is_relative</span>(st-&gt;start_time))</span><br><span class="line">                st-&gt;start_time = <span class="built_in">wrap_timestamp</span>(st, st-&gt;start_time);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">is_relative</span>(sti-&gt;cur_dts))</span><br><span class="line">                sti-&gt;cur_dts = <span class="built_in">wrap_timestamp</span>(st, sti-&gt;cur_dts);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pkt-&gt;dts = <span class="built_in">wrap_timestamp</span>(st, pkt-&gt;dts);</span><br><span class="line">        pkt-&gt;pts = <span class="built_in">wrap_timestamp</span>(st, pkt-&gt;pts);</span><br><span class="line"></span><br><span class="line">        force_codec_ids(s, st);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> audio: time filter; video: frame reordering (pts != dts) */</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;use_wallclock_as_timestamps)</span><br><span class="line">            pkt-&gt;dts = pkt-&gt;pts = <span class="built_in">av_rescale_q</span>(<span class="built_in">av_gettime</span>(), AV_TIME_BASE_Q, st-&gt;time_base);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pktl &amp;&amp; sti-&gt;request_probe &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">avpriv_packet_list_put</span>(&amp;si-&gt;raw_packet_buffer,</span><br><span class="line">                                     pkt, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        pkt1 = &amp;si-&gt;raw_packet_buffer.tail-&gt;pkt;</span><br><span class="line">        si-&gt;raw_packet_buffer_size += pkt1-&gt;size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((err = &lt;u&gt;<span class="built_in">probe_codec</span>(s, st, pkt1))&lt;/u&gt; &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="probe-codec"><a href="#probe-codec" class="headerlink" title="probe_codec"></a>probe_codec</h6><p>从这个函数的逻辑可以看到，会把每一次输入的 AVPacket 的内容拷贝到 AVProbeData 中的 buf 中，当输入 pkt 为空指针时，表示进行 probe，进行 probe 后会把 sti-&gt;request_probe 置为-1，那么后面再调用 probe_codec 时会被挡住。</p><p>而且这次的用于 probe 的数据是分 stream 存储的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">probe_codec</span><span class="params">(AVFormatContext *s, AVStream *st, <span class="type">const</span> AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sti-&gt;request_probe &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        AVProbeData *<span class="type">const</span> pd = &amp;sti-&gt;probe_data;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        <span class="built_in">av_log</span>(s, AV_LOG_DEBUG, <span class="string">&quot;probing stream %d pp:%d\n&quot;</span>, st-&gt;index, sti-&gt;probe_packets);</span><br><span class="line">        --sti-&gt;probe_packets;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> *new_buf = <span class="built_in">av_realloc</span>(pd-&gt;buf, pd-&gt;buf_size+pkt-&gt;size+AVPROBE_PADDING_SIZE);</span><br><span class="line">            <span class="keyword">if</span> (!new_buf) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_WARNING,</span><br><span class="line">                       <span class="string">&quot;Failed to reallocate probe buffer for stream %d\n&quot;</span>,</span><br><span class="line">                       st-&gt;index);</span><br><span class="line">                <span class="keyword">goto</span> no_packet;</span><br><span class="line">            &#125;</span><br><span class="line">            pd-&gt;buf = new_buf;</span><br><span class="line">            <span class="built_in">memcpy</span>(pd-&gt;buf + pd-&gt;buf_size, pkt-&gt;data, pkt-&gt;size);</span><br><span class="line">            pd-&gt;buf_size += pkt-&gt;size;</span><br><span class="line">            <span class="built_in">memset</span>(pd-&gt;buf + pd-&gt;buf_size, <span class="number">0</span>, AVPROBE_PADDING_SIZE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">no_packet:</span><br><span class="line">            sti-&gt;probe_packets = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!pd-&gt;buf_size) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_WARNING,</span><br><span class="line">                       <span class="string">&quot;nothing to probe for stream %d\n&quot;</span>, st-&gt;index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        end = si-&gt;raw_packet_buffer_size &gt;= s-&gt;probesize</span><br><span class="line">                || sti-&gt;probe_packets &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (end || <span class="built_in">av_log2</span>(pd-&gt;buf_size) != <span class="built_in">av_log2</span>(pd-&gt;buf_size - pkt-&gt;size)) &#123;</span><br><span class="line">            <span class="type">int</span> score = <span class="built_in">set_codec_from_probe_data</span>(s, st, pd);</span><br><span class="line">            <span class="keyword">if</span> (    (st-&gt;codecpar-&gt;codec_id != AV_CODEC_ID_NONE &amp;&amp; score &gt; AVPROBE_SCORE_STREAM_RETRY)</span><br><span class="line">                || end) &#123;</span><br><span class="line">                pd-&gt;buf_size = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">av_freep</span>(&amp;pd-&gt;buf);</span><br><span class="line">                sti-&gt;request_probe = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_id != AV_CODEC_ID_NONE) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(s, AV_LOG_DEBUG, <span class="string">&quot;probed stream %d\n&quot;</span>, st-&gt;index);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">av_log</span>(s, AV_LOG_WARNING, <span class="string">&quot;probed stream %d failed\n&quot;</span>, st-&gt;index);</span><br><span class="line">            &#125;</span><br><span class="line">            force_codec_ids(s, st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####### set_codec_from_probe_data</p><p>最后还是调用了 av_probe_input_format3，所以 probe 探测的就是 stream 该使用哪个 codec，具体就是确定 st-&gt;codecpar-&gt;codec_id、st-&gt;codecpar-&gt;codec_type 这几个变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">set_codec_from_probe_data</span><span class="params">(AVFormatContext *s, AVStream *st,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     AVProbeData *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">AVCodecID</span> id;</span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">AVMediaType</span> type;</span><br><span class="line">    &#125; fmt_id_type[] = &#123;</span><br><span class="line">        &#123; <span class="string">&quot;aac&quot;</span>,        AV_CODEC_ID_AAC,          AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;ac3&quot;</span>,        AV_CODEC_ID_AC3,          AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;aptx&quot;</span>,       AV_CODEC_ID_APTX,         AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;dts&quot;</span>,        AV_CODEC_ID_DTS,          AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;dvbsub&quot;</span>,     AV_CODEC_ID_DVB_SUBTITLE, AVMEDIA_TYPE_SUBTITLE &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;dvbtxt&quot;</span>,     AV_CODEC_ID_DVB_TELETEXT, AVMEDIA_TYPE_SUBTITLE &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;eac3&quot;</span>,       AV_CODEC_ID_EAC3,         AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;h264&quot;</span>,       AV_CODEC_ID_H264,         AVMEDIA_TYPE_VIDEO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;hevc&quot;</span>,       AV_CODEC_ID_HEVC,         AVMEDIA_TYPE_VIDEO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;loas&quot;</span>,       AV_CODEC_ID_AAC_LATM,     AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;m4v&quot;</span>,        AV_CODEC_ID_MPEG4,        AVMEDIA_TYPE_VIDEO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;mjpeg_2000&quot;</span>, AV_CODEC_ID_JPEG2000,     AVMEDIA_TYPE_VIDEO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;mp3&quot;</span>,        AV_CODEC_ID_MP3,          AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;mpegvideo&quot;</span>,  AV_CODEC_ID_MPEG2VIDEO,   AVMEDIA_TYPE_VIDEO    &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;truehd&quot;</span>,     AV_CODEC_ID_TRUEHD,       AVMEDIA_TYPE_AUDIO    &#125;,</span><br><span class="line">        &#123; <span class="number">0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="type">const</span> AVInputFormat *fmt = <span class="built_in">av_probe_input_format3</span>(pd, <span class="number">1</span>, &amp;score);</span><br><span class="line">    FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fmt) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(s, AV_LOG_DEBUG,</span><br><span class="line">               <span class="string">&quot;Probe with size=%d, packets=%d detected %s with score=%d\n&quot;</span>,</span><br><span class="line">               pd-&gt;buf_size, s-&gt;max_probe_packets - sti-&gt;probe_packets,</span><br><span class="line">               fmt-&gt;name, score);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; fmt_id_type[i].name; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(fmt-&gt;name, fmt_id_type[i].name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fmt_id_type[i].type != AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">                    st-&gt;codecpar-&gt;sample_rate)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (&lt;u&gt;sti-&gt;request_probe &gt; score&lt;/u&gt; &amp;&amp;</span><br><span class="line">                    &lt;u&gt;st-&gt;codecpar-&gt;codec_id != fmt_id_type[i].id&lt;/u&gt;)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                st-&gt;codecpar-&gt;codec_id   = fmt_id_type[i].id;</span><br><span class="line">                st-&gt;codecpar-&gt;codec_type = fmt_id_type[i].type;</span><br><span class="line">                sti-&gt;need_context_update = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> score;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="force-codec-ids"><a href="#force-codec-ids" class="headerlink" title="force_codec_ids"></a>force_codec_ids</h6><p>这个函数则是优先使用 AVFormatContext 上定义的 xxx_codec_id</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">force_codec_ids</span><span class="params">(AVFormatContext *s, AVStream *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (st-&gt;codecpar-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;video_codec_id)</span><br><span class="line">            st-&gt;codecpar-&gt;codec_id = s-&gt;video_codec_id;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;audio_codec_id)</span><br><span class="line">            st-&gt;codecpar-&gt;codec_id = s-&gt;audio_codec_id;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;subtitle_codec_id)</span><br><span class="line">            st-&gt;codecpar-&gt;codec_id = s-&gt;subtitle_codec_id;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_DATA:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;data_codec_id)</span><br><span class="line">            st-&gt;codecpar-&gt;codec_id = s-&gt;data_codec_id;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="parse-packet"><a href="#parse-packet" class="headerlink" title="parse_packet"></a>parse_packet</h5><p>这个函数就是把 demuxer 得到的 AVPacket 进行解析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">parse_packet</span><span class="params">(AVFormatContext *s, AVPacket *pkt,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> stream_index, <span class="type">int</span> flush)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    &lt;u&gt;AVPacket *out_pkt = si-&gt;parse_pkt;&lt;/u&gt;</span><br><span class="line">    AVStream *st = s-&gt;streams[stream_index];</span><br><span class="line">    FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *data = pkt-&gt;data;</span><br><span class="line">    <span class="type">int</span> size = pkt-&gt;size;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>, got_output = flush;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!size &amp;&amp; !flush &amp;&amp; sti-&gt;parser-&gt;flags &amp; PARSER_FLAG_COMPLETE_FRAMES) &#123;</span><br><span class="line">        <span class="comment">// preserve 0-size sync packets</span></span><br><span class="line">        <span class="built_in">compute_pkt_fields</span>(s, st, sti-&gt;parser, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span> || (flush &amp;&amp; got_output)) &#123;</span><br><span class="line">        <span class="type">int64_t</span> next_pts = pkt-&gt;pts;</span><br><span class="line">        <span class="type">int64_t</span> next_dts = pkt-&gt;dts;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">        len = <span class="built_in">av_parser_parse2</span>(sti-&gt;parser, sti-&gt;avctx,</span><br><span class="line">                               &lt;u&gt;&amp;out_pkt-&gt;data&lt;/u&gt;, &lt;u&gt;&amp;out_pkt-&gt;size&lt;/u&gt;, &lt;u&gt;data&lt;/u&gt;, &lt;u&gt;size&lt;/u&gt;,</span><br><span class="line">                               pkt-&gt;pts, pkt-&gt;dts, pkt-&gt;pos);</span><br><span class="line"></span><br><span class="line">        pkt-&gt;pts = pkt-&gt;dts = AV_NOPTS_VALUE;</span><br><span class="line">        pkt-&gt;pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/* increment read pointer */</span></span><br><span class="line">        <span class="built_in">av_assert1</span>(data || !len);</span><br><span class="line">        data  = len ? data + len : data;</span><br><span class="line">        size -= len;</span><br><span class="line"></span><br><span class="line">        got_output = !!out_pkt-&gt;size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!out_pkt-&gt;size)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;buf &amp;&amp; out_pkt-&gt;data == pkt-&gt;data) &#123;</span><br><span class="line">            <span class="comment">/* reference pkt-&gt;buf only when out_pkt-&gt;data is guaranteed to point</span></span><br><span class="line"><span class="comment">             * to data in it and not in the parser&#x27;s internal buffer. */</span></span><br><span class="line">            <span class="comment">/* <span class="doctag">XXX:</span> Ensure this is the case with all parsers when sti-&gt;parser-&gt;flags</span></span><br><span class="line"><span class="comment">             * is PARSER_FLAG_COMPLETE_FRAMES and check for that instead? */</span></span><br><span class="line">            out_pkt-&gt;buf = <span class="built_in">av_buffer_ref</span>(pkt-&gt;buf);</span><br><span class="line">            <span class="keyword">if</span> (!out_pkt-&gt;buf) &#123;</span><br><span class="line">                ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = <span class="built_in">av_packet_make_refcounted</span>(out_pkt);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;side_data) &#123;</span><br><span class="line">            out_pkt-&gt;side_data       = pkt-&gt;side_data;</span><br><span class="line">            out_pkt-&gt;side_data_elems = pkt-&gt;side_data_elems;</span><br><span class="line">            pkt-&gt;side_data          = <span class="literal">NULL</span>;</span><br><span class="line">            pkt-&gt;side_data_elems    = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set the duration */</span></span><br><span class="line">        out_pkt-&gt;duration = (sti-&gt;parser-&gt;flags &amp; PARSER_FLAG_COMPLETE_FRAMES) ? pkt-&gt;duration : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;avctx-&gt;sample_rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                out_pkt-&gt;duration =</span><br><span class="line">                    <span class="built_in">av_rescale_q_rnd</span>(sti-&gt;parser-&gt;duration,</span><br><span class="line">                                     (AVRational) &#123; <span class="number">1</span>, sti-&gt;avctx-&gt;sample_rate &#125;,</span><br><span class="line">                                     st-&gt;time_base,</span><br><span class="line">                                     AV_ROUND_DOWN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out_pkt-&gt;stream_index = st-&gt;index;</span><br><span class="line">        out_pkt-&gt;pts          = sti-&gt;parser-&gt;pts;</span><br><span class="line">        out_pkt-&gt;dts          = sti-&gt;parser-&gt;dts;</span><br><span class="line">        out_pkt-&gt;pos          = sti-&gt;parser-&gt;pos;</span><br><span class="line">        out_pkt-&gt;flags       |= pkt-&gt;flags &amp; (AV_PKT_FLAG_DISCARD | AV_PKT_FLAG_CORRUPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;need_parsing == AVSTREAM_PARSE_FULL_RAW)</span><br><span class="line">            &lt;u&gt;out_pkt-&gt;pos&lt;/u&gt; = sti-&gt;parser-&gt;frame_offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;parser-&gt;key_frame == <span class="number">1</span> ||</span><br><span class="line">            (sti-&gt;parser-&gt;key_frame == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">             sti-&gt;parser-&gt;pict_type == AV_PICTURE_TYPE_I))</span><br><span class="line">            out_pkt-&gt;flags |= AV_PKT_FLAG_KEY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;parser-&gt;key_frame == <span class="number">-1</span> &amp;&amp; sti-&gt;parser-&gt;pict_type ==AV_PICTURE_TYPE_NONE &amp;&amp; (pkt-&gt;flags&amp;AV_PKT_FLAG_KEY))</span><br><span class="line">            out_pkt-&gt;flags |= AV_PKT_FLAG_KEY;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">compute_pkt_fields</span>(s, st, sti-&gt;parser, out_pkt, next_dts, next_pts);</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">avpriv_packet_list_put</span>(&amp;si-&gt;parse_queue,</span><br><span class="line">                                     out_pkt, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* end of the stream =&gt; close and free the parser */</span></span><br><span class="line">    <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">        <span class="built_in">av_parser_close</span>(sti-&gt;parser);</span><br><span class="line">        sti-&gt;parser = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">av_packet_unref</span>(out_pkt);</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try-decode-frame"><a href="#try-decode-frame" class="headerlink" title="try_decode_frame"></a>try_decode_frame</h4><p>尝试对 packet 进行解码，说实话我也不知道这样做是为什么。但是经过调试之后发现经过 try_decode_frame 后 h264 解码器会设置 avctx-&gt;pix_fmt，而这个参数恰好是 has_codec_parameters 函数需要检查的，所以可能有些参数直到解码之后才能确定，这里尝试解码可能就是为了获得这些参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* returns 1 or 0 if or if not decoded data was returned, or a negative error */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">try_decode_frame</span><span class="params">(AVFormatContext *s, AVStream *st,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> AVPacket *avpkt, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">    AVCodecContext *<span class="type">const</span> avctx = sti-&gt;avctx;</span><br><span class="line">    <span class="type">const</span> AVCodec *codec;</span><br><span class="line">    <span class="type">int</span> got_picture = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    AVFrame *frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">    AVSubtitle subtitle;</span><br><span class="line">    AVPacket pkt = *avpkt;</span><br><span class="line">    <span class="type">int</span> do_skip_frame = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVDiscard</span> skip_frame;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">avcodec_is_open</span>(avctx) &amp;&amp;</span><br><span class="line">        sti-&gt;info-&gt;found_decoder &lt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (st-&gt;codecpar-&gt;codec_id != -sti-&gt;info-&gt;found_decoder || !st-&gt;codecpar-&gt;codec_id)) &#123;</span><br><span class="line">        AVDictionary *thread_opt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        codec = <span class="built_in">find_probe_decoder</span>(s, st, st-&gt;codecpar-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!codec) &#123;</span><br><span class="line">            sti-&gt;info-&gt;found_decoder = -st-&gt;codecpar-&gt;codec_id;</span><br><span class="line">            ret                     = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">avcodec_open2</span>(avctx, codec, options ? options : &amp;thread_opt);</span><br><span class="line">        <span class="keyword">if</span> (!options)</span><br><span class="line">            <span class="built_in">av_dict_free</span>(&amp;thread_opt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sti-&gt;info-&gt;found_decoder = -avctx-&gt;codec_id;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        sti-&gt;info-&gt;found_decoder = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!sti-&gt;info-&gt;found_decoder)</span><br><span class="line">        sti-&gt;info-&gt;found_decoder = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sti-&gt;info-&gt;found_decoder &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avpriv_codec_get_cap_skip_frame_fill_param</span>(avctx-&gt;codec)) &#123;</span><br><span class="line">        do_skip_frame = <span class="number">1</span>;</span><br><span class="line">        skip_frame = avctx-&gt;skip_frame;</span><br><span class="line">        avctx-&gt;skip_frame = AVDISCARD_ALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pkt.size &gt; <span class="number">0</span> || (!pkt.data &amp;&amp; got_picture)) &amp;&amp;</span><br><span class="line">           ret &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (!<span class="built_in">has_codec_parameters</span>(st, <span class="literal">NULL</span>) || !<span class="built_in">has_decode_delay_been_guessed</span>(st) ||</span><br><span class="line">            (!sti-&gt;codec_info_nb_frames &amp;&amp;</span><br><span class="line">             (avctx-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_CHANNEL_CONF)))) &#123;</span><br><span class="line">        got_picture = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||</span><br><span class="line">            avctx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            ret = <span class="built_in">avcodec_send_packet</span>(avctx, &amp;pkt);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != <span class="built_in">AVERROR</span>(EAGAIN) &amp;&amp; ret != AVERROR_EOF)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">                pkt.size = <span class="number">0</span>;</span><br><span class="line">            ret = <span class="built_in">avcodec_receive_frame</span>(avctx, frame);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">                got_picture = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF)</span><br><span class="line">                ret = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line">            ret = <span class="built_in">avcodec_decode_subtitle2</span>(avctx, &amp;subtitle,</span><br><span class="line">                                           &amp;got_picture, &amp;pkt);</span><br><span class="line">            <span class="keyword">if</span> (got_picture)</span><br><span class="line">                <span class="built_in">avsubtitle_free</span>(&amp;subtitle);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">                pkt.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (got_picture)</span><br><span class="line">                sti-&gt;nb_decoded_frames++;</span><br><span class="line">            ret       = got_picture;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">if</span> (do_skip_frame) &#123;</span><br><span class="line">        avctx-&gt;skip_frame = skip_frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="part-3"><a href="#part-3" class="headerlink" title="part 3"></a>part 3</h3><p>第三部分则是一些收尾工作。</p><p>前面都是对 AVStream 和 AVCodecContext 上的参数做一些调整，在最后面把 AVCodecContext 的参数拷贝回 AVStream，结合前面，可以得到整个流程：</p><ul><li>首先 read_head 创建 AVStream，并往 AVStream 中设置部分信息</li><li>然后把 AVStream 的信息拷贝到 AVCodecContext</li><li>然后尝试解码，解码过程可能更新 AVCodecContext，最后再把更新过的 AVCodecContext 拷贝回 AVStream</li></ul><p>在最后又把 AVCodecContext 给关掉了，所以后面还要自己再重新创建 AVCodecContext</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_find_stream_info</span><span class="params">(AVFormatContext *ic, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (eof_reached) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flush_codecs) &#123;</span><br><span class="line">        AVPacket *empty_pkt = si-&gt;pkt;</span><br><span class="line">        <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">av_packet_unref</span>(empty_pkt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">            AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">            FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* flush the decoders */</span></span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;info-&gt;found_decoder == <span class="number">1</span>) &#123;</span><br><span class="line">                err = <span class="built_in">try_decode_frame</span>(ic, st, empty_pkt,</span><br><span class="line">                                        (options &amp;&amp; i &lt; orig_nb_streams)</span><br><span class="line">                                        ? &amp;options[i] : <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(ic, AV_LOG_INFO,</span><br><span class="line">                        <span class="string">&quot;decoding for stream %d failed\n&quot;</span>, st-&gt;index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ff_rfps_calculate</span>(ic);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        AVCodecContext *<span class="type">const</span> avctx = sti-&gt;avctx;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            <span class="keyword">if</span> (avctx-&gt;codec_id == AV_CODEC_ID_RAWVIDEO &amp;&amp; !avctx-&gt;codec_tag &amp;&amp; !avctx-&gt;bits_per_coded_sample) &#123;</span><br><span class="line">                <span class="type">uint32_t</span> tag= <span class="built_in">avcodec_pix_fmt_to_codec_tag</span>(avctx-&gt;pix_fmt);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">avpriv_pix_fmt_find</span>(PIX_FMT_LIST_RAW, tag) == avctx-&gt;pix_fmt)</span><br><span class="line">                    avctx-&gt;codec_tag= tag;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* estimate average framerate if not set by demuxer */</span></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!st-&gt;r_frame_rate.num) &#123;</span><br><span class="line">                <span class="keyword">if</span> (    avctx-&gt;time_base.den * (<span class="type">int64_t</span>) st-&gt;time_base.num</span><br><span class="line">                    &lt;= avctx-&gt;time_base.num * (<span class="type">uint64_t</span>)avctx-&gt;ticks_per_frame * st-&gt;time_base.den) &#123;</span><br><span class="line">                    <span class="built_in">av_reduce</span>(&amp;st-&gt;r_frame_rate.num, &amp;st-&gt;r_frame_rate.den,</span><br><span class="line">                              avctx-&gt;time_base.den, (<span class="type">int64_t</span>)avctx-&gt;time_base.num * avctx-&gt;ticks_per_frame, INT_MAX);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    st-&gt;r_frame_rate.num = st-&gt;time_base.den;</span><br><span class="line">                    st-&gt;r_frame_rate.den = st-&gt;time_base.num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sti-&gt;display_aspect_ratio.num &amp;&amp; sti-&gt;display_aspect_ratio.den) &#123;</span><br><span class="line">                AVRational hw_ratio = &#123; avctx-&gt;height, avctx-&gt;width &#125;;</span><br><span class="line">                st-&gt;sample_aspect_ratio = <span class="built_in">av_mul_q</span>(sti-&gt;display_aspect_ratio,</span><br><span class="line">                                                   hw_ratio);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!avctx-&gt;bits_per_coded_sample)</span><br><span class="line">                avctx-&gt;bits_per_coded_sample =</span><br><span class="line">                    <span class="built_in">av_get_bits_per_sample</span>(avctx-&gt;codec_id);</span><br><span class="line">            <span class="comment">// set stream disposition based on audio service type</span></span><br><span class="line">            <span class="keyword">switch</span> (avctx-&gt;audio_service_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> AV_AUDIO_SERVICE_TYPE_EFFECTS:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_CLEAN_EFFECTS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_VISUAL_IMPAIRED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_HEARING_IMPAIRED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AV_AUDIO_SERVICE_TYPE_COMMENTARY:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_COMMENT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AV_AUDIO_SERVICE_TYPE_KARAOKE:</span><br><span class="line">                st-&gt;disposition = AV_DISPOSITION_KARAOKE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (probesize)</span><br><span class="line">        <span class="built_in">estimate_timings</span>(ic, old_offset);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_opt_set_int</span>(ic, <span class="string">&quot;skip_clear&quot;</span>, <span class="number">0</span>, AV_OPT_SEARCH_CHILDREN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span> &amp;&amp; ic-&gt;nb_streams)</span><br><span class="line">        <span class="comment">/* We could not have all the codec parameters before EOF. */</span></span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *errmsg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* if no packet was ever seen, update context now for has_codec_parameters */</span></span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;avctx_inited) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">                st-&gt;codecpar-&gt;format == AV_SAMPLE_FMT_NONE)</span><br><span class="line">                st-&gt;codecpar-&gt;format = sti-&gt;avctx-&gt;sample_fmt;</span><br><span class="line">            ret = <span class="built_in">avcodec_parameters_to_context</span>(sti-&gt;avctx, st-&gt;codecpar);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> find_stream_info_err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">has_codec_parameters</span>(st, &amp;errmsg)) &#123;</span><br><span class="line">            <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">            <span class="built_in">avcodec_string</span>(buf, <span class="built_in">sizeof</span>(buf), sti-&gt;avctx, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">av_log</span>(ic, AV_LOG_WARNING,</span><br><span class="line">                   <span class="string">&quot;Could not find codec parameters for stream %d (%s): %s\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;Consider increasing the value for the &#x27;analyzeduration&#x27; (%&quot;</span>PRId64<span class="string">&quot;) and &#x27;probesize&#x27; (%&quot;</span>PRId64<span class="string">&quot;) options\n&quot;</span>,</span><br><span class="line">                   i, buf, errmsg, ic-&gt;max_analyze_duration, ic-&gt;probesize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">compute_chapters_end</span>(ic);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> find_stream_info_err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update the stream parameters from the internal codec contexts */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;avctx_inited) &#123;</span><br><span class="line">            ret = <span class="built_in">avcodec_parameters_from_context</span>(st-&gt;codecpar, sti-&gt;avctx);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> find_stream_info_err;</span><br><span class="line">            ret = <span class="built_in">add_coded_side_data</span>(st, sti-&gt;avctx);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> find_stream_info_err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sti-&gt;avctx_inited = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">find_stream_info_err:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = ic-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;info) &#123;</span><br><span class="line">            <span class="built_in">av_freep</span>(&amp;sti-&gt;info-&gt;duration_error);</span><br><span class="line">            <span class="built_in">av_freep</span>(&amp;sti-&gt;info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">avcodec_close</span>(sti-&gt;avctx);</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> avcodec_close() frees AVOption settable fields which includes ch_layout,</span></span><br><span class="line">        <span class="comment">//        so we need to restore it.</span></span><br><span class="line">        <span class="built_in">av_channel_layout_copy</span>(&amp;sti-&gt;avctx-&gt;ch_layout, &amp;st-&gt;codecpar-&gt;ch_layout);</span><br><span class="line">        <span class="built_in">av_bsf_free</span>(&amp;sti-&gt;extract_extradata.bsf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ic-&gt;pb) &#123;</span><br><span class="line">        FFIOContext *<span class="type">const</span> ctx = <span class="built_in">ffiocontext</span>(ic-&gt;pb);</span><br><span class="line">        <span class="built_in">av_log</span>(ic, AV_LOG_DEBUG, <span class="string">&quot;After avformat_find_stream_info() pos: %&quot;</span>PRId64<span class="string">&quot; bytes read:%&quot;</span>PRId64<span class="string">&quot; seeks:%d frames:%d\n&quot;</span>,</span><br><span class="line">               <span class="built_in">avio_tell</span>(ic-&gt;pb), ctx-&gt;bytes_read, ctx-&gt;seek_count, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">unref_then_goto_end:</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(pkt1);</span><br><span class="line">    <span class="keyword">goto</span> find_stream_info_err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg 之 demuxer/decoder 相关 api (一)</title>
      <link href="/2023/05/10/ffmpeg-%E4%B9%8B-demuxer-decoder-%E7%9B%B8%E5%85%B3-api-%E4%B8%80/"/>
      <url>/2023/05/10/ffmpeg-%E4%B9%8B-demuxer-decoder-%E7%9B%B8%E5%85%B3-api-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>上篇文章介绍了 muxer 和 encoder 的 api，这篇文章介绍一下 demuxer 和 decoder 的 api。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>还是以一个例子为研究对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* format_name = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span> AVInputFormat *iformat = <span class="built_in">av_find_input_format</span>(format_name);</span><br><span class="line"><span class="type">char</span>* filename;</span><br><span class="line"></span><br><span class="line">AVFormatContext *format_ctx = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line"></span><br><span class="line">format_ctx-&gt;interrupt_callback.callback = ...;</span><br><span class="line">format_ctx-&gt;interrupt_callback.opaque = ...;</span><br><span class="line"></span><br><span class="line">AVDictionary *format_opt;</span><br><span class="line"><span class="built_in">avformat_open_input</span>(&amp;format_ctx, filename, iformat, &amp;format_opt);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avformat_find_stream_info</span>(format_ctx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; format_ctx-&gt;nb_streams; i++)</span><br><span class="line">    format_ctx-&gt;streams[i]-&gt;discard = AVDISCARD_ALL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========</span></span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line">idx = <span class="built_in">av_find_best_stream</span>(format_ctx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">AVStream *video_stream = format_ctx-&gt;streams[idx];</span><br><span class="line"></span><br><span class="line">AVCodecParameters *codecpar = video_stream-&gt;codecpar;</span><br><span class="line"><span class="type">const</span> AVCodec *video_codec = <span class="built_in">avcodec_find_decoder</span>(codecpar-&gt;codec_id);</span><br><span class="line">AVCodecContext *video_codec_ctx = <span class="built_in">avcodec_alloc_context3</span>(video_codec);</span><br><span class="line"><span class="built_in">avcodec_parameters_to_context</span>(video_codec_ctx, codecpar);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avcodec_open2</span>(video_codec_ctx, video_codec, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">format_ctx-&gt;streams[idx]-&gt;discard = AVDISCARD_DEFAULT;</span><br><span class="line"></span><br><span class="line">video_stream-&gt;index;</span><br><span class="line">video_stream-&gt;time_base;</span><br><span class="line">video_stream-&gt;r_frame_rate;</span><br><span class="line">&lt;u&gt;video_codec_ctx-&gt;pkt_timebase = video_stream-&gt;time_base;&lt;/u&gt;</span><br><span class="line"><span class="comment">// ===========</span></span><br><span class="line"><span class="comment">// ===========</span></span><br><span class="line">idx = <span class="built_in">av_find_best_stream</span>(format_ctx, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">AVStream *audio_stream = format_ctx-&gt;streams[idx];</span><br><span class="line"></span><br><span class="line">AVCodecParameters *codecpar = audio_stream-&gt;codecpar;</span><br><span class="line"><span class="type">const</span> AVCodec *audio_codec = <span class="built_in">avcodec_find_decoder</span>(codecpar-&gt;codec_id);</span><br><span class="line">AVCodecContext *audio_codec_ctx = <span class="built_in">avcodec_alloc_context3</span>(audio_codec);</span><br><span class="line"><span class="built_in">avcodec_parameters_to_context</span>(audio_codec_ctx, codecpar);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avcodec_open2</span>(audio_codec_ctx, audio_codec, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">format_ctx-&gt;streams[idx]-&gt;discard = AVDISCARD_DEFAULT;</span><br><span class="line"></span><br><span class="line">audio_stream-&gt;index;</span><br><span class="line">audio_stream-&gt;time_base;</span><br><span class="line">audio_stream-&gt;r_frame_rate;</span><br><span class="line">audio_codec_ctx-&gt;pkt_timebase = audio_stream-&gt;time_base;</span><br><span class="line"><span class="comment">// ===========</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> timestamp;</span><br><span class="line"><span class="built_in">avformat_seek_file</span>(format_ctx, <span class="number">-1</span>, INT64_MIN, timestamp, INT64_MAX, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">avcodec_flush_buffers</span>(video_codec_ctx);</span><br><span class="line"><span class="built_in">avcodec_flush_buffers</span>(audio_codec_ctx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AVFrame *frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">ret = <span class="built_in">avcodec_receive_frame</span>(audio_codec_ctx, frame);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN)) &#123;</span><br><span class="line">    AVPacket pkt = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ret = <span class="built_in">av_read_frame</span>(format_ctx, &amp;pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret == AVERROR_EOF)</span><br><span class="line">        <span class="built_in">avcodec_send_packet</span>(audio_codec_ctx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">avcodec_send_packet</span>(audio_codec_ctx, &amp;pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="av-find-input-format"><a href="#av-find-input-format" class="headerlink" title="av_find_input_format"></a>av_find_input_format</h2><p>通过 AVInputFormat.name 进行匹配找到 AVInputFormat</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVInputFormat *<span class="title">av_find_input_format</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *short_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVInputFormat *fmt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span> *i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((fmt = <span class="built_in">av_demuxer_iterate</span>(&amp;i)))</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">av_match_name</span>(short_name, fmt-&gt;name))</span><br><span class="line">            <span class="keyword">return</span> fmt;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avformat-alloc-context"><a href="#avformat-alloc-context" class="headerlink" title="avformat_alloc_context"></a>avformat_alloc_context</h2><p>这个和 muxer 的时候是一样的，分配 AVFormatContext 的内存</p><h2 id="avformat-open-input"><a href="#avformat-open-input" class="headerlink" title="avformat_open_input"></a>avformat_open_input</h2><p>这个函数打开一个输入源并读取头部，fmt 参数可以为空，这样自动根据 filename 来探测 fmt，事实上 AVFormatContext 也可以让这个函数自己分配，传一个空的 AVFormatContext*也可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="type">const</span> <span class="type">char</span> *filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> AVInputFormat *fmt, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFormatContext *s = *ps;</span><br><span class="line">    FFFormatContext *si;</span><br><span class="line">    AVDictionary *tmp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_ID3</span></span><br><span class="line">    ID3v2ExtraMeta *id3v2_extra_meta = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (&lt;u&gt;!s &amp;&amp; !(s = <span class="built_in">avformat_alloc_context</span>())&lt;/u&gt;)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">    si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (fmt)</span><br><span class="line">        s-&gt;iformat = fmt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options)</span><br><span class="line">        <span class="built_in">av_dict_copy</span>(&amp;tmp, *options, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;pb) <span class="comment">// must be before any goto fail</span></span><br><span class="line">        s-&gt;flags |= AVFMT_FLAG_CUSTOM_IO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_opt_set_dict</span>(s, &amp;tmp)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(s-&gt;url = <span class="built_in">av_strdup</span>(filename ? filename : <span class="string">&quot;&quot;</span>))) &#123;</span><br><span class="line">        ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">init_input</span>(s, filename, &amp;tmp)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    s-&gt;probe_score = ret;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">avio_skip</span>(s-&gt;pb, s-&gt;skip_initial_bytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check filename in case an image number is expected. */</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;iformat-&gt;flags &amp; AVFMT_NEEDNUMBER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">av_filename_number_test</span>(filename)) &#123;</span><br><span class="line">            ret = <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;duration = s-&gt;start_time = AV_NOPTS_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate private data. */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* e.g. AVFMT_NOFILE formats will not have an AVIOContext */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_ID3</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;pb)</span><br><span class="line">        <span class="built_in">ff_id3v2_read_dict</span>(s-&gt;pb, &amp;si-&gt;id3v2_meta, ID3v2_DEFAULT_MAGIC, &amp;id3v2_extra_meta);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;iformat-&gt;init) &#123;</span><br><span class="line">        ret = s-&gt;iformat-&gt;<span class="built_in">init</span>(s);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(s-&gt;flags &amp; AVFMT_FLAG_PRIV_OPT) &amp;&amp; s-&gt;iformat-&gt;read_header)</span><br><span class="line">        <span class="keyword">if</span> ((ret = s-&gt;iformat-&gt;<span class="built_in">read_header</span>(s)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;iformat-&gt;flags_internal &amp; FF_FMT_INIT_CLEANUP)</span><br><span class="line">                <span class="keyword">goto</span> close;</span><br><span class="line">            <span class="keyword">goto</span> deinit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_ID3</span></span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;metadata) &#123;</span><br><span class="line">        s-&gt;metadata    = si-&gt;id3v2_meta;</span><br><span class="line">        si-&gt;id3v2_meta = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (si-&gt;id3v2_meta) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(s, AV_LOG_WARNING, <span class="string">&quot;Discarding ID3 tags because more suitable tags were found.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">av_dict_free</span>(&amp;si-&gt;id3v2_meta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id3v2_extra_meta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(s-&gt;iformat-&gt;name, <span class="string">&quot;mp3&quot;</span>) || !<span class="built_in">strcmp</span>(s-&gt;iformat-&gt;name, <span class="string">&quot;aac&quot;</span>) ||</span><br><span class="line">            !<span class="built_in">strcmp</span>(s-&gt;iformat-&gt;name, <span class="string">&quot;tta&quot;</span>) || !<span class="built_in">strcmp</span>(s-&gt;iformat-&gt;name, <span class="string">&quot;wav&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">ff_id3v2_parse_apic</span>(s, id3v2_extra_meta)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> close;</span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">ff_id3v2_parse_chapters</span>(s, id3v2_extra_meta)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> close;</span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">ff_id3v2_parse_priv</span>(s, id3v2_extra_meta)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> close;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">av_log</span>(s, AV_LOG_DEBUG, <span class="string">&quot;demuxer does not support additional id3 data, skipping\n&quot;</span>);</span><br><span class="line">        <span class="built_in">ff_id3v2_free_extra_meta</span>(&amp;id3v2_extra_meta);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">avformat_queue_attached_pictures</span>(s)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> close;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;pb &amp;&amp; !si-&gt;data_offset)</span><br><span class="line">        si-&gt;data_offset = <span class="built_in">avio_tell</span>(s-&gt;pb);</span><br><span class="line"></span><br><span class="line">    si-&gt;raw_packet_buffer_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">update_stream_avctx</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">        <span class="built_in">av_dict_free</span>(options);</span><br><span class="line">        *options = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    *ps = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="init-input"><a href="#init-input" class="headerlink" title="init_input"></a>init_input</h3><p>先通过 av_probe_input_format2 使用文件名来探测格式，然后打开 AVIOContext，如果 av_probe_input_format2 失败，再尝试 av_probe_input_buffer2 读取部分文件内容来探测格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">init_input</span><span class="params">(AVFormatContext *s, <span class="type">const</span> <span class="type">char</span> *filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                      AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    AVProbeData pd = &#123; filename, <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> score = AVPROBE_SCORE_RETRY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;pb) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((s-&gt;iformat &amp;&amp; s-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE) ||</span><br><span class="line">        (!s-&gt;iformat &amp;&amp; (s-&gt;iformat = <span class="built_in">av_probe_input_format2</span>(&amp;pd, <span class="number">0</span>, &amp;score))))</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = s-&gt;<span class="built_in">io_open</span>(s, &amp;s-&gt;pb, filename, AVIO_FLAG_READ | s-&gt;avio_flags, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;iformat)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">av_probe_input_buffer2</span>(s-&gt;pb, &amp;s-&gt;iformat, filename,</span><br><span class="line">                                  s, <span class="number">0</span>, s-&gt;format_probesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="av-probe-input-format2"><a href="#av-probe-input-format2" class="headerlink" title="av_probe_input_format2"></a>av_probe_input_format2</h4><p>这个函数通过文件名来探测封装格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVInputFormat *<span class="title">av_probe_input_format2</span><span class="params">(<span class="type">const</span> AVProbeData *pd,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int</span> is_opened, <span class="type">int</span> *score_max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> score_ret;</span><br><span class="line">    <span class="type">const</span> AVInputFormat *fmt = <span class="built_in">av_probe_input_format3</span>(pd, is_opened, &amp;score_ret);</span><br><span class="line">    <span class="keyword">if</span> (score_ret &gt; *score_max) &#123;</span><br><span class="line">        *score_max = score_ret;</span><br><span class="line">        <span class="keyword">return</span> fmt;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="av-probe-input-format3"><a href="#av-probe-input-format3" class="headerlink" title="av_probe_input_format3"></a>av_probe_input_format3</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This structure contains the data a format has to probe a file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVProbeData</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buf; <span class="comment">/**&lt; Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero. */</span></span><br><span class="line">    <span class="type">int</span> buf_size;       <span class="comment">/**&lt; Size of buf except extra allocated bytes */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mime_type; <span class="comment">/**&lt; mime_type, when known. */</span></span><br><span class="line">&#125; AVProbeData;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVInputFormat *<span class="title">av_probe_input_format3</span><span class="params">(<span class="type">const</span> AVProbeData *pd,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int</span> is_opened, <span class="type">int</span> *score_ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVProbeData lpd = *pd;</span><br><span class="line">    <span class="type">const</span> AVInputFormat *fmt1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> AVInputFormat *fmt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> score, score_max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span> *i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">uint8_t</span> zerobuffer[AVPROBE_PADDING_SIZE];</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_ID3</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">nodat</span> &#123;</span><br><span class="line">        NO_ID3,</span><br><span class="line">        ID3_ALMOST_GREATER_PROBE,</span><br><span class="line">        ID3_GREATER_PROBE,</span><br><span class="line">        ID3_GREATER_MAX_PROBE,</span><br><span class="line">    &#125; nodat = NO_ID3;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!lpd.buf)</span><br><span class="line">        lpd.buf = (<span class="type">unsigned</span> <span class="type">char</span> *) zerobuffer;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_ID3</span></span><br><span class="line">    <span class="keyword">if</span> (lpd.buf_size &gt; <span class="number">10</span> &amp;&amp; <span class="built_in">ff_id3v2_match</span>(lpd.buf, ID3v2_DEFAULT_MAGIC)) &#123;</span><br><span class="line">        <span class="type">int</span> id3len = <span class="built_in">ff_id3v2_tag_len</span>(lpd.buf);</span><br><span class="line">        <span class="keyword">if</span> (lpd.buf_size &gt; id3len + <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lpd.buf_size &lt; <span class="number">2LL</span>*id3len + <span class="number">16</span>)</span><br><span class="line">                nodat = ID3_ALMOST_GREATER_PROBE;</span><br><span class="line">            lpd.buf      += id3len;</span><br><span class="line">            lpd.buf_size -= id3len;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id3len &gt;= PROBE_BUF_MAX) &#123;</span><br><span class="line">            nodat = ID3_GREATER_MAX_PROBE;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            nodat = ID3_GREATER_PROBE;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((fmt1 = <span class="built_in">av_demuxer_iterate</span>(&amp;i))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fmt1-&gt;flags &amp; AVFMT_EXPERIMENTAL)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!is_opened == !(fmt1-&gt;flags &amp; AVFMT_NOFILE) &amp;&amp; <span class="built_in">strcmp</span>(fmt1-&gt;name, <span class="string">&quot;image2&quot;</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fmt1-&gt;read_probe) &#123;</span><br><span class="line">            score = fmt1-&gt;<span class="built_in">read_probe</span>(&amp;lpd);</span><br><span class="line">            <span class="keyword">if</span> (score)</span><br><span class="line">                <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_TRACE, <span class="string">&quot;Probing %s score:%d size:%d\n&quot;</span>, fmt1-&gt;name, score, lpd.buf_size);</span><br><span class="line">            <span class="keyword">if</span> (fmt1-&gt;extensions &amp;&amp; <span class="built_in">av_match_ext</span>(lpd.filename, fmt1-&gt;extensions)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_ID3</span></span><br><span class="line">                <span class="keyword">switch</span> (nodat) &#123;</span><br><span class="line">                <span class="keyword">case</span> NO_ID3:</span><br><span class="line">                    score = <span class="built_in">FFMAX</span>(score, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ID3_GREATER_PROBE:</span><br><span class="line">                <span class="keyword">case</span> ID3_ALMOST_GREATER_PROBE:</span><br><span class="line">                    score = <span class="built_in">FFMAX</span>(score, AVPROBE_SCORE_EXTENSION / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ID3_GREATER_MAX_PROBE:</span><br><span class="line">                    score = <span class="built_in">FFMAX</span>(score, AVPROBE_SCORE_EXTENSION);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                score = <span class="built_in">FFMAX</span>(score, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fmt1-&gt;extensions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">av_match_ext</span>(lpd.filename, fmt1-&gt;extensions))</span><br><span class="line">                score = AVPROBE_SCORE_EXTENSION;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">av_match_name</span>(lpd.mime_type, fmt1-&gt;mime_type)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (AVPROBE_SCORE_MIME &gt; score) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">&quot;Probing %s score:%d increased to %d due to MIME type\n&quot;</span>, fmt1-&gt;name, score, AVPROBE_SCORE_MIME);</span><br><span class="line">                score = AVPROBE_SCORE_MIME;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (score &gt; score_max) &#123;</span><br><span class="line">            score_max = score;</span><br><span class="line">            fmt       = fmt1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score == score_max)</span><br><span class="line">            fmt = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_ID3</span></span><br><span class="line">    <span class="keyword">if</span> (nodat == ID3_GREATER_PROBE)</span><br><span class="line">        score_max = <span class="built_in">FFMIN</span>(AVPROBE_SCORE_EXTENSION / <span class="number">2</span> - <span class="number">1</span>, score_max);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    *score_ret = score_max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数的核心是尝试通过 read_probe 函数和文件名来确定使用哪个 AVInputFormat</p><h4 id="s-gt-io-open"><a href="#s-gt-io-open" class="headerlink" title="s-&gt;io_open"></a>s-&gt;io_open</h4><p>这个函数打开 AVIOContext，io_open 默认就是 io_open_default</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVFormatContext *<span class="title">avformat_alloc_context</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    s-&gt;io_open  = io_open_default;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">io_open_default</span><span class="params">(AVFormatContext *s, AVIOContext **pb,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> <span class="type">char</span> *url, <span class="type">int</span> flags, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> loglevel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(url, s-&gt;url) ||</span><br><span class="line">        s-&gt;iformat &amp;&amp; !<span class="built_in">strcmp</span>(s-&gt;iformat-&gt;name, <span class="string">&quot;image2&quot;</span>) ||</span><br><span class="line">        s-&gt;oformat &amp;&amp; !<span class="built_in">strcmp</span>(s-&gt;oformat-&gt;name, <span class="string">&quot;image2&quot;</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">        loglevel = AV_LOG_DEBUG;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        loglevel = AV_LOG_INFO;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_log</span>(s, loglevel, <span class="string">&quot;Opening \&#x27;%s\&#x27; for %s\n&quot;</span>, url, flags &amp; AVIO_FLAG_WRITE ? <span class="string">&quot;writing&quot;</span> : <span class="string">&quot;reading&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ffio_open_whitelist</span>(pb, url, flags, &amp;s-&gt;interrupt_callback, options, s-&gt;protocol_whitelist, s-&gt;protocol_blacklist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ffio_open_whitelist 放在后面专门的 ffmpeg IO 的文章来介绍，这里先略过，我们只需要知道，调用 s-&gt;io_open 后就打开了输入源</p><h4 id="av-probe-input-buffer2"><a href="#av-probe-input-buffer2" class="headerlink" title="av_probe_input_buffer2"></a>av_probe_input_buffer2</h4><p>这个函数要求在 AVIOContext 已经创建之后才执行，他只有在不知道 AVInputFormat 时才执行，比如上面 av_probe_input_format2 探测时发现文件名没有后缀，则无法确定该使用哪个 AVInputFormat。在 AVIOContext 已经创建之后可以通过读取部分输入源的内容来探测输入源的格式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_probe_input_buffer2</span><span class="params">(AVIOContext *pb, <span class="type">const</span> AVInputFormat **fmt,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">void</span> *logctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> max_probe_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVProbeData pd = &#123; filename ? filename : <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">    <span class="type">uint8_t</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>, probe_size, buf_offset = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!max_probe_size)</span><br><span class="line">        max_probe_size = PROBE_BUF_MAX;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (max_probe_size &lt; PROBE_BUF_MIN) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(logctx, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;Specified probe size value %u cannot be &lt; %u\n&quot;</span>, max_probe_size, PROBE_BUF_MIN);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= max_probe_size)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pb-&gt;av_class) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> *mime_type_opt = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">char</span> *semi;</span><br><span class="line">        <span class="built_in">av_opt_get</span>(pb, <span class="string">&quot;mime_type&quot;</span>, AV_OPT_SEARCH_CHILDREN, &amp;mime_type_opt);</span><br><span class="line">        pd.mime_type = (<span class="type">const</span> <span class="type">char</span> *)mime_type_opt;</span><br><span class="line">        semi = pd.mime_type ? <span class="built_in">strchr</span>(pd.mime_type, <span class="string">&#x27;;&#x27;</span>) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (semi) &#123;</span><br><span class="line">            *semi = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (probe_size = PROBE_BUF_MIN; probe_size &lt;= max_probe_size &amp;&amp; !*fmt;</span><br><span class="line">         probe_size = <span class="built_in">FFMIN</span>(probe_size &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                            <span class="built_in">FFMAX</span>(max_probe_size, probe_size + <span class="number">1</span>))) &#123;</span><br><span class="line">        score = probe_size &lt; max_probe_size ? AVPROBE_SCORE_RETRY : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read probe data. */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = <span class="built_in">av_reallocp</span>(&amp;buf, probe_size + AVPROBE_PADDING_SIZE)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        <span class="keyword">if</span> ((ret = <span class="built_in">avio_read</span>(pb, buf + buf_offset,</span><br><span class="line">                             probe_size - buf_offset)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Fail if error was not end of file, otherwise, lower score. */</span></span><br><span class="line">            <span class="keyword">if</span> (ret != AVERROR_EOF)</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">            score = <span class="number">0</span>;</span><br><span class="line">            ret   = <span class="number">0</span>;          <span class="comment">/* error was end of file, nothing read */</span></span><br><span class="line">        &#125;</span><br><span class="line">        buf_offset += ret;</span><br><span class="line">        <span class="keyword">if</span> (buf_offset &lt; offset)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        pd.buf_size = buf_offset - offset;</span><br><span class="line">        pd.buf = &amp;buf[offset];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(pd.buf + pd.buf_size, <span class="number">0</span>, AVPROBE_PADDING_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Guess file format. */</span></span><br><span class="line">        *fmt = <span class="built_in">av_probe_input_format2</span>(&amp;pd, <span class="number">1</span>, &amp;score);</span><br><span class="line">        <span class="keyword">if</span> (*fmt) &#123;</span><br><span class="line">            <span class="comment">/* This can only be true in the last iteration. */</span></span><br><span class="line">            <span class="keyword">if</span> (score &lt;= AVPROBE_SCORE_RETRY) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(logctx, AV_LOG_WARNING,</span><br><span class="line">                       <span class="string">&quot;Format %s detected only with low score of %d, &quot;</span></span><br><span class="line">                       <span class="string">&quot;misdetection possible!\n&quot;</span>, (*fmt)-&gt;name, score);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">av_log</span>(logctx, AV_LOG_DEBUG,</span><br><span class="line">                       <span class="string">&quot;Format %s probed with size=%d and score=%d\n&quot;</span>,</span><br><span class="line">                       (*fmt)-&gt;name, probe_size, score);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">            FILE *f = <span class="built_in">fopen</span>(<span class="string">&quot;probestat.tmp&quot;</span>, <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(f, <span class="string">&quot;probe_size:%d format:%s score:%d filename:%s\n&quot;</span>, probe_size, (*fmt)-&gt;name, score, filename);</span><br><span class="line">            <span class="built_in">fclose</span>(f);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!*fmt)</span><br><span class="line">        ret = AVERROR_INVALIDDATA;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="comment">/* Rewind. Reuse probe buffer to avoid seeking. */</span></span><br><span class="line">    ret2 = <span class="built_in">ffio_rewind_with_probe_data</span>(pb, &amp;buf, buf_offset);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">        ret = ret2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_freep</span>(&amp;pd.mime_type);</span><br><span class="line">    <span class="keyword">return</span> ret &lt; <span class="number">0</span> ? ret : score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数通过 avio_read 从输入源中读取一定 buffer 后还是会调用 av_probe_input_format2，但此时 AVProbeData 中有了 buffer，那么 AVInputFormat.read_probe 可以进行更全面的探测，不再只是根据文件名来决定当前 AVInputFormat 是否适用。</p><p>在 probe 完成之后，会调用 ffio_rewind_with_probe_data 将预先读取的数据归还给 AVIOContext，这样后面的 avio_read 会先消耗这部分数据，就好像是从头开始读，从而避免 seek</p><h3 id="s-gt-iformat-gt-init"><a href="#s-gt-iformat-gt-init" class="headerlink" title="s-&gt;iformat-&gt;init"></a>s-&gt;iformat-&gt;init</h3><p>这里是调用每个 format 自己的 init 函数对 AVFormatContext 进行初始化</p><h3 id="s-gt-iformat-gt-read-header"><a href="#s-gt-iformat-gt-read-header" class="headerlink" title="s-&gt;iformat-&gt;read_header"></a>s-&gt;iformat-&gt;read_header</h3><p>这里就是调用每个 format 自己的 read_header 函数对 demuxer 过程进行初始化。在这个函数中可能会创建 stream，所以会在下面调用 update_stream_avctx</p><h3 id="update-stream-avctx"><a href="#update-stream-avctx" class="headerlink" title="update_stream_avctx"></a>update_stream_avctx</h3><p>这个函数主要是通过 avcodec_parameters_to_context 把 stream 上的参数拷贝到 stream 中的 AVCodecContext，因为上面 read_header 可能会创建 stream</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">update_stream_avctx</span><span class="params">(AVFormatContext *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *<span class="type">const</span> st  = s-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// av_format_new_stream总会设置need_context_update为1</span></span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;need_context_update)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* close parser, because it depends on the codec */</span></span><br><span class="line">        <span class="keyword">if</span> (sti-&gt;parser &amp;&amp; sti-&gt;avctx-&gt;codec_id != st-&gt;codecpar-&gt;codec_id) &#123;</span><br><span class="line">            <span class="built_in">av_parser_close</span>(sti-&gt;parser);</span><br><span class="line">            sti-&gt;parser = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update internal codec context, for the parser */</span></span><br><span class="line">        ret = <span class="built_in">avcodec_parameters_to_context</span>(sti-&gt;avctx, st-&gt;codecpar);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        sti-&gt;need_context_update = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++标准库之__compressed_pair</title>
      <link href="/2023/05/10/C-%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B-compressed-pair/"/>
      <url>/2023/05/10/C-%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B-compressed-pair/</url>
      
        <content type="html"><![CDATA[<p>这篇博客介绍一下之前 shared_ptr 中用到的 <code>__compressed_pair</code>。</p><p><code>__compressed_pair</code> 和 pair 的区别在于，<code>__compressed_pair</code> 会做空基类优化，而 pair 不会做空基类优化，<code>__compressed_pair</code> 更像是只有两个元素的 tuple（因为 tuple 也会做空基类优化）。</p><p>接下来具体看看 <code>__compressed_pair</code> 的源码。</p><p><code>__compressed_pair</code> 是在 <code>__compressed_pair_elem</code> 的基础上构建的，<code>__compressed_pair</code> 继承了两个 <code>__compressed_pair_elem</code>，索引分别为 0 和 1，这种方式和 tuple 一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_T1</span>, <span class="keyword">class</span> <span class="title class_">_T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__compressed_pair</span> : <span class="keyword">private</span> __compressed_pair_elem&lt;_T1, <span class="number">0</span>&gt;,</span><br><span class="line">                          <span class="keyword">private</span> __compressed_pair_elem&lt;_T2, <span class="number">1</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE __compressed_pair_elem&lt;_T1, <span class="number">0</span>&gt; _Base1;</span><br><span class="line">  <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE __compressed_pair_elem&lt;_T2, <span class="number">1</span>&gt; _Base2;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__compressed_pair</code> 内部没有定义数据成员，数据存储放在了 <code>__compressed_pair_elem</code> 中</p><p>默认构造函数。要求 <code>_T1</code> 和 <code>_T2</code> 都是 default_constructible，<code>__dependent_type</code> 在 unique_ptr 中已经介绍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">class</span> = <span class="keyword">typename</span> enable_if&lt;</span><br><span class="line">          __dependent_type&lt;is_default_constructible&lt;_T1&gt;, _Dummy&gt;::value &amp;&amp;</span><br><span class="line">          __dependent_type&lt;is_default_constructible&lt;_T2&gt;, _Dummy&gt;::value</span><br><span class="line">      &gt;::type</span><br><span class="line">  &gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">  <span class="keyword">constexpr</span> __compressed_pair() &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以选择对第一个、第二个、全部成员进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Tp不能和当前__compressed_pair的类型相同</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">typename</span> enable_if&lt;!is_same&lt;<span class="keyword">typename</span> decay&lt;_Tp&gt;::type,</span><br><span class="line">                                                   __compressed_pair&gt;::value,</span><br><span class="line">                                          <span class="type">bool</span>&gt;::type = <span class="literal">true</span>&gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY <span class="keyword">constexpr</span> <span class="keyword">explicit</span></span><br><span class="line">  __compressed_pair(_Tp&amp;&amp; <span class="type">__t</span>)</span><br><span class="line">      : _Base1(std::forward&lt;_Tp&gt;(<span class="type">__t</span>)), _Base2() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY <span class="keyword">constexpr</span></span><br><span class="line">  __compressed_pair(__second_tag, _Tp&amp;&amp; <span class="type">__t</span>) <span class="comment">// 第一个参数必须是second_tag类型</span></span><br><span class="line">      : _Base1(), _Base2(std::forward&lt;_Tp&gt;(<span class="type">__t</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> _U1, <span class="keyword">class</span> _U2&gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY <span class="keyword">constexpr</span></span><br><span class="line">  __compressed_pair(_U1&amp;&amp; __t1, _U2&amp;&amp; __t2)</span><br><span class="line">      : _Base1(std::forward&lt;_U1&gt;(__t1)), _Base2(std::forward&lt;_U2&gt;(__t2)) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>__compressed_pair</code> 还有一个构造函数，这个函数类似其他模板的 emplace 函数，直接把参数转发给 Base，调用 Base 类的非拷贝构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Args1, <span class="keyword">class</span>... _Args2&gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14</span><br><span class="line">  __compressed_pair(<span class="type">piecewise_construct_t</span> __pc, tuple&lt;_Args1...&gt; __first_args,</span><br><span class="line">                    tuple&lt;_Args2...&gt; __second_args) <span class="comment">// 第一个参数必须是piecewise_construct_t</span></span><br><span class="line">      : _Base1(__pc, _VSTD::<span class="built_in">move</span>(__first_args),     <span class="comment">// 接下来是两个tuple</span></span><br><span class="line">               <span class="keyword">typename</span> __make_tuple_indices&lt;<span class="keyword">sizeof</span>...(_Args1)&gt;::<span class="built_in">type</span>()),</span><br><span class="line">        _Base2(__pc, _VSTD::<span class="built_in">move</span>(__second_args),</span><br><span class="line">               <span class="keyword">typename</span> __make_tuple_indices&lt;<span class="keyword">sizeof</span>...(_Args2)&gt;::<span class="built_in">type</span>()) &#123;&#125;</span><br></pre></td></tr></table></figure><p>通常上面的 tuple 参数的模板参数是引用类型，因为该 tuple 仅仅用于参数的转发，不会发生拷贝，类似 forward_as_tuple，具体放到 tuple 中介绍。</p><p><code>__make_tuple_indices</code> 也放到 tuple 中介绍，它用于产生一组索引，用于后续的 tuple 元素访问</p><p>first()和 second()，用于访问第一个和第二个元素。其实就是将当前指针转换为 base 类型，然后调用 base 的 <code>__get()</code> 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">  <span class="keyword">typename</span> _Base1::reference <span class="title">first</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Base1&amp;&gt;(*<span class="keyword">this</span>).__get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">  <span class="keyword">typename</span> _Base2::reference <span class="title">second</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Base2&amp;&gt;(*<span class="keyword">this</span>).__get();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来看一下 <code>__compressed_pair_elem</code>，看看它是如何做空基类优化的。</p><p>这个类不难理解。</p><p>首先它针对 <code>_CanBeEmptyBase</code> 这个条件有不同特化，也就是 <code>_Tp</code> 不能为空基类时用下面的模板，<code>_Tp</code> 可以为空基类的则用后面的模板。<code>_CanBeEmptyBase</code> 要求 <code>_Tp</code> 为 empty 以及不能为 final。</p><p><code>_Tp</code> 不能为空时在 <code>__compressed_pair_elem</code> 中有一个 <code>_Tp</code> 类型的成员变量，后续的操作（比如构造）会作用到该变量上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="type">int</span> _Idx,</span><br><span class="line">          <span class="type">bool</span> _CanBeEmptyBase =</span><br><span class="line">              &lt;u&gt;is_empty&lt;_Tp&gt;::value&lt;/u&gt; &amp;&amp; &lt;u&gt;!__libcpp_is_final&lt;_Tp&gt;::value&lt;/u&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> __compressed_pair_elem &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp _ParamT;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Tp&amp; const_reference;</span><br><span class="line"></span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY <span class="keyword">constexpr</span> __compressed_pair_elem() : __value_() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>, <span class="keyword">class</span> = <span class="keyword">typename</span> enable_if&lt;</span><br><span class="line">      !is_same&lt;__compressed_pair_elem, <span class="keyword">typename</span> decay&lt;_Up&gt;::type&gt;::value</span><br><span class="line">  &gt;::type&gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">explicit</span></span><br><span class="line">  __compressed_pair_elem(_Up&amp;&amp; __u)</span><br><span class="line">      : __value_(_VSTD::forward&lt;_Up&gt;(__u))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Args, <span class="type">size_t</span>... _Indexes&gt; <span class="comment">// emplace初始化</span></span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14</span><br><span class="line">  __compressed_pair_elem(<span class="type">piecewise_construct_t</span>, tuple&lt;_Args...&gt; __args,</span><br><span class="line">                         __tuple_indices&lt;_Indexes...&gt;)</span><br><span class="line">      : __value_(_VSTD::forward&lt;_Args&gt;(_VSTD::<span class="built_in">get</span>&lt;_Indexes&gt;(__args))...) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY reference __get() _NOEXCEPT &#123; <span class="keyword">return</span> __value_; &#125;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">  const_reference __get() <span class="type">const</span> _NOEXCEPT &#123; <span class="keyword">return</span> __value_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  _Tp __value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 <code>_CanBeEmptyBase</code> 为 true 的情况，有以下特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="type">int</span> _Idx&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__compressed_pair_elem</span>&lt;_Tp, _Idx, <span class="literal">true</span>&gt; : <span class="keyword">private</span> _Tp &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp _ParamT;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Tp&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp __value_type;</span><br><span class="line"></span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY <span class="keyword">constexpr</span> __compressed_pair_elem() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>, <span class="keyword">class</span> = <span class="keyword">typename</span> enable_if&lt;</span><br><span class="line">        !is_same&lt;__compressed_pair_elem, <span class="keyword">typename</span> decay&lt;_Up&gt;::type&gt;::value</span><br><span class="line">  &gt;::type&gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">explicit</span></span><br><span class="line">  __compressed_pair_elem(_Up&amp;&amp; __u)</span><br><span class="line">      : __value_type(_VSTD::forward&lt;_Up&gt;(__u))</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Args, <span class="type">size_t</span>... _Indexes&gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14</span><br><span class="line">  __compressed_pair_elem(<span class="type">piecewise_construct_t</span>, tuple&lt;_Args...&gt; __args,</span><br><span class="line">                         __tuple_indices&lt;_Indexes...&gt;)</span><br><span class="line">      : __value_type(_VSTD::forward&lt;_Args&gt;(_VSTD::<span class="built_in">get</span>&lt;_Indexes&gt;(__args))...) &#123;&#125;</span><br><span class="line">      </span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY reference __get() _NOEXCEPT &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">  const_reference __get() <span class="type">const</span> _NOEXCEPT &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于空基类的情况，没有 <code>_Tp __value_;</code> 这个成员，而是 <code>__compressed_pair_elem&lt;_Tp, _Idx, true&gt; : private _Tp</code>，也就是让 <code>__compressed_pair_elem</code> 继承 <code>_Tp</code>。</p><p>这样做的原理是：C++ 对于空类的对象会视为有 1byte 的 size，因为 C++ 要求相同类型的对象，不能有相同的地址，但是对于不同类型的对象，地址可以相同，“<strong>不同类型的对象</strong>”包括了继承的场景，比如继承可以视为子类对象内部嵌了一个父类对象，这种情况可以视为不同类型的对象，所以他们的地址可以相同（更多内容参见 C++ 对象模型 一书），这样子父类和子类两个空对象可以共用 1byte，从而实现优化。</p><p>可能上面比较奇怪的是，为什么空的类还定义了接受参数的构造函数，因为空类和构造函数参数为空没有关系，这里是为了尽可能的把参数转发到 <code>_Tp</code> 的构造函数。</p><p>总的来说，<code>__compressed_pair_elem</code> 就是对输入的模板参数_Tp 的一个包装</p><p><code>__compressed_pair</code> 的模板参数不仅可以是值类型，还可以是引用类型，比如之前 unique_ptr 中 deleter 可以是引用类型。</p><p>此外，在正常的代码中无法使用 <code>__compressed_pair</code>，tuple 算是更通用的 <code>__compressed_pair</code>，它里面也使用的空基类压缩，后面介绍 tuple 时会看到。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++标准库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg 之 muxer/encoder 相关 api (二)</title>
      <link href="/2023/05/05/ffmpeg-%E4%B9%8B-muxer-encoder-%E7%9B%B8%E5%85%B3-api-%E4%BA%8C/"/>
      <url>/2023/05/05/ffmpeg-%E4%B9%8B-muxer-encoder-%E7%9B%B8%E5%85%B3-api-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>这篇文章接着上一篇继续分析剩下的函数。</p><h2 id="avcodec-send-frame"><a href="#avcodec-send-frame" class="headerlink" title="avcodec_send_frame"></a>avcodec_send_frame</h2><p>编解码调用的送数据接口：</p><blockquote><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br/>encoder: avcodec_send_frame, avcodec_receive_packet<br/>muxer: av_write_frame<br/>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br/>demuxer: av_read_frame<br/>decoder: avcodec_send_packet, avcodec_receive_frame<br/>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p></blockquote><p>先看看 avcodec_send_frame。avci 中有个 buffer_frame，用于缓存输入的 frame，如果 buffer_frame 已经有了数据，那么这次 avcodec_send_frame 不会发送 frame，会返回 <code>AVERROR(EAGAIN)</code>。如果输入的 frame 为空，那么进入 draining 模式，后续不会再接受输入。如果 buffer_pkt 这个输出缓存为空，就尝试调用 encode_receive_packet_internal 进行解码，而 encode_send_frame_internal 其实没有做解码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> attribute_align_arg <span class="title">avcodec_send_frame</span><span class="params">(AVCodecContext *avctx, <span class="type">const</span> AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecInternal *avci = avctx-&gt;internal;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">avcodec_is_open</span>(avctx) || !<span class="built_in">av_codec_is_encoder</span>(avctx-&gt;codec))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avci-&gt;draining)</span><br><span class="line">        <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avci-&gt;buffer_frame-&gt;buf[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EAGAIN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame) &#123;</span><br><span class="line">        avci-&gt;draining = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="built_in">encode_send_frame_internal</span>(avctx, frame);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!avci-&gt;buffer_pkt-&gt;data &amp;&amp; !avci-&gt;buffer_pkt-&gt;side_data) &#123;</span><br><span class="line">        ret = <span class="built_in">encode_receive_packet_internal</span>(avctx, avci-&gt;buffer_pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != <span class="built_in">AVERROR</span>(EAGAIN) &amp;&amp; ret != AVERROR_EOF)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="encode-send-frame-internal"><a href="#encode-send-frame-internal" class="headerlink" title="encode_send_frame_internal"></a>encode_send_frame_internal</h3><p>这个函数就是把输入的 src AVFrame ref 到 avci-&gt;buffer_frame</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">encode_send_frame_internal</span><span class="params">(AVCodecContext *avctx, <span class="type">const</span> AVFrame *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecInternal *avci = avctx-&gt;internal;</span><br><span class="line">    AVFrame *dst = avci-&gt;buffer_frame;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;codec-&gt;type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_frame_ref</span>(dst, src);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;codec-&gt;type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">        ret = <span class="built_in">encode_generate_icc_profile</span>(avctx, dst);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="encode-receive-packet-internal"><a href="#encode-receive-packet-internal" class="headerlink" title="encode_receive_packet_internal"></a>encode_receive_packet_internal</h3><p>这个函数执行了解码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">encode_receive_packet_internal</span><span class="params">(AVCodecContext *avctx, AVPacket *avpkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecInternal *avci = avctx-&gt;internal;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avci-&gt;draining_done)</span><br><span class="line">        <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert0</span>(!avpkt-&gt;data &amp;&amp; !avpkt-&gt;side_data);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ffcodec</span>(avctx-&gt;codec)-&gt;cb_type == FF_CODEC_CB_TYPE_RECEIVE_PACKET) &#123;</span><br><span class="line">        ret = <span class="built_in">ffcodec</span>(avctx-&gt;codec)-&gt;cb.<span class="built_in">receive_packet</span>(avctx, avpkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">av_packet_unref</span>(avpkt);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Encoders must always return ref-counted buffers.</span></span><br><span class="line">            <span class="comment">// Side-data only packets have no data and can be not ref-counted.</span></span><br><span class="line">            <span class="built_in">av_assert0</span>(!avpkt-&gt;data || avpkt-&gt;buf);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        ret = <span class="built_in">encode_simple_receive_packet</span>(avctx, avpkt);</span><br><span class="line">    <span class="keyword">if</span> (&lt;u&gt;ret &gt;= <span class="number">0</span>&lt;/u&gt;)</span><br><span class="line">        &lt;u&gt;avpkt-&gt;flags&lt;/u&gt; |= avci-&gt;intra_only_flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == AVERROR_EOF)</span><br><span class="line">        avci-&gt;draining_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="encode-simple-receive-packet"><a href="#encode-simple-receive-packet" class="headerlink" title="encode_simple_receive_packet"></a>encode_simple_receive_packet</h4><p>看更常见的 encode_simple_receive_packet 解码逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">encode_simple_receive_packet</span><span class="params">(AVCodecContext *avctx, AVPacket *avpkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!avpkt-&gt;data &amp;&amp; !avpkt-&gt;side_data) &#123;</span><br><span class="line">        ret = <span class="built_in">encode_simple_internal</span>(avctx, avpkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="encode-simple-internal"><a href="#encode-simple-internal" class="headerlink" title="encode_simple_internal"></a>encode_simple_internal</h5><p>这里又出现了 in_frame，之前是把输入 frame 放在了 buffer_frame 中，如果 in_frame 为空，会尝试调用 ff_encode_get_frame 把 buffer_frame 移动到 in_frame。取到 in_frame 后调用 codec 中定义的 encode 函数进行编码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_encode_get_frame</span><span class="params">(AVCodecContext *avctx, AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecInternal *avci = avctx-&gt;internal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avci-&gt;draining)</span><br><span class="line">        <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!avci-&gt;buffer_frame-&gt;buf[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EAGAIN);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_frame_move_ref</span>(frame, avci-&gt;buffer_frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">encode_simple_internal</span><span class="params">(AVCodecContext *avctx, AVPacket *avpkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecInternal   *avci = avctx-&gt;internal;</span><br><span class="line">    AVFrame          *frame = avci-&gt;in_frame;</span><br><span class="line">    <span class="type">const</span> FFCodec *<span class="type">const</span> codec = <span class="built_in">ffcodec</span>(avctx-&gt;codec);</span><br><span class="line">    <span class="type">int</span> got_packet;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avci-&gt;draining_done)</span><br><span class="line">        <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;buf[<span class="number">0</span>] &amp;&amp; !avci-&gt;draining) &#123;</span><br><span class="line">        <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">        ret = <span class="built_in">ff_encode_get_frame</span>(avctx, frame);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != AVERROR_EOF)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(avctx-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_DELAY ||</span><br><span class="line">              (avci-&gt;frame_thread_encoder &amp;&amp; avctx-&gt;active_thread_type &amp; FF_THREAD_FRAME)))</span><br><span class="line">            <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flushing is signaled with a NULL frame</span></span><br><span class="line">        frame = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    got_packet = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert0</span>(codec-&gt;cb_type == FF_CODEC_CB_TYPE_ENCODE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CONFIG_FRAME_THREAD_ENCODER &amp;&amp;</span><br><span class="line">        avci-&gt;frame_thread_encoder &amp;&amp; (avctx-&gt;active_thread_type &amp; FF_THREAD_FRAME))</span><br><span class="line">        <span class="comment">/* This might modify frame, but it doesn&#x27;t matter, because</span></span><br><span class="line"><span class="comment">         * the frame properties used below are not used for video</span></span><br><span class="line"><span class="comment">         * (due to the delay inherent in frame threaded encoding, it makes</span></span><br><span class="line"><span class="comment">         *  no sense to use the properties of the current frame anyway). */</span></span><br><span class="line">        ret = <span class="built_in">ff_thread_video_encode_frame</span>(avctx, avpkt, frame, &amp;got_packet);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = codec-&gt;cb.<span class="built_in">encode</span>(avctx, avpkt, frame, &amp;got_packet);</span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec-&gt;type == AVMEDIA_TYPE_VIDEO &amp;&amp; !ret &amp;&amp; got_packet &amp;&amp;</span><br><span class="line">            &lt;u&gt;!(avctx-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_DELAY)&lt;/u&gt;)</span><br><span class="line">            avpkt-&gt;pts = avpkt-&gt;dts = frame-&gt;pts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert0</span>(ret &lt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">emms_c</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ret &amp;&amp; got_packet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (avpkt-&gt;data) &#123;</span><br><span class="line">            ret = <span class="built_in">av_packet_make_refcounted</span>(avpkt);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (frame &amp;&amp; !(avctx-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_DELAY)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (avctx-&gt;codec-&gt;type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">                <span class="keyword">if</span> (avpkt-&gt;pts == AV_NOPTS_VALUE)</span><br><span class="line">                    avpkt-&gt;pts = frame-&gt;pts;</span><br><span class="line">                <span class="keyword">if</span> (!avpkt-&gt;duration)</span><br><span class="line">                    avpkt-&gt;duration = <span class="built_in">ff_samples_to_time_base</span>(avctx,</span><br><span class="line">                                                              frame-&gt;nb_samples);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;codec-&gt;type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            avpkt-&gt;dts = avpkt-&gt;pts;</span><br><span class="line">        &#125;</span><br><span class="line">        avpkt-&gt;flags |= avci-&gt;intra_only_flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avci-&gt;draining &amp;&amp; !got_packet)</span><br><span class="line">        avci-&gt;draining_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> || !got_packet)</span><br><span class="line">        <span class="built_in">av_packet_unref</span>(avpkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame)</span><br><span class="line">        <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (got_packet)</span><br><span class="line">        <span class="comment">// Encoders must always return ref-counted buffers.</span></span><br><span class="line">        <span class="comment">// Side-data only packets have no data and can be not ref-counted.</span></span><br><span class="line">        <span class="built_in">av_assert0</span>(!avpkt-&gt;data || avpkt-&gt;buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avcodec-receive-packet"><a href="#avcodec-receive-packet" class="headerlink" title="avcodec_receive_packet"></a>avcodec_receive_packet</h2><p>这个函数用于从 encoder 中取数据，由于之前 avcodec_send_frame 已经尝试主动解码了，所以这个函数一般可以直接取到 buffer_pkt，如果 buffer_pkt 为空，则调用 encode_receive_packet_internal 进行解码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> attribute_align_arg <span class="title">avcodec_receive_packet</span><span class="params">(AVCodecContext *avctx, AVPacket *avpkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecInternal *avci = avctx-&gt;internal;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_packet_unref</span>(avpkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">avcodec_is_open</span>(avctx) || !<span class="built_in">av_codec_is_encoder</span>(avctx-&gt;codec))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avci-&gt;buffer_pkt-&gt;data || avci-&gt;buffer_pkt-&gt;side_data) &#123;</span><br><span class="line">        <span class="built_in">av_packet_move_ref</span>(avpkt, avci-&gt;buffer_pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="built_in">encode_receive_packet_internal</span>(avctx, avpkt);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="av-write-frame"><a href="#av-write-frame" class="headerlink" title="av_write_frame"></a>av_write_frame</h2><p>这个函数把 packet 写到 muxer 中，为什么不叫 write_packet?</p><p>可以看到，下面出现了 parse_pkt，估计也是缓存 buffer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_write_frame</span><span class="params">(AVFormatContext *s, AVPacket *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    AVPacket *pkt = si-&gt;parse_pkt;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;oformat-&gt;flags &amp; AVFMT_ALLOW_FLUSH) &#123;</span><br><span class="line">            ret = s-&gt;oformat-&gt;<span class="built_in">write_packet</span>(s, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">flush_if_needed</span>(s);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span> &amp;&amp; s-&gt;pb &amp;&amp; s-&gt;pb-&gt;error &lt; <span class="number">0</span>)</span><br><span class="line">                ret = s-&gt;pb-&gt;error;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in-&gt;flags &amp; AV_PKT_FLAG_UNCODED_FRAME) &#123;</span><br><span class="line">        pkt = in;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We don&#x27;t own in, so we have to make sure not to modify it.</span></span><br><span class="line"><span class="comment">         * (ff_write_chained() relies on this fact.)</span></span><br><span class="line"><span class="comment">         * The following avoids copying in&#x27;s data unnecessarily.</span></span><br><span class="line"><span class="comment">         * Copying side data is unavoidable as a bitstream filter</span></span><br><span class="line"><span class="comment">         * may change it, e.g. free it on errors. */</span></span><br><span class="line">        pkt-&gt;data = in-&gt;data;</span><br><span class="line">        pkt-&gt;size = in-&gt;size;</span><br><span class="line">        ret = <span class="built_in">av_packet_copy_props</span>(pkt, in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in-&gt;buf) &#123;</span><br><span class="line">            pkt-&gt;buf = <span class="built_in">av_buffer_ref</span>(in-&gt;buf);</span><br><span class="line">            <span class="keyword">if</span> (!pkt-&gt;buf) &#123;</span><br><span class="line">                ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">write_packets_common</span>(s, pkt, <span class="number">0</span><span class="comment">/*non-interleaved*/</span>);</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="comment">// Uncoded frames using the noninterleaved codepath are also freed here</span></span><br><span class="line">    <span class="built_in">av_packet_unref</span>(pkt);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="write-packets-common"><a href="#write-packets-common" class="headerlink" title="write_packets_common"></a>write_packets_common</h3><p>上面函数内部调用了 write_packets_common 来写入 packet。</p><p>check_packet、prepare_input_packet、check_bitstream 都没有做什么重要的事</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">write_packets_common</span><span class="params">(AVFormatContext *s, AVPacket *pkt, <span class="type">int</span> interleaved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVStream *st;</span><br><span class="line">    FFStream *sti;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">check_packet</span>(s, pkt);</span><br><span class="line"></span><br><span class="line">    st = s-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">    sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">prepare_input_packet</span>(s, st, pkt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">check_bitstream</span>(s, sti, pkt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sti-&gt;bsfc) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">write_packets_from_bsfs</span>(s, st, pkt, interleaved);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">write_packet_common</span>(s, st, pkt, interleaved);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="write-packet-common"><a href="#write-packet-common" class="headerlink" title="write_packet_common"></a>write_packet_common</h4><p>write_packet_common 才是真正写 packet 的地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">write_packet_common</span><span class="params">(AVFormatContext *s, AVStream *st, AVPacket *pkt, <span class="type">int</span> interleaved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">guess_pkt_duration</span>(s, st, pkt);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_COMPUTE_PKT_FIELDS2</span></span><br><span class="line">    <span class="keyword">if</span> (!(s-&gt;oformat-&gt;flags &amp; AVFMT_NOTIMESTAMPS) &amp;&amp; (ret = <span class="built_in">compute_muxer_pkt_fields</span>(s, st, pkt)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interleaved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;dts == AV_NOPTS_VALUE &amp;&amp; !(s-&gt;oformat-&gt;flags &amp; AVFMT_NOTIMESTAMPS))</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">interleaved_write_packet</span>(s, pkt, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">write_packet</span>(s, pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="write-packet"><a href="#write-packet" class="headerlink" title="write_packet"></a>write_packet</h5><p>在 write_packet 里面调用 write_uncoded_frame 或者 write_packet</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">write_packet</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    AVStream *<span class="type">const</span> st = s-&gt;streams[pkt-&gt;stream_index];</span><br><span class="line">    FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the timestamp offsetting below is adjusted, adjust</span></span><br><span class="line">    <span class="comment">// ff_interleaved_peek similarly.</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;output_ts_offset) &#123;</span><br><span class="line">        <span class="type">int64_t</span> offset = <span class="built_in">av_rescale_q</span>(s-&gt;output_ts_offset, AV_TIME_BASE_Q, st-&gt;time_base);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;dts != AV_NOPTS_VALUE)</span><br><span class="line">            pkt-&gt;dts += offset;</span><br><span class="line">        <span class="keyword">if</span> (pkt-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">            pkt-&gt;pts += offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">handle_avoid_negative_ts</span>(si, sti, pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pkt-&gt;flags &amp; AV_PKT_FLAG_UNCODED_FRAME)) &#123;</span><br><span class="line">        AVFrame **frame = (AVFrame **)pkt-&gt;data;</span><br><span class="line">        <span class="built_in">av_assert0</span>(pkt-&gt;size == <span class="built_in">sizeof</span>(*frame));</span><br><span class="line">        ret = s-&gt;oformat-&gt;<span class="built_in">write_uncoded_frame</span>(s, pkt-&gt;stream_index, frame, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = s-&gt;oformat-&gt;<span class="built_in">write_packet</span>(s, pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;pb &amp;&amp; ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">flush_if_needed</span>(s);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;pb-&gt;error &lt; <span class="number">0</span>)</span><br><span class="line">            ret = s-&gt;pb-&gt;error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">        st-&gt;nb_frames++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ffmpeg/libavformat/mux.c</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">flush_if_needed</span><span class="params">(AVFormatContext *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;pb &amp;&amp; s-&gt;pb-&gt;error &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;flush_packets == <span class="number">1</span> || s-&gt;flags &amp; AVFMT_FLAG_FLUSH_PACKETS)</span><br><span class="line">            <span class="built_in">avio_flush</span>(s-&gt;pb);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;flush_packets &amp;&amp; !(s-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">            <span class="built_in">avio_write_marker</span>(s-&gt;pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_FLUSH_POINT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看官方的 mux.c 例子，下面把该例子的核心步骤抽取了出来，他和上面例子的步骤基本上是一样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *filename;</span><br><span class="line">AVFormatContext *oc;</span><br><span class="line"></span><br><span class="line"><span class="built_in">avformat_alloc_output_context2</span>(&amp;oc, <span class="literal">NULL</span>, <span class="literal">NULL</span>, filename);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> AVOutputFormat *fmt = oc-&gt;oformat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt-&gt;video_codec 是 AVCodecID</span></span><br><span class="line"><span class="keyword">if</span> (fmt-&gt;video_codec != AV_CODEC_ID_NONE) &#123;</span><br><span class="line">    <span class="type">const</span> AVCodec *video_codec = <span class="built_in">avcodec_find_encoder</span>(fmt-&gt;video_codec);</span><br><span class="line"></span><br><span class="line">    AVStream *stream_video = <span class="built_in">avformat_new_stream</span>(oc, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Format-specific stream ID.</span></span><br><span class="line"><span class="comment">     * decoding: set by libavformat</span></span><br><span class="line"><span class="comment">     * encoding: set by the user, replaced by libavformat if left unset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    stream_video-&gt;id = oc-&gt;nb_streams<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    AVCodecContext *enc_video = <span class="built_in">avcodec_alloc_context3</span>(video_codec);</span><br><span class="line"></span><br><span class="line">    enc_video-&gt;bit_rate = <span class="number">400000</span>;</span><br><span class="line">    <span class="comment">/* Resolution must be a multiple of two. */</span></span><br><span class="line">    enc_video-&gt;width    = <span class="number">352</span>;</span><br><span class="line">    enc_video-&gt;height   = <span class="number">288</span>;</span><br><span class="line"></span><br><span class="line">    stream_video-&gt;time_base = (AVRational)&#123; <span class="number">1</span>, <span class="number">25</span> &#125;;</span><br><span class="line">    enc_video-&gt;time_base       = stream_video-&gt;time_base;</span><br><span class="line">    enc_video-&gt;pix_fmt       = AV_PIX_FMT_YUV420P;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fmt-&gt;audio_codec != AV_CODEC_ID_NONE) &#123;</span><br><span class="line">    <span class="type">const</span> AVCodec *audio_codec = <span class="built_in">avcodec_find_encoder</span>(fmt-&gt;audio_codec);</span><br><span class="line"></span><br><span class="line">    AVStream *stream_audio = <span class="built_in">avformat_new_stream</span>(oc, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    stream_audio-&gt;id = oc-&gt;nb_streams<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    AVCodecContext *enc_audio = <span class="built_in">avcodec_alloc_context3</span>(audio_codec);</span><br><span class="line"></span><br><span class="line">    enc_audio-&gt;sample_fmt  = audio_codec-&gt;sample_fmts ?</span><br><span class="line">            audio_codec-&gt;sample_fmts[<span class="number">0</span>] : AV_SAMPLE_FMT_FLTP;</span><br><span class="line">    enc_audio-&gt;bit_rate    = <span class="number">64000</span>;</span><br><span class="line">    enc_audio-&gt;sample_rate = <span class="number">44100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio_codec-&gt;supported_samplerates) &#123;</span><br><span class="line">        enc_audio-&gt;sample_rate = audio_codec-&gt;supported_samplerates[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; audio_codec-&gt;supported_samplerates[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (audio_codec-&gt;supported_samplerates[i] == <span class="number">44100</span>)</span><br><span class="line">                enc_audio-&gt;sample_rate = <span class="number">44100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">av_channel_layout_copy</span>(&amp;enc_audio-&gt;ch_layout, &amp;(AVChannelLayout)AV_CHANNEL_LAYOUT_STEREO);</span><br><span class="line">    stream_audio-&gt;time_base = (AVRational)&#123; <span class="number">1</span>, enc_audio-&gt;sample_rate &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AVDictionary *opt = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">avcodec_open2</span>(enc_video, video_codec, &amp;opt);</span><br><span class="line"><span class="comment">/* copy the stream parameters to the muxer */</span></span><br><span class="line"><span class="built_in">avcodec_parameters_from_context</span>(stream_video-&gt;codecpar, enc_video);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avcodec_open2</span>(enc_audio, audio_codec, &amp;opt);</span><br><span class="line"><span class="built_in">avcodec_parameters_from_context</span>(stream_audio-&gt;codecpar, enc_audio);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(fmt-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">    ret = <span class="built_in">avio_open</span>(&amp;oc-&gt;pb, filename, AVIO_FLAG_WRITE);</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">avformat_write_header</span>(oc, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">AVFrame *frame;</span><br><span class="line">AVPacket *pkt;</span><br><span class="line">ret = <span class="built_in">avcodec_send_frame</span>(enc_video, frame);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ?</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ret = <span class="built_in">avcodec_receive_packet</span>(enc_video, pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_packet_rescale_ts</span>(pkt, enc_video-&gt;time_base, stream_video-&gt;time_base);</span><br><span class="line">    pkt-&gt;stream_index = stream_video-&gt;index;</span><br><span class="line">    ret = <span class="built_in">av_interleaved_write_frame</span>(fmt_ctx, pkt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">av_write_trailer</span>(oc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avcodec_free_context</span>(&amp;enc_video);</span><br><span class="line"><span class="built_in">avcodec_free_context</span>(&amp;enc_audio);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(fmt-&gt;flags &amp; AVFMT_NOFILE))</span><br><span class="line">    <span class="comment">/* Close the output file. */</span></span><br><span class="line">    <span class="built_in">avio_closep</span>(&amp;oc-&gt;pb);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free the stream */</span></span><br><span class="line"><span class="built_in">avformat_free_context</span>(oc);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg 之 muxer/encoder 相关 api (一)</title>
      <link href="/2023/05/05/ffmpeg-%E4%B9%8B-muxer-encoder-%E7%9B%B8%E5%85%B3-api-%E4%B8%80/"/>
      <url>/2023/05/05/ffmpeg-%E4%B9%8B-muxer-encoder-%E7%9B%B8%E5%85%B3-api-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>这篇文章简要介绍如何使用 ffmpeg 进行 encoder 和 muxer，同时分析部分 api 函数的源码。我们以一个具体的编码例子进行分析。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是一个 encoder + muxer 的例子（不完全）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *filename = <span class="string">&quot;aa.mp4&quot;</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">AVFormatContext *format_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> AVOutputFormat *format = <span class="built_in">av_guess_format</span>(<span class="literal">NULL</span>, filename, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">avformat_alloc_output_context2</span>(&amp;format_ctx, format,</span><br><span class="line">                                     <span class="literal">NULL</span>, filename);</span><br><span class="line"></span><br><span class="line">format_ctx-&gt;flags |= AVFMT_FLAG_NONBLOCK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以设置AVFormatContext及其私有结构上的属性</span></span><br><span class="line">AVDictionary *dict = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">av_opt_set_dict2</span>(format_ctx, dict, AV_OPT_SEARCH_CHILDREN);</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">avio_open2</span>(&amp;format_ctx-&gt;pb, filename, AVIO_FLAG_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果遇到错误</span></span><br><span class="line"><span class="built_in">avformat_free_context</span>(format_ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// audio encoder</span></span><br><span class="line"><span class="type">const</span> AVCodec *encA = <span class="built_in">avcodec_find_encoder</span>(format_ctx-&gt;oformat-&gt;audio_codec);</span><br><span class="line">AVCodecContext *enc_ctxA = <span class="built_in">avcodec_alloc_context3</span>(encA);</span><br><span class="line">    <span class="type">int</span> format, sample_rate, channels;</span><br><span class="line">    enc_ctxA-&gt;sample_fmt  = format;</span><br><span class="line">    enc_ctxA-&gt;sample_rate = sample_rate;</span><br><span class="line">    <span class="built_in">av_channel_layout_default</span>(&amp;enc_ctxA-&gt;ch_layout, channels);</span><br><span class="line">    enc_ctxA-&gt;time_base   = (AVRational)&#123; <span class="number">1</span>, sample_rate &#125;;</span><br><span class="line">    enc_ctxA-&gt;strict_std_compliance = FF_COMPLIANCE_UNOFFICIAL;</span><br><span class="line">    <span class="type">int</span> bitrate, vbr, level;</span><br><span class="line">    <span class="built_in">av_opt_set_int</span>(enc_ctxA, <span class="string">&quot;b&quot;</span>, bitrate, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">av_opt_set_int</span>(enc_ctxA, <span class="string">&quot;vbr&quot;</span>, vbr, AV_OPT_SEARCH_CHILDREN);</span><br><span class="line">    <span class="built_in">av_opt_set_int</span>(enc_ctxA, <span class="string">&quot;compression_level&quot;</span>, level, <span class="number">0</span>);</span><br><span class="line">ret = <span class="built_in">avcodec_open2</span>(enc_ctxA, encA, <span class="literal">NULL</span>);</span><br><span class="line">AVStream *streamA = <span class="built_in">avformat_new_stream</span>(format_ctx, encA);</span><br><span class="line">ret = <span class="built_in">avcodec_parameters_from_context</span>(streamA-&gt;codecpar, enc_ctxA);</span><br><span class="line">    streamA-&gt;time_base = enc_ctxA-&gt;time_base;</span><br><span class="line"></span><br><span class="line"><span class="comment">// video encoder</span></span><br><span class="line"><span class="type">const</span> AVCodec *encV = <span class="built_in">avcodec_find_encoder</span>(format_ctx-&gt;oformat-&gt;video_codec);</span><br><span class="line">AVCodecContext *enc_ctxV = <span class="built_in">avcodec_alloc_context3</span>(encV);</span><br><span class="line">    <span class="type">int</span> format, w, h;</span><br><span class="line">    AVRational frame_rate;</span><br><span class="line">    enc_ctxV-&gt;pix_fmt   = format;</span><br><span class="line">    enc_ctxV-&gt;width     = w;</span><br><span class="line">    enc_ctxV-&gt;height    = h;</span><br><span class="line">    enc_ctxV-&gt;time_base = <span class="built_in">av_inv_q</span>(frame_rate);</span><br><span class="line">    enc_ctxV-&gt;strict_std_compliance = FF_COMPLIANCE_UNOFFICIAL;</span><br><span class="line">ret = <span class="built_in">avcodec_open2</span>(enc_ctxV, encV, <span class="literal">NULL</span>);</span><br><span class="line">AVStream *streamV = <span class="built_in">avformat_new_stream</span>(format_ctx, encV);</span><br><span class="line">ret = <span class="built_in">avcodec_parameters_from_context</span>(streamV-&gt;codecpar, enc_ctxV);</span><br><span class="line">    streamV-&gt;time_base = enc_ctxV-&gt;time_base;</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">avformat_write_header</span>(format_ctx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果遇到错误</span></span><br><span class="line"><span class="built_in">avcodec_free_context</span>(&amp;enc_ctxV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// audio的编码，封装过程，video也是类似的</span></span><br><span class="line">AVPacket *pkt;</span><br><span class="line">AVFrame *frame;</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">avcodec_send_frame</span>(enc_ctxA, frame);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ret = <span class="built_in">avcodec_receive_packet</span>(enc_ctxA, pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ret = <span class="built_in">av_write_frame</span>(format_ctx, pkt);</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当想要发送eof时，让上面 avcodec_send_frame 时的frame为NULL</span></span><br><span class="line"><span class="comment">// 此时还要写入format尾部</span></span><br><span class="line"><span class="keyword">if</span> (ret == AVERROR_EOF)</span><br><span class="line">    <span class="built_in">av_write_trailer</span>(format_ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后关闭encoder和muxer</span></span><br><span class="line"><span class="built_in">avcodec_free_context</span>(&amp;enc_ctxA);</span><br><span class="line"><span class="built_in">avcodec_free_context</span>(&amp;enc_ctxV);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (format_ctx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (format_ctx-&gt;pb)</span><br><span class="line">        <span class="built_in">avio_close</span>(format_ctx-&gt;pb);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">avformat_free_context</span>(format_ctx);</span><br><span class="line">    format_ctx = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就具体看看每个函数做了什么工作。</p><h2 id="av-guess-format"><a href="#av-guess-format" class="headerlink" title="av_guess_format"></a>av_guess_format</h2><p>av_guess_format 函数返回一个 AVOutputFormat 指针，优先使用输入的 short_name 和 <code>AVOutputFormat.name</code> 进行比对，其次根据 mime_type，最后根据 filename 的后缀名决定使用哪个解封装格式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVOutputFormat *<span class="title">av_guess_format</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *short_name, <span class="type">const</span> <span class="type">char</span> *filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">const</span> <span class="type">char</span> *mime_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVOutputFormat *fmt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> AVOutputFormat *fmt_found = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span> *i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> score_max, score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* specific test for image sequences */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IMAGE2_MUXER</span></span><br><span class="line">    <span class="keyword">if</span> (!short_name &amp;&amp; filename &amp;&amp;</span><br><span class="line">        <span class="built_in">av_filename_number_test</span>(filename) &amp;&amp;</span><br><span class="line">        <span class="built_in">ff_guess_image2_codec</span>(filename) != AV_CODEC_ID_NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">av_guess_format</span>(<span class="string">&quot;image2&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Find the proper file type. */</span></span><br><span class="line">    score_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((fmt = <span class="built_in">av_muxer_iterate</span>(&amp;i))) &#123;</span><br><span class="line">        score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fmt-&gt;name &amp;&amp; short_name &amp;&amp; <span class="built_in">av_match_name</span>(short_name, fmt-&gt;name))</span><br><span class="line">            score += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (fmt-&gt;mime_type &amp;&amp; mime_type &amp;&amp; !<span class="built_in">strcmp</span>(fmt-&gt;mime_type, mime_type))</span><br><span class="line">            score += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (filename &amp;&amp; fmt-&gt;extensions &amp;&amp;</span><br><span class="line">            <span class="built_in">av_match_ext</span>(filename, fmt-&gt;extensions)) &#123;</span><br><span class="line">            score += <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (score &gt; score_max) &#123;</span><br><span class="line">            score_max = score;</span><br><span class="line">            fmt_found = fmt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt_found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avformat-alloc-output-context2"><a href="#avformat-alloc-output-context2" class="headerlink" title="avformat_alloc_output_context2"></a>avformat_alloc_output_context2</h2><p>avformat_alloc_output_context2 函数创建 AVFormatContext 对象，其内部也有 av_guess_format 过程，在创建 AVFormatContext 时，会根据 AVOutputFormat 创建相应的私有结构，还会把属性设为默认值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_alloc_output_context2</span><span class="params">(AVFormatContext **avctx, <span class="type">const</span> AVOutputFormat *oformat,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="type">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFormatContext *s = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    *avctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!s)</span><br><span class="line">        <span class="keyword">goto</span> nomem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!oformat) &#123;</span><br><span class="line">... <span class="comment">// av_guess_format</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;oformat = oformat;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ffofmt</span>(s-&gt;oformat)-&gt;priv_data_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s-&gt;priv_data = <span class="built_in">av_mallocz</span>(<span class="built_in">ffofmt</span>(s-&gt;oformat)-&gt;priv_data_size);</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;priv_data)</span><br><span class="line">            <span class="keyword">goto</span> nomem;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;oformat-&gt;priv_class) &#123;</span><br><span class="line">            *(<span class="type">const</span> AVClass**)s-&gt;priv_data= s-&gt;oformat-&gt;priv_class;</span><br><span class="line">            <span class="built_in">av_opt_set_defaults</span>(s-&gt;priv_data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        s-&gt;priv_data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(s-&gt;url = <span class="built_in">av_strdup</span>(filename)))</span><br><span class="line">            <span class="keyword">goto</span> nomem;</span><br><span class="line">    &#125;</span><br><span class="line">    *avctx = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">nomem:</span><br><span class="line">    <span class="built_in">av_log</span>(s, AV_LOG_ERROR, <span class="string">&quot;Out of memory\n&quot;</span>);</span><br><span class="line">    ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">error:</span><br><span class="line">    <span class="built_in">avformat_free_context</span>(s);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> FFOutputFormat *<span class="title">ffofmt</span><span class="params">(<span class="type">const</span> AVOutputFormat *fmt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> FFOutputFormat*)fmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="avformat-alloc-context"><a href="#avformat-alloc-context" class="headerlink" title="avformat_alloc_context"></a>avformat_alloc_context</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVFormatContext *<span class="title">avformat_alloc_context</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*si));</span><br><span class="line">    AVFormatContext *s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    s = &amp;si-&gt;pub;</span><br><span class="line">    s-&gt;av_class = &amp;av_format_context_class;</span><br><span class="line">    s-&gt;io_open  = io_open_default;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_AVFORMAT_IO_CLOSE</span></span><br><span class="line">FF_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line">    s-&gt;io_close = ff_format_io_close_default;</span><br><span class="line">FF_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    s-&gt;io_close2= io_close2_default;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_opt_set_defaults</span>(s);</span><br><span class="line"></span><br><span class="line">    si-&gt;pkt = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">    si-&gt;parse_pkt = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;pkt || !si-&gt;parse_pkt) &#123;</span><br><span class="line">        <span class="built_in">avformat_free_context</span>(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    si-&gt;shortest_end = AV_NOPTS_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>avio_open2 属于 IO 部分，这部分内容放在另一篇文章中介绍。</p><h2 id="avcodec-find-encoder"><a href="#avcodec-find-encoder" class="headerlink" title="avcodec_find_encoder"></a>avcodec_find_encoder</h2><p>avcodec_find_encoder 是根据输入的 AVCodecID 查找 AVCodec*，思路和上面的 av_guess_format 里面 AVOutputFormat 查找比较类似，这里不仔细展开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVCodec *<span class="title">avcodec_find_encoder</span><span class="params">(<span class="keyword">enum</span> AVCodecID id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find_codec</span>(id, av_codec_is_encoder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avcodec-alloc-context3"><a href="#avcodec-alloc-context3" class="headerlink" title="avcodec_alloc_context3"></a>avcodec_alloc_context3</h2><p>找到 AVCodec 后就可以创建 AVCodecContext，和上面通过 AVOutputFormat 创建 AVFormatContext 类似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVCodecContext *<span class="title">avcodec_alloc_context3</span><span class="params">(<span class="type">const</span> AVCodec *codec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecContext *avctx= <span class="built_in">av_malloc</span>(<span class="built_in">sizeof</span>(AVCodecContext));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!avctx)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">init_context_defaults</span>(avctx, codec) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_free</span>(avctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> avctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">init_context_defaults</span><span class="params">(AVCodecContext *s, <span class="type">const</span> AVCodec *codec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FFCodec *<span class="type">const</span> codec2 = <span class="built_in">ffcodec</span>(codec);</span><br><span class="line">    <span class="type">int</span> flags=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in">sizeof</span>(AVCodecContext));</span><br><span class="line"></span><br><span class="line">    s-&gt;av_class = &amp;av_codec_context_class;</span><br><span class="line"></span><br><span class="line">    s-&gt;codec_type = codec ? codec-&gt;type : AVMEDIA_TYPE_UNKNOWN;</span><br><span class="line">    <span class="keyword">if</span> (codec) &#123;</span><br><span class="line">        s-&gt;codec = codec;</span><br><span class="line">        s-&gt;codec_id = codec-&gt;id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s-&gt;codec_type == AVMEDIA_TYPE_AUDIO)</span><br><span class="line">        flags= AV_OPT_FLAG_AUDIO_PARAM;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s-&gt;codec_type == AVMEDIA_TYPE_VIDEO)</span><br><span class="line">        flags= AV_OPT_FLAG_VIDEO_PARAM;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE)</span><br><span class="line">        flags= AV_OPT_FLAG_SUBTITLE_PARAM;</span><br><span class="line">    <span class="built_in">av_opt_set_defaults2</span>(s, flags, flags);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_channel_layout_uninit</span>(&amp;s-&gt;ch_layout);</span><br><span class="line"></span><br><span class="line">    s-&gt;time_base           = (AVRational)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    s-&gt;framerate           = (AVRational)&#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    s-&gt;pkt_timebase        = (AVRational)&#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    s-&gt;get_buffer2         = avcodec_default_get_buffer2;</span><br><span class="line">    s-&gt;get_format          = avcodec_default_get_format;</span><br><span class="line">    s-&gt;get_encode_buffer   = avcodec_default_get_encode_buffer;</span><br><span class="line">    s-&gt;execute             = avcodec_default_execute;</span><br><span class="line">    s-&gt;execute2            = avcodec_default_execute2;</span><br><span class="line">    s-&gt;sample_aspect_ratio = (AVRational)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    s-&gt;ch_layout.order     = AV_CHANNEL_ORDER_UNSPEC;</span><br><span class="line">    s-&gt;pix_fmt             = AV_PIX_FMT_NONE;</span><br><span class="line">    s-&gt;sw_pix_fmt          = AV_PIX_FMT_NONE;</span><br><span class="line">    s-&gt;sample_fmt          = AV_SAMPLE_FMT_NONE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_REORDERED_OPAQUE</span></span><br><span class="line">FF_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line">    s-&gt;reordered_opaque    = AV_NOPTS_VALUE;</span><br><span class="line">FF_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span>(codec &amp;&amp; codec2-&gt;priv_data_size)&#123;</span><br><span class="line">        s-&gt;priv_data = <span class="built_in">av_mallocz</span>(codec2-&gt;priv_data_size);</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;priv_data)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="keyword">if</span>(codec-&gt;priv_class)&#123;</span><br><span class="line">            *(<span class="type">const</span> AVClass**)s-&gt;priv_data = codec-&gt;priv_class;</span><br><span class="line">            <span class="built_in">av_opt_set_defaults</span>(s-&gt;priv_data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (codec &amp;&amp; codec2-&gt;defaults) &#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">const</span> FFCodecDefault *d = codec2-&gt;defaults;</span><br><span class="line">        <span class="keyword">while</span> (d-&gt;key) &#123;</span><br><span class="line">            ret = <span class="built_in">av_opt_set</span>(s, d-&gt;key, d-&gt;value, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">av_assert0</span>(ret &gt;= <span class="number">0</span>);</span><br><span class="line">            d++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avcodec-open2"><a href="#avcodec-open2" class="headerlink" title="avcodec_open2"></a>avcodec_open2</h2><p>创建 AVCodecContext 后还要进行打开操作，如果之前 avcodec_alloc_context3 创建 AVCodecContext 的时候已经传了 AVCodec，那么下面的 codec 参数可以为空，如果要传 codec，要注意和 AVCodecContext 中的一致（如果有的话）。avcodec_open2 会创建并初始化 AVCodecInternal</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> attribute_align_arg <span class="title">avcodec_open2</span><span class="params">(AVCodecContext *avctx, <span class="type">const</span> AVCodec *codec, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    AVCodecInternal *avci;</span><br><span class="line">    <span class="type">const</span> FFCodec *codec2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">avcodec_is_open</span>(avctx))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!codec &amp;&amp; !avctx-&gt;codec) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(avctx, AV_LOG_ERROR, <span class="string">&quot;No codec provided to avcodec_open2()\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (codec &amp;&amp; avctx-&gt;codec &amp;&amp; codec != avctx-&gt;codec) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(avctx, AV_LOG_ERROR, <span class="string">&quot;This AVCodecContext was allocated for %s, &quot;</span></span><br><span class="line">                                    <span class="string">&quot;but %s passed to avcodec_open2()\n&quot;</span>, avctx-&gt;codec-&gt;name, codec-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!codec)</span><br><span class="line">        codec = avctx-&gt;codec;</span><br><span class="line">    codec2 = <span class="built_in">ffcodec</span>(codec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((avctx-&gt;codec_type != AVMEDIA_TYPE_UNKNOWN &amp;&amp; avctx-&gt;codec_type != codec-&gt;type) ||</span><br><span class="line">        (avctx-&gt;codec_id   != AV_CODEC_ID_NONE     &amp;&amp; avctx-&gt;codec_id   != codec-&gt;id)) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(avctx, AV_LOG_ERROR, <span class="string">&quot;Codec type or id mismatches\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avctx-&gt;codec_type = codec-&gt;type;</span><br><span class="line">    avctx-&gt;codec_id   = codec-&gt;id;</span><br><span class="line">    avctx-&gt;codec      = codec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;extradata_size &lt; <span class="number">0</span> || avctx-&gt;extradata_size &gt;= FF_MAX_EXTRADATA_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    avci = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*avci));</span><br><span class="line">...</span><br><span class="line">    avctx-&gt;internal = avci;</span><br><span class="line"></span><br><span class="line">    avci-&gt;buffer_frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">    avci-&gt;buffer_pkt = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (codec2-&gt;priv_data_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!avctx-&gt;priv_data) &#123;</span><br><span class="line">            avctx-&gt;priv_data = <span class="built_in">av_mallocz</span>(codec2-&gt;priv_data_size);</span><br><span class="line">            <span class="keyword">if</span> (!avctx-&gt;priv_data) &#123;</span><br><span class="line">                ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">                <span class="keyword">goto</span> free_and_end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (codec-&gt;priv_class) &#123;</span><br><span class="line">                *(<span class="type">const</span> AVClass **)avctx-&gt;priv_data = codec-&gt;priv_class;</span><br><span class="line">                <span class="built_in">av_opt_set_defaults</span>(avctx-&gt;priv_data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (codec-&gt;priv_class &amp;&amp; (ret = <span class="built_in">av_opt_set_dict</span>(avctx-&gt;priv_data, options)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> free_and_end;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        avctx-&gt;priv_data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_opt_set_dict</span>(avctx, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> free_and_end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;codec_whitelist &amp;&amp; <span class="built_in">av_match_list</span>(codec-&gt;name, avctx-&gt;codec_whitelist, <span class="string">&#x27;,&#x27;</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Codec not on whitelist</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// only call ff_set_dimensions() for non H.264/VP6F/DXV codecs so as not to overwrite previously setup dimensions</span></span><br><span class="line">    <span class="keyword">if</span> (!(avctx-&gt;coded_width &amp;&amp; avctx-&gt;coded_height &amp;&amp; avctx-&gt;width &amp;&amp; avctx-&gt;height &amp;&amp;</span><br><span class="line">          (avctx-&gt;codec_id == AV_CODEC_ID_H264 || avctx-&gt;codec_id == AV_CODEC_ID_VP6F || avctx-&gt;codec_id == AV_CODEC_ID_DXV))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;coded_width &amp;&amp; avctx-&gt;coded_height)</span><br><span class="line">            ret = <span class="built_in">ff_set_dimensions</span>(avctx, avctx-&gt;coded_width, avctx-&gt;coded_height);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (avctx-&gt;width &amp;&amp; avctx-&gt;height)</span><br><span class="line">            ret = <span class="built_in">ff_set_dimensions</span>(avctx, avctx-&gt;width, avctx-&gt;height);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> free_and_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((avctx-&gt;coded_width || avctx-&gt;coded_height || avctx-&gt;width || avctx-&gt;height)</span><br><span class="line">        &amp;&amp; (  <span class="built_in">av_image_check_size2</span>(avctx-&gt;coded_width, avctx-&gt;coded_height, avctx-&gt;max_pixels, AV_PIX_FMT_NONE, <span class="number">0</span>, avctx) &lt; <span class="number">0</span></span><br><span class="line">           || <span class="built_in">av_image_check_size2</span>(avctx-&gt;width,       avctx-&gt;height,       avctx-&gt;max_pixels, AV_PIX_FMT_NONE, <span class="number">0</span>, avctx) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(avctx, AV_LOG_WARNING, <span class="string">&quot;Ignoring invalid width/height values\n&quot;</span>);</span><br><span class="line">        <span class="built_in">ff_set_dimensions</span>(avctx, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;width &gt; <span class="number">0</span> &amp;&amp; avctx-&gt;height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">av_image_check_sar</span>(avctx-&gt;width, avctx-&gt;height,</span><br><span class="line">                               avctx-&gt;sample_aspect_ratio) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">av_log</span>(avctx, AV_LOG_WARNING, <span class="string">&quot;ignoring invalid SAR: %u/%u\n&quot;</span>,</span><br><span class="line">                   avctx-&gt;sample_aspect_ratio.num,</span><br><span class="line">                   avctx-&gt;sample_aspect_ratio.den);</span><br><span class="line">            avctx-&gt;sample_aspect_ratio = (AVRational)&#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;sample_rate &lt; <span class="number">0</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;block_align &lt; <span class="number">0</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AV_CODEC_CAP_CHANNEL_CONF is a decoder-only flag; so the code below</span></span><br><span class="line"><span class="comment">     * in particular checks that nb_channels is set for all audio encoders. */</span></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp; !avctx-&gt;ch_layout.nb_channels</span><br><span class="line">        &amp;&amp; !(codec-&gt;capabilities &amp; AV_CODEC_CAP_CHANNEL_CONF)) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;ch_layout.nb_channels &amp;&amp; !<span class="built_in">av_channel_layout_check</span>(&amp;avctx-&gt;ch_layout)) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;ch_layout.nb_channels &gt; FF_SANE_NB_CHANNELS) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avctx-&gt;frame_num = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_AVCTX_FRAME_NUMBER</span></span><br><span class="line">FF_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line">    avctx-&gt;frame_number = avctx-&gt;frame_num;</span><br><span class="line">FF_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    avctx-&gt;codec_descriptor = <span class="built_in">avcodec_descriptor_get</span>(avctx-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((avctx-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_EXPERIMENTAL) &amp;&amp;</span><br><span class="line">        avctx-&gt;strict_std_compliance &gt; FF_COMPLIANCE_EXPERIMENTAL) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *codec_string = <span class="built_in">av_codec_is_encoder</span>(codec) ? <span class="string">&quot;encoder&quot;</span> : <span class="string">&quot;decoder&quot;</span>;</span><br><span class="line">        <span class="type">const</span> AVCodec *codec2;</span><br><span class="line">        <span class="built_in">av_log</span>(avctx, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;The %s &#x27;%s&#x27; is experimental but experimental codecs are not enabled, &quot;</span></span><br><span class="line">               <span class="string">&quot;add &#x27;-strict %d&#x27; if you want to use it.\n&quot;</span>,</span><br><span class="line">               codec_string, codec-&gt;name, FF_COMPLIANCE_EXPERIMENTAL);</span><br><span class="line">        codec2 = <span class="built_in">av_codec_is_encoder</span>(codec) ? <span class="built_in">avcodec_find_encoder</span>(codec-&gt;id) : <span class="built_in">avcodec_find_decoder</span>(codec-&gt;id);</span><br><span class="line">        <span class="keyword">if</span> (!(codec2-&gt;capabilities &amp; AV_CODEC_CAP_EXPERIMENTAL))</span><br><span class="line">            <span class="built_in">av_log</span>(avctx, AV_LOG_ERROR, <span class="string">&quot;Alternatively use the non experimental %s &#x27;%s&#x27;.\n&quot;</span>,</span><br><span class="line">                codec_string, codec2-&gt;name);</span><br><span class="line">        ret = AVERROR_EXPERIMENTAL;</span><br><span class="line">        <span class="keyword">goto</span> free_and_end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avctx-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">        (!avctx-&gt;time_base.num || !avctx-&gt;time_base.den)) &#123;</span><br><span class="line">        avctx-&gt;time_base.num = <span class="number">1</span>;</span><br><span class="line">        avctx-&gt;time_base.den = avctx-&gt;sample_rate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">av_codec_is_encoder</span>(avctx-&gt;codec))</span><br><span class="line">        ret = <span class="built_in">ff_encode_preinit</span>(avctx);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = <span class="built_in">ff_decode_preinit</span>(avctx);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> free_and_end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAVE_THREADS &amp;&amp; !avci-&gt;frame_thread_encoder) &#123;</span><br><span class="line">        <span class="comment">/* Frame-threaded decoders call FFCodec.init for their child contexts. */</span></span><br><span class="line">        <span class="built_in">lock_avcodec</span>(codec2);</span><br><span class="line">        ret = <span class="built_in">ff_thread_init</span>(avctx);</span><br><span class="line">        <span class="built_in">unlock_avcodec</span>(codec2);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> free_and_end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!HAVE_THREADS &amp;&amp; !(codec2-&gt;caps_internal &amp; FF_CODEC_CAP_AUTO_THREADS))</span><br><span class="line">        avctx-&gt;thread_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(avctx-&gt;active_thread_type &amp; FF_THREAD_FRAME) ||</span><br><span class="line">        avci-&gt;frame_thread_encoder) &#123;</span><br><span class="line">        <span class="keyword">if</span> (codec2-&gt;init) &#123;</span><br><span class="line">            <span class="built_in">lock_avcodec</span>(codec2);</span><br><span class="line">            ret = codec2-&gt;<span class="built_in">init</span>(avctx);</span><br><span class="line">            <span class="built_in">unlock_avcodec</span>(codec2);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                avci-&gt;needs_close = codec2-&gt;caps_internal &amp; FF_CODEC_CAP_INIT_CLEANUP;</span><br><span class="line">                <span class="keyword">goto</span> free_and_end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        avci-&gt;needs_close = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">av_codec_is_decoder</span>(avctx-&gt;codec)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!avctx-&gt;bit_rate)</span><br><span class="line">            avctx-&gt;bit_rate = <span class="built_in">get_bit_rate</span>(avctx);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* validate channel layout from the decoder */</span></span><br><span class="line">        <span class="keyword">if</span> ((avctx-&gt;ch_layout.nb_channels &amp;&amp; !<span class="built_in">av_channel_layout_check</span>(&amp;avctx-&gt;ch_layout)) ||</span><br><span class="line">            avctx-&gt;ch_layout.nb_channels &gt; FF_SANE_NB_CHANNELS) &#123;</span><br><span class="line">            ret = <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">            <span class="keyword">goto</span> free_and_end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (avctx-&gt;bits_per_coded_sample &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">            <span class="keyword">goto</span> free_and_end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (codec-&gt;priv_class)</span><br><span class="line">        <span class="built_in">av_assert0</span>(*(<span class="type">const</span> AVClass **)avctx-&gt;priv_data == codec-&gt;priv_class);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">free_and_end:</span><br><span class="line">    <span class="built_in">avcodec_close</span>(avctx);</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avformat-new-stream"><a href="#avformat-new-stream" class="headerlink" title="avformat_new_stream"></a>avformat_new_stream</h2><p>为了将 encoder 和 muxer 联系起来，需要创建 stream，在创建 stream 的时候，也会在内部创建 AVCodecContext，但是 stream 内部的 AVCodecContext 已经废弃了，所以上面的例子中单独创建了 AVCodecContext</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVStream *<span class="title">avformat_new_stream</span><span class="params">(AVFormatContext *s, <span class="type">const</span> AVCodec *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    FFStream *sti;</span><br><span class="line">    AVStream *st;</span><br><span class="line">    AVStream **streams;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;nb_streams &gt;= s-&gt;max_streams) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    streams = <span class="built_in">av_realloc_array</span>(s-&gt;streams, s-&gt;nb_streams + <span class="number">1</span>, <span class="built_in">sizeof</span>(*streams));</span><br><span class="line">...</span><br><span class="line">    s-&gt;streams = streams;</span><br><span class="line"></span><br><span class="line">    sti = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*sti));</span><br><span class="line">...</span><br><span class="line">    st = &amp;sti-&gt;pub;</span><br><span class="line"></span><br><span class="line">    st-&gt;av_class = &amp;stream_class;</span><br><span class="line">    st-&gt;codecpar = <span class="built_in">avcodec_parameters_alloc</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    sti-&gt;avctx = <span class="built_in">avcodec_alloc_context3</span>(<span class="literal">NULL</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;iformat) &#123;</span><br><span class="line">        sti-&gt;info = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*sti-&gt;info));</span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;info)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_R_FRAME_RATE</span></span><br><span class="line">        sti-&gt;info-&gt;last_dts      = AV_NOPTS_VALUE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        sti-&gt;info-&gt;fps_first_dts = AV_NOPTS_VALUE;</span><br><span class="line">        sti-&gt;info-&gt;fps_last_dts  = AV_NOPTS_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* default pts setting is MPEG-like */</span></span><br><span class="line">        <span class="built_in">avpriv_set_pts_info</span>(st, <span class="number">33</span>, <span class="number">1</span>, <span class="number">90000</span>);</span><br><span class="line">        <span class="comment">/* we set the current DTS to 0 so that formats without any timestamps</span></span><br><span class="line"><span class="comment">         * but durations get some timestamps, formats with some unknown</span></span><br><span class="line"><span class="comment">         * timestamps have their first few packets buffered and the</span></span><br><span class="line"><span class="comment">         * timestamps corrected before they are returned to the user */</span></span><br><span class="line">        sti-&gt;cur_dts = RELATIVE_TS_BASE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sti-&gt;cur_dts = AV_NOPTS_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st-&gt;index      = s-&gt;nb_streams;</span><br><span class="line">    st-&gt;start_time = AV_NOPTS_VALUE;</span><br><span class="line">    st-&gt;duration   = AV_NOPTS_VALUE;</span><br><span class="line">    sti-&gt;first_dts     = AV_NOPTS_VALUE;</span><br><span class="line">    sti-&gt;probe_packets = &lt;u&gt;s-&gt;max_probe_packets&lt;/u&gt;;</span><br><span class="line">    sti-&gt;pts_wrap_reference = AV_NOPTS_VALUE;</span><br><span class="line">    sti-&gt;pts_wrap_behavior  = AV_PTS_WRAP_IGNORE;</span><br><span class="line"></span><br><span class="line">    sti-&gt;last_IP_pts = AV_NOPTS_VALUE;</span><br><span class="line">    sti-&gt;last_dts_for_order_check = AV_NOPTS_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_REORDER_DELAY + <span class="number">1</span>; i++)</span><br><span class="line">        sti-&gt;pts_buffer[i] = AV_NOPTS_VALUE;</span><br><span class="line"></span><br><span class="line">    st-&gt;sample_aspect_ratio = (AVRational) &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    sti-&gt;inject_global_side_data = si-&gt;inject_global_side_data;</span><br><span class="line"></span><br><span class="line">    &lt;u&gt;sti-&gt;need_context_update = <span class="number">1</span>;&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">    s-&gt;streams[s-&gt;nb_streams++] = st;</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">ff_free_stream</span>(&amp;st);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avcodec-parameters-from-context"><a href="#avcodec-parameters-from-context" class="headerlink" title="avcodec_parameters_from_context"></a>avcodec_parameters_from_context</h2><p>把之前单独创建的 AVCodecContext 中的参数拷贝到 stream 中的 codecpar</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avcodec_parameters_from_context</span><span class="params">(AVCodecParameters *par,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> AVCodecContext *codec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">codec_parameters_reset</span>(par);</span><br><span class="line"></span><br><span class="line">    par-&gt;codec_type = codec-&gt;codec_type;</span><br><span class="line">    par-&gt;codec_id   = codec-&gt;codec_id;</span><br><span class="line">    par-&gt;codec_tag  = codec-&gt;codec_tag;</span><br><span class="line"></span><br><span class="line">    par-&gt;bit_rate              = codec-&gt;bit_rate;</span><br><span class="line">    par-&gt;bits_per_coded_sample = codec-&gt;bits_per_coded_sample;</span><br><span class="line">    par-&gt;bits_per_raw_sample   = codec-&gt;bits_per_raw_sample;</span><br><span class="line">    par-&gt;profile               = codec-&gt;profile;</span><br><span class="line">    par-&gt;level                 = codec-&gt;level;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (par-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">        par-&gt;format              = codec-&gt;pix_fmt;</span><br><span class="line">        par-&gt;width               = codec-&gt;width;</span><br><span class="line">        par-&gt;height              = codec-&gt;height;</span><br><span class="line">        par-&gt;field_order         = codec-&gt;field_order;</span><br><span class="line">        par-&gt;color_range         = codec-&gt;color_range;</span><br><span class="line">        par-&gt;color_primaries     = codec-&gt;color_primaries;</span><br><span class="line">        par-&gt;color_trc           = codec-&gt;color_trc;</span><br><span class="line">        par-&gt;color_space         = codec-&gt;colorspace;</span><br><span class="line">        par-&gt;chroma_location     = codec-&gt;chroma_sample_location;</span><br><span class="line">        par-&gt;sample_aspect_ratio = codec-&gt;sample_aspect_ratio;</span><br><span class="line">        par-&gt;video_delay         = codec-&gt;has_b_frames;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">        par-&gt;format           = codec-&gt;sample_fmt;</span><br><span class="line">...</span><br><span class="line">        ret = <span class="built_in">av_channel_layout_copy</span>(&amp;par-&gt;ch_layout, &amp;codec-&gt;ch_layout);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">...</span><br><span class="line">        par-&gt;sample_rate      = codec-&gt;sample_rate;</span><br><span class="line">        par-&gt;block_align      = codec-&gt;block_align;</span><br><span class="line">        par-&gt;frame_size       = codec-&gt;frame_size;</span><br><span class="line">        par-&gt;initial_padding  = codec-&gt;initial_padding;</span><br><span class="line">        par-&gt;trailing_padding = codec-&gt;trailing_padding;</span><br><span class="line">        par-&gt;seek_preroll     = codec-&gt;seek_preroll;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">        par-&gt;width  = codec-&gt;width;</span><br><span class="line">        par-&gt;height = codec-&gt;height;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (codec-&gt;extradata) &#123;</span><br><span class="line">        par-&gt;extradata = <span class="built_in">av_mallocz</span>(codec-&gt;extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (!par-&gt;extradata)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="built_in">memcpy</span>(par-&gt;extradata, codec-&gt;extradata, codec-&gt;extradata_size);</span><br><span class="line">        par-&gt;extradata_size = codec-&gt;extradata_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avformat-write-header"><a href="#avformat-write-header" class="headerlink" title="avformat_write_header"></a>avformat_write_header</h2><p>对 AVFormatContext 做一些初始化工作。在 avformat_init_output 中可能会执行 init_pts 函数，所以在 avformat_write_header 中做了一个特判，避免重复调用 init_pts</p><p>avio_write_marker 就是将当前 iostream 标记为某个类型，可以看到，在调用 <code>ffofmt(s-&gt;oformat)-&gt;write_header</code> 后又调用 avio_write_marker 将当前 iostream 标记为 <code>AVIO_DATA_MARKER_UNKNOWN</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_write_header</span><span class="params">(AVFormatContext *s, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    <span class="type">int</span> already_initialized = si-&gt;initialized;</span><br><span class="line">    <span class="type">int</span> streams_already_initialized = &lt;u&gt;si-&gt;streams_initialized&lt;/u&gt;;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!already_initialized)</span><br><span class="line">        <span class="keyword">if</span> ((ret = <span class="built_in">avformat_init_output</span>(s, options)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(s-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE) &amp;&amp; s-&gt;pb) <span class="comment">// 有file</span></span><br><span class="line">        <span class="built_in">avio_write_marker</span>(s-&gt;pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_HEADER);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ffofmt</span>(s-&gt;oformat)-&gt;write_header) &#123;</span><br><span class="line">        ret = <span class="built_in">ffofmt</span>(s-&gt;oformat)-&gt;<span class="built_in">write_header</span>(s);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span> &amp;&amp; s-&gt;pb &amp;&amp; s-&gt;pb-&gt;error &lt; <span class="number">0</span>)</span><br><span class="line">            ret = s-&gt;pb-&gt;error;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        <span class="built_in">flush_if_needed</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(s-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE) &amp;&amp; s-&gt;pb)</span><br><span class="line">        <span class="built_in">avio_write_marker</span>(s-&gt;pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_UNKNOWN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;streams_initialized) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = <span class="built_in">init_pts</span>(s)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> streams_already_initialized;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">deinit_muxer</span>(s);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="avformat-init-output"><a href="#avformat-init-output" class="headerlink" title="avformat_init_output"></a>avformat_init_output</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avformat_init_output</span><span class="params">(AVFormatContext *s, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">init_muxer</span>(s, options)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    si-&gt;initialized = <span class="number">1</span>;</span><br><span class="line">    si-&gt;streams_initialized = ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ffofmt</span>(s-&gt;oformat)-&gt;init &amp;&amp; ret) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = <span class="built_in">init_pts</span>(s)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> AVSTREAM_INIT_IN_INIT_OUTPUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> AVSTREAM_INIT_IN_WRITE_HEADER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="init-muxer"><a href="#init-muxer" class="headerlink" title="init_muxer"></a>init_muxer</h4><p>检查 stream 上的参数是否已经设置</p><p>可能调用 AVOutputFormat 中的 init 函数初始化 AVFormatContext</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">init_muxer</span><span class="params">(AVFormatContext *s, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line">    AVDictionary *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> FFOutputFormat *of = <span class="built_in">ffofmt</span>(s-&gt;oformat);</span><br><span class="line">    AVDictionaryEntry *e;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options)</span><br><span class="line">        <span class="built_in">av_dict_copy</span>(&amp;tmp, *options, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_opt_set_dict</span>(s, &amp;tmp)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;priv_data &amp;&amp; s-&gt;oformat-&gt;priv_class &amp;&amp; *(<span class="type">const</span> AVClass**)s-&gt;priv_data == s-&gt;oformat-&gt;priv_class &amp;&amp;</span><br><span class="line">        (ret = <span class="built_in">av_opt_set_dict2</span>(s-&gt;priv_data, &amp;tmp, AV_OPT_SEARCH_CHILDREN)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;url &amp;&amp; !(s-&gt;url = <span class="built_in">av_strdup</span>(<span class="string">&quot;&quot;</span>))) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some sanity checks</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;nb_streams == <span class="number">0</span> &amp;&amp; !(of-&gt;p.flags &amp; AVFMT_NOSTREAMS)) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查stream</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream          *<span class="type">const</span>  st = s-&gt;streams[i];</span><br><span class="line">        FFStream          *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        AVCodecParameters *<span class="type">const</span> par = st-&gt;codecpar;</span><br><span class="line">        <span class="type">const</span> AVCodecDescriptor *desc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!st-&gt;time_base.num) &#123;</span><br><span class="line">            <span class="comment">/* fall back on the default timebase values */</span></span><br><span class="line">            <span class="keyword">if</span> (par-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp; par-&gt;sample_rate)</span><br><span class="line">                <span class="built_in">avpriv_set_pts_info</span>(st, <span class="number">64</span>, <span class="number">1</span>, par-&gt;sample_rate);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">avpriv_set_pts_info</span>(st, <span class="number">33</span>, <span class="number">1</span>, <span class="number">90000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (par-&gt;codec_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            <span class="keyword">if</span> (par-&gt;sample_rate &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_ERROR, <span class="string">&quot;sample rate not set\n&quot;</span>);</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (!par-&gt;block_align)</span><br><span class="line">                par-&gt;block_align = par-&gt;ch_layout.nb_channels *</span><br><span class="line">                                   <span class="built_in">av_get_bits_per_sample</span>(par-&gt;codec_id) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            <span class="keyword">if</span> ((par-&gt;width &lt;= <span class="number">0</span> || par-&gt;height &lt;= <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                !(of-&gt;p.flags &amp; AVFMT_NODIMENSIONS)) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(s, AV_LOG_ERROR, <span class="string">&quot;dimensions not set\n&quot;</span>);</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">av_cmp_q</span>(st-&gt;sample_aspect_ratio, par-&gt;sample_aspect_ratio)</span><br><span class="line">                &amp;&amp; <span class="built_in">fabs</span>(<span class="built_in">av_q2d</span>(st-&gt;sample_aspect_ratio) - <span class="built_in">av_q2d</span>(par-&gt;sample_aspect_ratio)) &gt; <span class="number">0.004</span>*<span class="built_in">av_q2d</span>(st-&gt;sample_aspect_ratio)</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (st-&gt;sample_aspect_ratio.num != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    st-&gt;sample_aspect_ratio.den != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    par-&gt;sample_aspect_ratio.num != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    par-&gt;sample_aspect_ratio.den != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(s, AV_LOG_ERROR, <span class="string">&quot;Aspect ratio mismatch between muxer &quot;</span></span><br><span class="line">                           <span class="string">&quot;(%d/%d) and encoder layer (%d/%d)\n&quot;</span>,</span><br><span class="line">                           st-&gt;sample_aspect_ratio.num, st-&gt;sample_aspect_ratio.den,</span><br><span class="line">                           par-&gt;sample_aspect_ratio.num,</span><br><span class="line">                           par-&gt;sample_aspect_ratio.den);</span><br><span class="line">...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        desc = <span class="built_in">avcodec_descriptor_get</span>(par-&gt;codec_id);</span><br><span class="line">        <span class="keyword">if</span> (desc &amp;&amp; desc-&gt;props &amp; AV_CODEC_PROP_REORDER)</span><br><span class="line">            sti-&gt;reorder = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        sti-&gt;is_intra_only = <span class="built_in">ff_is_intra_only</span>(par-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (of-&gt;p.codec_tag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (   par-&gt;codec_tag</span><br><span class="line">                &amp;&amp; par-&gt;codec_id == AV_CODEC_ID_RAWVIDEO</span><br><span class="line">                &amp;&amp; (   <span class="built_in">av_codec_get_tag</span>(of-&gt;p.codec_tag, par-&gt;codec_id) == <span class="number">0</span></span><br><span class="line">                    || <span class="built_in">av_codec_get_tag</span>(of-&gt;p.codec_tag, par-&gt;codec_id) == <span class="built_in">MKTAG</span>(<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">                &amp;&amp; !<span class="built_in">validate_codec_tag</span>(s, st)) &#123;</span><br><span class="line">                <span class="comment">// the current rawvideo encoding system ends up setting</span></span><br><span class="line">                <span class="comment">// the wrong codec_tag for avi/mov, we override it here</span></span><br><span class="line">                par-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (par-&gt;codec_tag) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">validate_codec_tag</span>(s, st)) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">uint32_t</span> otag = <span class="built_in">av_codec_get_tag</span>(s-&gt;oformat-&gt;codec_tag, par-&gt;codec_id);</span><br><span class="line">                    <span class="built_in">av_log</span>(s, AV_LOG_ERROR,</span><br><span class="line">                           <span class="string">&quot;Tag %s incompatible with output codec id &#x27;%d&#x27; (%s)\n&quot;</span>,</span><br><span class="line">                           <span class="built_in">av_fourcc2str</span>(par-&gt;codec_tag), par-&gt;codec_id, <span class="built_in">av_fourcc2str</span>(otag));</span><br><span class="line">...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                par-&gt;codec_tag = <span class="built_in">av_codec_get_tag</span>(of-&gt;p.codec_tag, par-&gt;codec_id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (par-&gt;codec_type != AVMEDIA_TYPE_ATTACHMENT)</span><br><span class="line">            si-&gt;nb_interleaved_streams++;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s-&gt;priv_data &amp;&amp; of-&gt;priv_data_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (e = <span class="literal">NULL</span>; e = <span class="built_in">av_dict_get</span>(s-&gt;metadata, <span class="string">&quot;encoder-&quot;</span>, e, AV_DICT_IGNORE_SUFFIX); ) &#123;</span><br><span class="line">        <span class="built_in">av_dict_set</span>(&amp;s-&gt;metadata, e-&gt;key, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">         <span class="built_in">av_dict_free</span>(options);</span><br><span class="line">         *options = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of-&gt;init) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = of-&gt;<span class="built_in">init</span>(s)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (of-&gt;deinit)</span><br><span class="line">                of-&gt;<span class="built_in">deinit</span>(s);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">av_dict_free</span>(&amp;tmp);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="init-pts"><a href="#init-pts" class="headerlink" title="init_pts"></a>init_pts</h4><p>初始化 stream 上的 pts</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">init_pts</span><span class="params">(AVFormatContext *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FFFormatContext *<span class="type">const</span> si = <span class="built_in">ffformatcontext</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init PTS generation */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; s-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *<span class="type">const</span> st = s-&gt;streams[i];</span><br><span class="line">        FFStream *<span class="type">const</span> sti = <span class="built_in">ffstream</span>(st);</span><br><span class="line">        <span class="type">int64_t</span> den = AV_NOPTS_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (st-&gt;codecpar-&gt;codec_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            den = (<span class="type">int64_t</span>)st-&gt;time_base.num * st-&gt;codecpar-&gt;sample_rate;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            den = (<span class="type">int64_t</span>)st-&gt;time_base.num * st-&gt;time_base.den;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sti-&gt;priv_pts)</span><br><span class="line">            sti-&gt;priv_pts = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*sti-&gt;priv_pts));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (den != AV_NOPTS_VALUE) &#123;</span><br><span class="line">...</span><br><span class="line">            <span class="built_in">frac_init</span>(sti-&gt;priv_pts, <span class="number">0</span>, <span class="number">0</span>, den);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11多线程</title>
      <link href="/2023/05/02/C-11%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/05/02/C-11%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍一下 C++11 提供的线程库。</p><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><p>基本使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">A</span><span class="params">(f, <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TYPE_VIS</span> thread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 成员数据</span></span><br><span class="line">    <span class="type">__libcpp_thread_t</span> __t_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __thread_id id;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">__libcpp_thread_t</span> native_handle_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造</span></span><br><span class="line">    <span class="built_in">thread</span>() _NOEXCEPT : __t_(_LIBCPP_NULL_THREAD) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板构造函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._Args,</span><br><span class="line">              <span class="keyword">class</span> = <span class="keyword">typename</span> enable_if</span><br><span class="line">              &lt;</span><br><span class="line">                   !is_same&lt;<span class="keyword">typename</span> __uncvref&lt;_Fp&gt;::type, thread&gt;::value</span><br><span class="line">              &gt;::type</span><br><span class="line">             &gt;</span><br><span class="line">        <span class="keyword">explicit</span> <span class="built_in">thread</span>(_Fp&amp;&amp; __f, _Args&amp;&amp;... __args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造</span></span><br><span class="line">    <span class="built_in">thread</span>(thread&amp;&amp; <span class="type">__t</span>) _NOEXCEPT : __t_(<span class="type">__t</span>.__t_) &#123;<span class="type">__t</span>.__t_ = _LIBCPP_NULL_THREAD;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动赋值</span></span><br><span class="line">    thread&amp; <span class="keyword">operator</span>=(thread&amp;&amp; <span class="type">__t</span>) _NOEXCEPT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(thread&amp; <span class="type">__t</span>)</span> _NOEXCEPT </span>&#123;_VSTD::<span class="built_in">swap</span>(__t_, <span class="type">__t</span>.__t_);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> !__libcpp_thread_isnull(&amp;__t_);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ec = EINVAL;</span><br><span class="line">        <span class="keyword">if</span> (!__libcpp_thread_isnull(&amp;__t_))</span><br><span class="line">        &#123;</span><br><span class="line">            ec = __libcpp_thread_join(&amp;__t_);</span><br><span class="line">            <span class="keyword">if</span> (ec == <span class="number">0</span>)</span><br><span class="line">                __t_ = _LIBCPP_NULL_THREAD;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (ec)</span><br><span class="line">            __throw_system_error(ec, <span class="string">&quot;thread::join failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ec = EINVAL;</span><br><span class="line">        <span class="keyword">if</span> (!__libcpp_thread_isnull(&amp;__t_))</span><br><span class="line">        &#123;</span><br><span class="line">            ec = __libcpp_thread_detach(&amp;__t_);</span><br><span class="line">            <span class="keyword">if</span> (ec == <span class="number">0</span>)</span><br><span class="line">                __t_ = _LIBCPP_NULL_THREAD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ec)</span><br><span class="line">            __throw_system_error(ec, <span class="string">&quot;thread::detach failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    id <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> __libcpp_thread_get_id(&amp;__t_);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    native_handle_type <span class="title">native_handle</span><span class="params">()</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> __t_;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">thread</span>()</span><br><span class="line">    &#123;   <span class="comment">// thread必须join或者detach，否则析构的时候会报错</span></span><br><span class="line">        <span class="keyword">if</span> (!__libcpp_thread_isnull(&amp;__t_))</span><br><span class="line">            <span class="built_in">terminate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，上面的很多方法都是通过 <code>__libcpp_thread_xxx</code> 实现的，而 <code>__libcpp_thread_xxx</code> 则封装了具体的线程 API，如果是 linux 平台，<code>__libcpp_thread_xxx</code> 可能是 pthread，如果是 windows，<code>__libcpp_thread_xxx</code> 可能是 windows 的线程库</p><p><code>__libcpp_thread_xxx</code> 具体在 <code>__threading_support</code> 头文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutex</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">pthread_mutex_t</span> <span class="type">__libcpp_mutex_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LIBCPP_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">pthread_mutex_t</span> <span class="type">__libcpp_recursive_mutex_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Condition Variable</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">pthread_cond_t</span> <span class="type">__libcpp_condvar_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LIBCPP_CONDVAR_INITIALIZER PTHREAD_COND_INITIALIZER</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute once</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">pthread_once_t</span> __libcpp_exec_once_flag;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LIBCPP_EXEC_ONCE_INITIALIZER PTHREAD_ONCE_INIT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread id</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">pthread_t</span> __libcpp_thread_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LIBCPP_NULL_THREAD 0U</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">pthread_t</span> <span class="type">__libcpp_thread_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread Local Storage</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">pthread_key_t</span> __libcpp_tls_key;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">bool</span> __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pthread_equal</span>(t1, t2) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __libcpp_thread_create(<span class="type">__libcpp_thread_t</span> *<span class="type">__t</span>, <span class="type">void</span> *(*__func)(<span class="type">void</span> *),</span><br><span class="line">                           <span class="type">void</span> *__arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pthread_create</span>(<span class="type">__t</span>, <span class="number">0</span>, __func, __arg);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意 pthread_t、<code>__libcpp_thread_id</code>、<code>__libcpp_thread_t</code>、<code>__thread_id</code>：<code>__libcpp_thread_id</code> 和 <code>__libcpp_thread_t</code> 都是 pthread_t 的别名，而 <code>__thread_id</code> 是对 <code>__libcpp_thread_id</code> 的包装，他有一个 private 的 implicit 的构造函数（接受 <code>__libcpp_thread_id</code> 参数），从而可以有 <code>__libcpp_thread_id</code> 到 <code>__thread_id</code> 的自动转换，但是该转换只能在友元，比如 <code>this_thread::get_id()</code> 函数中访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">pthread_t</span> __libcpp_thread_id;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">pthread_t</span> <span class="type">__libcpp_thread_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> __thread_id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> pthread_t is a pointer on Darwin but a long on Linux.</span></span><br><span class="line">    <span class="comment">// NULL is the no-thread value on Darwin.  Someone needs to check</span></span><br><span class="line">    <span class="comment">// on other platforms.  We assume 0 works everywhere for now.</span></span><br><span class="line">    __libcpp_thread_id __id_;</span><br><span class="line"></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    __thread_id() _NOEXCEPT : __id_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    __thread_id(__libcpp_thread_id __id) : __id_(__id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> __thread_id <span class="title">this_thread::get_id</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> this_thread</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">__thread_id <span class="comment">// 从__libcpp_thread_id自动转换为__thread_id</span></span><br><span class="line"><span class="built_in">get_id</span>() _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __libcpp_thread_get_current_id();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看模板构造函数，这个构造函数使用最多。此构造函数生效的条件是 <code>_Fp</code> 不能是 thread 类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._Args,</span><br><span class="line">          <span class="keyword">class</span> = <span class="keyword">typename</span> enable_if</span><br><span class="line">          &lt;</span><br><span class="line">               !is_same&lt;<span class="keyword">typename</span> __uncvref&lt;_Fp&gt;::type, thread&gt;::value</span><br><span class="line">          &gt;::type</span><br><span class="line">         &gt;</span><br><span class="line">    _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">thread</span>(_Fp&amp;&amp; __f, _Args&amp;&amp;... __args);</span><br></pre></td></tr></table></figure><p><code>__uncvref</code> 就是先去除引用，再去除 const、volatile 限定符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__uncvref</span>  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE <span class="keyword">typename</span> remove_cv&lt;<span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type&gt;::type type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模板构造函数中使用了一个 tuple 来存储可调用对象和参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._Args,</span><br><span class="line">          <span class="keyword">class</span></span><br><span class="line">         &gt;</span><br><span class="line">thread::<span class="built_in">thread</span>(_Fp&amp;&amp; __f, _Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> unique_ptr&lt;__thread_struct&gt; _TSPtr;</span><br><span class="line">    _TSPtr __tsp(<span class="keyword">new</span> __thread_struct);</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;_TSPtr, <span class="keyword">typename</span> decay&lt;_Fp&gt;::type, <span class="keyword">typename</span> decay&lt;_Args&gt;::type...&gt; _Gp;</span><br><span class="line">    _VSTD::unique_ptr&lt;_Gp&gt; __p(</span><br><span class="line">            <span class="keyword">new</span> _Gp(std::<span class="built_in">move</span>(__tsp),</span><br><span class="line">                    __decay_copy(_VSTD::forward&lt;_Fp&gt;(__f)),</span><br><span class="line">                    __decay_copy(_VSTD::forward&lt;_Args&gt;(__args))...));</span><br><span class="line">    <span class="type">int</span> __ec = __libcpp_thread_create(&amp;__t_, &amp;__thread_proxy&lt;_Gp&gt;, __p.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">if</span> (__ec == <span class="number">0</span>)</span><br><span class="line">        __p.<span class="built_in">release</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __throw_system_error(__ec, <span class="string">&quot;thread constructor failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 <code>typename decay&lt;_Fp&gt;::type</code> 和 <code>typename decay&lt;_Args&gt;::type...</code> 会把模板类型进行退化。退化具体包括以下操作：去除引用，去除 const&#x2F;volatile，函数&#x2F;数组转换为函数指针&#x2F;数组首元素指针。</p><p>比如，如果 <code>_Fp</code> 是函数引用（当传给 thread 一个函数名时，<code>__f</code> 会推断为函数引用），<code>typename decay&lt;_Fp&gt;::type</code> 就是函数指针，如果 <code>_Args</code> 是引用类型，<code>typename decay&lt;_Args&gt;::type...</code> 将是值类型。</p><p>所以创建的 <code>tuple&lt;_TSPtr, typename decay&lt;_Fp&gt;::type, typename decay&lt;_Args&gt;::type...&gt;</code> 里面都是值类型。</p><p>上面的构造函数使用了 <code>__decay_copy</code> 保证传给 <code>_Gp</code> 的参数是 decay 之后的类型，因为 <code>__decay_copy</code> 返回类型为 decay 后类型的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="keyword">typename</span> decay&lt;_Tp&gt;::type</span><br><span class="line">__decay_copy(_Tp&amp;&amp; <span class="type">__t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _VSTD::forward&lt;_Tp&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意，如果传给 thread 的是右值引用，而且参数类型 decay 之后就是他自身，那么参数会一路移动到 tuple 中，比如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f, move(a))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!a) </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a is null&quot;</span> &lt;&lt; endl;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为 <code>__decay_copy</code> 返回的虽然是值，但是他是临时值，后续的 tuple 构造函数会使用右值引用来指向该值，于是 tuple 内部继续发生移动构造。</p><p>上面 <code>__libcpp_thread_create</code> 函数调用 pthread_create 来创建线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __libcpp_thread_create(<span class="type">__libcpp_thread_t</span> *<span class="type">__t</span>, <span class="type">void</span> *(*__func)(<span class="type">void</span> *),</span><br><span class="line">                           <span class="type">void</span> *__arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pthread_create</span>(<span class="type">__t</span>, <span class="number">0</span>, __func, __arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传给新线程执行的函数是 <code>__thread_proxy</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>&gt;</span><br><span class="line"><span class="type">void</span>* __thread_proxy(<span class="type">void</span>* __vp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _Fp = std::tuple&lt; unique_ptr&lt;__thread_struct&gt;, Functor, Args...&gt;</span></span><br><span class="line">    std::unique_ptr&lt;_Fp&gt; __p(<span class="built_in">static_cast</span>&lt;_Fp*&gt;(__vp));</span><br><span class="line">    __thread_local_data().<span class="built_in">set_pointer</span>(_VSTD::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(*__p).<span class="built_in">release</span>());</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __make_tuple_indices&lt;tuple_size&lt;_Fp&gt;::value, <span class="number">2</span>&gt;::type _Index;</span><br><span class="line">    __thread_execute(*__p, _Index());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__thread_proxy</code> 中重新使用 unique_ptr 包装输入的 <code>__vp</code> 指针，而 thread 构造函数会对 unique_ptr 进行 release 操作。</p><p><code>unique_ptr::release()</code> 不是释放指针，<strong>不会进行 delete 操作</strong>，<code>thread::thread(...)</code> 进行 release 之后，在 <code>__thread_proxy&lt;_Gp&gt;</code> 函数中又会重新得到该 unique_ptr，相当于进行了一个转移。</p><p><code>__make_tuple_indices&lt;tuple_size&lt;_Fp&gt;::value, 2&gt;::type</code> 返回一个序列，从 2 开始到 <code>tuple_size&lt;_Fp&gt;::value</code>，这刚好就是参数的索引，和 bind 里面是一样的。</p><p>最终函数执行是在 <code>__thread_execute</code> 里面，调用 <code>__invoke</code> 来执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_TSp</span>, <span class="keyword">class</span> <span class="title class_">_Fp</span>, <span class="keyword">class</span> ..._Args, <span class="type">size_t</span> ..._Indices&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="type">void</span></span><br><span class="line">__thread_execute(tuple&lt;_TSp, _Fp, _Args...&gt;&amp; <span class="type">__t</span>, __tuple_indices&lt;_Indices...&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    __invoke(_VSTD::<span class="built_in">move</span>(_VSTD::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(<span class="type">__t</span>)), _VSTD::<span class="built_in">move</span>(_VSTD::<span class="built_in">get</span>&lt;_Indices&gt;(<span class="type">__t</span>))...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__invoke</code> 会根据第一个参数的类型（比如是函数指针还是类成员函数指针）决定如何进行调用，这部分和 bind 是一样的。</p><h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h3><p>mutex 类如下，对于 linux 平台，mutex 就是封装了 pthread 的 mutex。从下面代码可以看到，mutex 无法拷贝构造、拷贝赋值、移动构造、移动赋值，所以要让 mutex 有移动语义，还需要使用 unique_ptr 进行包装。</p><p>其他的操作，lock、try_lock、unlock 和 pthread 是一样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mutex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用 _LIBCPP_MUTEX_INITIALIZER 来初始化__libcpp_mutex_t</span></span><br><span class="line">    <span class="type">__libcpp_mutex_t</span> __m_ = _LIBCPP_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mutex</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mutex</span>(<span class="type">const</span> mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    mutex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> mutex&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    mutex::~<span class="built_in">mutex</span>() _NOEXCEPT</span><br><span class="line">    &#123;</span><br><span class="line">        __libcpp_mutex_destroy(&amp;__m_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ec = __libcpp_mutex_lock(&amp;__m_);</span><br><span class="line">        <span class="keyword">if</span> (ec)</span><br><span class="line">            __throw_system_error(ec, <span class="string">&quot;mutex lock failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __libcpp_mutex_trylock(&amp;__m_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ec = __libcpp_mutex_unlock(&amp;__m_);</span><br><span class="line">        (<span class="type">void</span>)ec;</span><br><span class="line">        _LIBCPP_ASSERT(ec == <span class="number">0</span>, <span class="string">&quot;call to mutex::unlock failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">__libcpp_mutex_t</span>* native_handle_type;</span><br><span class="line">    <span class="function">native_handle_type <span class="title">native_handle</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> &amp;__m_;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h3><p>lock_guard 是 mutex 的辅助类。lock_guard 的构造函数接受一个锁类型的变量，同时在构造函数内加锁，还会在析构时释放锁，所以加锁和 lock_guard 的生命周期是关联的。lock_guard 还有一个构造函数，他可以接受一个已经加锁的锁变量，要使用这个构造函数，第二个参数必须是 adopt_lock_t 类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Mutex</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_guard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Mutex mutex_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutex_type&amp; __m_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(mutex_type&amp; __m)</span></span></span><br><span class="line"><span class="function">        : __m_(__m) &#123;</span>__m_.<span class="built_in">lock</span>();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时表示当前线程已经加锁</span></span><br><span class="line">    <span class="built_in">lock_guard</span>(mutex_type&amp; __m, <span class="type">adopt_lock_t</span>)</span><br><span class="line">        : __m_(__m) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">lock_guard</span>() &#123;__m_.<span class="built_in">unlock</span>();&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">lock_guard</span>(lock_guard <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    lock_guard&amp; <span class="keyword">operator</span>=(lock_guard <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h3><p>unique_lock 和 lock_guard 类似，都提供了将锁和自己的生命周期关联起来的功能。但是 unique_lock 语义更丰富，有移动构造和移动赋值，还提供了 defer_lock、try_to_lock 两种构造语义，defer_lock 就是构造时不加锁，后面可以自己主动加锁，try_to_lock 则是在构造时使用 try_to_lock 而非 lock。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Mutex</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_lock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Mutex mutex_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutex_type* __m_;</span><br><span class="line">    <span class="type">bool</span> __owns_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unique_lock</span>() : __m_(<span class="literal">nullptr</span>), __owns_(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unique_lock</span><span class="params">(mutex_type&amp; __m)</span></span></span><br><span class="line"><span class="function">        : __m_(_VSTD::addressof(__m)), __owns_(true) &#123;</span>__m_-&gt;<span class="built_in">lock</span>();&#125;</span><br><span class="line">    <span class="built_in">unique_lock</span>(mutex_type&amp; __m, <span class="type">defer_lock_t</span>)</span><br><span class="line">        : __m_(_VSTD::<span class="built_in">addressof</span>(__m)), __owns_(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">unique_lock</span>(mutex_type&amp; __m, <span class="type">try_to_lock_t</span>)</span><br><span class="line">        : __m_(_VSTD::<span class="built_in">addressof</span>(__m)), __owns_(__m.<span class="built_in">try_lock</span>()) &#123;&#125;</span><br><span class="line">    <span class="built_in">unique_lock</span>(mutex_type&amp; __m, <span class="type">adopt_lock_t</span>)</span><br><span class="line">        : __m_(_VSTD::<span class="built_in">addressof</span>(__m)), __owns_(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">...</span><br><span class="line">    ~<span class="built_in">unique_lock</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__owns_)</span><br><span class="line">            __m_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unique_lock</span>(unique_lock <span class="type">const</span>&amp;); <span class="comment">// = delete;</span></span><br><span class="line">    unique_lock&amp; <span class="keyword">operator</span>=(unique_lock <span class="type">const</span>&amp;); <span class="comment">// = delete;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unique_lock</span>(unique_lock&amp;&amp; __u) _NOEXCEPT</span><br><span class="line">        : __m_(__u.__m_), __owns_(__u.__owns_)</span><br><span class="line">        &#123;__u.__m_ = <span class="literal">nullptr</span>; __u.__owns_ = <span class="literal">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">    unique_lock&amp; <span class="keyword">operator</span>=(unique_lock&amp;&amp; __u) _NOEXCEPT</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__owns_)</span><br><span class="line">            __m_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        __m_ = __u.__m_;</span><br><span class="line">        __owns_ = __u.__owns_;</span><br><span class="line">        __u.__m_ = <span class="literal">nullptr</span>;</span><br><span class="line">        __u.__owns_ = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (__m_ == <span class="literal">nullptr</span>)</span><br><span class="line">            __throw_system_error(EPERM, <span class="string">&quot;unique_lock::lock: references null mutex&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__owns_)</span><br><span class="line">            __throw_system_error(EDEADLK, <span class="string">&quot;unique_lock::lock: already locked&quot;</span>);</span><br><span class="line">        __m_-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        __owns_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (__m_ == <span class="literal">nullptr</span>)</span><br><span class="line">            __throw_system_error(EPERM, <span class="string">&quot;unique_lock::try_lock: references null mutex&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__owns_)</span><br><span class="line">            __throw_system_error(EDEADLK, <span class="string">&quot;unique_lock::try_lock: already locked&quot;</span>);</span><br><span class="line">        __owns_ = __m_-&gt;<span class="built_in">try_lock</span>();</span><br><span class="line">        <span class="keyword">return</span> __owns_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!__owns_)</span><br><span class="line">            __throw_system_error(EPERM, <span class="string">&quot;unique_lock::unlock: not locked&quot;</span>);</span><br><span class="line">        __m_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        __owns_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_lock&amp; __u)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _VSTD::<span class="built_in">swap</span>(__m_, __u.__m_);</span><br><span class="line">        _VSTD::<span class="built_in">swap</span>(__owns_, __u.__owns_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">mutex_type* <span class="title">release</span><span class="params">()</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutex_type* __m = __m_;</span><br><span class="line">        __m_ = <span class="literal">nullptr</span>;</span><br><span class="line">        __owns_ = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> __m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h3><p>C++11 的条件变量和 pthread 条件变量语义基本类似，都有 wait、signal 等动作。condition_variable 只接受 unique_lock，而且传给 wait 的 unique_lock 必须上锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TYPE_VIS</span> condition_variable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">__libcpp_condvar_t</span> __cv_ = _LIBCPP_CONDVAR_INITIALIZER;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">condition_variable</span>() _NOEXCEPT = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">condition_variable</span>() &#123;</span><br><span class="line">        __libcpp_condvar_destroy(&amp;__cv_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">condition_variable</span>(<span class="type">const</span> condition_variable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    condition_variable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> condition_variable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        __libcpp_condvar_signal(&amp;__cv_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        __libcpp_condvar_broadcast(&amp;__cv_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传给wait的unique_lock必须上锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(unique_lock&lt;mutex&gt;&amp; __lk)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!lk.<span class="built_in">owns_lock</span>())</span><br><span class="line">            __throw_system_error(EPERM,</span><br><span class="line">                                      <span class="string">&quot;condition_variable::wait: mutex not locked&quot;</span>);</span><br><span class="line">        <span class="type">int</span> ec = __libcpp_condvar_wait(&amp;__cv_, lk.<span class="built_in">mutex</span>()-&gt;<span class="built_in">native_handle</span>());</span><br><span class="line">        <span class="keyword">if</span> (ec)</span><br><span class="line">            __throw_system_error(ec, <span class="string">&quot;condition_variable wait failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Predicate</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(unique_lock&lt;mutex&gt;&amp; __lk, _Predicate __pred)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!__pred())</span><br><span class="line">            <span class="built_in">wait</span>(__lk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Clock</span>, <span class="keyword">class</span> <span class="title class_">_Duration</span>&gt;</span><br><span class="line">    <span class="function">cv_status</span></span><br><span class="line"><span class="function">    <span class="title">wait_until</span><span class="params">(unique_lock&lt;mutex&gt;&amp; __lk,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; <span class="type">__t</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line">        <span class="keyword">using</span> __clock_tp_ns = time_point&lt;_Clock, nanoseconds&gt;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">typename</span> _Clock::time_point __now = _Clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">__t</span> &lt;= __now)</span><br><span class="line">            <span class="keyword">return</span> cv_status::timeout;</span><br><span class="line">    </span><br><span class="line">        __clock_tp_ns __t_ns = __clock_tp_ns(__safe_nanosecond_cast(<span class="type">__t</span>.<span class="built_in">time_since_epoch</span>()));</span><br><span class="line">    </span><br><span class="line">        __do_timed_wait(__lk, __t_ns);</span><br><span class="line">        <span class="keyword">return</span> _Clock::<span class="built_in">now</span>() &lt; <span class="type">__t</span> ? cv_status::no_timeout : cv_status::timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Clock</span>, <span class="keyword">class</span> <span class="title class_">_Duration</span>, <span class="keyword">class</span> <span class="title class_">_Predicate</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">wait_until</span><span class="params">(unique_lock&lt;mutex&gt;&amp; __lk,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; <span class="type">__t</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">               _Predicate __pred)</span></span>;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">__libcpp_condvar_t</span>* native_handle_type;</span><br><span class="line">    <span class="function">native_handle_type <span class="title">native_handle</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> &amp;__cv_;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> __do_timed_wait(unique_lock&lt;mutex&gt;&amp; __lk,</span><br><span class="line">       chrono::time_point&lt;chrono::system_clock, chrono::nanoseconds&gt;) _NOEXCEPT &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line">        <span class="keyword">if</span> (!lk.<span class="built_in">owns_lock</span>())</span><br><span class="line">            __throw_system_error(EPERM,</span><br><span class="line">                                <span class="string">&quot;condition_variable::timed wait: mutex not locked&quot;</span>);</span><br><span class="line">...</span><br><span class="line">        <span class="type">int</span> ec = __libcpp_condvar_timedwait(&amp;__cv_, lk.<span class="built_in">mutex</span>()-&gt;<span class="built_in">native_handle</span>(), &amp;ts);</span><br><span class="line">        <span class="keyword">if</span> (ec != <span class="number">0</span> &amp;&amp; ec != ETIMEDOUT)</span><br><span class="line">            __throw_system_error(ec, <span class="string">&quot;condition_variable timed_wait failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Clock</span>&gt;</span><br><span class="line">    <span class="type">void</span> __do_timed_wait(unique_lock&lt;mutex&gt;&amp; __lk,</span><br><span class="line">       chrono::time_point&lt;_Clock, chrono::nanoseconds&gt;) _NOEXCEPT &#123;</span><br><span class="line">        <span class="built_in">wait_for</span>(__lk, __tp - _Clock::<span class="built_in">now</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="once-flag-和-call-once"><a href="#once-flag-和-call-once" class="headerlink" title="once_flag 和 call_once"></a>once_flag 和 call_once</h3><p>C++11 线程库也有 thread_once，但是他没有使用 pthread 的 thread_once，而是自己实现了 thread_once，原理和之前介绍过的 glib 的 thread_once 类似。同样要注意，once_flag 也要求为静态生命周期。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Callable, <span class="keyword">class</span>... _Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">(once_flag&amp;, _Callable&amp;&amp;, _Args&amp;&amp;...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">once_flag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">once_flag</span>() _NOEXCEPT : __state_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> _State_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">once_flag</span>(<span class="type">const</span> once_flag&amp;); <span class="comment">// = delete;</span></span><br><span class="line">    once_flag&amp; <span class="keyword">operator</span>=(<span class="type">const</span> once_flag&amp;); <span class="comment">// = delete;</span></span><br><span class="line">    </span><br><span class="line">    _State_type __state_;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Callable, <span class="keyword">class</span>... _Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">friend</span></span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">call_once</span><span class="params">(once_flag&amp;, _Callable&amp;&amp;, _Args&amp;&amp;...)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>call_once 函数也是先检查 once_flag 是否为 <code>~0</code>，判断函数是否已经执行完成，如果没有执行，或者正在执行，则调用 <code>__call_once</code> 做进一步判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Callable, <span class="keyword">class</span>... _Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">call_once</span><span class="params">(once_flag&amp; __flag, _Callable&amp;&amp; __func, _Args&amp;&amp;... __args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__libcpp_acquire_load(&amp;__flag.__state_) != ~once_flag::_State_type(<span class="number">0</span>) <span class="comment">/*111*/</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> tuple&lt;_Callable&amp;&amp;, _Args&amp;&amp;...&gt; _Gp;</span><br><span class="line">        _Gp __f(_VSTD::forward&lt;_Callable&gt;(__func), _VSTD::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">        __call_once_param&lt;_Gp&gt; __p(__f);</span><br><span class="line">        __call_once(__flag.__state_, &amp;__p, &amp;__call_once_proxy&lt;_Gp&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>call_once 函数创建的 <code>typedef tuple&lt;_Callable&amp;&amp;, _Args&amp;&amp;...&gt; _Gp;</code> 的里面是引用类型，因为根据模板参数推断原理，<code>_Callable</code> 和 <code>_Args</code> 一定是 <code>T</code> 或者 <code>T&amp;</code>，再在其右边加 <code>&amp;&amp;</code>，折叠之后一定是 <code>T&amp;</code> 或者 <code>T&amp;&amp;</code>。所以 tuple 里面存的是引用类型。</p><p>在 <code>__call_once</code> 函数中，通过判断 flag 是否为 1 来确定目标函数是否正在被执行，但是没执行完，如果当前线程发现 flg 为 0，那么表示还没有其他线程执行过目标函数，于是尝试执行目标函数并将 flag 设为 1 来让其他线程等待，最后执行完目标函数后，将 flag 设为 <code>~0</code>，flag 为 <code>~0</code> 表示目标函数已经执行完成，其他线程会从等待中退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutex.cpp</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">_LIBCPP_SAFE_STATIC <span class="type">static</span> <span class="type">__libcpp_mutex_t</span> mut = _LIBCPP_MUTEX_INITIALIZER;</span><br><span class="line">_LIBCPP_SAFE_STATIC <span class="type">static</span> <span class="type">__libcpp_condvar_t</span> cv = _LIBCPP_CONDVAR_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __call_once(<span class="keyword">volatile</span> once_flag::_State_type&amp; flag, <span class="type">void</span>* arg,</span><br><span class="line">                 <span class="built_in">void</span> (*func)(<span class="type">void</span>*))</span><br><span class="line">&#123;</span><br><span class="line">    __libcpp_mutex_lock(&amp;mut);</span><br><span class="line">    <span class="keyword">while</span> (flag == <span class="number">1</span>)</span><br><span class="line">        __libcpp_condvar_wait(&amp;cv, &amp;mut);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __libcpp_relaxed_store(&amp;flag, once_flag::_State_type(<span class="number">1</span>));</span><br><span class="line">        __libcpp_mutex_unlock(&amp;mut);</span><br><span class="line">        <span class="built_in">func</span>(arg);</span><br><span class="line">        __libcpp_mutex_lock(&amp;mut);</span><br><span class="line">        __libcpp_atomic_store(&amp;flag, ~once_flag::_State_type(<span class="number">0</span>),</span><br><span class="line">                              _AO_Release);</span><br><span class="line">        __libcpp_mutex_unlock(&amp;mut);</span><br><span class="line">        __libcpp_condvar_broadcast(&amp;cv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __libcpp_mutex_unlock(&amp;mut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看 <code>__call_once_proxy</code>，这个函数把任务交给了输入的 <code>__call_once_param</code> 对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">__call_once_proxy(<span class="type">void</span>* __vp)</span><br><span class="line">&#123;</span><br><span class="line">    __call_once_param&lt;_Fp&gt;* __p = <span class="keyword">static_cast</span>&lt;__call_once_param&lt;_Fp&gt;*&gt;(__vp);</span><br><span class="line">    (*__p)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__call_once_param</code> 内部存储了之前存放函数和参数的 tuple，同时他还是一个可调用对象，它的 operator()函数会调用 invoke 来执行目标函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Fp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__call_once_param</span></span><br><span class="line">&#123;</span><br><span class="line">    _Fp&amp; __f_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> __call_once_param(_Fp&amp; __f) : __f_(__f) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> __make_tuple_indices&lt;tuple_size&lt;_Fp&gt;::value, <span class="number">1</span>&gt;::type _Index;</span><br><span class="line">        __execute(_Index());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="type">size_t</span> ..._Indices&gt;</span><br><span class="line">    <span class="type">void</span> __execute(__tuple_indices&lt;_Indices...&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        __invoke(_VSTD::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(_VSTD::<span class="built_in">move</span>(__f_)), _VSTD::<span class="built_in">get</span>&lt;_Indices&gt;(_VSTD::<span class="built_in">move</span>(__f_))...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，call_once 没有使用 pthread_once 函数，而是自己通过原子变量，配合锁实现 thread_once，实现原理基本上和 glib 一致。call_once 也是共享一套全局的 mutex、cond，不管有几个不同的 call，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> once_flag f,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gi</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mi</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">call_once</span>(f, gi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ei</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">call_once</span>(f, gi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ti</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">call_once</span>(k, mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">di</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">call_once</span>(k, mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">a</span><span class="params">(yi)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">b</span><span class="params">(ei)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">c</span><span class="params">(ti)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">d</span><span class="params">(di)</span></span>;</span><br><span class="line">    </span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    c.<span class="built_in">join</span>();</span><br><span class="line">    d.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的四个 call_once 分为两组，分别对应 once_flag f 和 k，但是他们底层共用一套 mutex、cond。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++标准库 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程之thread_once</title>
      <link href="/2023/05/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bthread-once/"/>
      <url>/2023/05/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bthread-once/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍一下 pthread_once 和 glib 的 thread_once。</p><h1 id="pthread-once"><a href="#pthread-once" class="headerlink" title="pthread_once"></a>pthread_once</h1><p>pthread 中有一个非常有用的函数 pthread_once，这个函数可以保证当多个线程都可能执行某个函数时，这个函数只会执行一次。</p><p>其使用方法如下，先定义有静态生命周期的 pthread_once_t 类型的变量，并将他赋值为 PTHREAD_ONCE_INIT，然后调用 pthread_once 函数，第一个参数为定义的 pthread_once_t 变量的指针，第二个参数为想要执行的函数的函数指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span>(*init_routine)())</span></span>;</span><br></pre></td></tr></table></figure><p>除了像上面把 pthread_once_t 放在全局作用域，还可以在函数中定义 static pthread_once_t 变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line">    <span class="built_in">pthread_once</span>(&amp;once_control, init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pthread_once 的效果是，当前线程执行 pthread_once 时：</p><ul><li>如果 init 函数没有被执行（通过检查 pthread_once_t），那么执行 init 函数</li><li>如果 init 函数已经执行完了，那么直接 return</li><li>如果 init 函数正在被其他线程执行，但是还没有完成，那么当前线程会阻塞，直到 init 函数被其他线程执行完成</li></ul><p>注意 pthread_once 的 init 函数只能是 <code>void(void)</code> 这种形式。</p><h1 id="glib-的-thread-once"><a href="#glib-的-thread-once" class="headerlink" title="glib 的 thread_once"></a>glib 的 thread_once</h1><p>我们接下来看看 glib 的 thread_once 的实现，下面的函数中 static_g_define_type_id 就相当于 pthread_once_t 变量，my_obj_get_type_once 函数就是只能被执行一次的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GType </span></span><br><span class="line"><span class="function"><span class="title">my_obj_get_type</span> <span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">static</span> gsize static_g_define_type_id = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Prelude goes here */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g_once_init_enter</span> (&amp;static_g_define_type_id)) </span><br><span class="line">    &#123; </span><br><span class="line">      GType g_define_type_id = <span class="built_in">my_obj_get_type_once</span> (); </span><br><span class="line">      <span class="built_in">g_once_init_leave</span> (&amp;static_g_define_type_id, g_define_type_id); </span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> static_g_define_type_id; </span><br><span class="line">&#125; <span class="comment">/* closes my_obj_get_type() */</span></span><br></pre></td></tr></table></figure><h2 id="g-once-init-enter"><a href="#g-once-init-enter" class="headerlink" title="g_once_init_enter"></a>g_once_init_enter</h2><p>g_once_init_enter 中会检查输入的 location 指针来判断 my_obj_get_type_once 是否已经执行过了，如果 my_obj_get_type_once 还没执行或者正在被执行，程序逻辑会走入第 8 行的分支，在这个分支里会判断 my_obj_get_type_once 是否已经被其他线程正在执行，判断逻辑是：如果 g_once_init_list 中没有找到输入的 location 指针，表示当前 my_obj_get_type_once 没有被执行，那么将 location 指针插入 g_once_init_list，这样其他线程进入这里时会在第 9 行中判断为 false 从而走入 14 行所在的分支，然后会等待 <code>g_once_init_list中无法找到location指针</code> 这个条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gboolean</span></span><br><span class="line">(g_once_init_enter) (<span class="keyword">volatile</span> <span class="type">void</span> *location)</span><br><span class="line">&#123;</span><br><span class="line">  gsize *value_location = (gsize *) location;</span><br><span class="line">  gboolean need_init = FALSE;</span><br><span class="line">  <span class="built_in">g_mutex_lock</span> (&amp;g_once_mutex);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g_atomic_pointer_get</span> (value_location) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">g_slist_find</span> (g_once_init_list, (<span class="type">void</span>*) value_location))</span><br><span class="line">        &#123;</span><br><span class="line">          need_init = TRUE;</span><br><span class="line">          g_once_init_list = <span class="built_in">g_slist_prepend</span> (g_once_init_list, (<span class="type">void</span>*) value_location);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          <span class="built_in">g_cond_wait</span> (&amp;g_once_cond, &amp;g_once_mutex);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">g_slist_find</span> (g_once_init_list, (<span class="type">void</span>*) value_location));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">g_mutex_unlock</span> (&amp;g_once_mutex);</span><br><span class="line">  <span class="keyword">return</span> need_init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而将 location 指针从 g_once_init_list 中移除是在 g_once_init_leave 中执行的。当线程发现 init 函数没被执行过时，会将 location 指针插入 g_once_init_list，然后从 g_once_init_enter 中返回 true，那么回到 my_obj_get_type 后，就会执行 my_obj_get_type_once 以及 g_once_init_leave。</p><p>g_once_init_leave 逻辑比较简单，就是把 result 变量原子的赋给 location 指向的变量，然后将 location 从 g_once_init_list 中移除，这样其他在等待 <code>g_once_init_list中无法找到location指针</code> 条件的线程就能从 g_once_init_enter 中返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span></span><br><span class="line">(g_once_init_leave) (<span class="keyword">volatile</span> <span class="type">void</span> *location,</span><br><span class="line">                     gsize          result)</span><br><span class="line">&#123;</span><br><span class="line">  gsize *value_location = (gsize *) location;</span><br><span class="line">  gsize old_value;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (result != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  old_value = (gsize) <span class="built_in">g_atomic_pointer_exchange</span> (value_location, result);</span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (old_value == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_mutex_lock</span> (&amp;g_once_mutex);</span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (g_once_init_list != <span class="literal">NULL</span>);</span><br><span class="line">  g_once_init_list = <span class="built_in">g_slist_remove</span> (g_once_init_list, (<span class="type">void</span>*) value_location);</span><br><span class="line">  <span class="built_in">g_cond_broadcast</span> (&amp;g_once_cond);</span><br><span class="line">  <span class="built_in">g_mutex_unlock</span> (&amp;g_once_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 glib 的 thread_once 也实现了：当一个线程执行 thread_once 时，他必须自己执行完 init 函数或者阻塞直到其他线程执行完 init 函数。</p><p>从实现来看，让我感觉比较神奇的是所有的 thread_once 竟然共用一个 mutex 和 condition，比如现在有两个想要实现 thread_once 的地方，他们都会调用 g_once_init_enter 和 g_once_init_leave，在这个过程中是共用一套 mutex 和 condition 来实现各自的 thread_once 的。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pthread多线程</title>
      <link href="/2023/05/02/pthread%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/05/02/pthread%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>最近重新温习了多线程编程的内容，计划写几篇文章总结一下自己对多线程编程的理解，这篇文章介绍 pthread 多线程编程。</p><h1 id="线程的生命周期和状态管理"><a href="#线程的生命周期和状态管理" class="headerlink" title="线程的生命周期和状态管理"></a>线程的生命周期和状态管理</h1><p>线程生命周期</p><ul><li><p>就绪</p><ul><li>当前线程处于调度队列，等待被调度执行</li></ul></li><li><p>运行</p><ul><li>cpu 正在执行当前线程</li></ul></li><li><p>阻塞</p><ul><li>当前线程处于等待队列（IO 阻塞、锁、条件变量、调用 sigwait 等待未发生的信号），可能是某个条件没被满足</li></ul></li><li><p>终止</p><ul><li>主动调用 pthread_exit，或者 return。线程终止后需要被 detach 或者 join 才能回收资源，否则会保留大部分资源</li><li>其他让线程处于终止态的行为：调用 pthread_cancel 取消线程，所以 cancel 不作为单独的状态</li><li>僵尸线程：等待资源被回收的线程，子线程没有被 pthread_detach()，并且早于主线程结束，那么子线程处于待回收的状态。主线程如果不 pthread_detach()、pthread_join()子线程，子线程就处于僵尸线程状态。总而言之，创建的每一个线程都应该使用 pthread_join 或者 pthread_detach 其中一个，以防止僵尸线程的出现。</li></ul></li></ul><h2 id="定义-pthread-t-变量"><a href="#定义-pthread-t-变量" class="headerlink" title="定义 pthread_t 变量"></a>定义 pthread_t 变量</h2><p>在创建线程之前，需要定义 pthread_t 类型的变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> thread;</span><br></pre></td></tr></table></figure><p>pthread_t 代表线程句柄，是一个不透明类型，用户不可以对他的类型做假设。pthread_t 不一定是 int 类型，比如在 linux 上 pthread_t 是 long，在 mac 上 pthread_t 是指针。</p><p>像上面这样定义的 pthread_t 变量还不能使用，只有在使用 pthread_create 对这个 pthread_t 变量进行初始化后这个变量才有意义。除了 pthread_create，另外一种得到有意义的 pthread_t 变量的方法是 pthread_self 函数，这个函数返回当前线程的 pthread_t 变量。</p><p>pthread_t 变量一般是作为参数传给其他 pthread 函数，pthread_t 类型可以拷贝。</p><h2 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> thread1, <span class="type">pthread_t</span> thread2)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread_equal 函数接受两个 pthread_t 变量，并比较这两个变量是否指代同一个线程</p><h2 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>*(*start)(<span class="type">void</span>*),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p>创建一个线程。pthread_create 会对 thread 参数指向的 pthread_t 变量进行初始化；attr 指向 pthread_attr_t 变量，可以通过这个参数对 thread 的属性，比如 detach、stacksize、调度优先级进行设定，这部分放到后面线程属性再介绍；start 指向一个函数地址，这个函数的签名必须是 <code>void*(void*)</code>，此函数就是创建的线程的主函数；arg 则是将要传给 start 函数的参数。</p><p>注意 <code>新创建的线程</code> 和 <code>当前线程从pthread_create返回</code> 到底谁先执行不确定，取决于操作系统调度。</p><h2 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">pthead_t</span> <span class="title">pthread_self</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>返回当前线程的 pthead_t。主线程（main 函数）可以通过 pthread_self()返回自己的 pthread_t，这样其他线程可以通过该 pthread_t 操纵主线程，比如 detach&#x2F;join 主线程，但一般不会这样做，主线程总是特殊的。</p><h2 id="sched-yield"><a href="#sched-yield" class="headerlink" title="sched_yield"></a>sched_yield</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sched_yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>让出当前线程的执行权限，让操作系统进行线程调度，当线程再次被调度时，程序会从该函数返回处开始执行。</p><p>通过 sched_yield 可以实现自旋锁，比如线程检查某个数据后发现不满足继续执行的条件，则让出执行权限，等下次调度时重复上面的步骤。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(<span class="comment">/* some condition */</span>) &#123;</span><br><span class="line">    <span class="built_in">sched_yield</span>();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>需要注意这里的自旋锁阻塞不会发生 busy wait，sched_yield 时让出了执行权限，CPU 没有空转。</p><h2 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span> *value_ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>如果主线程调用 pthread_exit，将阻塞直到所有子线程结束。本来由于主线程的特殊性，主线程退出后，哪怕其他子线程还在执行，也会直接“蒸发”。但如果主线程调用 pthread_exit 退出，那么可以保证其他线程都退出后主线程再退出。</p><p>pthread_exit 可以用于等待设置了 detach 属性的子线程，本来是无法知道设置了 detach 属性的子线程会何时退出。pthread_exit 则可以让主线程确保所有其他子线程都退出后再退出。对于没有设置 detach 属性的子线程，无需使用 pthread_exit，使用 pthread_join 即可。</p><p>子线程调用 pthread_exit 则会退出子线程进入终止状态，如果子线程已经 detach 了，就会进行资源回收，如果没有则还需要 join 或者 detach 子线程来回收资源。</p><p>value_ptr 是作为线程返回值传出去。</p><h2 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread_detach 会让线程分离，分离的意义是子线程结束后可以立刻被回收资源（比如虚拟内存、堆栈、系统资源）。如果子线程不 detach，那么线程结束时就不会回收资源，需要主线程主动 join 或者 detach 子线程才会回收资源。可以在子线程运行过程中调用 detach，也可以在子线程结束后调用 detach。</p><p>detach 只要知道 pthread_t 就可以进行，可以在任意线程内 detach 任意线程（比如自己 detach 自己）。</p><p>除了 pthread_detach，还可以在线程创建时设置 detach 属性，这也可以让子线程结束时就回收资源。</p><h2 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **value_ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>阻塞调用者，直到某个线程终止。还可以将子线程的返回值保存在 value_ptr 指向的内存中，value_ptr 为 nullptr 表示不关心子线程的返回值。</p><p>pthread_join 和 pthread_detach 是互斥的。对一个线程 detach 后，不能再 join，detach 表示不关心子线程的结束，让子线程结束时自动释放资源。对一个没有 detach 的线程进行 join 并返回后，线程的资源也已经被回收了，也不能再 detach，此时连 pthread_t 都已经无效了。</p><p>考虑这样一种情况，一个没有设置 detach 的线程结束后，处于待回收的状态，此时可以对他进行 detach 或者 join，detach 表示不关心返回值，join 则会取得返回值。</p><h2 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span> <span class="params">(<span class="type">pthread_t</span> thread)</span></span></span><br></pre></td></tr></table></figure><p>取消操作和取消点（cancellation point）有关系，这部分等以后再补充。</p><h1 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h1><p>在通过 pthread_create 创建线程时，可以通过线程属性设置线程的调度策略、线程的堆栈、线程是否 detach</p><p>先定义一个 pthread_attr_t 变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_attr_t</span> attr;</span><br></pre></td></tr></table></figure><p>对 pthread_attr_t 变量进行初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure><p>设置 detach 属性，detachstate 可以是 PTHREAD_CREATE_JOINABLE</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span></span>;</span><br></pre></td></tr></table></figure><p>获得 detach 属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span></span>;</span><br></pre></td></tr></table></figure><p>设置栈的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setstacksize</span> <span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">size_t</span> stacksize)</span></span></span><br></pre></td></tr></table></figure><p>获得栈的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getstacksize</span> <span class="params">(<span class="type">pthread_attr_t</span>* attr, <span class="type">size_t</span>* stacksize)</span></span></span><br></pre></td></tr></table></figure><p>设置栈的地址。这个函数应避免使用，有些库不支持这个函数，而且指定栈的地址后程序的可移植性较差</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setstackaddr</span> <span class="params">(<span class="type">pthread_attr_t</span>* attr, stackaddr)</span></span></span><br></pre></td></tr></table></figure><p>获得栈的地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getstackaddr</span> <span class="params">(<span class="type">pthread_attr_t</span>* attr, stackaddr)</span></span></span><br></pre></td></tr></table></figure><p>销毁 pthread_attr_t。pthread_attr_t 变量初始化后记得销毁，因为 pthread_attr_t 也是不透明对象，pthread 库的实现有可能会在初始化时动态分配内存，同时也不应该试图复制 pthread_attr_t。</p><p>pthread_attr_t 应该在 pthread_create 调用之后立即销毁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>在多线程编程中线程之间共享内存，为了避免线程之间的竞争访问，需要对线程之间进行同步和协调。对线程进行同步，有锁、信号量、条件变量这几种同步工具：</p><table><thead><tr><th>同步工具</th><th>使用场景</th></tr></thead><tbody><tr><td>锁（二元信号量）</td><td>避免线程同时访问某个资源</td></tr><tr><td>信号量</td><td>限制能同时访问被保护资源的线程数</td></tr><tr><td>条件变量</td><td>线程需要等待某个条件满足</td></tr></tbody></table><h2 id="锁（互斥量）"><a href="#锁（互斥量）" class="headerlink" title="锁（互斥量）"></a>锁（互斥量）</h2><p>锁可以视为一种特殊的信号量，在同一时刻只允许一个线程访问被保护的资源。</p><p>锁的语义很明确，一个线程加锁之后就暂时获得了资源的所有权，加锁之后一定要释放锁，释放锁之后其他线程才有可能访问被保护的资源。</p><h3 id="定义-pthread-mutex-t-变量"><a href="#定义-pthread-mutex-t-变量" class="headerlink" title="定义 pthread_mutex_t 变量"></a>定义 pthread_mutex_t 变量</h3><p>定义 pthread_mutex_t 类型的变量。注意 pthread_mutex_t 不能进行拷贝，所以如果 pthread_mutex_t 需要在多个函数中使用，需要在全局定义 pthread_mutex_t，或者将 pthread_mutex_t 分配在堆内存中，如果仅在一个函数中使用，可以在栈上定义。如果想用 C++ 包装 pthread_mutex_t，建议使用 unique_ptr 进行包装，这样就有了移动语义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br></pre></td></tr></table></figure><h3 id="初始化-pthread-mutex-t"><a href="#初始化-pthread-mutex-t" class="headerlink" title="初始化 pthread_mutex_t"></a>初始化 pthread_mutex_t</h3><p>对 pthread_mutex_t 进行初始化，如果使用 pthread_mutex_init 函数，还可以传递 pthread_mutexattr_t 的指针来设置锁的属性，使用 PTHREAD_MUTEX_INITIALIZER 则只能使用默认属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* attr)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="pthread-mutexattr-t"><a href="#pthread-mutexattr-t" class="headerlink" title="pthread_mutexattr_t"></a>pthread_mutexattr_t</h3><p>通过 pthread_mutexattr_t 设置锁的属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutexattr_t</span> attr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="pthread_mutex_lock"></a>pthread_mutex_lock</h3><p>对互斥量进行加锁。如果锁已经被其他线程持有，那么当前线程会阻塞到锁被释放，然后会继续尝试加锁，如果失败，则继续阻塞到锁被其他线程释放，不断重复这个过程，直到成功加锁。如果这个锁已经被当前线程持有，那么再加锁会导致死锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span></span><br></pre></td></tr></table></figure><h3 id="pthread-mutex-trylock"><a href="#pthread-mutex-trylock" class="headerlink" title="pthread_mutex_trylock"></a>pthread_mutex_trylock</h3><p>尝试进行加锁，但不会阻塞。返回 0 表示加锁成功；返回 EBUSY 表示已经有其他线程加锁了；返回 EDEADLK 表示当前线程已经持有这个锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span></span><br></pre></td></tr></table></figure><h3 id="phtread-mutex-unlock"><a href="#phtread-mutex-unlock" class="headerlink" title="phtread_mutex_unlock"></a>phtread_mutex_unlock</h3><p>释放锁。返回 0 表示成功；如果当前线程没有持有这个锁（比如是其他线程加锁，或者根本没加锁），返回 EPERM</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phtread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span></span><br></pre></td></tr></table></figure><h3 id="pthread-mutex-destroy"><a href="#pthread-mutex-destroy" class="headerlink" title="pthread_mutex_destroy"></a>pthread_mutex_destroy</h3><p>销毁锁。返回 EBUSY 表示当前锁被其他线程加锁。当调用这个函数时，要么没有线程持有这个锁，要么当前线程持有这个锁，销毁一个被当前线程持有的锁是允许的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span></span><br></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量用于描述这样一种关系：当线程 A 检查共享数据时，发现他的状态不满足自己的要求，那么此时线程 A 只能阻塞，直到这个条件满足了才能继续往下执行。</p><p>所以条件变量用于<strong>通知共享数据状态的变化</strong>，比如线程 B 修改共享数据后就可以通过条件变量唤醒线程 A，让他再看看此时共享数据是否满足他的要求。</p><p>条件变量常常和锁一起使用，这个锁用于保护共享数据，因为线程 A 和 B 都要访问共享数据，必须互斥的修改&#x2F;检查共享数据。</p><p>需要注意：条件变量的作用是通知，不是互斥，互斥访问共享数据是由额外的互斥量提供的。</p><h3 id="定义-pthread-cond-t-变量"><a href="#定义-pthread-cond-t-变量" class="headerlink" title="定义 pthread_cond_t 变量"></a>定义 pthread_cond_t 变量</h3><p>条件变量也无法拷贝，和互斥量一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br></pre></td></tr></table></figure><h3 id="初始化-pthread-mutex-t-1"><a href="#初始化-pthread-mutex-t-1" class="headerlink" title="初始化 pthread_mutex_t"></a>初始化 pthread_mutex_t</h3><p>attr 为 NULL 表示创建默认属性的 pthread_cond_t，和使用 PTHREAD_COND_INITIALIZER 一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> myconvar = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* cond, <span class="type">pthread_condattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="pthread-condattr-t"><a href="#pthread-condattr-t" class="headerlink" title="pthread_condattr_t"></a>pthread_condattr_t</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_condattr_t</span> t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="type">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="type">pthread_condattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="pthread-cond-destroy"><a href="#pthread-cond-destroy" class="headerlink" title="pthread_cond_destroy"></a>pthread_cond_destroy</h3><p>销毁条件变量，但是如果该条件变量上还有线程在等待，返回 EBUSY</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="pthread-cond-wait"><a href="#pthread-cond-wait" class="headerlink" title="pthread_cond_wait"></a>pthread_cond_wait</h3><p>调用 pthread_cond_wait 时，mutex 必须被锁住，然后 pthread_cond_wait 会释放锁并阻塞线程，当 pthread_cond_wait 返回时，mutex 会被重新上锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="pthread-cond-timedwait"><a href="#pthread-cond-timedwait" class="headerlink" title="pthread_cond_timedwait"></a>pthread_cond_timedwait</h3><p>带有超时的 wait。调用 pthread_cond_timedwait 时，mutex 必须被锁住，如果超时返回，那么返回码是 ETIMEDOUT。注意超时返回时互斥量也是锁住的状态，此时可能获取互斥量阻塞的时间比超时等待的时间还要长</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond&lt;em&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">&lt;/em&gt;&lt;em&gt;                           &lt;/em&gt;<span class="type">pthread_mutex_t</span>&lt;em&gt; *&lt;/em&gt;mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="pthread_cond_signal"></a>pthread_cond_signal</h3><p>唤醒至少一个等待线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="pthread-cond-broadcast"><a href="#pthread-cond-broadcast" class="headerlink" title="pthread_cond_broadcast"></a>pthread_cond_broadcast</h3><p>将所有等待此条件变量的线程放回调度队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p>典型的使用条件变量的例子：</p><ul><li>等待者。先加锁，然后检查共享数据是否满足条件，不满足则进入 wait，进入 wait 之后会阻塞当前线程并释放锁，这样其他线程才有机会加锁并修改数据，当 pthread_cond_wait 返回时，锁处于上锁状态，继续检查条件，如果不满足，继续等待，否则退出循环，并释放锁。建议总是在循环中等待条件变量唤醒，以避免程序错误、多处理器竞争、假唤醒</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(mutex);</span><br><span class="line"><span class="keyword">while</span>(<span class="comment">/* condition */</span>) &#123;</span><br><span class="line">    <span class="built_in">pthread_cond_wait</span>(cond, mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(mutex);</span><br></pre></td></tr></table></figure><ul><li>唤醒者。也是先加锁，只要是访问共享数据，都要处于加锁状态，然后修改共享数据，然后通知条件变量：“当前数据已改变，请尝试检查”，在通知条件变量后释放锁。建议总是在发完信号之后再解锁互斥量，如果在发信号之前解锁，那么低优先级线程可以锁住互斥量，这时高优先级线程将阻塞在获取锁的过程</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(mutex);</span><br><span class="line"><span class="comment">// ... modify shared data</span></span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(cond);</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(mutex);</span><br></pre></td></tr></table></figure><p>条件变量还有一个容易错的地方：让一个条件变量通知多个条件，这样很容易造成死锁，应当每个条件使用一个条件变量来通知。但是一个互斥量可以用在多个条件中，因为互斥量是和共享数据相关的，一个共享数据可以产生多个条件，但此时只需一个互斥量就可以。</p><p>一个典型的例子：有一个队列，生产者需要检查队列是否为满，消费者需要检查队列是否为空，从而一个共享数据就有两个条件，那么我们需要两个条件变量一个互斥量。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gobject 信号之 g_signal_emit</title>
      <link href="/2023/05/01/Gobject-%E4%BF%A1%E5%8F%B7%E4%B9%8B-g-signal-emit/"/>
      <url>/2023/05/01/Gobject-%E4%BF%A1%E5%8F%B7%E4%B9%8B-g-signal-emit/</url>
      
        <content type="html"><![CDATA[<p>分析完 g_signal_connect 之后到了最后一个函数 g_signal_emit，g_signal_emit 用于触发信号，执行之前 connect 的回调函数</p><h1 id="g-signal-emit"><a href="#g-signal-emit" class="headerlink" title="g_signal_emit"></a>g_signal_emit</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_signal_emit</span> <span class="params">(gpointer instance,</span></span></span><br><span class="line"><span class="params"><span class="function">         guint    signal_id,</span></span></span><br><span class="line"><span class="params"><span class="function">         GQuark   detail,</span></span></span><br><span class="line"><span class="params"><span class="function">         ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  va_list var_args;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">va_start</span> (var_args, detail);</span><br><span class="line">  <span class="built_in">g_signal_emit_valist</span> (instance, signal_id, detail, var_args);</span><br><span class="line">  <span class="built_in">va_end</span> (var_args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="g-signal-emit-valist"><a href="#g-signal-emit-valist" class="headerlink" title="g_signal_emit_valist"></a>g_signal_emit_valist</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_signal_emit_valist</span> <span class="params">(gpointer instance,</span></span></span><br><span class="line"><span class="params"><span class="function">          guint    signal_id,</span></span></span><br><span class="line"><span class="params"><span class="function">          GQuark   detail,</span></span></span><br><span class="line"><span class="params"><span class="function">          va_list  var_args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GValue *instance_and_params;</span><br><span class="line">  GType signal_return_type;</span><br><span class="line">  GValue *param_values;</span><br><span class="line">  SignalNode *node;</span><br><span class="line">  guint i, n_params;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SIGNAL_LOCK</span> ();</span><br><span class="line">  <span class="comment">// 查找signal_id对应的SignalNode，之前说过</span></span><br><span class="line">  <span class="comment">// SignalNode中有函数返回类型、参数类型信息</span></span><br><span class="line">  <span class="comment">// 有了这些才能正确执行connect的callback</span></span><br><span class="line">  node = <span class="built_in">LOOKUP_SIGNAL_NODE</span> (signal_id);</span><br><span class="line">  <span class="keyword">if</span> (!node || !<span class="built_in">g_type_is_a</span> (<span class="built_in">G_TYPE_FROM_INSTANCE</span> (instance), node-&gt;itype))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (<span class="string">&quot;%s: signal id &#x27;%u&#x27; is invalid for instance &#x27;%p&#x27;&quot;</span>, G_STRLOC, signal_id, instance);</span><br><span class="line">      <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;single_va_closure != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备函数返回类型、参数类型信息</span></span><br><span class="line">  n_params = node-&gt;n_params;</span><br><span class="line">  signal_return_type = node-&gt;return_type;</span><br><span class="line">  <span class="comment">// 这里参数加1是因为之前计算参数数目的时候没有算排在第一位的instance指针这个参数</span></span><br><span class="line">  instance_and_params = <span class="built_in">g_newa0</span> (GValue, n_params + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// param_values在instance_and_params的基础上加1，刚好跳过instance参数</span></span><br><span class="line">  param_values = instance_and_params + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; node-&gt;n_params; i++)</span><br><span class="line">    &#123; <span class="comment">// 初始化除去第一个instance指针的parameters参数</span></span><br><span class="line">      gchar *error;</span><br><span class="line">      GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;</span><br><span class="line">      gboolean static_scope = node-&gt;param_types[i] &amp; G_SIGNAL_TYPE_STATIC_SCOPE;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">G_VALUE_COLLECT_INIT</span> (param_values + i, ptype,</span><br><span class="line">          var_args,</span><br><span class="line">          static_scope ? G_VALUE_NOCOPY_CONTENTS : <span class="number">0</span>,</span><br><span class="line">          &amp;error);</span><br><span class="line">      <span class="keyword">if</span> (error)</span><br><span class="line">  &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  instance_and_params-&gt;g_type = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 初始化第一个instance参数</span></span><br><span class="line">  <span class="built_in">g_value_init_from_instance</span> (instance_and_params, instance);</span><br><span class="line">  <span class="keyword">if</span> (signal_return_type == G_TYPE_NONE)</span><br><span class="line">    <span class="built_in">signal_emit_unlocked_R</span> (node, detail, instance, <span class="literal">NULL</span>, instance_and_params);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      GValue return_value = G_VALUE_INIT;</span><br><span class="line">      gchar *error = <span class="literal">NULL</span>;</span><br><span class="line">      GType rtype = signal_return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;</span><br><span class="line">      gboolean static_scope = signal_return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">g_value_init</span> (&amp;return_value, rtype);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">signal_emit_unlocked_R</span> (node, detail, instance, &amp;return_value, instance_and_params);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">G_VALUE_LCOPY</span> (&amp;return_value,</span><br><span class="line">         var_args,</span><br><span class="line">         static_scope ? G_VALUE_NOCOPY_CONTENTS : <span class="number">0</span>,</span><br><span class="line">         &amp;error);</span><br><span class="line">      <span class="keyword">if</span> (!error)</span><br><span class="line">  <span class="built_in">g_value_unset</span> (&amp;return_value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">g_warning</span> (<span class="string">&quot;%s: %s&quot;</span>, G_STRLOC, error);</span><br><span class="line">    <span class="built_in">g_free</span> (error);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* we purposely leak the value here, it might not be</span></span><br><span class="line"><span class="comment">     * in a correct state if an error condition occurred</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n_params; i++)</span><br><span class="line">    <span class="built_in">g_value_unset</span> (param_values + i);</span><br><span class="line">  <span class="built_in">g_value_unset</span> (instance_and_params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="signal-emit-unlocked-R"><a href="#signal-emit-unlocked-R" class="headerlink" title="signal_emit_unlocked_R"></a>signal_emit_unlocked_R</h3><p>g_signal_emit_valist 准备好参数后，调用 signal_emit_unlocked_R 执行回调函数。</p><p>signal_emit_unlocked_R 也比较长，但核心步骤就是调用 class_closure 以及之前 g_signal_connect 的 callback，从里面可以看到 G_SIGNAL_RUN_FIRST 的意义，accumulate 如何控制剩下的回调是否执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> gboolean</span></span><br><span class="line"><span class="function"><span class="title">signal_emit_unlocked_R</span> <span class="params">(SignalNode   *node,</span></span></span><br><span class="line"><span class="params"><span class="function">      GQuark        detail,</span></span></span><br><span class="line"><span class="params"><span class="function">      gpointer      instance,</span></span></span><br><span class="line"><span class="params"><span class="function">      GValue       *emission_return,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> GValue *instance_and_params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  SignalAccumulator *accumulator;</span><br><span class="line">  Emission emission;</span><br><span class="line">  GClosure *class_closure;</span><br><span class="line">  HandlerList *hlist;</span><br><span class="line">  Handler *handler_list = <span class="literal">NULL</span>;</span><br><span class="line">  GValue *return_accu, accu = G_VALUE_INIT;</span><br><span class="line">  guint signal_id;</span><br><span class="line">  gulong max_sequential_handler_number;</span><br><span class="line">  gboolean return_value_altered = FALSE;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">SIGNAL_LOCK</span> ();</span><br><span class="line">  signal_id = node-&gt;signal_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;flags &amp; G_SIGNAL_NO_RECURSE)</span><br><span class="line">    &#123;</span><br><span class="line">      Emission *emission_node = <span class="built_in">emission_find</span> (signal_id, detail, instance);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (emission_node)</span><br><span class="line">        &#123;</span><br><span class="line">          emission_node-&gt;state = EMISSION_RESTART;</span><br><span class="line">          <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line">          <span class="keyword">return</span> return_value_altered;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  accumulator = node-&gt;accumulator;</span><br><span class="line">  <span class="keyword">if</span> (accumulator)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line">      <span class="built_in">g_value_init</span> (&amp;accu, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE);</span><br><span class="line">      return_accu = &amp;accu;</span><br><span class="line">      <span class="built_in">SIGNAL_LOCK</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    return_accu = emission_return;</span><br><span class="line">  emission.instance = instance;</span><br><span class="line">  emission.ihint.signal_id = node-&gt;signal_id;</span><br><span class="line">  emission.ihint.detail = detail;</span><br><span class="line">  emission.ihint.run_type = <span class="number">0</span>;</span><br><span class="line">  emission.state = <span class="number">0</span>;</span><br><span class="line">  emission.chain_type = G_TYPE_NONE;</span><br><span class="line">  <span class="built_in">emission_push</span> (&amp;emission);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 查找class_closure，里面有之前g_signal_new时传的class_offset参数</span></span><br><span class="line">  class_closure = <span class="built_in">signal_lookup_closure</span> (node, instance);</span><br><span class="line">  </span><br><span class="line"> EMIT_RESTART:</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (handler_list)</span><br><span class="line">    <span class="built_in">handler_unref_R</span> (signal_id, instance, handler_list);</span><br><span class="line">  max_sequential_handler_number = g_handler_sequential_number;</span><br><span class="line">  hlist = <span class="built_in">handler_list_lookup</span> (signal_id, instance);</span><br><span class="line">  handler_list = hlist ? hlist-&gt;handlers : <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (handler_list)</span><br><span class="line">    <span class="built_in">handler_ref</span> (handler_list);</span><br><span class="line">  </span><br><span class="line">  emission.ihint.run_type = G_SIGNAL_RUN_FIRST | G_SIGNAL_ACCUMULATOR_FIRST_RUN;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((node-&gt;flags &amp; G_SIGNAL_RUN_FIRST) &amp;&amp; class_closure)</span><br><span class="line">    &#123; <span class="comment">// 如果有G_SIGNAL_RUN_FIRST flag，表示class_closure在其他connect的callback之前执行</span></span><br><span class="line">      emission.state = EMISSION_RUN;</span><br><span class="line"></span><br><span class="line">      emission.chain_type = <span class="built_in">G_TYPE_FROM_INSTANCE</span> (instance);</span><br><span class="line">      <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line">      <span class="built_in">g_closure_invoke</span> (class_closure,</span><br><span class="line">      return_accu,</span><br><span class="line">      node-&gt;n_params + <span class="number">1</span>,</span><br><span class="line">      instance_and_params,</span><br><span class="line">      &amp;emission.ihint);</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">accumulate</span> (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span><br><span class="line">    emission.state == EMISSION_RUN) <span class="comment">// accumulate控制是否继续调用剩下的函数</span></span><br><span class="line">  emission.state = EMISSION_STOP;</span><br><span class="line">      <span class="built_in">SIGNAL_LOCK</span> ();</span><br><span class="line">      emission.chain_type = G_TYPE_NONE;</span><br><span class="line">      return_value_altered = TRUE;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (emission.state == EMISSION_STOP)</span><br><span class="line">  <span class="keyword">goto</span> EMIT_CLEANUP;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (emission.state == EMISSION_RESTART)</span><br><span class="line">  <span class="keyword">goto</span> EMIT_RESTART;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (node-&gt;emission_hooks)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (handler_list)</span><br><span class="line">    &#123;</span><br><span class="line">      Handler *handler = handler_list;</span><br><span class="line">      </span><br><span class="line">      emission.state = EMISSION_RUN;</span><br><span class="line">      <span class="built_in">handler_ref</span> (handler);</span><br><span class="line">      <span class="keyword">do</span> <span class="comment">// 在这个while循环里面处理handler_list里的callback</span></span><br><span class="line">  &#123;</span><br><span class="line">    Handler *tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;after)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">handler_unref_R</span> (signal_id, instance, handler_list);</span><br><span class="line">        handler_list = handler;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;</span><br><span class="line">       handler-&gt;sequential_number &lt; max_sequential_handler_number)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line">        <span class="built_in">g_closure_invoke</span> (handler-&gt;closure,</span><br><span class="line">        return_accu,</span><br><span class="line">        node-&gt;n_params + <span class="number">1</span>,</span><br><span class="line">        instance_and_params,</span><br><span class="line">        &amp;emission.ihint);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">accumulate</span> (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span><br><span class="line">      emission.state == EMISSION_RUN) <span class="comment">// 这里也是accumulate</span></span><br><span class="line">    emission.state = EMISSION_STOP;</span><br><span class="line">        <span class="built_in">SIGNAL_LOCK</span> ();</span><br><span class="line">        return_value_altered = TRUE;</span><br><span class="line">        </span><br><span class="line">        tmp = emission.state == EMISSION_RUN ? handler-&gt;next : <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      tmp = handler-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">      <span class="built_in">handler_ref</span> (tmp);</span><br><span class="line">    <span class="built_in">handler_unref_R</span> (signal_id, instance, handler_list);</span><br><span class="line">    handler_list = handler;</span><br><span class="line">    handler = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">while</span> (handler);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (emission.state == EMISSION_STOP)</span><br><span class="line">  <span class="keyword">goto</span> EMIT_CLEANUP;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (emission.state == EMISSION_RESTART)</span><br><span class="line">  <span class="keyword">goto</span> EMIT_RESTART;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  emission.ihint.run_type &amp;= ~G_SIGNAL_RUN_FIRST;</span><br><span class="line">  emission.ihint.run_type |= G_SIGNAL_RUN_LAST;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((node-&gt;flags &amp; G_SIGNAL_RUN_LAST) &amp;&amp; class_closure)</span><br><span class="line">    &#123; <span class="comment">// G_SIGNAL_RUN_LAST 略过</span></span><br><span class="line"> ...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (handler_list)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> EMIT_CLEANUP:</span><br><span class="line">  </span><br><span class="line">  emission.ihint.run_type &amp;= ~G_SIGNAL_RUN_LAST;</span><br><span class="line">  emission.ihint.run_type |= G_SIGNAL_RUN_CLEANUP;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((node-&gt;flags &amp; G_SIGNAL_RUN_CLEANUP) &amp;&amp; class_closure)</span><br><span class="line">    &#123;</span><br><span class="line">      gboolean need_unset = FALSE;</span><br><span class="line">      </span><br><span class="line">      emission.state = EMISSION_STOP;</span><br><span class="line">      </span><br><span class="line">      emission.chain_type = <span class="built_in">G_TYPE_FROM_INSTANCE</span> (instance);</span><br><span class="line">      <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;return_type != G_TYPE_NONE &amp;&amp; !accumulator)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">g_value_init</span> (&amp;accu, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE);</span><br><span class="line">    need_unset = TRUE;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="built_in">g_closure_invoke</span> (class_closure,</span><br><span class="line">      node-&gt;return_type != G_TYPE_NONE ? &amp;accu : <span class="literal">NULL</span>,</span><br><span class="line">      node-&gt;n_params + <span class="number">1</span>,</span><br><span class="line">      instance_and_params,</span><br><span class="line">      &amp;emission.ihint);</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">accumulate</span> (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span><br><span class="line">          emission.state == EMISSION_RUN)</span><br><span class="line">        emission.state = EMISSION_STOP;</span><br><span class="line">      <span class="keyword">if</span> (need_unset)</span><br><span class="line">  <span class="built_in">g_value_unset</span> (&amp;accu);</span><br><span class="line">      <span class="built_in">SIGNAL_LOCK</span> ();</span><br><span class="line">      return_value_altered = TRUE;</span><br><span class="line"></span><br><span class="line">      emission.chain_type = G_TYPE_NONE;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (emission.state == EMISSION_RESTART)</span><br><span class="line">  <span class="keyword">goto</span> EMIT_RESTART;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (handler_list)</span><br><span class="line">    <span class="built_in">handler_unref_R</span> (signal_id, instance, handler_list);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">emission_pop</span> (&amp;emission);</span><br><span class="line">  <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line">  <span class="keyword">if</span> (accumulator)</span><br><span class="line">    <span class="built_in">g_value_unset</span> (&amp;accu);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> return_value_altered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="signal-lookup-closure"><a href="#signal-lookup-closure" class="headerlink" title="signal_lookup_closure"></a>signal_lookup_closure</h4><p>这个函数查找之前 signal_add_class_closure 中插入的 class_closure，如果当前 instance 对应的 GType 在 node-&gt;class_closure_bsa 中找不到，还会使用当前 instance 的父类类型进行查找，也就是可以继承父类的 class_closure</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> GClosure*</span></span><br><span class="line"><span class="function"><span class="title">signal_lookup_closure</span> <span class="params">(SignalNode    *node,</span></span></span><br><span class="line"><span class="params"><span class="function">           GTypeInstance *instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ClassClosure *cc;</span><br><span class="line"></span><br><span class="line">  cc = <span class="built_in">signal_find_class_closure</span> (node, <span class="built_in">G_TYPE_FROM_INSTANCE</span> (instance));</span><br><span class="line">  <span class="keyword">return</span> cc ? cc-&gt;closure : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> ClassClosure*</span></span><br><span class="line"><span class="function"><span class="title">signal_find_class_closure</span> <span class="params">(SignalNode *node,</span></span></span><br><span class="line"><span class="params"><span class="function">         GType       itype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GBSearchArray *bsa = node-&gt;class_closure_bsa;</span><br><span class="line">  ClassClosure *cc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bsa)</span><br><span class="line">    &#123;</span><br><span class="line">      ClassClosure key;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* cc-&gt;instance_type is 0 for default closure */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">g_bsearch_array_get_n_nodes</span> (bsa) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          cc = <span class="built_in">g_bsearch_array_get_nth</span> (bsa, &amp;g_class_closure_bconfig, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (cc &amp;&amp; cc-&gt;instance_type == <span class="number">0</span>) <span class="comment">/* check for default closure */</span></span><br><span class="line">            <span class="keyword">return</span> cc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      key.instance_type = itype;</span><br><span class="line">      cc = <span class="built_in">g_bsearch_array_lookup</span> (bsa, &amp;g_class_closure_bconfig, &amp;key);</span><br><span class="line">      <span class="keyword">while</span> (!cc &amp;&amp; key.instance_type)</span><br><span class="line">  &#123;</span><br><span class="line">    key.instance_type = <span class="built_in">g_type_parent</span> (key.instance_type);</span><br><span class="line">    cc = <span class="built_in">g_bsearch_array_lookup</span> (bsa, &amp;g_class_closure_bconfig, &amp;key);</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cc = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> cc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="handler-list-lookup"><a href="#handler-list-lookup" class="headerlink" title="handler_list_lookup"></a>handler_list_lookup</h4><p>和之前 g_signal_connect 时 handler_insert 相反，找到特定 instance 特定 signal_id 对应的 HandlerList 链表，因为 g_signal_connect 的得到的 handler 是先按 instance，然后按 signal_id 存储的。一个 instance 上可以对一个信号 connect 多次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> HandlerList*</span></span><br><span class="line"><span class="function"><span class="title">handler_list_lookup</span> <span class="params">(guint    signal_id,</span></span></span><br><span class="line"><span class="params"><span class="function">         gpointer instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GBSearchArray *hlbsa = <span class="built_in">g_hash_table_lookup</span> (g_handler_list_bsa_ht, instance);</span><br><span class="line">  HandlerList key;</span><br><span class="line">  </span><br><span class="line">  key.signal_id = signal_id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> hlbsa ? <span class="built_in">g_bsearch_array_lookup</span> (hlbsa, &amp;g_signal_hlbsa_bconfig, &amp;key) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="g-closure-invoke"><a href="#g-closure-invoke" class="headerlink" title="g_closure_invoke"></a>g_closure_invoke</h4><p>上面 class_closure 和 g_signal_connect 得到的 closure 都是调用这个函数来执行。这个函数会调用之前给 Closure 设置的 marshal 函数来执行 callback。</p><p>从下面代码可以看到，如果设置了 GRealClosure 的 meta_marshal，那么优先使用 meta_marshal，其次使用 GClosure 中的 marshal。而之前的 class_closure 中就设置了 meta_marshal，g_signal_connect 得到的 closure 中只设置了 marshal，所以 class_closure 和 g_signal_connect 得到的 closure 最后调用的 marshal 函数不一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">g_closure_invoke</span> (GClosure       *closure,</span><br><span class="line">      GValue <span class="comment">/*out*/</span> *return_value,</span><br><span class="line">      guint           n_param_values, <span class="comment">// 包含了instance，但是不包含最后的user pointers</span></span><br><span class="line">      <span class="type">const</span> GValue   *param_values,</span><br><span class="line">      gpointer        invocation_hint)</span><br><span class="line">&#123;</span><br><span class="line">  GRealClosure *real_closure;</span><br><span class="line"></span><br><span class="line">  real_closure = <span class="built_in">G_REAL_CLOSURE</span> (closure);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_closure_ref</span> (closure);      <span class="comment">/* preserve floating flag */</span></span><br><span class="line">  <span class="keyword">if</span> (!closure-&gt;is_invalid)</span><br><span class="line">    &#123;</span><br><span class="line">      GClosureMarshal marshal;</span><br><span class="line">      gpointer marshal_data;</span><br><span class="line">      gboolean in_marshal = closure-&gt;in_marshal;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">SET</span> (closure, in_marshal, TRUE);</span><br><span class="line">      <span class="keyword">if</span> (real_closure-&gt;meta_marshal)</span><br><span class="line">  &#123;<span class="comment">// 如果有meta_marshal</span></span><br><span class="line">    marshal_data = real_closure-&gt;meta_marshal_data;</span><br><span class="line">    marshal = real_closure-&gt;meta_marshal;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">  &#123;<span class="comment">// 没有meta_marshal则使用marshal</span></span><br><span class="line">    marshal_data = <span class="literal">NULL</span>;</span><br><span class="line">    marshal = closure-&gt;marshal;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">if</span> (!in_marshal)</span><br><span class="line">  <span class="built_in">closure_invoke_notifiers</span> (closure, PRE_NOTIFY);</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">marshal</span> (closure,</span><br><span class="line">         return_value,</span><br><span class="line">         n_param_values, param_values,</span><br><span class="line">         invocation_hint,</span><br><span class="line">         marshal_data);</span><br><span class="line">         </span><br><span class="line">      <span class="keyword">if</span> (!in_marshal)</span><br><span class="line">  <span class="built_in">closure_invoke_notifiers</span> (closure, POST_NOTIFY);</span><br><span class="line">      <span class="built_in">SET</span> (closure, in_marshal, in_marshal);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">g_closure_unref</span> (closure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class_closure 和普通 connect 得到的 closure 结构如下</p><p><img src="/images/Gobject-%E4%BF%A1%E5%8F%B7%E4%B9%8B-g-signal-emit/PXaRbrLPJotDFJxtYwmcgFJDnYc.jpg"></p><h5 id="g-type-class-meta-marshal"><a href="#g-type-class-meta-marshal" class="headerlink" title="g_type_class_meta_marshal"></a>g_type_class_meta_marshal</h5><p>如果是 meta_marshal，那么上面 g_closure_invoke 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">marshal</span> (closure,</span><br><span class="line"> return_value,</span><br><span class="line"> n_param_values, param_values,</span><br><span class="line"> invocation_hint,</span><br><span class="line"> marshal_data);</span><br></pre></td></tr></table></figure><p>就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">g_type_class_meta_marshal</span>(closure,</span><br><span class="line">         return_value,</span><br><span class="line">         n_param_values, param_values,</span><br><span class="line">         invocation_hint,</span><br><span class="line">         offset);</span><br></pre></td></tr></table></figure><p>g_type_class_meta_marshal 会通过 offset 参数取得虚函数指针，这才是 class_closure 中真正被调用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_type_class_meta_marshal</span> <span class="params">(GClosure       *closure,</span></span></span><br><span class="line"><span class="params"><span class="function">         GValue <span class="comment">/*out*/</span> *return_value,</span></span></span><br><span class="line"><span class="params"><span class="function">         guint           n_param_values,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">const</span> GValue   *param_values,</span></span></span><br><span class="line"><span class="params"><span class="function">         gpointer        invocation_hint,</span></span></span><br><span class="line"><span class="params"><span class="function">         gpointer        marshal_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GTypeClass *<span class="keyword">class</span>;</span><br><span class="line">  gpointer callback;</span><br><span class="line">  <span class="comment">/* GType itype = (GType) closure-&gt;data; */</span></span><br><span class="line">  guint offset = <span class="built_in">GPOINTER_TO_UINT</span> (marshal_data);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> = <span class="built_in">G_TYPE_INSTANCE_GET_CLASS</span> (<span class="built_in">g_value_peek_pointer</span> (param_values + <span class="number">0</span>), itype, GTypeClass);</span><br><span class="line">  callback = <span class="built_in">G_STRUCT_MEMBER</span> (gpointer, <span class="keyword">class</span>, offset);</span><br><span class="line">  <span class="keyword">if</span> (callback)</span><br><span class="line">    closure-&gt;<span class="built_in">marshal</span> (closure,</span><br><span class="line">          return_value,</span><br><span class="line">          n_param_values, param_values,</span><br><span class="line">          invocation_hint,</span><br><span class="line">          callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="g-cclosure-marshal-generic"><a href="#g-cclosure-marshal-generic" class="headerlink" title="g_cclosure_marshal_generic"></a>g_cclosure_marshal_generic</h5><p>但是如果是普通 connect 得到的 closure，g_closure_invoke 中 marshal 就是 g_cclosure_marshal_generic。而且传给 g_cclosure_marshal_generic 的最后一个参数为 NULL，从下面代码 <code>ffi_call (&amp;cif, marshal_data ? marshal_data : cc-&gt;callback, rvalue, args);</code> 可知，如果 g_cclosure_marshal_generic 的最后一个参数为 NULL，会从 GCClosure 中取得 callback</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_cclosure_marshal_generic</span> <span class="params">(GClosure     *closure,</span></span></span><br><span class="line"><span class="params"><span class="function">                            GValue       *return_gvalue,</span></span></span><br><span class="line"><span class="params"><span class="function">                            guint         n_param_values,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> GValue *param_values,</span></span></span><br><span class="line"><span class="params"><span class="function">                            gpointer      invocation_hint,</span></span></span><br><span class="line"><span class="params"><span class="function">                            gpointer      marshal_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ffi_type *rtype;</span><br><span class="line">  <span class="type">void</span> *rvalue;</span><br><span class="line">  <span class="type">int</span> n_args;</span><br><span class="line">  ffi_type **atypes;</span><br><span class="line">  <span class="type">void</span> **args;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  ffi_cif cif;</span><br><span class="line">  GCClosure *cc = (GCClosure*) closure;</span><br><span class="line">  gint *enum_tmpval;</span><br><span class="line">  gboolean tmpval_used = FALSE;</span><br><span class="line"></span><br><span class="line">  enum_tmpval = <span class="built_in">g_alloca</span> (<span class="built_in">sizeof</span> (gint));</span><br><span class="line">  <span class="keyword">if</span> (return_gvalue &amp;&amp; <span class="built_in">G_VALUE_TYPE</span> (return_gvalue))</span><br><span class="line">    &#123;</span><br><span class="line">      rtype = <span class="built_in">value_to_ffi_type</span> (return_gvalue, &amp;rvalue, enum_tmpval, &amp;tmpval_used);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      rtype = &amp;ffi_type_void;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  rvalue = <span class="built_in">g_alloca</span> (<span class="built_in">MAX</span> (rtype-&gt;size, <span class="built_in">sizeof</span> (ffi_arg)));</span><br><span class="line"></span><br><span class="line">  n_args = n_param_values + <span class="number">1</span>; <span class="comment">// 加上最后的user pointer参数</span></span><br><span class="line">  atypes = <span class="built_in">g_alloca</span> (<span class="built_in">sizeof</span> (ffi_type *) * n_args);</span><br><span class="line">  args =  <span class="built_in">g_alloca</span> (<span class="built_in">sizeof</span> (gpointer) * n_args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tmpval_used)</span><br><span class="line">    enum_tmpval = <span class="built_in">g_alloca</span> (<span class="built_in">sizeof</span> (gint));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">G_CCLOSURE_SWAP_DATA</span> (closure))</span><br><span class="line">    &#123;</span><br><span class="line">... <span class="comment">// 先不管</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      atypes[<span class="number">0</span>] = <span class="built_in">value_to_ffi_type</span> (param_values + <span class="number">0</span>,</span><br><span class="line">                                     &amp;args[<span class="number">0</span>],</span><br><span class="line">                                     enum_tmpval,</span><br><span class="line">                                     &amp;tmpval_used);</span><br><span class="line">      atypes[n_args<span class="number">-1</span>] = &amp;ffi_type_pointer;</span><br><span class="line">      args[n_args<span class="number">-1</span>] = &amp;closure-&gt;data; <span class="comment">// 把user pointer传给最后一个参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n_args - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (tmpval_used)</span><br><span class="line">        enum_tmpval = <span class="built_in">g_alloca</span> (<span class="built_in">sizeof</span> (gint));</span><br><span class="line"></span><br><span class="line">      atypes[i] = <span class="built_in">value_to_ffi_type</span> (param_values + i,</span><br><span class="line">                                     &amp;args[i],</span><br><span class="line">                                     enum_tmpval,</span><br><span class="line">                                     &amp;tmpval_used);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ffi_prep_cif</span> (&amp;cif, FFI_DEFAULT_ABI, n_args, rtype, atypes) != FFI_OK)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ffi_call</span> (&amp;cif, marshal_data ? marshal_data : cc-&gt;callback, rvalue, args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (return_gvalue &amp;&amp; <span class="built_in">G_VALUE_TYPE</span> (return_gvalue))</span><br><span class="line">    <span class="built_in">value_from_ffi_type</span> (return_gvalue, rvalue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>g_cclosure_marshal_generic 使用了 ffi 库来调用 callback 函数，这部分可以暂时不管。</p><p>我们来看另外一个有意思的地方。</p><p>g_signal_new 时，class_closure 中对应的 callback 函数是没有最后的 user pointer 的，而 g_signal_connect 则允许用户额外传一个 user pointer，也就是说 g_signal_new 时的 callback 函数的参数个数比 g_signal_connect 的 callback 的参数个数要小 1。</p><p>但是从上面 g_cclosure_marshal_generic 的 32 行、50 行可以清楚的看到，不管是 class_closure 还是普通 g_signal_connect 的 callback 都统一设置了额外的 user pointer 参数。</p><p>那么会发生函数实参个数比函数形参的个数要多的现象。这其实是允许的，函数调用者可以传给被调用对他来说用不到的参数（C 编译器可能不允许这种参数不匹配的情况，但是 ffi 可能使用了汇编代码绕过了这个限制），我之前有篇博客介绍了变长参数，两者原理有类似的地方。</p><p>参考资料：</p><p><a href="https://github.com/zorgnax/gobject-examples/blob/master/01-media-from-book/media.c">https://github.com/zorgnax/gobject-examples/blob/master/01-media-from-book/media.c</a></p>]]></content>
      
      
      <categories>
          
          <category> gobject </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gobject 信号之 g_signal_connect</title>
      <link href="/2023/05/01/Gobject-%E4%BF%A1%E5%8F%B7%E4%B9%8B-g-signal-connect/"/>
      <url>/2023/05/01/Gobject-%E4%BF%A1%E5%8F%B7%E4%B9%8B-g-signal-connect/</url>
      
        <content type="html"><![CDATA[<h1 id="g-signal-connect"><a href="#g-signal-connect" class="headerlink" title="g_signal_connect"></a>g_signal_connect</h1><p>接着再来看 g_signal_connect，他是一个宏，调用了 g_signal_connect_data</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> g_signal_connect(instance, detailed_signal, c_handler, data) \</span></span><br><span class="line"><span class="meta">    g_signal_connect_data ((instance), (detailed_signal), (c_handler), (data), NULL, (GConnectFlags) 0)</span></span><br></pre></td></tr></table></figure><h2 id="g-signal-connect-data"><a href="#g-signal-connect-data" class="headerlink" title="g_signal_connect_data"></a>g_signal_connect_data</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gulong</span></span><br><span class="line"><span class="function"><span class="title">g_signal_connect_data</span> <span class="params">(gpointer       instance,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> gchar   *detailed_signal, <span class="comment">// signal name</span></span></span></span><br><span class="line"><span class="params"><span class="function">           GCallback      c_handler,</span></span></span><br><span class="line"><span class="params"><span class="function">           gpointer       data, <span class="comment">// user data</span></span></span></span><br><span class="line"><span class="params"><span class="function">           GClosureNotify destroy_data,</span></span></span><br><span class="line"><span class="params"><span class="function">           GConnectFlags  connect_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  guint signal_id;</span><br><span class="line">  gulong handler_seq_no = <span class="number">0</span>;</span><br><span class="line">  GQuark detail = <span class="number">0</span>;</span><br><span class="line">  GType itype;</span><br><span class="line">  gboolean swapped, after;</span><br><span class="line"></span><br><span class="line">  swapped = (connect_flags &amp; G_CONNECT_SWAPPED) != FALSE;</span><br><span class="line">  after = (connect_flags &amp; G_CONNECT_AFTER) != FALSE;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SIGNAL_LOCK</span> ();</span><br><span class="line">  <span class="comment">// 先找到实例的真正类型</span></span><br><span class="line">  itype = <span class="built_in">G_TYPE_FROM_INSTANCE</span> (instance);</span><br><span class="line">  <span class="comment">// 通过实例所属类型以及信号的name查找signal_id</span></span><br><span class="line">  <span class="comment">// signal_parse_name内部调用signal_id_lookup进行查找</span></span><br><span class="line">  <span class="comment">// 会查找itype及其父类上名为detailed_signal的SignalNode</span></span><br><span class="line">  signal_id = <span class="built_in">signal_parse_name</span> (detailed_signal, itype, &amp;detail, TRUE);</span><br><span class="line">  <span class="keyword">if</span> (signal_id)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 通过signal_id查找SignalNode</span></span><br><span class="line">      SignalNode *node = <span class="built_in">LOOKUP_SIGNAL_NODE</span> (signal_id);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">node_check_deprecated</span> (node);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))</span><br><span class="line">  <span class="built_in">g_warning</span> (<span class="string">&quot;%s: signal &#x27;%s&#x27; does not support details&quot;</span>, G_STRLOC, detailed_signal);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">g_type_is_a</span> (itype, node-&gt;itype))</span><br><span class="line">        <span class="built_in">g_warning</span> (<span class="string">&quot;%s: signal &#x27;%s&#x27; is invalid for instance &#x27;%p&#x27; of type &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                   G_STRLOC, detailed_signal, instance, <span class="built_in">g_type_name</span> (itype));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// 创建输入的callback对应的handler</span></span><br><span class="line">    Handler *handler = <span class="built_in">handler_new</span> (signal_id, instance, after);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">G_TYPE_IS_OBJECT</span> (node-&gt;itype))</span><br><span class="line">            _g_object_set_has_signal_handler ((GObject *) instance, signal_id);</span><br><span class="line"></span><br><span class="line">    handler_seq_no = handler-&gt;sequential_number;</span><br><span class="line">    handler-&gt;detail = detail;</span><br><span class="line">    handler-&gt;closure = <span class="built_in">g_closure_ref</span> ((swapped ? g_cclosure_new_swap : g_cclosure_new) (c_handler, data, destroy_data));</span><br><span class="line">    <span class="built_in">g_closure_sink</span> (handler-&gt;closure);</span><br><span class="line">    <span class="comment">// 将handler插入到instance中signal_id对应的链表中</span></span><br><span class="line">    <span class="built_in">handler_insert</span> (signal_id, instance, handler);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;c_marshaller &amp;&amp; <span class="built_in">G_CLOSURE_NEEDS_MARSHAL</span> (handler-&gt;closure))</span><br><span class="line">      &#123; <span class="comment">// 设置closure的marshal函数</span></span><br><span class="line">        <span class="built_in">g_closure_set_marshal</span> (handler-&gt;closure, node-&gt;c_marshaller);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;va_marshaller)</span><br><span class="line">    _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);</span><br><span class="line">      &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">g_warning</span> (<span class="string">&quot;%s: signal &#x27;%s&#x27; is invalid for instance &#x27;%p&#x27; of type &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">               G_STRLOC, detailed_signal, instance, <span class="built_in">g_type_name</span> (itype));</span><br><span class="line">  <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> handler_seq_no;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="signal-parse-name"><a href="#signal-parse-name" class="headerlink" title="signal_parse_name"></a>signal_parse_name</h3><p>本质还是通过 signal_id_lookup 查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> guint</span></span><br><span class="line"><span class="function"><span class="title">signal_parse_name</span> <span class="params">(<span class="type">const</span> gchar *name,</span></span></span><br><span class="line"><span class="params"><span class="function">       GType        itype,</span></span></span><br><span class="line"><span class="params"><span class="function">       GQuark      *detail_p,</span></span></span><br><span class="line"><span class="params"><span class="function">       gboolean     force_quark)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> gchar *colon = <span class="built_in">strchr</span> (name, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">  guint signal_id;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!colon)</span><br><span class="line">    &#123;</span><br><span class="line">      signal_id = <span class="built_in">signal_id_lookup</span> (name, itype);</span><br><span class="line">      <span class="keyword">if</span> (signal_id &amp;&amp; detail_p)</span><br><span class="line">  *detail_p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (colon[<span class="number">1</span>] == <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    signal_id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> signal_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>Handler 结构如下，他保存了 signal_id、处理 callback 的 closure、该 callback 连接的 instance 等信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_Handler</span></span><br><span class="line">&#123;</span><br><span class="line">  gulong        sequential_number;</span><br><span class="line">  Handler      *next;</span><br><span class="line">  Handler      *prev;</span><br><span class="line">  GQuark  detail;</span><br><span class="line">  guint         signal_id;</span><br><span class="line">  guint         ref_count;</span><br><span class="line">  guint         block_count : <span class="number">16</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLER_MAX_BLOCK_COUNT (1 &lt;&lt; 16)</span></span><br><span class="line">  guint         after : <span class="number">1</span>;</span><br><span class="line">  guint         has_invalid_closure_notify : <span class="number">1</span>;</span><br><span class="line">  GClosure     *closure;</span><br><span class="line">  gpointer      instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="handler-new"><a href="#handler-new" class="headerlink" title="handler_new"></a>handler_new</h3><p>通过 handler_new 创建 Handler，最后还把 handler 插入到了一个全局 hash_table 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> Handler*</span></span><br><span class="line"><span class="function"><span class="title">handler_new</span> <span class="params">(guint signal_id, gpointer instance, gboolean after)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Handler *handler = <span class="built_in">g_slice_new</span> (Handler);</span><br><span class="line">  handler-&gt;sequential_number = g_handler_sequential_number++;</span><br><span class="line">  handler-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">  handler-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  handler-&gt;detail = <span class="number">0</span>;</span><br><span class="line">  handler-&gt;signal_id = signal_id;</span><br><span class="line">  handler-&gt;instance = instance;</span><br><span class="line">  handler-&gt;ref_count = <span class="number">1</span>;</span><br><span class="line">  handler-&gt;block_count = <span class="number">0</span>;</span><br><span class="line">  handler-&gt;after = after != FALSE;</span><br><span class="line">  handler-&gt;closure = <span class="literal">NULL</span>;</span><br><span class="line">  handler-&gt;has_invalid_closure_notify = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_hash_table_add</span> (g_handlers, handler);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="g-cclosure-new"><a href="#g-cclosure-new" class="headerlink" title="g_cclosure_new"></a>g_cclosure_new</h3><p>g_cclosure_new 会创建一个 closure，该 closure 在调用 callback_func 函数时，会把 user_data 作为最后一个参数传给 callback_func</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GClosure*</span></span><br><span class="line"><span class="function"><span class="title">g_cclosure_new</span> <span class="params">(GCallback      callback_func,</span></span></span><br><span class="line"><span class="params"><span class="function">    gpointer       user_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    GClosureNotify destroy_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GClosure *closure;</span><br><span class="line">  </span><br><span class="line">  closure = <span class="built_in">g_closure_new_simple</span> (<span class="built_in">sizeof</span> (GCClosure), user_data);</span><br><span class="line">  <span class="keyword">if</span> (destroy_data)</span><br><span class="line">    <span class="built_in">g_closure_add_finalize_notifier</span> (closure, user_data, destroy_data);</span><br><span class="line">  ((GCClosure*) closure)-&gt;callback = (gpointer) callback_func;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> closure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>g_cclosure_new 内部也是调用 g_closure_new_simple 函数，但是这次创建的是 GCClosure 而不是 GClosure，GCClosure 在 GClosure 的后面还加了一个 callback 字段，等到后面处理 Closure 的时候就知道 callback 是如何调用了的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* closure for C function calls, callback() is the user function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_GCClosure</span></span><br><span class="line">&#123;</span><br><span class="line">  GClosure  closure;</span><br><span class="line">  gpointer  callback;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="handler-insert"><a href="#handler-insert" class="headerlink" title="handler_insert"></a>handler_insert</h3><p>通过 handler_insert 把 handler 插入到一个双向链表中，由下面 handler_list_ensure 可知，这个双向链表里的每一项都是 connect 到同一个 signal_id 的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">handler_insert</span> <span class="params">(guint    signal_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    gpointer instance,</span></span></span><br><span class="line"><span class="params"><span class="function">    Handler  *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  HandlerList *hlist;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_assert</span> (handler-&gt;prev == <span class="literal">NULL</span> &amp;&amp; handler-&gt;next == <span class="literal">NULL</span>); <span class="comment">/* paranoid */</span></span><br><span class="line"></span><br><span class="line">  hlist = <span class="built_in">handler_list_ensure</span> (signal_id, instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将handler插入到HandlerList这个双向链表</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="handler-list-ensure"><a href="#handler-list-ensure" class="headerlink" title="handler_list_ensure"></a>handler_list_ensure</h4><p>从下面可知每个 instance 有一个 GBSearchArray，我们通过 signal_id 来查找该 GBSearchArray，查找结果是 HandlerList，这个 HandlerList 里的每一个 Handler 都是 connect 到同一个 signal_id 的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> HandlerList*</span></span><br><span class="line"><span class="function"><span class="title">handler_list_ensure</span> <span class="params">(guint    signal_id,</span></span></span><br><span class="line"><span class="params"><span class="function">         gpointer instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GBSearchArray *hlbsa = <span class="built_in">g_hash_table_lookup</span> (g_handler_list_bsa_ht, instance);</span><br><span class="line">  HandlerList key;</span><br><span class="line">  </span><br><span class="line">  key.signal_id = signal_id;</span><br><span class="line">  key.handlers    = <span class="literal">NULL</span>;</span><br><span class="line">  key.tail_before = <span class="literal">NULL</span>;</span><br><span class="line">  key.tail_after  = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (!hlbsa)</span><br><span class="line">    &#123;</span><br><span class="line">      hlbsa = <span class="built_in">g_bsearch_array_create</span> (&amp;g_signal_hlbsa_bconfig);</span><br><span class="line">      hlbsa = <span class="built_in">g_bsearch_array_insert</span> (hlbsa, &amp;g_signal_hlbsa_bconfig, &amp;key);</span><br><span class="line">      <span class="built_in">g_hash_table_insert</span> (g_handler_list_bsa_ht, instance, hlbsa);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      GBSearchArray *o = hlbsa;</span><br><span class="line"></span><br><span class="line">      hlbsa = <span class="built_in">g_bsearch_array_insert</span> (o, &amp;g_signal_hlbsa_bconfig, &amp;key);</span><br><span class="line">      <span class="keyword">if</span> (hlbsa != o)</span><br><span class="line">          <span class="built_in">g_hash_table_insert</span> (g_handler_list_bsa_ht, instance, hlbsa);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">g_bsearch_array_lookup</span> (hlbsa, &amp;g_signal_hlbsa_bconfig, &amp;key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> gobject </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gobject 信号之 g_signal_new</title>
      <link href="/2023/05/01/Gobject-%E4%BF%A1%E5%8F%B7%E4%B9%8B-g-signal-new/"/>
      <url>/2023/05/01/Gobject-%E4%BF%A1%E5%8F%B7%E4%B9%8B-g-signal-new/</url>
      
        <content type="html"><![CDATA[<p>这篇文章来介绍 Gobject 的最后一个特性：信号和闭包。</p><p>Gobject 的信号主要有 3 个 api：g_signal_new、g_signal_connect、g_signal_emit。使用流程如下：</p><ul><li>首先在 class_init 中调用 g_signal_new 创建信号，这里要注意，信号是属于类的，和属性一样</li><li>通过 g_object_new 创建对象，然后将回调函数通过 g_signal_connect 连接到信号上</li><li>最后对对象调用 g_signal_emit 触发信号，执行上一步连接的回调函数</li></ul><h1 id="g-signal-new"><a href="#g-signal-new" class="headerlink" title="g_signal_new"></a>g_signal_new</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">guint</span></span><br><span class="line"><span class="function"><span class="title">g_signal_new</span> <span class="params">(<span class="type">const</span> gchar  *signal_name,</span></span></span><br><span class="line"><span class="params"><span class="function">        GType     itype,</span></span></span><br><span class="line"><span class="params"><span class="function">        GSignalFlags    signal_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">        guint               class_offset,</span></span></span><br><span class="line"><span class="params"><span class="function">        GSignalAccumulator  accumulator,</span></span></span><br><span class="line"><span class="params"><span class="function">        gpointer      accu_data,</span></span></span><br><span class="line"><span class="params"><span class="function">        GSignalCMarshaller  c_marshaller,</span></span></span><br><span class="line"><span class="params"><span class="function">        GType     return_type,</span></span></span><br><span class="line"><span class="params"><span class="function">        guint     n_params,</span></span></span><br><span class="line"><span class="params"><span class="function">        ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  va_list args;</span><br><span class="line">  guint signal_id;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (signal_name != <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">va_start</span> (args, n_params);</span><br><span class="line"></span><br><span class="line">  signal_id = <span class="built_in">g_signal_new_valist</span> (signal_name, itype, signal_flags,</span><br><span class="line">                                   class_offset ? <span class="built_in">g_signal_type_cclosure_new</span> (itype, class_offset) : <span class="literal">NULL</span>,</span><br><span class="line">           accumulator, accu_data, c_marshaller,</span><br><span class="line">                                   return_type, n_params, args);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">va_end</span> (args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> signal_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>signal_name。信号的名字</li><li>itype。信号所属的类型，注意信号可以继承，子类可以使用父类的信号</li><li>signal_flags。指定默认 handler（通过 class_offset 指定的虚函数）的属性，可以是 G_SIGNAL_RUN_FIRST、G_SIGNAL_RUN_LAST 等</li><li>class_offset。类结构 struct 实例的首地址加上该偏移指向一个函数指针，这个函数指针指向的函数就是信号的默认 handler，子类可以通过虚函数覆盖（修改指定偏移处的函数指针）来定义自己的默认 handler，如果 class_offset 为 0，那么将没有默认 handler</li><li>accumulator。在每执行一个 handler 后会执行 accumulator，会根据其返回值决定是否继续执行剩下的 handler</li><li>accu_data。传给 accumulator 函数的数据</li><li>c_marshaller。自定义的 marshal 函数，内部需要执行 callback 函数，建议保持为空，使用默认 marshal 函数即可</li><li>return_type。返回值类型</li><li>n_params。去除第一个 GObject 参数后剩余的参数个数，不考虑 user pointer 在内</li><li>变长参数。去除第一个 GObject 参数后剩余的参数的类型，不考虑 user pointer 在内</li></ul><h2 id="g-signal-type-cclosure-new"><a href="#g-signal-type-cclosure-new" class="headerlink" title="g_signal_type_cclosure_new"></a>g_signal_type_cclosure_new</h2><p>当 class_offset 不为 0 时，会调用 g_signal_type_cclosure_new 函数创建一个 GClosure，这个 GClosure 用于处理默认 handler。</p><ul><li>g_signal_type_cclosure_new 先创建了一个 GRealClosure，这个 GRealClosure 里面有 GClosure</li><li>然后将 itype 也就是 GType 类型设给了 GClosure.data，这样就知道这个 Closure 只能在 itype 及其子类的对象中执行，后面会进行这个检查</li><li>然后将 struct_offset 也就是虚函数的偏移设给 GRealClosure.meta_marshal_data</li><li>然后将 g_type_class_meta_marshal 函数设给了 GRealClosure.meta_marshal</li><li>然后将 g_type_class_meta_marshalv 函数设给了 GRealClosure.va_meta_marshal</li></ul><p>上面的 itype、struct_offset、g_type_class_meta_marshal、g_type_class_meta_marshalv 在执行默认 handler 时会用到，比如会通过 struct_offset 信息找到需要执行的函数在虚函数表中的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GClosure*</span></span><br><span class="line"><span class="function"><span class="title">g_signal_type_cclosure_new</span> <span class="params">(GType    itype,</span></span></span><br><span class="line"><span class="params"><span class="function">          guint    struct_offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GClosure *closure;</span><br><span class="line">  </span><br><span class="line">  closure = <span class="built_in">g_closure_new_simple</span> (<span class="built_in">sizeof</span> (GClosure), (gpointer) itype);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">G_TYPE_IS_INTERFACE</span> (itype))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 不考虑interface</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_closure_set_meta_marshal</span> (closure, <span class="built_in">GUINT_TO_POINTER</span> (struct_offset), g_type_class_meta_marshal);</span><br><span class="line">      <span class="built_in">g_closure_set_meta_va_marshal</span> (closure, g_type_class_meta_marshalv);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> closure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="g-closure-new-simple"><a href="#g-closure-new-simple" class="headerlink" title="g_closure_new_simple"></a>g_closure_new_simple</h3><p>创建 GRealClosure，然后设置 GRealClosure 中 GClosure 部分的 data 字段的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GClosure*</span></span><br><span class="line"><span class="function"><span class="title">g_closure_new_simple</span> <span class="params">(guint           sizeof_closure,</span></span></span><br><span class="line"><span class="params"><span class="function">          gpointer        data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GClosure *closure;</span><br><span class="line">  gint private_size;</span><br><span class="line">  gchar *allocated;</span><br><span class="line"></span><br><span class="line">  private_size = <span class="built_in">sizeof</span> (GRealClosure) - <span class="built_in">sizeof</span> (GClosure);</span><br><span class="line">...</span><br><span class="line">    allocated = <span class="built_in">g_malloc0</span> (private_size + sizeof_closure);</span><br><span class="line"></span><br><span class="line">  closure = (GClosure *) (allocated + private_size);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SET</span> (closure, ref_count, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">SET</span> (closure, floating, TRUE);</span><br><span class="line">  closure-&gt;data = data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> closure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GRealClosure 和 GClosure 的关系如下，GRealClosure 在 GClosure 的基础上多了一些私有变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_GRealClosure</span>  GRealClosure;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_GRealClosure</span></span><br><span class="line">&#123;</span><br><span class="line">  GClosureMarshal meta_marshal;</span><br><span class="line">  gpointer meta_marshal_data;</span><br><span class="line">  GVaClosureMarshal va_meta_marshal;</span><br><span class="line">  GVaClosureMarshal va_marshal;</span><br><span class="line">  GClosure closure;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GClosure:</span></span><br><span class="line"><span class="comment"> * @in_marshal: Indicates whether the closure is currently being invoked with </span></span><br><span class="line"><span class="comment"> *  g_closure_invoke()</span></span><br><span class="line"><span class="comment"> * @is_invalid: Indicates whether the closure has been invalidated by </span></span><br><span class="line"><span class="comment"> *  g_closure_invalidate()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * A #GClosure represents a callback supplied by the programmer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_GClosure</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">  guint ref_count : <span class="number">15</span>;  <span class="comment">/* (atomic) */</span></span><br><span class="line">  <span class="comment">/* meta_marshal is not used anymore but must be zero for historical reasons</span></span><br><span class="line"><span class="comment">     as it was exposed in the G_CLOSURE_N_NOTIFIERS macro */</span></span><br><span class="line">  guint meta_marshal_nouse : <span class="number">1</span>;  <span class="comment">/* (atomic) */</span></span><br><span class="line">  guint n_guards : <span class="number">1</span>;  <span class="comment">/* (atomic) */</span></span><br><span class="line">  guint n_fnotifiers : <span class="number">2</span>;  <span class="comment">/* finalization notifiers (atomic) */</span></span><br><span class="line">  guint n_inotifiers : <span class="number">8</span>;  <span class="comment">/* invalidation notifiers (atomic) */</span></span><br><span class="line">  guint in_inotify : <span class="number">1</span>;  <span class="comment">/* (atomic) */</span></span><br><span class="line">  guint floating : <span class="number">1</span>;  <span class="comment">/* (atomic) */</span></span><br><span class="line">  <span class="comment">/*&lt; protected &gt;*/</span></span><br><span class="line">  guint derivative_flag : <span class="number">1</span>;  <span class="comment">/* (atomic) */</span></span><br><span class="line">  <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">  guint in_marshal : <span class="number">1</span>;  <span class="comment">/* (atomic) */</span></span><br><span class="line">  guint is_invalid : <span class="number">1</span>;  <span class="comment">/* (atomic) */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*&lt; private &gt;*/</span>   <span class="built_in">void</span>   (*marshal)  (GClosure       *closure,</span><br><span class="line">                        GValue <span class="comment">/*out*/</span> *return_value,</span><br><span class="line">                        guint           n_param_values,</span><br><span class="line">                        <span class="type">const</span> GValue   *param_values,</span><br><span class="line">                        gpointer        invocation_hint,</span><br><span class="line">                        gpointer        marshal_data);</span><br><span class="line">  <span class="comment">/*&lt; protected &gt;*/</span> gpointer data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*&lt; private &gt;*/</span>   GClosureNotifyData *notifiers;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* invariants/constraints:</span></span><br><span class="line"><span class="comment">   * - -&gt;marshal and -&gt;data are _invalid_ as soon as -&gt;is_invalid==TRUE</span></span><br><span class="line"><span class="comment">   * - invocation of all inotifiers occurs prior to fnotifiers</span></span><br><span class="line"><span class="comment">   * - order of inotifiers is random</span></span><br><span class="line"><span class="comment">   *   inotifiers may _not_ free/invalidate parameter values (e.g. -&gt;data)</span></span><br><span class="line"><span class="comment">   * - order of fnotifiers is random</span></span><br><span class="line"><span class="comment">   * - each notifier may only be removed before or during its invocation</span></span><br><span class="line"><span class="comment">   * - reference counting may only happen prior to fnotify invocation</span></span><br><span class="line"><span class="comment">   *   (in that sense, fnotifiers are really finalization handlers)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="g-closure-set-meta-marshal"><a href="#g-closure-set-meta-marshal" class="headerlink" title="g_closure_set_meta_marshal"></a>g_closure_set_meta_marshal</h3><p>这个函数把输入的 meta_marshal、marshal_data 设给了 GRealClosure</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_closure_set_meta_marshal</span> <span class="params">(GClosure       *closure,</span></span></span><br><span class="line"><span class="params"><span class="function">          gpointer        marshal_data,</span></span></span><br><span class="line"><span class="params"><span class="function">          GClosureMarshal meta_marshal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GRealClosure *real_closure;</span><br><span class="line"></span><br><span class="line">  real_closure = <span class="built_in">G_REAL_CLOSURE</span> (closure);</span><br><span class="line"></span><br><span class="line">  real_closure-&gt;meta_marshal = meta_marshal;</span><br><span class="line">  real_closure-&gt;meta_marshal_data = marshal_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="g-closure-set-meta-va-marshal"><a href="#g-closure-set-meta-va-marshal" class="headerlink" title="g_closure_set_meta_va_marshal"></a>g_closure_set_meta_va_marshal</h3><p>这个函数把输入的 va_meta_marshal 设给了 GRealClosure</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_closure_set_meta_va_marshal</span> <span class="params">(GClosure       *closure,</span></span></span><br><span class="line"><span class="params"><span class="function">             GVaClosureMarshal va_meta_marshal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GRealClosure *real_closure;</span><br><span class="line"></span><br><span class="line">  real_closure = <span class="built_in">G_REAL_CLOSURE</span> (closure);</span><br><span class="line"></span><br><span class="line">  real_closure-&gt;va_meta_marshal = va_meta_marshal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="g-signal-new-valist"><a href="#g-signal-new-valist" class="headerlink" title="g_signal_new_valist"></a>g_signal_new_valist</h2><p>g_signal_new 在创建默认 handler 的 Closure 后执行 g_signal_new_valist。</p><p>g_signal_new_valist 主要是将变长参数整理为 GType 数组，然后调用 g_signal_newv</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">guint</span></span><br><span class="line"><span class="function"><span class="title">g_signal_new_valist</span> <span class="params">(<span class="type">const</span> gchar       *signal_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                     GType              itype,</span></span></span><br><span class="line"><span class="params"><span class="function">                     GSignalFlags       signal_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                     GClosure          *class_closure,</span></span></span><br><span class="line"><span class="params"><span class="function">                     GSignalAccumulator accumulator,</span></span></span><br><span class="line"><span class="params"><span class="function">                     gpointer           accu_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                     GSignalCMarshaller c_marshaller,</span></span></span><br><span class="line"><span class="params"><span class="function">                     GType              return_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                     guint              n_params,</span></span></span><br><span class="line"><span class="params"><span class="function">                     va_list            args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Somewhat arbitrarily reserve 200 bytes. That should cover the majority</span></span><br><span class="line"><span class="comment">   * of cases where n_params is small and still be small enough for what we</span></span><br><span class="line"><span class="comment">   * want to put on the stack. */</span></span><br><span class="line">  GType param_types_stack[<span class="number">200</span> / <span class="built_in">sizeof</span> (GType)];</span><br><span class="line">  GType *param_types_heap = <span class="literal">NULL</span>;</span><br><span class="line">  GType *param_types;</span><br><span class="line">  guint i;</span><br><span class="line">  guint signal_id;</span><br><span class="line"></span><br><span class="line">  param_types = param_types_stack;</span><br><span class="line">  <span class="keyword">if</span> (n_params &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">G_UNLIKELY</span> (n_params &gt; <span class="built_in">G_N_ELEMENTS</span> (param_types_stack)))</span><br><span class="line">        &#123;</span><br><span class="line">          param_types_heap = <span class="built_in">g_new</span> (GType, n_params);</span><br><span class="line">          param_types = param_types_heap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n_params; i++)</span><br><span class="line">        param_types[i] = <span class="built_in">va_arg</span> (args, GType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  signal_id = <span class="built_in">g_signal_newv</span> (signal_name, itype, signal_flags,</span><br><span class="line">                             class_closure, accumulator, accu_data, c_marshaller,</span><br><span class="line">                             return_type, n_params, param_types);</span><br><span class="line">  <span class="built_in">g_free</span> (param_types_heap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> signal_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="g-signal-newv"><a href="#g-signal-newv" class="headerlink" title="g_signal_newv"></a>g_signal_newv</h3><p>像之前的属性一样，g_signal_newv 也会创建一个信号对象，然后把这个对象插入一个全局的 hash 表中。下面的函数虽然长，但其实做的事主要是：</p><ul><li>创建 SignalNode 对象，并把他插入一个全局的表中</li><li>把输入的 class_closure、accumulator、return_type、param_types 等信息复制到 SignalNode 中</li></ul><p>后面只要有这个 SignalNode，那么完全就知道 handler 函数该怎么调用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">guint</span></span><br><span class="line"><span class="function"><span class="title">g_signal_newv</span> <span class="params">(<span class="type">const</span> gchar       *signal_name,</span></span></span><br><span class="line"><span class="params"><span class="function">               GType              itype,</span></span></span><br><span class="line"><span class="params"><span class="function">               GSignalFlags       signal_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">               GClosure          *class_closure,</span></span></span><br><span class="line"><span class="params"><span class="function">               GSignalAccumulator accumulator,</span></span></span><br><span class="line"><span class="params"><span class="function">               gpointer     accu_data,</span></span></span><br><span class="line"><span class="params"><span class="function">               GSignalCMarshaller c_marshaller,</span></span></span><br><span class="line"><span class="params"><span class="function">               GType      return_type,</span></span></span><br><span class="line"><span class="params"><span class="function">               guint              n_params,</span></span></span><br><span class="line"><span class="params"><span class="function">               GType     *param_types)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> gchar *name;</span><br><span class="line">  gchar *signal_name_copy = <span class="literal">NULL</span>;</span><br><span class="line">  guint signal_id, i;</span><br><span class="line">  SignalNode *node;</span><br><span class="line">  GSignalCMarshaller builtin_c_marshaller;</span><br><span class="line">  GSignalCVaMarshaller builtin_va_marshaller;</span><br><span class="line">  GSignalCVaMarshaller va_marshaller;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">is_canonical</span> (signal_name))</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      name = signal_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SIGNAL_LOCK</span> ();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先通过name和itype查找signal_id，signal_id其实是g_signal_nodes数组的索引</span></span><br><span class="line"><span class="comment">// signal_id_lookup函数的查找逻辑是在itype类及其父类中查找name</span></span><br><span class="line"><span class="comment">// 也就是不允许一个继承体系中出现同名的信号</span></span><br><span class="line">  signal_id = <span class="built_in">signal_id_lookup</span> (name, itype);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    static inline SignalNode*</span></span><br><span class="line"><span class="comment">    LOOKUP_SIGNAL_NODE (guint signal_id)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      if (signal_id &lt; g_n_signal_nodes)</span></span><br><span class="line"><span class="comment">        return g_signal_nodes[signal_id];</span></span><br><span class="line"><span class="comment">      else</span></span><br><span class="line"><span class="comment">        return NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  node = <span class="built_in">LOOKUP_SIGNAL_NODE</span> (signal_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果能通过name和itype找到SignalNode，就代表在该继承体系中信号名已存在，不能重复创建</span></span><br><span class="line">  <span class="keyword">if</span> (node &amp;&amp; !node-&gt;destroyed)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (G_STRLOC <span class="string">&quot;: signal \&quot;%s\&quot; already exists in the &#x27;%s&#x27; %s&quot;</span>,</span><br><span class="line">                 name,</span><br><span class="line">                 <span class="built_in">type_debug_name</span> (node-&gt;itype),</span><br><span class="line">                 <span class="built_in">G_TYPE_IS_INTERFACE</span> (node-&gt;itype) ? <span class="string">&quot;interface&quot;</span> : <span class="string">&quot;class ancestry&quot;</span>);</span><br><span class="line">      <span class="built_in">g_free</span> (signal_name_copy);</span><br><span class="line">      <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (node &amp;&amp; node-&gt;itype != itype)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (G_STRLOC <span class="string">&quot;: signal \&quot;%s\&quot; for type &#x27;%s&#x27; was previously created for type &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                 name,</span><br><span class="line">                 <span class="built_in">type_debug_name</span> (itype),</span><br><span class="line">                 <span class="built_in">type_debug_name</span> (node-&gt;itype));</span><br><span class="line">      <span class="built_in">g_free</span> (signal_name_copy);</span><br><span class="line">      <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面两步是检查参数和返回值的类型</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n_params; i++)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">G_TYPE_IS_VALUE</span> (param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))</span><br><span class="line">      &#123;</span><br><span class="line">  <span class="built_in">g_warning</span> (G_STRLOC <span class="string">&quot;: parameter %d of type &#x27;%s&#x27; for signal \&quot;%s::%s\&quot; is not a value type&quot;</span>,</span><br><span class="line">       i + <span class="number">1</span>, <span class="built_in">type_debug_name</span> (param_types[i]), <span class="built_in">type_debug_name</span> (itype), name);</span><br><span class="line">  <span class="built_in">g_free</span> (signal_name_copy);</span><br><span class="line">  <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">if</span> (return_type != G_TYPE_NONE &amp;&amp; !<span class="built_in">G_TYPE_IS_VALUE</span> (return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (G_STRLOC <span class="string">&quot;: return value of type &#x27;%s&#x27; for signal \&quot;%s::%s\&quot; is not a value type&quot;</span>,</span><br><span class="line">     <span class="built_in">type_debug_name</span> (return_type), <span class="built_in">type_debug_name</span> (itype), name);</span><br><span class="line">      <span class="built_in">g_free</span> (signal_name_copy);</span><br><span class="line">      <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果之前没找到SignalNode，那么就可以创建新的SignalNode</span></span><br><span class="line">  <span class="comment">/* setup permanent portion of signal node */</span></span><br><span class="line">  <span class="keyword">if</span> (!node)</span><br><span class="line">    &#123;</span><br><span class="line">      SignalKey key;</span><br><span class="line">      </span><br><span class="line">      signal_id = g_n_signal_nodes++;</span><br><span class="line">      node = <span class="built_in">g_new</span> (SignalNode, <span class="number">1</span>);</span><br><span class="line">      node-&gt;signal_id = signal_id;</span><br><span class="line">      g_signal_nodes = <span class="built_in">g_renew</span> (SignalNode*, g_signal_nodes, g_n_signal_nodes);</span><br><span class="line">      g_signal_nodes[signal_id] = node;</span><br><span class="line">      node-&gt;itype = itype;</span><br><span class="line">      key.itype = itype;</span><br><span class="line">      key.signal_id = signal_id;</span><br><span class="line">      node-&gt;name = <span class="built_in">g_intern_string</span> (name);</span><br><span class="line">      key.quark = <span class="built_in">g_quark_from_string</span> (name);</span><br><span class="line">      g_signal_key_bsa = <span class="built_in">g_bsearch_array_insert</span> (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  node-&gt;destroyed = FALSE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* setup reinitializable portion */</span></span><br><span class="line">  node-&gt;single_va_closure_is_valid = FALSE;</span><br><span class="line">  node-&gt;flags = signal_flags &amp; G_SIGNAL_FLAGS_MASK;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 复制参数和返回值的类型信息到SignalNode</span></span><br><span class="line">  node-&gt;n_params = n_params;</span><br><span class="line">  node-&gt;param_types = <span class="built_in">g_memdup2</span> (param_types, <span class="built_in">sizeof</span> (GType) * n_params);</span><br><span class="line">  node-&gt;return_type = return_type;</span><br><span class="line">  node-&gt;class_closure_bsa = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 复制accumulator信息到SignalNode</span></span><br><span class="line">  <span class="keyword">if</span> (accumulator)</span><br><span class="line">    &#123;</span><br><span class="line">      node-&gt;accumulator = <span class="built_in">g_new</span> (SignalAccumulator, <span class="number">1</span>);</span><br><span class="line">      node-&gt;accumulator-&gt;func = accumulator;</span><br><span class="line">      node-&gt;accumulator-&gt;data = accu_data;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    node-&gt;accumulator = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  builtin_c_marshaller = <span class="literal">NULL</span>;</span><br><span class="line">  builtin_va_marshaller = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pick up built-in va marshallers for standard types, and</span></span><br><span class="line"><span class="comment">     instead of generic marshaller if no marshaller specified */</span></span><br><span class="line">  <span class="keyword">if</span> (n_params == <span class="number">0</span> &amp;&amp; return_type == G_TYPE_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">... <span class="comment">// marshaller优化，略过</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (c_marshaller == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (builtin_c_marshaller)</span><br><span class="line">        &#123;</span><br><span class="line">          c_marshaller = builtin_c_marshaller;</span><br><span class="line">          va_marshaller = builtin_va_marshaller;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">  &#123;  <span class="comment">// 如果不优化，那么会使用这两个marshaller</span></span><br><span class="line">    c_marshaller = g_cclosure_marshal_generic;</span><br><span class="line">    va_marshaller = g_cclosure_marshal_generic_va;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    va_marshaller = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 复制marshaller信息到SignalNode</span></span><br><span class="line">  node-&gt;c_marshaller = c_marshaller;</span><br><span class="line">  node-&gt;va_marshaller = va_marshaller;</span><br><span class="line">  node-&gt;emission_hooks = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (class_closure) <span class="comment">// 将class_closure添加到SignalNode</span></span><br><span class="line">    <span class="built_in">signal_add_class_closure</span> (node, <span class="number">0</span>, class_closure);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SIGNAL_UNLOCK</span> ();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_free</span> (signal_name_copy);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> signal_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SignalNode-结构"><a href="#SignalNode-结构" class="headerlink" title="SignalNode 结构"></a>SignalNode 结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_SignalNode</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* permanent portion */</span></span><br><span class="line">  guint              signal_id;</span><br><span class="line">  GType              itype;</span><br><span class="line">  <span class="type">const</span> gchar       *name;</span><br><span class="line">  guint              destroyed : <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* reinitializable portion */</span></span><br><span class="line">  guint              flags : <span class="number">9</span>;</span><br><span class="line">  guint              n_params : <span class="number">8</span>;</span><br><span class="line">  guint              single_va_closure_is_valid : <span class="number">1</span>;</span><br><span class="line">  guint              single_va_closure_is_after : <span class="number">1</span>;</span><br><span class="line">  GType       *param_types; <span class="comment">/* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span></span><br><span class="line">  GType        return_type; <span class="comment">/* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span></span><br><span class="line">  GBSearchArray     *class_closure_bsa;</span><br><span class="line">  SignalAccumulator *accumulator;</span><br><span class="line">  GSignalCMarshaller c_marshaller;</span><br><span class="line">  GSignalCVaMarshaller va_marshaller;</span><br><span class="line">  GHookList         *emission_hooks;</span><br><span class="line"></span><br><span class="line">  GClosure *single_va_closure;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="signal-id-lookup"><a href="#signal-id-lookup" class="headerlink" title="signal_id_lookup"></a>signal_id_lookup</h4><p>看看 signal_id_lookup 函数如何通过 itype 和 name 查找 signal_id</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> guint</span></span><br><span class="line"><span class="function"><span class="title">signal_id_lookup</span> <span class="params">(<span class="type">const</span> gchar *name,</span></span></span><br><span class="line"><span class="params"><span class="function">                  GType  itype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GQuark quark;</span><br><span class="line">  GType *ifaces, type = itype;</span><br><span class="line">  SignalKey key;</span><br><span class="line">  guint n_ifaces;</span><br><span class="line"></span><br><span class="line">  quark = <span class="built_in">g_quark_try_string</span> (name);</span><br><span class="line">  key.quark = quark;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在当前类及其父类中查找name</span></span><br><span class="line">  <span class="comment">/* try looking up signals for this type and its ancestors */</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      SignalKey *signal_key;</span><br><span class="line">      </span><br><span class="line">      key.itype = type;</span><br><span class="line">      signal_key = <span class="built_in">g_bsearch_array_lookup</span> (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (signal_key)</span><br><span class="line">  <span class="keyword">return</span> signal_key-&gt;signal_id;</span><br><span class="line">      </span><br><span class="line">      type = <span class="built_in">g_type_parent</span> (type);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* no luck, try interfaces it exports */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the @name is non-canonical, try again. This is the slow path — people</span></span><br><span class="line"><span class="comment">   * should use canonical names in their queries if they want performance. */</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">is_canonical</span> (name))</span><br><span class="line">    &#123;</span><br><span class="line">      guint signal_id;</span><br><span class="line">      gchar *name_copy = <span class="built_in">g_strdup</span> (name);</span><br><span class="line">      <span class="built_in">canonicalize_key</span> (name_copy);</span><br><span class="line"></span><br><span class="line">      signal_id = <span class="built_in">signal_id_lookup</span> (name_copy, itype);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">g_free</span> (name_copy);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> signal_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="signal-add-class-closure"><a href="#signal-add-class-closure" class="headerlink" title="signal_add_class_closure"></a>signal_add_class_closure</h4><p>再看看 class_closure 这个管理默认 handler 的 closure 如何和 signalnode 进行关联。从下面函数可以看到，是把 closure 插入到了 node-&gt;class_closure_bsa 中，class_closure_bsa 是一个二分查找数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">signal_add_class_closure</span> <span class="params">(SignalNode *node,</span></span></span><br><span class="line"><span class="params"><span class="function">        GType       itype,</span></span></span><br><span class="line"><span class="params"><span class="function">        GClosure   *closure)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ClassClosure key;</span><br><span class="line"></span><br><span class="line">  node-&gt;single_va_closure_is_valid = FALSE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!node-&gt;class_closure_bsa)</span><br><span class="line">    node-&gt;class_closure_bsa = <span class="built_in">g_bsearch_array_create</span> (&amp;g_class_closure_bconfig);</span><br><span class="line">  key.instance_type = itype;</span><br><span class="line">  key.closure = <span class="built_in">g_closure_ref</span> (closure);</span><br><span class="line">  node-&gt;class_closure_bsa = <span class="built_in">g_bsearch_array_insert</span> (node-&gt;class_closure_bsa,</span><br><span class="line">                &amp;g_class_closure_bconfig,</span><br><span class="line">                &amp;key);</span><br><span class="line">  <span class="built_in">g_closure_sink</span> (closure);</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;c_marshaller &amp;&amp; closure &amp;&amp; <span class="built_in">G_CLOSURE_NEEDS_MARSHAL</span> (closure))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_closure_set_marshal</span> (closure, node-&gt;c_marshaller);</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;va_marshaller)</span><br><span class="line">  _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>G_CLOSURE_NEEDS_MARSHAL 如下，之前创建 closure 时是没有设置他的 marshal 的，所以上面函数会走到 20 行中设置通过 g_closure_set_marshal 函数来设置 <code>closure-&gt;marshal</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> G_CLOSURE_NEEDS_MARSHAL(closure) (((GClosure*) (closure))-&gt;marshal == NULL)</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_closure_set_marshal</span> <span class="params">(GClosure       *closure,</span></span></span><br><span class="line"><span class="params"><span class="function">           GClosureMarshal marshal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closure-&gt;marshal &amp;&amp; closure-&gt;marshal != marshal)</span><br><span class="line">    <span class="built_in">g_warning</span> (<span class="string">&quot;attempt to override closure-&gt;marshal (%p) with new marshal (%p)&quot;</span>,</span><br><span class="line">         closure-&gt;marshal, marshal);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    closure-&gt;marshal = marshal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面_g_closure_set_va_marshal 中会设置 GRealClosure.va_marshal，因为创建 closure 时是设置的 meta_marshal 和 va_meta_marshal</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_g_closure_set_va_marshal (GClosure       *closure,</span><br><span class="line">         GVaClosureMarshal marshal)</span><br><span class="line">&#123;</span><br><span class="line">  GRealClosure *real_closure;</span><br><span class="line"></span><br><span class="line">  real_closure = <span class="built_in">G_REAL_CLOSURE</span> (closure);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (real_closure-&gt;va_marshal &amp;&amp; real_closure-&gt;va_marshal != marshal)</span><br><span class="line">    <span class="built_in">g_warning</span> (<span class="string">&quot;attempt to override closure-&gt;va_marshal (%p) with new marshal (%p)&quot;</span>,</span><br><span class="line">         real_closure-&gt;va_marshal, marshal);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    real_closure-&gt;va_marshal = marshal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，就看完了 g_signal_new 的过程，他创建了一个 signalnode 的对象，把所有信息都保存在这个对象中，只要能找到这个对象，那么如何执行回调函数就一清二楚了。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> gobject </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gobject之属性get/set</title>
      <link href="/2023/04/29/Gobject%E4%B9%8B%E5%B1%9E%E6%80%A7get-set/"/>
      <url>/2023/04/29/Gobject%E4%B9%8B%E5%B1%9E%E6%80%A7get-set/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍一下 Gobject 的另外一个特性：属性 get&#x2F;set。还是以之前的代码为研究对象，但是这次增加了属性相关的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glib-object.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TYPE_OBJ (my_obj_get_type())</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ(o)              (G_TYPE_CHECK_INSTANCE_CAST ((o), MY_TYPE_OBJ, MyObj))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_IS_OBJ(o)           (G_TYPE_CHECK_INSTANCE_TYPE ((o), MY_TYPE_OBJ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class), MY_TYPE_OBJ, MyObjClass))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_IS_OBJ_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class), MY_TYPE_OBJ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ_GET_CLASS(o)    (G_TYPE_INSTANCE_GET_CLASS ((o), MY_TYPE_OBJ, MyObjClass))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MyObj</span> MyObj;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MyObjClass</span> MyObjClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MyObj</span>&#123;</span><br><span class="line">    GObject obj;</span><br><span class="line">    gint i,j,k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MyObjClass</span>&#123;</span><br><span class="line">    GObjectClass <span class="keyword">class</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">GType <span class="title">my_obj_get_type</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>     <span class="title">my_obj_init</span>              <span class="params">(MyObj        *self)</span></span>; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>     <span class="title">my_obj_class_init</span>        <span class="params">(MyObjClass *klass)</span></span>; </span><br><span class="line"><span class="function"><span class="type">static</span> GType    <span class="title">my_obj_get_type_once</span>     <span class="params">(<span class="type">void</span>)</span></span>; </span><br><span class="line"><span class="type">static</span> gpointer my_obj_parent_class = <span class="literal">NULL</span>; </span><br><span class="line"><span class="type">static</span> gint     MyObj_private_offset; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>     <span class="title">my_obj_class_intern_init</span> <span class="params">(gpointer klass)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  my_obj_parent_class = <span class="built_in">g_type_class_peek_parent</span> (klass); </span><br><span class="line">  <span class="keyword">if</span> (MyObj_private_offset != <span class="number">0</span>) </span><br><span class="line">    <span class="built_in">g_type_class_adjust_private_offset</span> (klass, &amp;MyObj_private_offset); </span><br><span class="line">  <span class="built_in">my_obj_class_init</span> ((MyObjClass*) klass); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> gpointer </span></span><br><span class="line"><span class="function"><span class="title">my_obj_get_instance_private</span> <span class="params">(MyObj *self)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">G_STRUCT_MEMBER_P</span> (self, MyObj_private_offset)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">GType </span></span><br><span class="line"><span class="function"><span class="title">my_obj_get_type</span> <span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">static</span> gsize static_g_define_type_id = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Prelude goes here */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g_once_init_enter</span> (&amp;static_g_define_type_id)) </span><br><span class="line">    &#123; </span><br><span class="line">      GType g_define_type_id = <span class="built_in">my_obj_get_type_once</span> (); </span><br><span class="line">      <span class="built_in">g_once_init_leave</span> (&amp;static_g_define_type_id, g_define_type_id); </span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> static_g_define_type_id; </span><br><span class="line">&#125; <span class="comment">/* closes my_obj_get_type() */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> GType </span></span><br><span class="line"><span class="function"><span class="title">my_obj_get_type_once</span> <span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  GType g_define_type_id = </span><br><span class="line">        <span class="built_in">g_type_register_static_simple</span> (G_TYPE_OBJECT, </span><br><span class="line">                                       <span class="built_in">g_intern_static_string</span> (<span class="string">&quot;MyObj&quot;</span>), </span><br><span class="line">                                       <span class="built_in">sizeof</span> (MyObjClass), </span><br><span class="line">                                       (GClassInitFunc)(<span class="built_in">void</span> (*)(<span class="type">void</span>)) my_obj_class_intern_init, </span><br><span class="line">                                       <span class="built_in">sizeof</span> (MyObj), </span><br><span class="line">                                       (GInstanceInitFunc)(<span class="built_in">void</span> (*)(<span class="type">void</span>)) my_obj_init, </span><br><span class="line">                                       (GTypeFlags) <span class="number">0</span>); </span><br><span class="line">    &#123; <span class="comment">/* custom code follows */</span> </span><br><span class="line">    </span><br><span class="line">      <span class="comment">/* following custom code */</span> </span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> g_define_type_id; </span><br><span class="line">&#125; <span class="comment">/* closes my_obj_get_type_once() */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_obj_init</span><span class="params">(MyObj *self)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">  PROP_0,</span><br><span class="line">  PROP_WINDOW_SIZE,</span><br><span class="line">  PROP_WINDOW_THRESHOLD,</span><br><span class="line">  PROP_TIMEOUT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_WINDOW_SIZE             32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_WINDOW_THRESHOLD        4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_TIMEOUT                 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">my_obj_set_property</span> <span class="params">(GObject * object, guint prop_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> GValue * value, GParamSpec * pspec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  MyObj *obj;</span><br><span class="line"></span><br><span class="line">  obj =  (MyObj*)object;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (prop_id) &#123;</span><br><span class="line">    <span class="keyword">case</span> PROP_WINDOW_SIZE:</span><br><span class="line">      obj-&gt;i = <span class="built_in">g_value_get_int</span> (value);</span><br><span class="line">      <span class="built_in">g_print</span>(<span class="string">&quot;set PROP_WINDOW_SIZE\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PROP_WINDOW_THRESHOLD:</span><br><span class="line">      obj-&gt;j = <span class="built_in">g_value_get_int</span> (value);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PROP_TIMEOUT:</span><br><span class="line">      obj-&gt;k = <span class="built_in">g_value_get_int</span> (value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">G_OBJECT_WARN_INVALID_PROPERTY_ID</span> (object, prop_id, pspec);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">my_obj_get_property</span> <span class="params">(GObject * object, guint prop_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    GValue * value, GParamSpec * pspec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  MyObj *obj;</span><br><span class="line"></span><br><span class="line">  obj =  (MyObj*)object;</span><br><span class="line">  <span class="keyword">switch</span> (prop_id) &#123;</span><br><span class="line">    <span class="keyword">case</span> PROP_WINDOW_SIZE:</span><br><span class="line">      <span class="built_in">g_value_set_int</span> (value, obj-&gt;i);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PROP_WINDOW_THRESHOLD:</span><br><span class="line">      <span class="built_in">g_value_set_int</span> (value, obj-&gt;j);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PROP_TIMEOUT:</span><br><span class="line">      <span class="built_in">g_value_set_int</span> (value, obj-&gt;k);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">G_OBJECT_WARN_INVALID_PROPERTY_ID</span> (object, prop_id, pspec);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_obj_class_init</span><span class="params">(MyObjClass *klass)</span> </span>&#123;</span><br><span class="line">  GObjectClass *gobject_class = <span class="built_in">G_OBJECT_CLASS</span> (klass);</span><br><span class="line"></span><br><span class="line">  gobject_class-&gt;set_property = my_obj_set_property;</span><br><span class="line">  gobject_class-&gt;get_property = my_obj_get_property;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_object_class_install_property</span> (gobject_class, PROP_WINDOW_SIZE,</span><br><span class="line">      <span class="built_in">g_param_spec_int</span> (<span class="string">&quot;window-size&quot;</span>, <span class="string">&quot;Window size&quot;</span>,</span><br><span class="line">          <span class="string">&quot;The size of the window used to calculate rate and offset&quot;</span>, <span class="number">2</span>, <span class="number">1024</span>,</span><br><span class="line">          DEFAULT_WINDOW_SIZE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));</span><br><span class="line">  <span class="built_in">g_object_class_install_property</span> (gobject_class, PROP_WINDOW_THRESHOLD,</span><br><span class="line">      <span class="built_in">g_param_spec_int</span> (<span class="string">&quot;window-threshold&quot;</span>, <span class="string">&quot;Window threshold&quot;</span>,</span><br><span class="line">          <span class="string">&quot;The threshold to start calculating rate and offset&quot;</span>, <span class="number">2</span>, <span class="number">1024</span>,</span><br><span class="line">          DEFAULT_WINDOW_THRESHOLD,</span><br><span class="line">          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));</span><br><span class="line">  <span class="built_in">g_object_class_install_property</span> (gobject_class, PROP_TIMEOUT,</span><br><span class="line">      <span class="built_in">g_param_spec_int</span> (<span class="string">&quot;timeout&quot;</span>, <span class="string">&quot;Timeout&quot;</span>,</span><br><span class="line">          <span class="string">&quot;The amount of time, in nanoseconds, to sample master and slave clocks&quot;</span>,</span><br><span class="line">          <span class="number">0</span>, <span class="number">1024</span>, DEFAULT_TIMEOUT,</span><br><span class="line">          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">void</span> * f = <span class="built_in">g_object_new</span>(MY_TYPE_OBJ,  <span class="string">&quot;window-size&quot;</span>, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line">    gint val = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">g_object_get</span>(f, <span class="string">&quot;window-size&quot;</span>, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">g_print</span>(<span class="string">&quot;value of val is %d\n&quot;</span>, val);</span><br><span class="line">    <span class="built_in">g_print</span>(<span class="string">&quot;first program\n&quot;</span>);</span><br><span class="line">    <span class="built_in">g_object_unref</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想让自己的 Gobject 类支持属性设置，只需要在 class_init 中重载父类的 set_property、get_property 函数指针，然后把属性安装到相应的类上。接下来就以上面的代码为例，看看属性安装、属性 get、属性 set 中到底发生了什么。</p><p>首先看 my_obj_class_init 函数，当其重载父类 GObject 的 get、set 函数时，是把自己的类结构 struct 实例中 GObjectClass 的那一部分取出来，而不是去改变 GObject 类的 GObjectClass 实例，这里不要弄错了。</p><h1 id="g-object-class-install-property"><a href="#g-object-class-install-property" class="headerlink" title="g_object_class_install_property"></a>g_object_class_install_property</h1><p>从注释中可以发现，所有属性都建议通过这个函数进行安装，此外允许子类通过定义同名的属性覆盖父类的属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * g_object_class_install_property:</span></span><br><span class="line"><span class="comment"> * @oclass: a #GObjectClass</span></span><br><span class="line"><span class="comment"> * @property_id: the id for the new property</span></span><br><span class="line"><span class="comment"> * @pspec: the #GParamSpec for the new property</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Installs a new property.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All properties should be installed during the class initializer.  It</span></span><br><span class="line"><span class="comment"> * is possible to install properties after that, but doing so is not</span></span><br><span class="line"><span class="comment"> * recommend, and specifically, is not guaranteed to be thread-safe vs.</span></span><br><span class="line"><span class="comment"> * use of properties on the same type on other threads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that it is possible to redefine a property in a derived class,</span></span><br><span class="line"><span class="comment"> * by installing a property with the same name. This can be useful at times,</span></span><br><span class="line"><span class="comment"> * e.g. to change the range of allowed values or the default value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_object_class_install_property</span> <span class="params">(GObjectClass *<span class="keyword">class</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">         guint         property_id,</span></span></span><br><span class="line"><span class="params"><span class="function">         GParamSpec   *pspec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GType oclass_type, parent_type;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (<span class="built_in">G_IS_OBJECT_CLASS</span> (<span class="keyword">class</span>));</span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (property_id &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得要安装属性的类的真正的GType</span></span><br><span class="line">  oclass_type = <span class="built_in">G_OBJECT_CLASS_TYPE</span> (<span class="keyword">class</span>);</span><br><span class="line">  parent_type = <span class="built_in">g_type_parent</span> (oclass_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CLASS_HAS_DERIVED_CLASS</span> (<span class="keyword">class</span>))</span><br><span class="line">    <span class="built_in">g_error</span> (<span class="string">&quot;Attempt to add property %s::%s to class after it was derived&quot;</span>, <span class="built_in">G_OBJECT_CLASS_NAME</span> (<span class="keyword">class</span>), pspec-&gt;name);</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>) <span class="built_in">validate_and_install_class_property</span> (<span class="keyword">class</span>,</span><br><span class="line">                                              oclass_type,</span><br><span class="line">                                              parent_type,</span><br><span class="line">                                              property_id,</span><br><span class="line">                                              pspec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_OBJECT_CLASS_TYPE(class)  (G_TYPE_FROM_CLASS (class))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_TYPE_FROM_CLASS(g_class)  (((GTypeClass*) (g_class))-&gt;g_type)</span></span><br></pre></td></tr></table></figure><h2 id="validate-and-install-class-property"><a href="#validate-and-install-class-property" class="headerlink" title="validate_and_install_class_property"></a>validate_and_install_class_property</h2><p>g_object_class_install_property 内部调用 validate_and_install_class_property。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> gboolean</span></span><br><span class="line"><span class="function"><span class="title">validate_and_install_class_property</span> <span class="params">(GObjectClass *<span class="keyword">class</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     GType         oclass_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     GType         parent_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     guint         property_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     GParamSpec   *pspec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">validate_pspec_to_install</span> (pspec))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_param_spec_ref_sink</span> (pspec);</span><br><span class="line">      <span class="built_in">g_param_spec_unref</span> (pspec);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pspec-&gt;flags &amp; G_PARAM_WRITABLE)</span><br><span class="line">    <span class="built_in">g_return_val_if_fail</span> (<span class="keyword">class</span>-&gt;set_property != <span class="literal">NULL</span>, FALSE);</span><br><span class="line">  <span class="keyword">if</span> (pspec-&gt;flags &amp; G_PARAM_READABLE)</span><br><span class="line">    <span class="built_in">g_return_val_if_fail</span> (<span class="keyword">class</span>-&gt;get_property != <span class="literal">NULL</span>, FALSE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span>-&gt;flags |= CLASS_HAS_PROPS_FLAG;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">install_property_internal</span> (oclass_type, property_id, pspec))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 如果pspec上定义了CONSTRUCT属性，将其添加到class-&gt;construct_properties</span></span><br><span class="line">          <span class="keyword">class</span>-&gt;construct_properties = <span class="built_in">g_slist_append</span> (<span class="keyword">class</span>-&gt;construct_properties, pspec);</span><br><span class="line">          <span class="keyword">class</span>-&gt;n_construct_properties += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* for property overrides of construct properties, we have to get rid</span></span><br><span class="line"><span class="comment">       * of the overridden inherited construct property</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">     <span class="comment">/* 对于父类被覆盖的带CONSTRUCT属性的pspec，需要把他从construct_properties中移除</span></span><br><span class="line"><span class="comment">        不然construct_properties中就有两个同名的属性了</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      pspec = <span class="built_in">g_param_spec_pool_lookup</span> (pspec_pool, pspec-&gt;name, parent_type, TRUE);</span><br><span class="line">      <span class="keyword">if</span> (pspec &amp;&amp; pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">class</span>-&gt;construct_properties = <span class="built_in">g_slist_remove</span> (<span class="keyword">class</span>-&gt;construct_properties, pspec);</span><br><span class="line">          <span class="keyword">class</span>-&gt;n_construct_properties -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="validate-pspec-to-install"><a href="#validate-pspec-to-install" class="headerlink" title="validate_pspec_to_install"></a>validate_pspec_to_install</h3><p>先通过 validate_pspec_to_install 检查输入的 GParamSpec。</p><p>其实没做啥事。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> gboolean</span></span><br><span class="line"><span class="function"><span class="title">validate_pspec_to_install</span> <span class="params">(GParamSpec *pspec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (<span class="built_in">G_IS_PARAM_SPEC</span> (pspec), FALSE);</span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (<span class="built_in">PARAM_SPEC_PARAM_ID</span> (pspec) == <span class="number">0</span>, FALSE); <span class="comment">/* paranoid */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (pspec-&gt;flags &amp; (G_PARAM_READABLE | G_PARAM_WRITABLE), FALSE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pspec-&gt;flags &amp; G_PARAM_CONSTRUCT)</span><br><span class="line">    <span class="built_in">g_return_val_if_fail</span> ((pspec-&gt;flags &amp; G_PARAM_CONSTRUCT_ONLY) == <span class="number">0</span>, FALSE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY))</span><br><span class="line">    <span class="built_in">g_return_val_if_fail</span> (pspec-&gt;flags &amp; G_PARAM_WRITABLE, FALSE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="install-property-internal"><a href="#install-property-internal" class="headerlink" title="install_property_internal"></a>install_property_internal</h3><p>然后通过 install_property_internal 安装属性，属性是安装在全局静态的 pspec_pool 中，一个 g_type 不能有同名的属性，但是不同的 g_type 可以有同名属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sinks @pspec if it’s a floating ref. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> gboolean</span></span><br><span class="line"><span class="function"><span class="title">install_property_internal</span> <span class="params">(GType       g_type,</span></span></span><br><span class="line"><span class="params"><span class="function">         guint       property_id,</span></span></span><br><span class="line"><span class="params"><span class="function">         GParamSpec *pspec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">g_param_spec_ref_sink</span> (pspec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g_param_spec_pool_lookup</span> (pspec_pool, pspec-&gt;name, g_type, FALSE))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (<span class="string">&quot;When installing property: type &#x27;%s&#x27; already has a property named &#x27;%s&#x27;&quot;</span>, <span class="built_in">g_type_name</span> (g_type), pspec-&gt;name);</span><br><span class="line">      <span class="built_in">g_param_spec_unref</span> (pspec);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">PARAM_SPEC_SET_PARAM_ID</span> (pspec, property_id);</span><br><span class="line">  <span class="built_in">g_param_spec_pool_insert</span> (pspec_pool, <span class="built_in">g_steal_pointer</span> (&amp;pspec), g_type);</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> GParamSpecPool      *pspec_pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_object_do_class_init</span> <span class="params">(GObjectClass *<span class="keyword">class</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">  pspec_pool = <span class="built_in">g_param_spec_pool_new</span> (TRUE);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="g-param-spec-pool-lookup"><a href="#g-param-spec-pool-lookup" class="headerlink" title="g_param_spec_pool_lookup"></a>g_param_spec_pool_lookup</h4><p>从 pool 中查找 owner_type 上的名为 param_name 的属性，可以选择是否从父类中查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GParamSpec*</span></span><br><span class="line"><span class="function"><span class="title">g_param_spec_pool_lookup</span> <span class="params">(GParamSpecPool *pool,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> gchar    *param_name,</span></span></span><br><span class="line"><span class="params"><span class="function">        GType           owner_type,</span></span></span><br><span class="line"><span class="params"><span class="function">        gboolean        walk_ancestors)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GParamSpec *pspec;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (pool != <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (param_name != <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_mutex_lock</span> (&amp;pool-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* try quick and away, i.e. without prefix */</span></span><br><span class="line">  pspec = <span class="built_in">param_spec_ht_lookup</span> (pool-&gt;hash_table, param_name, owner_type, walk_ancestors);</span><br><span class="line">  <span class="keyword">if</span> (pspec)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_mutex_unlock</span> (&amp;pool-&gt;mutex);</span><br><span class="line">      <span class="keyword">return</span> pspec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pool-&gt;type_prefixing)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *delim;</span><br><span class="line"></span><br><span class="line">      delim = <span class="built_in">strchr</span> (param_name, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* strip type prefix */</span></span><br><span class="line">      <span class="keyword">if</span> (delim &amp;&amp; delim[<span class="number">1</span>] == <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          guint l = delim - param_name;</span><br><span class="line">          gchar stack_buffer[<span class="number">32</span>], *buffer = l &lt; <span class="number">32</span> ? stack_buffer : <span class="built_in">g_new</span> (gchar, l + <span class="number">1</span>);</span><br><span class="line">          GType type;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">strncpy</span> (buffer, param_name, delim - param_name);</span><br><span class="line">          buffer[l] = <span class="number">0</span>;</span><br><span class="line">          type = <span class="built_in">g_type_from_name</span> (buffer);</span><br><span class="line">          <span class="keyword">if</span> (l &gt;= <span class="number">32</span>)</span><br><span class="line">            <span class="built_in">g_free</span> (buffer);</span><br><span class="line">          <span class="keyword">if</span> (type)         <span class="comment">/* type==0 isn&#x27;t a valid type pefix */</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* sanity check, these cases don&#x27;t make a whole lot of sense */</span></span><br><span class="line">              <span class="keyword">if</span> ((!walk_ancestors &amp;&amp; type != owner_type) || !<span class="built_in">g_type_is_a</span> (owner_type, type))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="built_in">g_mutex_unlock</span> (&amp;pool-&gt;mutex);</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              owner_type = type;</span><br><span class="line">              param_name += l + <span class="number">2</span>;</span><br><span class="line">              pspec = <span class="built_in">param_spec_ht_lookup</span> (pool-&gt;hash_table, param_name, owner_type, walk_ancestors);</span><br><span class="line">              <span class="built_in">g_mutex_unlock</span> (&amp;pool-&gt;mutex);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> pspec;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* malformed param_name */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_mutex_unlock</span> (&amp;pool-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="g-param-spec-pool-insert"><a href="#g-param-spec-pool-insert" class="headerlink" title="g_param_spec_pool_insert"></a>g_param_spec_pool_insert</h4><p>向 pool 中插入 pspec</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_param_spec_pool_insert</span> <span class="params">(GParamSpecPool *pool,</span></span></span><br><span class="line"><span class="params"><span class="function">        GParamSpec     *pspec,</span></span></span><br><span class="line"><span class="params"><span class="function">        GType           owner_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> gchar *p;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (pool &amp;&amp; pspec &amp;&amp; owner_type &gt; <span class="number">0</span> &amp;&amp; pspec-&gt;owner_type == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (p = pspec-&gt;name; *p; p++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strchr</span> (G_CSET_A_2_Z G_CSET_a_2_z G_CSET_DIGITS <span class="string">&quot;-_&quot;</span>, *p))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">g_warning</span> (G_STRLOC <span class="string">&quot;: pspec name \&quot;%s\&quot; contains invalid characters&quot;</span>, pspec-&gt;name);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="built_in">g_mutex_lock</span> (&amp;pool-&gt;mutex);</span><br><span class="line">      pspec-&gt;owner_type = owner_type;</span><br><span class="line">      <span class="built_in">g_param_spec_ref</span> (pspec);</span><br><span class="line">      <span class="built_in">g_hash_table_add</span> (pool-&gt;hash_table, pspec);</span><br><span class="line">      <span class="built_in">g_mutex_unlock</span> (&amp;pool-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_return_if_fail</span> (pool != <span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">g_return_if_fail</span> (pspec);</span><br><span class="line">      <span class="built_in">g_return_if_fail</span> (owner_type &gt; <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">g_return_if_fail</span> (pspec-&gt;owner_type == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="g-object-get-property"><a href="#g-object-get-property" class="headerlink" title="g_object_get_property"></a>g_object_get_property</h1><p>从上面的分析中发现，属性安装其实就是把属性描述符安装到一个全局的 hash 表中。接下来看看属性的 get</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_object_get_property</span> <span class="params">(GObject     *object,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> gchar *property_name,</span></span></span><br><span class="line"><span class="params"><span class="function">           GValue    *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GParamSpec *pspec;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (<span class="built_in">G_IS_OBJECT</span> (object));</span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (property_name != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (value != <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_object_ref</span> (object);</span><br><span class="line">  </span><br><span class="line">  pspec = <span class="built_in">find_pspec</span> (<span class="built_in">G_OBJECT_GET_CLASS</span> (object), property_name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g_object_get_is_valid_property</span> (object, pspec, property_name))</span><br><span class="line">    &#123;</span><br><span class="line">      GValue *prop_value, tmp_value = G_VALUE_INIT;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">G_VALUE_TYPE</span> (value) == G_TYPE_INVALID)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* zero-initialized value */</span></span><br><span class="line">          <span class="built_in">g_value_init</span> (value, pspec-&gt;value_type);</span><br><span class="line">          prop_value = value;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">G_VALUE_TYPE</span> (value) == pspec-&gt;value_type)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* auto-conversion of the callers value type */</span></span><br><span class="line">          <span class="built_in">g_value_reset</span> (value);</span><br><span class="line">          prop_value = value;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">g_value_type_transformable</span> (pspec-&gt;value_type, <span class="built_in">G_VALUE_TYPE</span> (value)))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">g_warning</span> (<span class="string">&quot;%s: can&#x27;t retrieve property &#x27;%s&#x27; of type &#x27;%s&#x27; as value of type &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                     G_STRFUNC, pspec-&gt;name,</span><br><span class="line">                     <span class="built_in">g_type_name</span> (pspec-&gt;value_type),</span><br><span class="line">                     <span class="built_in">G_VALUE_TYPE_NAME</span> (value));</span><br><span class="line">          <span class="built_in">g_object_unref</span> (object);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">g_value_init</span> (&amp;tmp_value, pspec-&gt;value_type);</span><br><span class="line">          prop_value = &amp;tmp_value;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">object_get_property</span> (object, pspec, prop_value);</span><br><span class="line">      <span class="keyword">if</span> (prop_value != value)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">g_value_transform</span> (prop_value, value);</span><br><span class="line">          <span class="built_in">g_value_unset</span> (&amp;tmp_value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_object_unref</span> (object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find-pspec"><a href="#find-pspec" class="headerlink" title="find_pspec"></a>find_pspec</h2><p>在对象所属的类型上查找给定名字的属性，先尝试在 GObjectClass.pspecs 数组中查找，找不到，再去全局表中查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> GParamSpec *</span></span><br><span class="line"><span class="function"><span class="title">find_pspec</span> <span class="params">(GObjectClass *<span class="keyword">class</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> <span class="type">char</span>   *property_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> PspecEntry *pspecs = (<span class="type">const</span> PspecEntry *)<span class="keyword">class</span>-&gt;pspecs;</span><br><span class="line">  gsize n_pspecs = <span class="keyword">class</span>-&gt;n_pspecs;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_assert</span> (n_pspecs &lt;= G_MAXSSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The limit for choosing between linear and binary search is</span></span><br><span class="line"><span class="comment">   * fairly arbitrary.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Both searches use pointer comparisons against @property_name.</span></span><br><span class="line"><span class="comment">   * If this function is called with a non-static @property_name,</span></span><br><span class="line"><span class="comment">   * it will fall through to the g_param_spec_pool_lookup() case.</span></span><br><span class="line"><span class="comment">   * That’s OK; this is an opportunistic optimisation which relies</span></span><br><span class="line"><span class="comment">   * on the fact that *most* (but not all) property lookups use</span></span><br><span class="line"><span class="comment">   * static property names.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (n_pspecs &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (gsize i = <span class="number">0</span>; i &lt; n_pspecs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (pspecs[i].name == property_name)</span><br><span class="line">            <span class="keyword">return</span> pspecs[i].pspec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      gssize lower = <span class="number">0</span>;</span><br><span class="line">      gssize upper = (<span class="type">int</span>)<span class="keyword">class</span>-&gt;n_pspecs - <span class="number">1</span>;</span><br><span class="line">      gssize mid;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (lower &lt;= upper)</span><br><span class="line">        &#123;</span><br><span class="line">          mid = (lower + upper) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (property_name &lt; pspecs[mid].name)</span><br><span class="line">            upper = mid - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (property_name &gt; pspecs[mid].name)</span><br><span class="line">            lower = mid + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> pspecs[mid].pspec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">g_param_spec_pool_lookup</span> (pspec_pool,</span><br><span class="line">                                   property_name,</span><br><span class="line">                                   ((GTypeClass *)<span class="keyword">class</span>)-&gt;g_type,</span><br><span class="line">                                   TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="object-get-property"><a href="#object-get-property" class="headerlink" title="object_get_property"></a>object_get_property</h2><p>获得属性之后要调用该属性所属的类的 get_property 函数，因为这个属性有可能继承自父类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">object_get_property</span> <span class="params">(GObject     *object,</span></span></span><br><span class="line"><span class="params"><span class="function">         GParamSpec  *pspec,</span></span></span><br><span class="line"><span class="params"><span class="function">         GValue      *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GTypeInstance *inst = (GTypeInstance *) object;</span><br><span class="line">  GObjectClass *<span class="keyword">class</span>;</span><br><span class="line">  guint param_id = <span class="built_in">PARAM_SPEC_PARAM_ID</span> (pspec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">G_LIKELY</span> (inst-&gt;g_class-&gt;g_type == pspec-&gt;owner_type))</span><br><span class="line">    <span class="keyword">class</span> = (GObjectClass *) inst-&gt;g_class;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">class</span> = <span class="built_in">g_type_class_peek</span> (pspec-&gt;owner_type);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_assert</span> (<span class="keyword">class</span> != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">param_spec_follow_override</span> (&amp;pspec);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">consider_issuing_property_deprecation_warning</span> (pspec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span>-&gt;<span class="built_in">get_property</span> (object, param_id, value, pspec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="g-object-set-property"><a href="#g-object-set-property" class="headerlink" title="g_object_set_property"></a>g_object_set_property</h1><p>再看看 g_object_set_property，其实和 get 差不多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_object_set_property</span> <span class="params">(GObject      *object,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> gchar  *property_name,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> GValue *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">g_object_setv</span> (object, <span class="number">1</span>, &amp;property_name, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_object_setv</span> <span class="params">(GObject       *object,</span></span></span><br><span class="line"><span class="params"><span class="function">               guint          n_properties,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> gchar   *names[],</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> GValue   values[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  guint i;</span><br><span class="line">  GObjectNotifyQueue *nqueue = <span class="literal">NULL</span>;</span><br><span class="line">  GParamSpec *pspec;</span><br><span class="line">  GObjectClass *<span class="keyword">class</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (<span class="built_in">G_IS_OBJECT</span> (object));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n_properties == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_object_ref</span> (object);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> = <span class="built_in">G_OBJECT_GET_CLASS</span> (object);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_g_object_has_notify_handler (object))</span><br><span class="line">    nqueue = <span class="built_in">g_object_notify_queue_freeze</span> (object, FALSE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n_properties; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      pspec = <span class="built_in">find_pspec</span> (<span class="keyword">class</span>, names[i]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">g_object_set_is_valid_property</span> (object, pspec, names[i]))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">object_set_property</span> (object, pspec, &amp;values[i], nqueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nqueue)</span><br><span class="line">    <span class="built_in">g_object_notify_queue_thaw</span> (object, nqueue);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_object_unref</span> (object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用 find_pspec 通过属性名查找属性描述符，然后调用 object_set_property 设置属性</p><h2 id="object-set-property"><a href="#object-set-property" class="headerlink" title="object_set_property"></a>object_set_property</h2><p>object_set_property 也要调用属性所属类的 set_property 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">object_set_property</span> <span class="params">(GObject             *object,</span></span></span><br><span class="line"><span class="params"><span class="function">         GParamSpec          *pspec,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">const</span> GValue        *value,</span></span></span><br><span class="line"><span class="params"><span class="function">         GObjectNotifyQueue  *nqueue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GTypeInstance *inst = (GTypeInstance *) object;</span><br><span class="line">  GObjectClass *<span class="keyword">class</span>;</span><br><span class="line">  GParamSpecClass *pclass;</span><br><span class="line">  guint param_id = <span class="built_in">PARAM_SPEC_PARAM_ID</span> (pspec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">G_LIKELY</span> (inst-&gt;g_class-&gt;g_type == pspec-&gt;owner_type))</span><br><span class="line">    <span class="keyword">class</span> = (GObjectClass *) inst-&gt;g_class;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">class</span> = <span class="built_in">g_type_class_peek</span> (pspec-&gt;owner_type);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_assert</span> (<span class="keyword">class</span> != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">param_spec_follow_override</span> (&amp;pspec);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">consider_issuing_property_deprecation_warning</span> (pspec);</span><br><span class="line"></span><br><span class="line">  pclass = <span class="built_in">G_PARAM_SPEC_GET_CLASS</span> (pspec);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g_value_type_compatible</span> (<span class="built_in">G_VALUE_TYPE</span> (value), pspec-&gt;value_type) &amp;&amp;</span><br><span class="line">      (pclass-&gt;value_validate == <span class="literal">NULL</span> ||</span><br><span class="line">       (pclass-&gt;value_is_valid != <span class="literal">NULL</span> &amp;&amp; pclass-&gt;<span class="built_in">value_is_valid</span> (pspec, value))))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">class</span>-&gt;<span class="built_in">set_property</span> (object, param_id, value, pspec);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* provide a copy to work from, convert (if necessary) and validate */</span></span><br><span class="line">      GValue tmp_value = G_VALUE_INIT;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">g_value_init</span> (&amp;tmp_value, pspec-&gt;value_type);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">g_value_transform</span> (value, &amp;tmp_value))</span><br><span class="line">        <span class="built_in">g_warning</span> (<span class="string">&quot;unable to set property &#x27;%s&#x27; of type &#x27;%s&#x27; from value of type &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                   pspec-&gt;name,</span><br><span class="line">                   <span class="built_in">g_type_name</span> (pspec-&gt;value_type),</span><br><span class="line">                   <span class="built_in">G_VALUE_TYPE_NAME</span> (value));</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">g_param_value_validate</span> (pspec, &amp;tmp_value) &amp;&amp; !(pspec-&gt;flags &amp; G_PARAM_LAX_VALIDATION))</span><br><span class="line">        &#123;</span><br><span class="line">          gchar *contents = <span class="built_in">g_strdup_value_contents</span> (value);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">g_warning</span> (<span class="string">&quot;value \&quot;%s\&quot; of type &#x27;%s&#x27; is invalid or out of range for property &#x27;%s&#x27; of type &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                     contents,</span><br><span class="line">                     <span class="built_in">G_VALUE_TYPE_NAME</span> (value),</span><br><span class="line">                     pspec-&gt;name,</span><br><span class="line">                     <span class="built_in">g_type_name</span> (pspec-&gt;value_type));</span><br><span class="line">          <span class="built_in">g_free</span> (contents);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">class</span>-&gt;<span class="built_in">set_property</span> (object, param_id, &amp;tmp_value, pspec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">g_value_unset</span> (&amp;tmp_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((pspec-&gt;flags &amp; (G_PARAM_EXPLICIT_NOTIFY | G_PARAM_READABLE)) == G_PARAM_READABLE &amp;&amp;</span><br><span class="line">      nqueue != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">g_object_notify_queue_add</span> (object, nqueue, pspec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="g-object-set"><a href="#g-object-set" class="headerlink" title="g_object_set"></a>g_object_set</h1><p>再 g_object_set，有了上面的基础其实也很容易理解了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_object_set</span> <span class="params">(gpointer     _object,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> gchar *first_property_name,</span></span></span><br><span class="line"><span class="params"><span class="function">        ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObject *object = _object;</span><br><span class="line">  va_list var_args;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (<span class="built_in">G_IS_OBJECT</span> (object));</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">va_start</span> (var_args, first_property_name);</span><br><span class="line">  <span class="built_in">g_object_set_valist</span> (object, first_property_name, var_args);</span><br><span class="line">  <span class="built_in">va_end</span> (var_args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="g-object-set-valist"><a href="#g-object-set-valist" class="headerlink" title="g_object_set_valist"></a>g_object_set_valist</h2><p>g_object_set 内部调用了变长参数版本 g_object_set_valist。g_object_set_valist 里面也是 find_pspec 和 object_set_property</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_object_set_valist</span> <span class="params">(GObject   *object,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">const</span> gchar *first_property_name,</span></span></span><br><span class="line"><span class="params"><span class="function">         va_list    var_args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObjectNotifyQueue *nqueue = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">const</span> gchar *name;</span><br><span class="line">  GObjectClass *<span class="keyword">class</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (<span class="built_in">G_IS_OBJECT</span> (object));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_object_ref</span> (object);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_g_object_has_notify_handler (object))</span><br><span class="line">    nqueue = <span class="built_in">g_object_notify_queue_freeze</span> (object, FALSE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> = <span class="built_in">G_OBJECT_GET_CLASS</span> (object);</span><br><span class="line"></span><br><span class="line">  name = first_property_name;</span><br><span class="line">  <span class="keyword">while</span> (name)</span><br><span class="line">    &#123;</span><br><span class="line">      GValue value = G_VALUE_INIT;</span><br><span class="line">      GParamSpec *pspec;</span><br><span class="line">      gchar *error = <span class="literal">NULL</span>;</span><br><span class="line">      GTypeValueTable *vtab;</span><br><span class="line">      </span><br><span class="line">      pspec = <span class="built_in">find_pspec</span> (<span class="keyword">class</span>, name);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">g_object_set_is_valid_property</span> (object, pspec, name))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">G_VALUE_COLLECT_INIT2</span> (&amp;value, vtab, pspec-&gt;value_type, var_args, G_VALUE_NOCOPY_CONTENTS, &amp;error);</span><br><span class="line">      <span class="keyword">if</span> (error)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">g_warning</span> (<span class="string">&quot;%s: %s&quot;</span>, G_STRFUNC, error);</span><br><span class="line">    <span class="built_in">g_free</span> (error);</span><br><span class="line">          <span class="built_in">g_value_unset</span> (&amp;value);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">object_set_property</span> (object, pspec, &amp;value, nqueue);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We open-code g_value_unset() here to avoid the</span></span><br><span class="line"><span class="comment">       * cost of looking up the GTypeValueTable again.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (vtab-&gt;value_free)</span><br><span class="line">        vtab-&gt;<span class="built_in">value_free</span> (&amp;value);</span><br><span class="line"></span><br><span class="line">      name = <span class="built_in">va_arg</span> (var_args, gchar*);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nqueue)</span><br><span class="line">    <span class="built_in">g_object_notify_queue_thaw</span> (object, nqueue);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_object_unref</span> (object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="g-object-new"><a href="#g-object-new" class="headerlink" title="g_object_new"></a>g_object_new</h1><p>最后再来考察一下 g_object_new 中和属性有关的部分，这次看 g_object_new_valist 分支</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gpointer</span></span><br><span class="line"><span class="function"><span class="title">g_object_new</span> <span class="params">(GType    object_type,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> gchar *first_property_name,</span></span></span><br><span class="line"><span class="params"><span class="function">        ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObject *object;</span><br><span class="line">  va_list var_args;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* short circuit for calls supplying no properties */</span></span><br><span class="line">  <span class="keyword">if</span> (!first_property_name)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g_object_new_with_properties</span> (object_type, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">va_start</span> (var_args, first_property_name);</span><br><span class="line">  object = <span class="built_in">g_object_new_valist</span> (object_type, first_property_name, var_args);</span><br><span class="line">  <span class="built_in">va_end</span> (var_args);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="g-object-new-valist"><a href="#g-object-new-valist" class="headerlink" title="g_object_new_valist"></a>g_object_new_valist</h2><p>这个函数把变长参数组织成 GObjectConstructParam 数组的形式，然后调用 g_object_new_internal</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GObject*</span></span><br><span class="line"><span class="function"><span class="title">g_object_new_valist</span> <span class="params">(GType        object_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> gchar *first_property_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                     va_list      var_args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObjectClass *<span class="keyword">class</span>, *unref_class = <span class="literal">NULL</span>;</span><br><span class="line">  GObject *object;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (<span class="built_in">G_TYPE_IS_OBJECT</span> (object_type), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to avoid thrashing the ref_count if we don&#x27;t need to (since</span></span><br><span class="line"><span class="comment">   * it&#x27;s a locked operation).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">class</span> = <span class="built_in">g_type_class_peek_static</span> (object_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">class</span>)</span><br><span class="line">    <span class="keyword">class</span> = unref_class = <span class="built_in">g_type_class_ref</span> (object_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first_property_name)</span><br><span class="line">    &#123;</span><br><span class="line">      GObjectConstructParam params_stack[<span class="number">16</span>];</span><br><span class="line">      GValue values_stack[<span class="built_in">G_N_ELEMENTS</span> (params_stack)];</span><br><span class="line">      GTypeValueTable *vtabs_stack[<span class="built_in">G_N_ELEMENTS</span> (params_stack)];</span><br><span class="line">      <span class="type">const</span> gchar *name;</span><br><span class="line">      GObjectConstructParam *params = params_stack;</span><br><span class="line">      GValue *values = values_stack;</span><br><span class="line">      GTypeValueTable **vtabs = vtabs_stack;</span><br><span class="line">      guint n_params = <span class="number">0</span>;</span><br><span class="line">      guint n_params_alloc = <span class="built_in">G_N_ELEMENTS</span> (params_stack);</span><br><span class="line"></span><br><span class="line">      name = first_property_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把变长参数组织成GObjectConstructParam数组</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          gchar *error = <span class="literal">NULL</span>;</span><br><span class="line">          GParamSpec *pspec = <span class="built_in">find_pspec</span> (<span class="keyword">class</span>, name);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">g_object_new_is_valid_property</span> (object_type, pspec, name, params, n_params))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">G_UNLIKELY</span> (n_params == n_params_alloc))</span><br><span class="line">            &#123;</span><br><span class="line">              guint i;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (n_params_alloc == <span class="built_in">G_N_ELEMENTS</span> (params_stack))</span><br><span class="line">                &#123;</span><br><span class="line">                  n_params_alloc = <span class="built_in">G_N_ELEMENTS</span> (params_stack) * <span class="number">2u</span>;</span><br><span class="line">                  params = <span class="built_in">g_new</span> (GObjectConstructParam, n_params_alloc);</span><br><span class="line">                  values = <span class="built_in">g_new</span> (GValue, n_params_alloc);</span><br><span class="line">                  vtabs = <span class="built_in">g_new</span> (GTypeValueTable *, n_params_alloc);</span><br><span class="line">                  <span class="built_in">memcpy</span> (params, params_stack, <span class="built_in">sizeof</span> (GObjectConstructParam) * n_params);</span><br><span class="line">                  <span class="built_in">memcpy</span> (values, values_stack, <span class="built_in">sizeof</span> (GValue) * n_params);</span><br><span class="line">                  <span class="built_in">memcpy</span> (vtabs, vtabs_stack, <span class="built_in">sizeof</span> (GTypeValueTable *) * n_params);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  n_params_alloc *= <span class="number">2u</span>;</span><br><span class="line">                  params = <span class="built_in">g_realloc</span> (params, <span class="built_in">sizeof</span> (GObjectConstructParam) * n_params_alloc);</span><br><span class="line">                  values = <span class="built_in">g_realloc</span> (values, <span class="built_in">sizeof</span> (GValue) * n_params_alloc);</span><br><span class="line">                  vtabs = <span class="built_in">g_realloc</span> (vtabs, <span class="built_in">sizeof</span> (GTypeValueTable *) * n_params_alloc);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n_params; i++)</span><br><span class="line">                params[i].value = &amp;values[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          params[n_params].pspec = pspec;</span><br><span class="line">          params[n_params].value = &amp;values[n_params];</span><br><span class="line">          <span class="built_in">memset</span> (&amp;values[n_params], <span class="number">0</span>, <span class="built_in">sizeof</span> (GValue));</span><br><span class="line"></span><br><span class="line">          <span class="built_in">G_VALUE_COLLECT_INIT2</span> (&amp;values[n_params], vtabs[n_params], pspec-&gt;value_type, var_args, G_VALUE_NOCOPY_CONTENTS, &amp;error);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (error)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">g_critical</span> (<span class="string">&quot;%s: %s&quot;</span>, G_STRFUNC, error);</span><br><span class="line">              <span class="built_in">g_value_unset</span> (&amp;values[n_params]);</span><br><span class="line">              <span class="built_in">g_free</span> (error);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          n_params++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((name = <span class="built_in">va_arg</span> (var_args, <span class="type">const</span> gchar *)));</span><br><span class="line"></span><br><span class="line">      object = <span class="built_in">g_object_new_internal</span> (<span class="keyword">class</span>, params, n_params);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (n_params--)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* We open-code g_value_unset() here to avoid the</span></span><br><span class="line"><span class="comment">           * cost of looking up the GTypeValueTable again.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">if</span> (vtabs[n_params]-&gt;value_free)</span><br><span class="line">            vtabs[n_params]-&gt;<span class="built_in">value_free</span> (params[n_params].value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">G_UNLIKELY</span> (n_params_alloc != <span class="built_in">G_N_ELEMENTS</span> (params_stack)))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">g_free</span> (params);</span><br><span class="line">          <span class="built_in">g_free</span> (values);</span><br><span class="line">          <span class="built_in">g_free</span> (vtabs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Fast case: no properties passed in. */</span></span><br><span class="line">    object = <span class="built_in">g_object_new_internal</span> (<span class="keyword">class</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unref_class)</span><br><span class="line">    <span class="built_in">g_type_class_unref</span> (unref_class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="g-object-new-internal"><a href="#g-object-new-internal" class="headerlink" title="g_object_new_internal"></a>g_object_new_internal</h3><p>在这个函数里面会根据输入的 属性-值 对对象进行初始化。对于构造属性，如果输入的 属性-值 中没有该属性，则对该属性进行默认值初始化（每个属性定义的时候有个默认值），但是对于非构造属性，除非输入的 属性-值 中指明，否则将不进行初始化。</p><blockquote><p>Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)<br/>which are not explicitly specified are set to their default values. Any<br/>private data for the object is guaranteed to be initialized with zeros, as<br/>per g_type_create_instance().</p></blockquote><p>也就是说构造属性一定会被初始化，但是非构造属性除非指明，其他情况将不初始化。但是在对象分配内存的时候，使用的是 malloc0 分配的内存，也就是内存分配后会被设置为 0。</p><p>这一点和 ffmpeg 不一样，ffmpeg 通常会使用 av_opt_set_defaults 将属性设为默认值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> gpointer</span></span><br><span class="line"><span class="function"><span class="title">g_object_new_internal</span> <span class="params">(GObjectClass          *<span class="keyword">class</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       GObjectConstructParam *params,</span></span></span><br><span class="line"><span class="params"><span class="function">                       guint                  n_params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObjectNotifyQueue *nqueue = <span class="literal">NULL</span>;</span><br><span class="line">  GObject *object;</span><br><span class="line">  guint i;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">G_UNLIKELY</span> <span class="params">(CLASS_HAS_CUSTOM_CONSTRUCTOR (<span class="keyword">class</span>))</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">g_object_new_with_custom_constructor</span> <span class="params">(<span class="keyword">class</span>, params, n_params)</span></span>;</span><br><span class="line"></span><br><span class="line">  object = (GObject *) <span class="built_in">g_type_create_instance</span> (<span class="keyword">class</span>-&gt;g_type_class.g_type);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_assert</span> (<span class="built_in">g_object_is_aligned</span> (object));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">unset_object_in_construction</span> (object);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CLASS_HAS_PROPS</span> (<span class="keyword">class</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      GSList *node;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (_g_object_has_notify_handler_X (object))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* This may or may not have been setup in g_object_init().</span></span><br><span class="line"><span class="comment">           * If it hasn&#x27;t, we do it now.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          nqueue = <span class="built_in">g_datalist_id_get_data</span> (&amp;object-&gt;qdata, quark_notify_queue);</span><br><span class="line">          <span class="keyword">if</span> (!nqueue)</span><br><span class="line">            nqueue = <span class="built_in">g_object_notify_queue_freeze</span> (object, FALSE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化构造属性</span></span><br><span class="line">      <span class="comment">/* We will set exactly n_construct_properties construct</span></span><br><span class="line"><span class="comment">       * properties, but they may come from either the class default</span></span><br><span class="line"><span class="comment">       * values or the passed-in parameter list.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">for</span> (node = <span class="keyword">class</span>-&gt;construct_properties; node; node = node-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">const</span> GValue *value;</span><br><span class="line">          GParamSpec *pspec;</span><br><span class="line">          guint j;</span><br><span class="line"></span><br><span class="line">          pspec = node-&gt;data;</span><br><span class="line">          value = <span class="literal">NULL</span>; <span class="comment">/* to silence gcc... */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n_params; j++)</span><br><span class="line">            <span class="keyword">if</span> (params[j].pspec == pspec)</span><br><span class="line">              &#123;</span><br><span class="line">                value = params[j].value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line"><span class="comment">// 如果输入参数没指明，使用默认初始化</span></span><br><span class="line">          <span class="keyword">if</span> (value == <span class="literal">NULL</span>)</span><br><span class="line">            value = <span class="built_in">g_param_spec_get_default_value</span> (pspec);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">object_set_property</span> (object, pspec, value, nqueue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* run &#x27;constructed&#x27; handler if there is a custom one */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CLASS_HAS_CUSTOM_CONSTRUCTED</span> (<span class="keyword">class</span>))</span><br><span class="line">    <span class="keyword">class</span>-&gt;<span class="built_in">constructed</span> (object);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把剩余的参数设置到相应的属性上，其余的属性将不初始化</span></span><br><span class="line">  <span class="comment">/* Set remaining properties.  The construct properties will</span></span><br><span class="line"><span class="comment">   * already have been taken, so set only the non-construct ones.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n_params; i++)</span><br><span class="line">    <span class="keyword">if</span> (!(params[i].pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY)))</span><br><span class="line">      <span class="built_in">object_set_property</span> (object, params[i].pspec, params[i].value, nqueue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nqueue)</span><br><span class="line">    <span class="built_in">g_object_notify_queue_thaw</span> (object, nqueue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="class-gt-construct-properties-和-class-gt-pspecs"><a href="#class-gt-construct-properties-和-class-gt-pspecs" class="headerlink" title="class-&gt;construct_properties 和 class-&gt;pspecs"></a>class-&gt;construct_properties 和 class-&gt;pspecs</h1><ul><li>class-&gt;construct_properties 是在 g_object_class_install_property 时，如果输入的属性有构造属性标识 G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY，那么将把这个属性添加到 construct_properties 中，在 construct_properties 中的属性在构造时会被初始化（用户指定值或者默认值初始化）</li><li>class-&gt;pspecs 的含义目前我也不太确定，看注释似乎是类的静态属性，而且 find_pspec 函数会优先在 class-&gt;pspecs 中查找，找不到再去全局表找</li><li>最后就是 class-&gt;construct_properties 在 GObject 的 base_init 中会从父类拷贝一份到子类，而 class-&gt;pspecs 会被设为空，也就是 class-&gt;construct_properties 会发生继承，而 class-&gt;pspecs 不会</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_object_base_class_init</span> <span class="params">(GObjectClass *<span class="keyword">class</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObjectClass *pclass = <span class="built_in">g_type_class_peek_parent</span> (<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t inherit HAS_DERIVED_CLASS flag from parent class */</span></span><br><span class="line">  <span class="keyword">class</span>-&gt;flags &amp;= ~CLASS_HAS_DERIVED_CLASS_FLAG;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pclass)</span><br><span class="line">    pclass-&gt;flags |= CLASS_HAS_DERIVED_CLASS_FLAG;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* reset instance specific fields and methods that don&#x27;t get inherited */</span></span><br><span class="line">  <span class="keyword">class</span>-&gt;construct_properties = pclass ? <span class="built_in">g_slist_copy</span> (pclass-&gt;construct_properties) : <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">class</span>-&gt;n_construct_properties = <span class="built_in">g_slist_length</span> (<span class="keyword">class</span>-&gt;construct_properties);</span><br><span class="line">  <span class="keyword">class</span>-&gt;get_property = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">class</span>-&gt;set_property = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">class</span>-&gt;pspecs = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">class</span>-&gt;n_pspecs = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://github.com/zorgnax/gobject-examples">https://github.com/zorgnax/gobject-examples</a></p><p><a href="https://github.com/ToshioCP/Gobject-tutorial">https://github.com/ToshioCP/Gobject-tutorial</a></p>]]></content>
      
      
      <categories>
          
          <category> gobject </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gobject之引用计数</title>
      <link href="/2023/04/29/Gobject%E4%B9%8B%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
      <url>/2023/04/29/Gobject%E4%B9%8B%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>这篇博客介绍一下 Gobject 的引用计数。</p><p>要让 Gobject 类支持引用计数，需要让类继承 GObject 类，之后通过下面的 api 管理对象：</p><ul><li>使用 g_object_new 创建对象</li><li>使用 g_object_ref 增加引用计数</li><li>使用 g_object_unref 减少引用计数</li></ul><h1 id="g-object-new"><a href="#g-object-new" class="headerlink" title="g_object_new"></a>g_object_new</h1><p>在 g_object_new 时会调用 g_type_create_instance 创建并初始化对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gpointer</span></span><br><span class="line"><span class="function"><span class="title">g_object_new</span> <span class="params">(GType    object_type,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> gchar *first_property_name,</span></span></span><br><span class="line"><span class="params"><span class="function">        ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">va_start</span> (var_args, first_property_name);</span><br><span class="line">  object = <span class="built_in">g_object_new_valist</span> (object_type, first_property_name, var_args);</span><br><span class="line">  <span class="built_in">va_end</span> (var_args);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">GObject*</span></span><br><span class="line"><span class="function"><span class="title">g_object_new_valist</span> <span class="params">(GType        object_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> gchar *first_property_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                     va_list      var_args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObjectClass *<span class="keyword">class</span>, *unref_class = <span class="literal">NULL</span>;</span><br><span class="line">  GObject *object;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">class</span> = <span class="built_in">g_type_class_peek_static</span> (object_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">class</span>)</span><br><span class="line">    <span class="keyword">class</span> = unref_class = <span class="built_in">g_type_class_ref</span> (object_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first_property_name)</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">      GObjectConstructParam *params = params_stack;</span><br><span class="line">...</span><br><span class="line">      guint n_params = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">      object = <span class="built_in">g_object_new_internal</span> (<span class="keyword">class</span>, params, n_params);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> gpointer</span></span><br><span class="line"><span class="function"><span class="title">g_object_new_internal</span> <span class="params">(GObjectClass          *<span class="keyword">class</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       GObjectConstructParam *params,</span></span></span><br><span class="line"><span class="params"><span class="function">                       guint                  n_params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObjectNotifyQueue *nqueue = <span class="literal">NULL</span>;</span><br><span class="line">  GObject *object;</span><br><span class="line">  guint i;</span><br><span class="line">...</span><br><span class="line">  object = (GObject *) <span class="built_in">g_type_create_instance</span> (<span class="keyword">class</span>-&gt;g_type_class.g_type);</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CLASS_HAS_PROPS</span> (<span class="keyword">class</span>))</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">GTypeInstance*</span></span><br><span class="line"><span class="function"><span class="title">g_type_create_instance</span> <span class="params">(GType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TypeNode *node;</span><br><span class="line">  GTypeInstance *instance;</span><br><span class="line">  GTypeClass *<span class="keyword">class</span>;</span><br><span class="line">  gchar *allocated;</span><br><span class="line">  gint private_size;</span><br><span class="line">  gint ivar_size;</span><br><span class="line">  guint i;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  node = <span class="built_in">lookup_type_node_I</span> (type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> = <span class="built_in">g_type_class_ref</span> (type);</span><br><span class="line"></span><br><span class="line">  private_size = node-&gt;data-&gt;instance.private_size;</span><br><span class="line">  ivar_size = node-&gt;data-&gt;instance.instance_size;</span><br><span class="line"></span><br><span class="line">  allocated = <span class="built_in">g_slice_alloc0</span> (private_size + ivar_size);</span><br><span class="line"></span><br><span class="line">  instance = (GTypeInstance *) (allocated + private_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = node-&gt;n_supers; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">      TypeNode *pnode;</span><br><span class="line">      </span><br><span class="line">      pnode = <span class="built_in">lookup_type_node_I</span> (node-&gt;supers[i]);</span><br><span class="line">      <span class="keyword">if</span> (pnode-&gt;data-&gt;instance.instance_init)</span><br><span class="line">  &#123;</span><br><span class="line">    instance-&gt;g_class = pnode-&gt;data-&gt;instance.<span class="keyword">class</span>;</span><br><span class="line">    pnode-&gt;data-&gt;instance.<span class="built_in">instance_init</span> (instance, <span class="keyword">class</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  instance-&gt;g_class = <span class="keyword">class</span>;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;data-&gt;instance.instance_init)</span><br><span class="line">    node-&gt;data-&gt;instance.<span class="built_in">instance_init</span> (instance, <span class="keyword">class</span>);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 g_type_create_instance 中可以清楚的看到：</p><ul><li>先分配内存（包括私有结构）</li><li>然后从上往下调用 instance_init</li></ul><h2 id="g-object-init"><a href="#g-object-init" class="headerlink" title="g_object_init"></a>g_object_init</h2><p>而 GObject 的 instance_init 函数 g_object_init 会初始化引用计数为 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_object_init</span> <span class="params">(GObject    *object,</span></span></span><br><span class="line"><span class="params"><span class="function">         GObjectClass *<span class="keyword">class</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  object-&gt;ref_count = <span class="number">1</span>;</span><br><span class="line">  object-&gt;qdata = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CLASS_HAS_PROPS</span> (<span class="keyword">class</span>) &amp;&amp; <span class="built_in">CLASS_NEEDS_NOTIFY</span> (<span class="keyword">class</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* freeze object&#x27;s notification queue, g_object_new_internal() preserves pairedness */</span></span><br><span class="line">      <span class="built_in">g_object_notify_queue_freeze</span> (object, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* mark object in-construction for notify_queue_thaw() and to allow construct-only properties */</span></span><br><span class="line">  <span class="built_in">set_object_in_construction</span> (object);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 instance_init 的调用时机，每个 GObject 或其子类的实例在创建时都会执行 g_object_init 函数，所以继承 GObject 的类在创建实例时就会初始化引用计数。</p><h1 id="g-object-ref"><a href="#g-object-ref" class="headerlink" title="g_object_ref"></a>g_object_ref</h1><p>再看看 g_object_ref 函数，该函数主要是将 ref_count 加 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gpointer</span></span><br><span class="line">(g_object_ref) (gpointer _object)</span><br><span class="line">&#123;</span><br><span class="line">  GObject *object = _object;</span><br><span class="line">  gint old_val;</span><br><span class="line">  gboolean object_already_finalized;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (<span class="built_in">G_IS_OBJECT</span> (object), <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  old_val = <span class="built_in">g_atomic_int_add</span> (&amp;object-&gt;ref_count, <span class="number">1</span>);</span><br><span class="line">  object_already_finalized = (old_val &lt;= <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (!object_already_finalized, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (old_val == <span class="number">1</span> &amp;&amp; <span class="built_in">OBJECT_HAS_TOGGLE_REF</span> (object))</span><br><span class="line">    <span class="built_in">toggle_refs_notify</span> (object, FALSE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE</span> (<span class="built_in">GOBJECT_OBJECT_REF</span>(object,<span class="built_in">G_TYPE_FROM_INSTANCE</span>(object),old_val));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="g-object-unref"><a href="#g-object-unref" class="headerlink" title="g_object_unref"></a>g_object_unref</h1><p>g_object_unref 则是释放引用，同时可能会执行 dispose 和 finalize 函数。</p><p>当引用计数大于 1，表示当前可能即便 unref，引用计数也不为 0，此时的逻辑比较简单，尝试进行 CAS 操作来竞争并减小引用计数，如果竞争成功就返回（因为此时肯定不是最后一个 unref 的），竞争失败就重试，此时有可能是最后一个引用</p><p>如果重试的时候发现自己的引用计数为 1，那么表示当前是最后一个引用，那么有可能需要析构。此时情况比较复杂，因为可能在析构的时候其他地方发生了 ref 操作。</p><p>检查 weak_ref 是否进行了 promote，weak_ref 提升之后引用计数会增加</p><p>如果当前引用计数为 1，那么会进行 dispose 操作</p><p>dispose 后再判断引用计数，因为在 dispose 时有可能又在其他地方进行了 ref</p><blockquote><p>但是感觉不太应该，因为没有 weak_ref 的话，如果当前自己是最后一个引用，那么其他地方是不可能提升引用的，因为其他地方已经没有指针可用了</p></blockquote><p>如果 ref 大于 1，则尝试 CAS 操作来竞争并减小引用计数，和上面一样，竞争成功则返回，竞争失败就在这里重试。重试之后发现自己就是最后一个引用，那么减小引用计数，减小引用计数之后再判断一下引用计数，因为可能此时其他地方又发生了 ref（这里也不应该，理由同上，在没有 weak_ref 的情况下其他地方不应该增加引用）</p><p>如果上一步获取引用计数发现其他地方进行了 ref，就返回，否则执行 finalize 和 g_type_free_instance</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_object_unref</span> <span class="params">(gpointer _object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObject *object = _object;</span><br><span class="line">  gint old_ref;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* here we want to atomically do: if (ref_count&gt;1) &#123; ref_count--; return; &#125; */</span></span><br><span class="line"> retry_atomic_decrement1:</span><br><span class="line">  old_ref = <span class="built_in">g_atomic_int_get</span> (&amp;object-&gt;ref_count);</span><br><span class="line">  <span class="keyword">if</span> (old_ref &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">g_atomic_int_compare_and_exchange</span> ((<span class="type">int</span> *)&amp;object-&gt;ref_count, old_ref, old_ref - <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">goto</span> retry_atomic_decrement1;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      GSList **weak_locations;</span><br><span class="line">      GObjectNotifyQueue *nqueue;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* The only way that this object can live at this point is if</span></span><br><span class="line"><span class="comment">       * there are outstanding weak references already established</span></span><br><span class="line"><span class="comment">       * before we got here.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * If there were not already weak references then no more can be</span></span><br><span class="line"><span class="comment">       * established at this time, because the other thread would have</span></span><br><span class="line"><span class="comment">       * to hold a strong ref in order to call</span></span><br><span class="line"><span class="comment">       * g_object_add_weak_pointer() and then we wouldn&#x27;t be here.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * Other GWeakRef&#x27;s (weak locations) instead may still be added</span></span><br><span class="line"><span class="comment">       * before the object is finalized, but in such case we&#x27;ll unset</span></span><br><span class="line"><span class="comment">       * them as part of the qdata removal.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      weak_locations = <span class="built_in">g_datalist_id_get_data</span> (&amp;object-&gt;qdata, quark_weak_locations);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (weak_locations != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">g_rw_lock_writer_lock</span> (&amp;weak_locations_lock);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* It is possible that one of the weak references beat us to</span></span><br><span class="line"><span class="comment">           * the lock. Make sure the refcount is still what we expected</span></span><br><span class="line"><span class="comment">           * it to be.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          old_ref = <span class="built_in">g_atomic_int_get</span> (&amp;object-&gt;ref_count);</span><br><span class="line">          <span class="keyword">if</span> (old_ref != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">g_rw_lock_writer_unlock</span> (&amp;weak_locations_lock);</span><br><span class="line">              <span class="keyword">goto</span> retry_atomic_decrement1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* We got the lock first, so the object will definitely die</span></span><br><span class="line"><span class="comment">           * now. Clear out all the weak references, if they&#x27;re still set.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          weak_locations = <span class="built_in">g_datalist_id_remove_no_notify</span> (&amp;object-&gt;qdata,</span><br><span class="line">                                                           quark_weak_locations);</span><br><span class="line">          <span class="built_in">g_clear_pointer</span> (&amp;weak_locations, weak_locations_free_unlocked);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">g_rw_lock_writer_unlock</span> (&amp;weak_locations_lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* freeze the notification queue, so we don&#x27;t accidentally emit</span></span><br><span class="line"><span class="comment">       * notifications during dispose() and finalize().</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * The notification queue stays frozen unless the instance acquires</span></span><br><span class="line"><span class="comment">       * a reference during dispose(), in which case we thaw it and</span></span><br><span class="line"><span class="comment">       * dispatch all the notifications. If the instance gets through</span></span><br><span class="line"><span class="comment">       * to finalize(), the notification queue gets automatically</span></span><br><span class="line"><span class="comment">       * drained when g_object_finalize() is reached and</span></span><br><span class="line"><span class="comment">       * the qdata is cleared.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      nqueue = <span class="built_in">g_object_notify_queue_freeze</span> (object, FALSE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* we are about to remove the last reference */</span></span><br><span class="line">      <span class="built_in">G_OBJECT_GET_CLASS</span> (object)-&gt;<span class="built_in">dispose</span> (object);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* may have been re-referenced meanwhile */</span></span><br><span class="line">    retry_atomic_decrement2:</span><br><span class="line">      old_ref = <span class="built_in">g_atomic_int_get</span> ((<span class="type">int</span> *)&amp;object-&gt;ref_count);</span><br><span class="line">      <span class="keyword">if</span> (old_ref &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">g_atomic_int_compare_and_exchange</span> ((<span class="type">int</span> *)&amp;object-&gt;ref_count, old_ref, old_ref - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">goto</span> retry_atomic_decrement2;</span><br><span class="line">          <span class="comment">/* emit all notifications that have been queued during dispose() */</span></span><br><span class="line">          <span class="built_in">g_object_notify_queue_thaw</span> (object, nqueue);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* we are still in the process of taking away the last ref */</span></span><br><span class="line">      <span class="built_in">g_datalist_id_set_data</span> (&amp;object-&gt;qdata, quark_closure_array, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">g_signal_handlers_destroy</span> (object);</span><br><span class="line">      <span class="built_in">g_datalist_id_set_data</span> (&amp;object-&gt;qdata, quark_weak_refs, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">g_datalist_id_set_data</span> (&amp;object-&gt;qdata, quark_weak_locations, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* decrement the last reference */</span></span><br><span class="line">      old_ref = <span class="built_in">g_atomic_int_add</span> (&amp;object-&gt;ref_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">g_return_if_fail</span> (old_ref &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* may have been re-referenced meanwhile */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">G_LIKELY</span> (old_ref == <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="built_in">G_OBJECT_GET_CLASS</span> (object)-&gt;<span class="built_in">finalize</span> (object);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">g_type_free_instance</span> ((GTypeInstance*) object);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* The instance acquired a reference between dispose() and</span></span><br><span class="line"><span class="comment">           * finalize(), so we need to thaw the notification queue</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="built_in">g_object_notify_queue_thaw</span> (object, nqueue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有点不理解上面的函数为什么这么设计，既然进入了 dispose 分支，那么当前就是最后一个引用，而 weakref 也是在第 17 行后立马就判断了的，后面代码逻辑似乎是不必要的，如果 weakref 成功 promote，那么当前不应该析构，直接返回，如果 weakref 和当前操作竞争失败，weakref 的 promote 应该返回空，当前操作直接 dispose+finalize。这里的思路和 C++ 标准库的 shared_ptr&#x2F;weak_ptr 不太一样。</p><h1 id="dispose-x2F-finalize-的链式调用"><a href="#dispose-x2F-finalize-的链式调用" class="headerlink" title="dispose&#x2F;finalize 的链式调用"></a>dispose&#x2F;finalize 的链式调用</h1><p>关于析构还有一点要注意，我们定义的 dispose、finalize 函数需要链式调用父类的 dispose、finalize 函数，这是因为当前类继承了父类，在初始化时依次调用了父类的 instance_init 函数，所以也需要调用每个父类的 dispose、finalize 函数来释放可能的资源。</p>]]></content>
      
      
      <categories>
          
          <category> gobject </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gobject初始化之实例struct初始化</title>
      <link href="/2023/04/29/Gobject%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E5%AE%9E%E4%BE%8Bstruct%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2023/04/29/Gobject%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E5%AE%9E%E4%BE%8Bstruct%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>这篇博客接着上一篇 类结构 struct 初始化 来介绍实例 struct 的初始化过程，希望从源码的角度理清 instance_init 函数的调用以及私有结构的存储。</p><h1 id="g-object-new-with-properties"><a href="#g-object-new-with-properties" class="headerlink" title="g_object_new_with_properties"></a>g_object_new_with_properties</h1><p>g_object_new_with_properties 函数在调用 g_type_class_ref 函数创建类结构 struct 后会调用 g_object_new_internal 函数创建实例 struct 的实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GObject *</span></span><br><span class="line"><span class="function"><span class="title">g_object_new_with_properties</span> <span class="params">(GType          object_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                              guint          n_properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">char</span>    *names[],</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> GValue   values[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObjectClass *<span class="keyword">class</span>, *unref_class = <span class="literal">NULL</span>;</span><br><span class="line">  GObject *object;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> = <span class="built_in">g_type_class_peek_static</span> (object_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">class</span> == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">class</span> = unref_class = <span class="built_in">g_type_class_ref</span> (object_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n_properties &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    object = <span class="built_in">g_object_new_internal</span> (<span class="keyword">class</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unref_class != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">g_type_class_unref</span> (unref_class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="g-object-new-internal"><a href="#g-object-new-internal" class="headerlink" title="g_object_new_internal"></a>g_object_new_internal</h2><p>g_object_new_internal 函数如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> gpointer</span></span><br><span class="line"><span class="function"><span class="title">g_object_new_internal</span> <span class="params">(GObjectClass          *<span class="keyword">class</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       GObjectConstructParam *params,</span></span></span><br><span class="line"><span class="params"><span class="function">                       guint                  n_params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObjectNotifyQueue *nqueue = <span class="literal">NULL</span>;</span><br><span class="line">  GObject *object;</span><br><span class="line">  guint i;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">G_UNLIKELY</span> <span class="params">(CLASS_HAS_CUSTOM_CONSTRUCTOR (<span class="keyword">class</span>))</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">g_object_new_with_custom_constructor</span> <span class="params">(<span class="keyword">class</span>, params, n_params)</span></span>;</span><br><span class="line"></span><br><span class="line">  object = (GObject *) <span class="built_in">g_type_create_instance</span> (<span class="keyword">class</span>-&gt;g_type_class.g_type);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">unset_object_in_construction</span> (object);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CLASS_HAS_PROPS</span> (<span class="keyword">class</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      GSList *node;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (_g_object_has_notify_handler_X (object))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* This may or may not have been setup in g_object_init().</span></span><br><span class="line"><span class="comment">           * If it hasn&#x27;t, we do it now.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          nqueue = <span class="built_in">g_datalist_id_get_data</span> (&amp;object-&gt;qdata, quark_notify_queue);</span><br><span class="line">          <span class="keyword">if</span> (!nqueue)</span><br><span class="line">            nqueue = <span class="built_in">g_object_notify_queue_freeze</span> (object, FALSE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We will set exactly n_construct_properties construct</span></span><br><span class="line"><span class="comment">       * properties, but they may come from either the class default</span></span><br><span class="line"><span class="comment">       * values or the passed-in parameter list.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">for</span> (node = <span class="keyword">class</span>-&gt;construct_properties; node; node = node-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">const</span> GValue *value;</span><br><span class="line">          GParamSpec *pspec;</span><br><span class="line">          guint j;</span><br><span class="line"></span><br><span class="line">          pspec = node-&gt;data;</span><br><span class="line">          value = <span class="literal">NULL</span>; <span class="comment">/* to silence gcc... */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n_params; j++)</span><br><span class="line">            <span class="keyword">if</span> (params[j].pspec == pspec)</span><br><span class="line">              &#123;</span><br><span class="line">                value = params[j].value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (value == <span class="literal">NULL</span>)</span><br><span class="line">            value = <span class="built_in">g_param_spec_get_default_value</span> (pspec);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">object_set_property</span> (object, pspec, value, nqueue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* run &#x27;constructed&#x27; handler if there is a custom one */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CLASS_HAS_CUSTOM_CONSTRUCTED</span> (<span class="keyword">class</span>))</span><br><span class="line">    <span class="keyword">class</span>-&gt;<span class="built_in">constructed</span> (object);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set remaining properties.  The construct properties will</span></span><br><span class="line"><span class="comment">   * already have been taken, so set only the non-construct ones.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n_params; i++)</span><br><span class="line">    <span class="keyword">if</span> (!(params[i].pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY)))</span><br><span class="line">      <span class="built_in">object_set_property</span> (object, params[i].pspec, params[i].value, nqueue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nqueue)</span><br><span class="line">    <span class="built_in">g_object_notify_queue_thaw</span> (object, nqueue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CLASS_HAS_CUSTOM_CONSTRUCTOR</code> 宏，判断用户是否自己定义了 constructor，自定义 constructor 用得非常少。如果用户自己定义了 constructor，那么使用自定义的 constructor 来创建实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS_HAS_CUSTOM_CONSTRUCTOR(class) \</span></span><br><span class="line"><span class="meta">    ((class)-&gt;constructor != g_object_constructor)</span></span><br></pre></td></tr></table></figure><h3 id="g-type-create-instance"><a href="#g-type-create-instance" class="headerlink" title="g_type_create_instance"></a>g_type_create_instance</h3><p>g_object_new_internal 中调用 g_type_create_instance 函数创建实例 struct 的实例，g_type_create_instance 也会 g_type_class_ref 一下，但是这次的就没有 unref 了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GTypeInstance*</span></span><br><span class="line"><span class="function"><span class="title">g_type_create_instance</span> <span class="params">(GType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TypeNode *node;</span><br><span class="line">  GTypeInstance *instance;</span><br><span class="line">  GTypeClass *<span class="keyword">class</span>;</span><br><span class="line">  gchar *allocated;</span><br><span class="line">  gint private_size;</span><br><span class="line">  gint ivar_size;</span><br><span class="line">  guint i;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  node = <span class="built_in">lookup_type_node_I</span> (type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> = <span class="built_in">g_type_class_ref</span> (type);</span><br><span class="line"></span><br><span class="line">  private_size = node-&gt;data-&gt;instance.private_size;</span><br><span class="line">  ivar_size = node-&gt;data-&gt;instance.instance_size;</span><br><span class="line"></span><br><span class="line">  allocated = <span class="built_in">g_slice_alloc0</span> (private_size + ivar_size);</span><br><span class="line"></span><br><span class="line">  instance = (GTypeInstance *) (allocated + private_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = node-&gt;n_supers; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">      TypeNode *pnode;</span><br><span class="line">      </span><br><span class="line">      pnode = <span class="built_in">lookup_type_node_I</span> (node-&gt;supers[i]);</span><br><span class="line">      <span class="keyword">if</span> (pnode-&gt;data-&gt;instance.instance_init)</span><br><span class="line">  &#123;</span><br><span class="line">    instance-&gt;g_class = pnode-&gt;data-&gt;instance.<span class="keyword">class</span>;</span><br><span class="line">    pnode-&gt;data-&gt;instance.<span class="built_in">instance_init</span> (instance, <span class="keyword">class</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  instance-&gt;g_class = <span class="keyword">class</span>;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;data-&gt;instance.instance_init)</span><br><span class="line">    node-&gt;data-&gt;instance.<span class="built_in">instance_init</span> (instance, <span class="keyword">class</span>);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>g_type_create_instance 函数主要：</p><ul><li>分配 instance_size+private_size 大小的内存，在这里会处理私有结构的内存</li><li>从最顶层父类到自己，依次调用每一个 instance_init 函数初始化当前的实例 struct 的实例</li></ul><p>g_type_create_instance 函数创建实例后，如果类上定义有属性，会设置这些属性，这部分放到属性 get&#x2F;set 中介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS_HAS_PROPS_FLAG 0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS_HAS_PROPS(class) \</span></span><br><span class="line"><span class="meta">    ((class)-&gt;flags &amp; CLASS_HAS_PROPS_FLAG)</span></span><br></pre></td></tr></table></figure><p>最后在对象构造完成后，如果定义了 constructed 函数，则会调用该函数。</p><h1 id="g-object-init"><a href="#g-object-init" class="headerlink" title="g_object_init"></a>g_object_init</h1><p>最后看一下 GObject 的 instance_init 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_object_init</span> <span class="params">(GObject    *object,</span></span></span><br><span class="line"><span class="params"><span class="function">         GObjectClass *<span class="keyword">class</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  object-&gt;ref_count = <span class="number">1</span>;</span><br><span class="line">  object-&gt;qdata = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CLASS_HAS_PROPS</span> (<span class="keyword">class</span>) &amp;&amp; <span class="built_in">CLASS_NEEDS_NOTIFY</span> (<span class="keyword">class</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* freeze object&#x27;s notification queue, g_object_new_internal() preserves pairedness */</span></span><br><span class="line">      <span class="built_in">g_object_notify_queue_freeze</span> (object, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* mark object in-construction for notify_queue_thaw() and to allow construct-only properties */</span></span><br><span class="line">  <span class="built_in">set_object_in_construction</span> (object);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数中初始化了引用计数。</p><h1 id="实例-struct-初始化、类-struct-初始化与-xx-base-init、xx-class-init、xx-init-函数"><a href="#实例-struct-初始化、类-struct-初始化与-xx-base-init、xx-class-init、xx-init-函数" class="headerlink" title="实例 struct 初始化、类 struct 初始化与 xx_base_init、xx_class_init、xx_init 函数"></a>实例 struct 初始化、类 struct 初始化与 xx_base_init、xx_class_init、xx_init 函数</h1><p>结合前一篇文章的内容，我们总结一下创建 gobject 时 xx_base_init、xx_class_init、xx_init 这些函数的调用时机。</p><p>第一次调用 g_object_new：</p><ul><li><p>创建类 struct 的实例</p><ul><li>把父类的类结构复制一份，然后从基类从上到下开始调用 base_init</li><li>调用目标类结构的 class_init 函数</li></ul></li><li><p>创建实例 struct 的实例</p><ul><li>把 instance_init 函数（就是 xx_init）从上往下调用一遍</li></ul></li></ul><p>非第一次调用 g_object_new：</p><ul><li><p>不用再创建类 struct 的实例</p></li><li><p>直接创建实例 struct 的实例</p><ul><li>把 instance_init 函数从上往下调用一遍</li></ul></li></ul><p>那么 xx_base_init、xx_class_init、xx_init 函数的作用就一清二楚了：</p><ul><li>xx_base_init 就像 C++ 中的构造函数（仅仅对类 struct 来说），会从上到下调用</li><li>xx_class_init 是仅仅特定类型所属的 xx_class_init 函数会调用，父类的不会调用</li><li>上面两个函数是类 struct 初始化时用到，而 xx_init 时实例 struct 初始化时用到，xx_init 也是从上往下都要调用一次</li></ul><p>gstelement 里面定义了 xx_base_init 函数，这个函数在 gstelement 里面是把 padtemplates 和 metadata 复制一份，因为上面创建类 struct 的实例时，会发生“父类类结构复制到子类”的操作，那么此时子类和父类使用了相同的 padtemplates 和 metadata 指针，这肯定是不行的。事实上 base_init 的作用大概率就是防止复制父类结构时复制的是指针，从而出现浅拷贝的情况。</p>]]></content>
      
      
      <categories>
          
          <category> gobject </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gobject初始化之类结构struct初始化</title>
      <link href="/2023/04/29/Gobject%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E7%B1%BB%E7%BB%93%E6%9E%84struct%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2023/04/29/Gobject%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E7%B1%BB%E7%BB%93%E6%9E%84struct%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>上篇博客介绍了类型注册的过程，类型注册的结果就是创建并初始化类对应的 TypeNode 实例。之前在介绍如何定义一个 Gobject 类时提到了类的 <code>结构struct</code>，这个 struct 每个类全局只有一个实例，用于实现类似 C++ 虚函数覆盖的效果。这篇博客就介绍一下类结构 struct 的初始化过程，同时通过代码分析一下 base_init、class_init 等函数的调用时机。</p><p>当通过 g_object_new 创建 <code>实例struct</code> 的实例时，如果类 <code>结构struct</code> 的实例没有被创建，会先创建该实例</p><h1 id="g-object-new"><a href="#g-object-new" class="headerlink" title="g_object_new"></a>g_object_new</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gpointer</span></span><br><span class="line"><span class="function"><span class="title">g_object_new</span> <span class="params">(GType    object_type,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> gchar *first_property_name,</span></span></span><br><span class="line"><span class="params"><span class="function">        ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObject *object;</span><br><span class="line">  va_list var_args;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* short circuit for calls supplying no properties */</span></span><br><span class="line">  <span class="keyword">if</span> (!first_property_name)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g_object_new_with_properties</span> (object_type, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">va_start</span> (var_args, first_property_name);</span><br><span class="line">  object = <span class="built_in">g_object_new_valist</span> (object_type, first_property_name, var_args);</span><br><span class="line">  <span class="built_in">va_end</span> (var_args);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单起见，假设上面函数调用时没有传递属性参数，于是调用的是 g_object_new_with_properties()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GObject *</span></span><br><span class="line"><span class="function"><span class="title">g_object_new_with_properties</span> <span class="params">(GType          object_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                              guint          n_properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> <span class="type">char</span>    *names[],</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> GValue   values[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObjectClass *<span class="keyword">class</span>, *unref_class = <span class="literal">NULL</span>;</span><br><span class="line">  GObject *object;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> = <span class="built_in">g_type_class_peek_static</span> (object_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">class</span> == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">class</span> = unref_class = <span class="built_in">g_type_class_ref</span> (object_type);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n_properties &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    object = <span class="built_in">g_object_new_internal</span> (<span class="keyword">class</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unref_class != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">g_type_class_unref</span> (unref_class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="g-type-class-peek-static"><a href="#g-type-class-peek-static" class="headerlink" title="g_type_class_peek_static"></a>g_type_class_peek_static</h2><p>g_object_new_with_properties 先调用 g_type_class_peek_static 尝试得到 <code>结构struct</code> 的实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gpointer</span></span><br><span class="line"><span class="function"><span class="title">g_type_class_peek_static</span> <span class="params">(GType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TypeNode *node;</span><br><span class="line">  gpointer <span class="keyword">class</span>;</span><br><span class="line">  </span><br><span class="line">  node = <span class="built_in">lookup_type_node_I</span> (type);</span><br><span class="line">  <span class="keyword">if</span> (node &amp;&amp; node-&gt;is_classed &amp;&amp; <span class="built_in">NODE_REFCOUNT</span> (node) &amp;&amp;</span><br><span class="line">      <span class="comment">/* peek only static types: */</span> node-&gt;plugin == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">g_atomic_int_get</span> (&amp;node-&gt;data-&gt;<span class="keyword">class</span>.init_state) == INITIALIZED)</span><br><span class="line">    <span class="comment">/* ref_count _may_ be 0 */</span></span><br><span class="line">    <span class="keyword">class</span> = node-&gt;data-&gt;<span class="keyword">class</span>.<span class="keyword">class</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">class</span> = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="g-type-class-ref"><a href="#g-type-class-ref" class="headerlink" title="g_type_class_ref"></a>g_type_class_ref</h2><p>如果 g_type_class_peek_static 返回的是空指针，代表此时还没有创建结构 struct 的实例，g_object_new_with_properties 会调用 g_type_class_ref 函数创建类结构 struct 的实例。g_type_class_ref 函数会：</p><blockquote><p>Increments the reference count of the class structure belonging to @type. This function will demand-create the class if it doesn’t exist already.</p></blockquote><p>由于 g_type_class_ref 和 g_object_new_internal 都会增加引用计数，所以引用计数会 +2，于是 g_object_new_with_properties 的最后还做了一个 unref 动作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gpointer</span></span><br><span class="line"><span class="function"><span class="title">g_type_class_ref</span> <span class="params">(GType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TypeNode *node;</span><br><span class="line">  GType ptype;</span><br><span class="line">  gboolean holds_ref;</span><br><span class="line">  GTypeClass *pclass;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* optimize for common code path */</span></span><br><span class="line">  node = <span class="built_in">lookup_type_node_I</span> (type);</span><br><span class="line">  <span class="keyword">if</span> (!node || !node-&gt;is_classed)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">G_LIKELY</span> (<span class="built_in">type_data_ref_U</span> (node)))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">G_LIKELY</span> (<span class="built_in">g_atomic_int_get</span> (&amp;node-&gt;data-&gt;<span class="keyword">class</span>.init_state) == INITIALIZED))</span><br><span class="line">        <span class="keyword">return</span> node-&gt;data-&gt;<span class="keyword">class</span>.<span class="keyword">class</span>;</span><br><span class="line">      holds_ref = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    holds_ref = FALSE;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* here, we either have node-&gt;data-&gt;class.class == NULL, or a recursive</span></span><br><span class="line"><span class="comment">   * call to g_type_class_ref() with a partly initialized class, or</span></span><br><span class="line"><span class="comment">   * node-&gt;data-&gt;class.init_state == INITIALIZED, because any</span></span><br><span class="line"><span class="comment">   * concurrently running initialization was guarded by class_init_rec_mutex.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">g_rec_mutex_lock</span> (&amp;class_init_rec_mutex); <span class="comment">/* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">g_type_class_ref也是一个递归向上的函数，他在初始化当前node时，</span></span><br><span class="line"><span class="comment">会先判断父类的结构struct已经创建，如果没有，对父类node调用g_type_class_ref</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="comment">/* we need an initialized parent class for initializing derived classes */</span></span><br><span class="line">  ptype = <span class="built_in">NODE_PARENT_TYPE</span> (node);</span><br><span class="line">  pclass = ptype ? <span class="built_in">g_type_class_ref</span> (ptype) : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">G_WRITE_LOCK</span> (&amp;type_rw_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!holds_ref)</span><br><span class="line">    <span class="built_in">type_data_ref_Wm</span> (node);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!node-&gt;data-&gt;<span class="keyword">class</span>.<span class="keyword">class</span>) <span class="comment">/* class uninitialized */</span></span><br><span class="line">    <span class="built_in">type_class_init_Wm</span> (node, pclass);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">G_WRITE_UNLOCK</span> (&amp;type_rw_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pclass)</span><br><span class="line">    <span class="built_in">g_type_class_unref</span> (pclass);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_rec_mutex_unlock</span> (&amp;class_init_rec_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> node-&gt;data-&gt;<span class="keyword">class</span>.<span class="keyword">class</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-data-ref-U"><a href="#type-data-ref-U" class="headerlink" title="type_data_ref_U"></a>type_data_ref_U</h3><p>g_type_class_ref 函数先通过 type_data_ref_U 函数增加当前 TypeNode 的引用计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> gboolean</span></span><br><span class="line"><span class="function"><span class="title">type_data_ref_U</span> <span class="params">(TypeNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  guint current;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    current = <span class="built_in">NODE_REFCOUNT</span> (node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current &lt; <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!<span class="built_in">g_atomic_int_compare_and_exchange</span> ((<span class="type">int</span> *) &amp;node-&gt;ref_count, current, current + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 type_data_ref_U 函数失败，表明 TypeNode 可能没有初始化，此时将调用 type_data_ref_Wm 函数初始化 TypeNode，和之前的类型注册过程一样</p><h3 id="type-class-init-Wm"><a href="#type-class-init-Wm" class="headerlink" title="type_class_init_Wm"></a>type_class_init_Wm</h3><p>TypeNode 初始化好之后，调用 type_class_init_Wm 函数创建结构 struct 的实例，该实例的指针会保存在 TypeNode-&gt;data-&gt;class.class 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">type_class_init_Wm</span> <span class="params">(TypeNode   *node,</span></span></span><br><span class="line"><span class="params"><span class="function">        GTypeClass *pclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GSList *slist, *init_slist = <span class="literal">NULL</span>;</span><br><span class="line">  GTypeClass *<span class="keyword">class</span>;</span><br><span class="line">  IFaceEntries *entries;</span><br><span class="line">  IFaceEntry *entry;</span><br><span class="line">  TypeNode *bnode, *pnode;</span><br><span class="line">  guint i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Accessing data-&gt;class will work for instantiatable types</span></span><br><span class="line"><span class="comment">   * too because ClassData is a subset of InstanceData</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">g_assert</span> (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp;</span><br><span class="line">      node-&gt;data-&gt;<span class="keyword">class</span>.class_size &amp;&amp;</span><br><span class="line">      !node-&gt;data-&gt;<span class="keyword">class</span>.<span class="keyword">class</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">g_atomic_int_get</span> (&amp;node-&gt;data-&gt;<span class="keyword">class</span>.init_state) == UNINITIALIZED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配class的内存</span></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;data-&gt;<span class="keyword">class</span>.class_private_size)</span><br><span class="line">    <span class="keyword">class</span> = <span class="built_in">g_malloc0</span> (<span class="built_in">ALIGN_STRUCT</span> (node-&gt;data-&gt;<span class="keyword">class</span>.class_size) + node-&gt;data-&gt;<span class="keyword">class</span>.class_private_size);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">class</span> = <span class="built_in">g_malloc0</span> (node-&gt;data-&gt;<span class="keyword">class</span>.class_size);</span><br><span class="line"></span><br><span class="line">  node-&gt;data-&gt;<span class="keyword">class</span>.<span class="keyword">class</span> = <span class="keyword">class</span>;</span><br><span class="line">  <span class="built_in">g_atomic_int_set</span> (&amp;node-&gt;data-&gt;<span class="keyword">class</span>.init_state, BASE_CLASS_INIT);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (pclass)</span><br><span class="line">    &#123;</span><br><span class="line">      pnode = <span class="built_in">lookup_type_node_I</span> (pclass-&gt;g_type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把父类的类struct实例拷贝到当前的类struct实例</span></span><br><span class="line">      <span class="built_in">memcpy</span> (<span class="keyword">class</span>, pclass, pnode-&gt;data-&gt;<span class="keyword">class</span>.class_size);</span><br><span class="line">      <span class="built_in">memcpy</span> (<span class="built_in">G_STRUCT_MEMBER_P</span> (<span class="keyword">class</span>, <span class="built_in">ALIGN_STRUCT</span> (node-&gt;data-&gt;<span class="keyword">class</span>.class_size)), <span class="built_in">G_STRUCT_MEMBER_P</span> (pclass, <span class="built_in">ALIGN_STRUCT</span> (pnode-&gt;data-&gt;<span class="keyword">class</span>.class_size)), pnode-&gt;data-&gt;<span class="keyword">class</span>.class_private_size);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node-&gt;is_instantiatable)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* We need to initialize the private_size here rather than in</span></span><br><span class="line"><span class="comment">     * type_data_make_W() since the class init for the parent</span></span><br><span class="line"><span class="comment">     * class may have changed pnode-&gt;data-&gt;instance.private_size.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    node-&gt;data-&gt;instance.private_size = pnode-&gt;data-&gt;instance.private_size;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">class</span>-&gt;g_type = <span class="built_in">NODE_TYPE</span> (node);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">G_WRITE_UNLOCK</span> (&amp;type_rw_lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* stack all base class initialization functions, so we</span></span><br><span class="line"><span class="comment">   * call them in ascending order.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (bnode = node; bnode; bnode = <span class="built_in">lookup_type_node_I</span> (<span class="built_in">NODE_PARENT_TYPE</span> (bnode)))</span><br><span class="line">    <span class="keyword">if</span> (bnode-&gt;data-&gt;<span class="keyword">class</span>.class_init_base)</span><br><span class="line">      init_slist = <span class="built_in">g_slist_prepend</span> (init_slist, (gpointer) bnode-&gt;data-&gt;<span class="keyword">class</span>.class_init_base);</span><br><span class="line">  <span class="keyword">for</span> (slist = init_slist; slist; slist = slist-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">      GBaseInitFunc class_init_base = (GBaseInitFunc) slist-&gt;data;</span><br><span class="line"><span class="comment">// 从上往下调用base_class_init</span></span><br><span class="line">      <span class="built_in">class_init_base</span> (<span class="keyword">class</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">g_slist_free</span> (init_slist);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">G_WRITE_LOCK</span> (&amp;type_rw_lock);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_atomic_int_set</span> (&amp;node-&gt;data-&gt;<span class="keyword">class</span>.init_state, BASE_IFACE_INIT);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Before we initialize the class, base initialize all interfaces, either</span></span><br><span class="line"><span class="comment">   * from parent, or through our holder info</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  pnode = <span class="built_in">lookup_type_node_I</span> (<span class="built_in">NODE_PARENT_TYPE</span> (node));</span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((entries = <span class="built_in">CLASSED_NODE_IFACES_ENTRIES_LOCKED</span> (node)) != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">    i &lt; <span class="built_in">IFACE_ENTRIES_N_ENTRIES</span> (entries))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// interface相关，暂时略过</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_atomic_int_set</span> (&amp;node-&gt;data-&gt;<span class="keyword">class</span>.init_state, CLASS_INIT);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">G_WRITE_UNLOCK</span> (&amp;type_rw_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用class_init</span></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;data-&gt;<span class="keyword">class</span>.class_init)</span><br><span class="line">    node-&gt;data-&gt;<span class="keyword">class</span>.<span class="built_in">class_init</span> (<span class="keyword">class</span>, (gpointer) node-&gt;data-&gt;<span class="keyword">class</span>.class_data);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">G_WRITE_LOCK</span> (&amp;type_rw_lock);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_atomic_int_set</span> (&amp;node-&gt;data-&gt;<span class="keyword">class</span>.init_state, IFACE_INIT);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* finish initializing the interfaces through our holder info.</span></span><br><span class="line"><span class="comment">   * inherited interfaces are already init_state == INITIALIZED, because</span></span><br><span class="line"><span class="comment">   * they either got setup in the above base_init loop, or during</span></span><br><span class="line"><span class="comment">   * class_init from within type_add_interface_Wm() for this or</span></span><br><span class="line"><span class="comment">   * an ancestor type.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((entries = <span class="built_in">CLASSED_NODE_IFACES_ENTRIES_LOCKED</span> (node)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="comment">// interface 相关，略去</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_atomic_int_set</span> (&amp;node-&gt;data-&gt;<span class="keyword">class</span>.init_state, INITIALIZED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数主要：</p><ul><li>为当前要创建的结构 struct 的实例分配内存</li><li>如果有父类，就把父类的结构 struct 的实例复制到当前的结构 struct 的实例</li><li>从最顶层父类到自己，依次调用每一个 base_init 函数初始化当前的结构 struct 的实例</li><li>调用当前类的 class_init 函数初始化当前的结构 struct 的实例</li></ul><p>此外还可以发现创建的结构 struct 的实例中还含有与之关联的 GType 信息，那些类型检查宏会用到这些信息，这部分后面再单独写一篇文章介绍</p><p>关于上面的‘private size’：</p><ul><li>class_private_size 是通过 g_type_add_class_private 函数修改</li><li>而 instance.private_size 是通过 g_type_class_adjust_private_offset 函数修改</li></ul><p>class_private_size 用得比较少，instance.private_size 就是之前博客介绍的类的私有结构的 size，在 type_class_init_Wm 函数中会把父类的 instance.private_size 赋给子类，子类如果也想定义自己的私有结构，会在 class_intern_init 函数中调用 g_type_class_adjust_private_offset 中增加 instance.private_size。</p><h1 id="g-object-base-class-init"><a href="#g-object-base-class-init" class="headerlink" title="g_object_base_class_init"></a>g_object_base_class_init</h1><p>最后看一下 GObject 的 base_class_init 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_object_base_class_init</span> <span class="params">(GObjectClass *<span class="keyword">class</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GObjectClass *pclass = <span class="built_in">g_type_class_peek_parent</span> (<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t inherit HAS_DERIVED_CLASS flag from parent class */</span></span><br><span class="line">  <span class="keyword">class</span>-&gt;flags &amp;= ~CLASS_HAS_DERIVED_CLASS_FLAG;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pclass)</span><br><span class="line">    pclass-&gt;flags |= CLASS_HAS_DERIVED_CLASS_FLAG;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* reset instance specific fields and methods that don&#x27;t get inherited */</span></span><br><span class="line">  <span class="keyword">class</span>-&gt;construct_properties = pclass ? <span class="built_in">g_slist_copy</span> (pclass-&gt;construct_properties) : <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">class</span>-&gt;n_construct_properties = <span class="built_in">g_slist_length</span> (<span class="keyword">class</span>-&gt;construct_properties);</span><br><span class="line">  <span class="keyword">class</span>-&gt;get_property = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">class</span>-&gt;set_property = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">class</span>-&gt;pspecs = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">class</span>-&gt;n_pspecs = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要是做了一些拷贝工作，避免父子类中的指针指向同一个对象（因为创建结构 struct 的实例时会直接拷贝父类的结构 struct 的实例），比如把 construct_properties 复制一份，把 pspecs 置为空。base_init 大部分就是做这种工作，比如 gstreamer 中的 GstElement 的 base_init 就是拷贝 padtemplates，让父子类的 padtemplate 指向不同的对象，避免析构时多次释放。</p>]]></content>
      
      
      <categories>
          
          <category> gobject </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg之YUV像素格式</title>
      <link href="/2023/04/26/ffmpeg%E4%B9%8BYUV%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F/"/>
      <url>/2023/04/26/ffmpeg%E4%B9%8BYUV%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍几种 YUV 像素格式。像素格式规定了图像的色彩特性，比如使用哪种颜色空间（yuv、rgb），有几个颜色分量（3 个、4 个或其他），色彩位深（8 比特、10 比特等），此外像素格式要规定每个色彩分量的存储方式（是 planar 平面 还是 packed 交错）。</p><h2 id="yuv420p"><a href="#yuv420p" class="headerlink" title="yuv420p"></a>yuv420p</h2><p>这种像素格式是最常见的格式。yuv 是指 yuv 色彩空间，420 表示采样格式，每 4 个 y 共用一个 u 和一个 v，p 表示 planar，也就是 3 个分量分平面存储。</p><p>根据 u 和 v 分量的存储顺序，yuv420p 又可以分为 YV12 和 YU12，YV12 的存储顺序是先存储 y，然后存储 v，然后存储 u，而 YU12 的存储顺序是先存储 y，然后存储 u，然后存储 v，我见过有的资料也称 YU12 为 I420。</p><p>如果每个 y u v 分量都是 8 比特位深，也就是一字节，那么对于一个 4x4 大小的图像，YV12 的存储布局如下</p><p><img src="/images/ffmpeg%E4%B9%8BYUV%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F/RPJPbvdetossyixRUkucVIP9nUb.png"></p><p>图来自 <a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv420.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv420.html</a></p><p>注意上图 cr 分量在 cb 的前面，cb、cr 的含义等同于 U、V，所以它是 YV12。</p><p>从上图可以看到，不同的平面之间紧凑排列，没有额外的间距。但如果对 Y 分量的行设定了对齐参数，比如让 Y 一行的实际存储空间所占据的字节数对齐到 16，则此时 Y 的一行末尾可能会有多余的 padding 字节用于对齐，此时 U 和 V 分量的一行也要有对齐字节，他们的 padding 字节是 Y 的 padding 字节的一半。也即不论是否发生对齐，都要满足 <code>Y一行占据的字节数=U一行占据的字节数+V一行占据的字节数</code> 这个条件。</p><p>我们看看 ffmpeg 中 yuv420p 格式的 AVPixFmtDescriptor 结构，这个结构之前有篇文章介绍了它的字段的含义，这里不再赘述，可以发现这里其实是 YU12 格式，因为 U 在前面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = &#123;</span><br><span class="line">    [AV_PIX_FMT_YUV420P] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;yuv420p&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">1</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        .flags = AV_PIX_FMT_FLAG_PLANAR,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="YUYV-和-UYVY"><a href="#YUYV-和-UYVY" class="headerlink" title="YUYV 和 UYVY"></a>YUYV 和 UYVY</h2><p>这两种格式属于交错格式，也就是所有分量在一个平面中保存，他们的采样方式是 422，也就是每两个 Y 共用一个 U 和 V。对于一个 4x4 的图像，YUYV 格式存储布局如下：</p><p><img src="/images/ffmpeg%E4%B9%8BYUV%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F/Ps83b0Jvhofjv7xf3YQcGlihnef.png"></p><p>图来自 <a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuyv.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuyv.html</a></p><p>它的存储布局就像它的名字一样，按 Y U Y V 这样的存储顺序，这样恰好就是两个 Y 共用一个 U 和 V。类似的如果是 UYVY，那么就是 U Y V Y 这样的存储顺序。</p><p>类似的还有 YVYU、VYUY 存储格式，原理和上面一样，就是分量存储顺序变了一下。</p><p>ffmpeg 中 yuyv 格式的描述符如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = &#123;</span><br><span class="line">...</span><br><span class="line">    [AV_PIX_FMT_YUYV422] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;yuyv422&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">0</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="yuv422p"><a href="#yuv422p" class="headerlink" title="yuv422p"></a>yuv422p</h2><p>从这个格式的名字就知道，它是 422 采样，也就是两个 Y 共用一个 U 和 V，和上面 YUYV 一样，但是他多了一个 p，表示不是交错存储，而是分别存储每个分量。这里就不多介绍，直接看例子，对于一个 4x4 的图像，yuv422p 存储顺序如下：</p><p><img src="/images/ffmpeg%E4%B9%8BYUV%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F/GYobbbRRWoYLhmxrLDGcMsMynxf.png"></p><p>图来自 <a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv422p.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv422p.html</a></p><p>yuv422p 和 yuv420p 一样，如果 Y 的行宽进行了对齐处理，那么 U、V 也要有 padding byte，依然要求 <code>Y一行占据的字节数=U一行占据的字节数+V一行占据的字节数</code></p><p>yuv422p 的描述符如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    [AV_PIX_FMT_YUV422P] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;yuv422p&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">0</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        .flags = AV_PIX_FMT_FLAG_PLANAR,</span><br><span class="line">    &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="yuv420sp"><a href="#yuv420sp" class="headerlink" title="yuv420sp"></a>yuv420sp</h2><p>这种格式和 yuv420p 的区别是：yuv420sp 用两个平面来存储分量，即让 Y 分量一个平面，让 UV 分量共用一个平面。根据 UV 平面的存储顺序，又可以区分为 NV12 和 NV21 两种格式，NV12 的存储布局如下</p><p><img src="/images/ffmpeg%E4%B9%8BYUV%E5%83%8F%E7%B4%A0%E6%A0%BC%E5%BC%8F/GTHob863YoWak6xt29lcmI2gnQc.png"></p><p>图来自 <a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-nv12.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-nv12.html</a></p><p>所以 NV12 的 UV 平面是按照 U V U V 这样的存储顺序，而且可以发现，UV 平面的宽度和 Y 平面是一样的，此时如果 Y 平面的行宽有对齐要求，那么 UV 平面的 padding 字节和 Y 平面一样，就不再是 YV12&#x2F;YU12 时的一半了。</p><p>NV21 和 NV12 的区别是 UV 平面按照 V U V U 这样的顺序进行存储。</p><p>NV21 和 NV12 描述符如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[AV_PIX_FMT_NV12] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;nv12&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">1</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        .flags = AV_PIX_FMT_FLAG_PLANAR,</span><br><span class="line">    &#125;,</span><br><span class="line">    [AV_PIX_FMT_NV21] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;nv21&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">1</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        .flags = AV_PIX_FMT_FLAG_PLANAR,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>关于 yuv 像素格式就介绍到这里，像素格式本身并不复杂，就是各种名字眼花缭乱，同一种存储格式可能有不同的叫法，重点是要弄清楚不同格式它的存储方式是什么，这样遇到某个没见过的格式时看他的存储方式也能弄清楚它的含义是什么。</p><p>参考资料：</p><p><a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv420.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv420.html</a></p><p><a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuyv.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuyv.html</a></p><p><a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv422p.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-yuv422p.html</a></p><p><a href="https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-nv12.html">https://www.kernel.org/doc/html/v4.10/media/uapi/v4l/pixfmt-nv12.html</a></p><p><a href="https://blog.csdn.net/teachermei/article/details/127650824">https://blog.csdn.net/teachermei/article/details/127650824</a></p><p><a href="https://blog.csdn.net/yu540135101/article/details/107121769">https://blog.csdn.net/yu540135101/article/details/107121769</a></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> 媒体格式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 gdb 进行调试（初级）</title>
      <link href="/2023/04/26/%E4%BD%BF%E7%94%A8-gdb-%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/"/>
      <url>/2023/04/26/%E4%BD%BF%E7%94%A8-gdb-%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近使用了 gdb 对程序进行调试，使用体验非常好，有种相见恨晚的感觉。其实之前就知道这个工具，但是它是命令行工具没有图形界面，心里有种畏惧感所以一直没有使用。</p><p>使用 gdb 调试比之前加 log 调试要舒服太多了，后面进行调试时要以 gdb 调试为主，加 log 为辅助手段。这篇文章就简要记录一下目前用到的 gdb 调试方法，后面用到更高级的调试方法会继续更新。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>要想使用 gdb 进行调试，程序编译时必须带 <code>-g</code> 选项，比如 <code>gcc main.c -o main -g</code></p><p>启动调试，可以直接 <code>gdb exefile</code>，也可以先进入 gdb 然后在 gdb 命令行内执行 <code>file exefile</code> 来加载可执行文件，如果可执行文件是可调试的，那么会出现 <code>Reading symbols from xxx...done.</code></p><p>通过 run 命令开始执行程序，run 的简写为 r。如果没有设断点，run 之后会一直执行到程序结束。如果程序有命令行参数，则可在 run 的后面指定</p><p>除了 run 还可以通过 start 指令让程序开始运行，但是 start 会停在程序的 main 函数的最开始</p><p>设置断点通过 break 指令，简写为 b。设置断点可以是文件名加行号的方式，如 <code>b filename.c:122</code>，这适合工程很大，源文件很多的情况。还可以设置条件断点，让程序只有在一定条件下才会停下：<code>b filename.c:122 condition</code>，这个我没有使用过，就不细说。</p><p>查看断点是通过 <code>info breakpoints</code>，删除断点通过 <code>delete breakpoint_num</code>，<code>breakpoint_num</code> 是 <code>info breakpoints</code> 时打印出的 <code>Num</code></p><p>info 指令有很多子选项，比如 <code>info locals</code> 可以查看当前函数中的局部变量，<code>info frame</code> 查看当前函数调用栈，更多功能可以在 gdb 命令行中输入 info 查看</p><p>查看断点附近源码，通过 <code>list</code> 命令，简写为 <code>l</code>，这个功能我也很少用，基本上都是对着源码调试</p><p>查看当前函数调用栈通过 backtrace 指令，简写为 bt，这个指令也非常有用，可以方便的查看当前函数的调用层次，对于复杂的工程通过 bt 可以很快确定函数调用逻辑</p><p>单步调试通过 next 命令，简写为 n，每一个 next 会执行当前上下文&#x2F;函数单元内的一条语句，比如某个语句是函数调用，那么 next 会执行这个函数，而不会进入到函数里面，再比如某个 <code>if (statement)</code> 的 <code>statement</code> 是复杂的语句，那么 next 会执行整个 <code>statement</code>。还可以在 next 后面加数字，比如 <code>n 2</code>，表示往后执行两条语句再停下。next 在分析复杂函数的执行流程时很有用，通过 next 可以清晰的看到程序的每个 if 分支走了哪里。</p><p>单步调试的另一个指令是 step，这个指令比 next 要更细一些，他遇到函数时会进入函数，要想从函数中返回，即跳过后面的语句，可以通过 finish 指令，finish 会从当前函数调用点返回，并在下一条语句处停住</p><p>continue 指令是让程序执行到下个断点，简写为 c</p><p>skip 指令可以指定某个函数在 step 时不会进入，比如 <code>skip function hello</code>，那么在 step 时遇到 hello 函数将不会进入</p><p>查看变量通过 print 指令，简写为 p，比如 <code>p var</code>，如果 var 是 char 类型指针，那么 p 会把字符串内容打印出来。如果 var 是 int 类型指针，那么可以对他解引用然后打印 <code>p *var</code></p><p>除了查看变量，还可以设置变量，通过 set 指令，但是目前我还没有使用过这个变量，这里略过，等用到了再介绍</p><p>最后要退出调试可以通过 quit 指令，简写为 q</p><h2 id="value-optimized-out"><a href="#value-optimized-out" class="headerlink" title="value optimized out"></a>value optimized out</h2><p>使用 gdb 调试时，打印变量时可能会出现 <code>$30 = &lt;value optimized out&gt;</code> 的提示，这是因为编译器在编译时开了优化 <code>gcc -O3</code>，把变量优化掉了。</p><p>此时可以关闭优化使用 <code>gcc -O0</code> 重新编译，也可以使用加 log 方法进行辅助。新版本的 gcc 有个优化选项 <code>gcc -Og</code>，这个优化选项的意思是在不影响 debug 的前提下尽可能去做优化（但是这个选项可能还是会出现 <code>value optimized out</code>，此时使用 <code>gcc -O0</code>）。除了上面的思路，还可以给变量加 volatile 限定，编译器不会对被这个限定符修饰的变量做优化，但是其他变量的优化还是会做的。</p><p>除了优化导致 <code>value optimized out</code>，还可能由于变量覆盖导致 <code>value optimized out</code>，对于变量被覆盖时如何查看变量请参见 <a href="https://stackoverflow.com/questions/5497855/what-does-value-optimized-out-mean-in-gdb">What does <value optimized out> mean in gdb?</a> 。</p><p>参考资料：</p><p><a href="https://blog.csdn.net/chen1415886044/article/details/105094688">https://blog.csdn.net/chen1415886044/article/details/105094688</a></p><p><a href="https://stackoverflow.com/questions/5497855/what-does-value-optimized-out-mean-in-gdb">What does <value optimized out> mean in gdb?</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>auto和decltype</title>
      <link href="/2023/04/26/auto%E5%92%8Cdecltype/"/>
      <url>/2023/04/26/auto%E5%92%8Cdecltype/</url>
      
        <content type="html"><![CDATA[<p>auto 和 decltype 是 C++ 的类型推导工具，利用好这两个工具能方便平时的编码工作。这篇博客总结一下自己对于 auto 和 decltype 的理解。</p><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>auto 推导出现在变量定义中，通过赋值语句右边的值的类型来推断左边要定义的变量的类型。</p><p>广义上变量定义包括显式的变量定义语句和函数的参数传递，所以模板函数的模板参数推断和变量定义语句中的 auto 推导的原理是一致的，下面介绍的关于 auto 推导的原理也适用于模板函数的模板参数推断。</p><p>先看不带任何修饰的 auto 推导。当 auto 不带任何修饰时，会把右边的变量类型经过退化（decay）后得到的类型作为 auto 的类型，退化操作包括：</p><ul><li>去掉引用</li><li>去掉顶层 const</li><li>数组自动转换为指针、函数名自动转换为指针</li></ul><p>看下面几个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i , &amp;j = i;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> k, &amp;l = k;</span><br><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> b = j; <span class="comment">// 去掉引用                 auto为int</span></span><br><span class="line"><span class="keyword">auto</span> b = k; <span class="comment">// 去掉顶层const            auto为int</span></span><br><span class="line"><span class="keyword">auto</span> b = l; <span class="comment">// 去掉引用、去掉顶层const    auto为int</span></span><br><span class="line"><span class="keyword">auto</span> b = a; <span class="comment">// 数组自动转换为指针         auto为char*</span></span><br></pre></td></tr></table></figure><p>第一条操作：去掉引用。这个很好理解，因为如果右边是引用，那么应当将右边变量视为被他引用的变量，这是引用的语义，引用是变量的别名。右边是引用并不意味着左边要定义的变量也是引用，将左边推断为引用显然是不合理的</p><p>第二条操作：去掉顶层 const。由于 auto 没有加任何修饰符，那么此时不会把左边推断为引用，所以是值传递，既然是值传递，那么右边是否是顶层 const 对左边也没有影响，同样右边是 const 并不意味着左边也是 const</p><p>第三条操作：假设右边是一个数组，如果 auto 推断时不进行数组转换为指针，那么左边推断得到的类型也是数组，就出现了数组赋值给数组的操作。这个操作在原有的 C++ 赋值规则中是不允许的，所以要进行转换，语言的设计要满足一致性，新引入的规则不应该和已有的规则矛盾。函数名自动转换为指针也类似。</p><p>再看带修饰的 auto 推导。先看不带&amp;的情况，此时和上面不带任何修饰的 auto 推导没有本质区别，给 auto 加非引用修饰只是表示我们能确定左边类型的部分信息，看下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> * i = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">auto</span> t = i; <span class="comment">// auto是int const *</span></span><br><span class="line"><span class="keyword">auto</span> * s = i; <span class="comment">// auto是int const</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> * k = i; <span class="comment">// auto是int</span></span><br></pre></td></tr></table></figure><p>所以此时还是会对右边类型进行退化处理，然后将退化后的类型“减去”左边的已知部分得到 auto。此时 auto 就像一个<strong>占位符</strong>一样。</p><p>带修饰的 auto 推导和不带修饰的 auto 推导还是有一点区别：带修饰的 auto 推导可以显式的添加 const 来把变量声明为顶层 const，但是不带修饰的 auto 由于类型退化不可能推断得到顶层 const；此外带修饰的 const 还可以让左边类型比右边类型更严格，比如加上额外的 const 修饰</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> i = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> *<span class="type">const</span> k = i; <span class="comment">// 左边类型比右边更严格</span></span><br></pre></td></tr></table></figure><p>最后分析带&amp;的 auto 推导。给 auto 加上&amp;修饰后，表示左边想要定义一个引用，那么此时还需要对右边类型做退化吗？</p><p>首先，引用要去掉，因为始终应该把右边的引用视为他绑定的对象，也就是右边的类型应该追溯到真正对象的类型，这一点在所有 auto 推导中都是一样的</p><p>那剩余两个操作，去掉 const 和自动转换是否要执行呢？显然是不可以的，因为此时定义的是引用，而引用的语义是变量的别名，做了自动转换后引用指向的是转换后的类型，显然是错误的。看下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> i = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp; t = i; <span class="comment">// auto是int *const，不能去掉const</span></span><br><span class="line">             <span class="comment">// 如果去掉const， 那么t是int *&amp;，一个非const绑定到const，非法</span></span><br></pre></td></tr></table></figure><p>所以带&amp;的 auto 推导不会执行退化的后两步，而是把右边类型去除引用后加上左边修饰的引用组成一个引用类型。</p><p>再看几个例子加深一下印象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> b = a; <span class="comment">// b 是int*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; c = a; <span class="comment">// auto是int[3]，b是 int(&amp;)[3]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> d = f; <span class="comment">// auto是函数指针 int(*)()</span></span><br><span class="line"><span class="keyword">auto</span>&amp; e = f; <span class="comment">// auto是函数类型，e是函数引用</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i; <span class="comment">// j是int类型</span></span><br><span class="line"><span class="keyword">auto</span>&amp; k = i; <span class="comment">// k是int const&amp;类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* <span class="type">const</span> p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">auto</span> q = p; <span class="comment">// q是int const*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; r = p; <span class="comment">// q是int const* const &amp;</span></span><br></pre></td></tr></table></figure><p>最后来看看 auto &amp;&amp;。auto &amp;&amp;被称为万能引用，他和模板函数中 T&amp;&amp;是一样的，可以接受左值或者右值参数，看下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; a = <span class="number">1</span>; <span class="comment">// 接受右值 auto是int，a是int&amp;&amp;类型</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; c = b; <span class="comment">// 接受左值，auto是int&amp;，根据引用折叠，c是int&amp;类型</span></span><br></pre></td></tr></table></figure><p>auto&amp;&amp;推断时</p><ul><li>如果右边是左值，先按照 auto&amp;进行推断，推断得到 auto 后，在 auto 右边加一个&amp;组合成新的 auto，然后将这个新 auto 和&amp;&amp;组合，所以实际的类型是 auto&amp; &amp;&amp;，这里的 auto 是按照常规的 auto&amp;进行推断得到的，而&amp; &amp;&amp;最终会折叠为&amp;，所以当右边是左值时 audo&amp;&amp;等价于 auto&amp;</li><li>如果右边是右值（包括纯右值和将亡值），先按照常规的 auto&amp;进行推断，推断得到 auto 之后不做处理，直接和&amp;&amp;组合，所以最后的类型是 auto &amp;&amp;</li></ul><p>auto&amp;&amp;推断时，右边类型也不会做退化的后两步，因为也是引用推断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> &amp;&amp; j = i; <span class="comment">// auto是 int const&amp;, j经过折叠是int const&amp;</span></span><br></pre></td></tr></table></figure><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>decltype 是另一种类型推导工具，他对表达式、变量进行推导，把表达式结果的类型、变量的类型作为自己的结果。</p><p>如果 decltype 中只有单个变量，那么 decltype 推断得到的类型就是该变量在源码定义时的类型，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) k = i; <span class="comment">// k是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) k = i; <span class="comment">// k是int const类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* <span class="type">const</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) k = i; <span class="comment">// k是int const* const类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) k = i; <span class="comment">// k是int &amp;&amp;类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) k = i; <span class="comment">// k是int &amp;类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> A a;</span><br><span class="line"><span class="keyword">decltype</span>(a.i) k = i; <span class="comment">// k是int类型，不是const int</span></span><br></pre></td></tr></table></figure><p>注意‘单个变量’包含 <code>a-&gt;b, a.b</code> 这种形式</p><p>所有其他的情况，decltype 推断规则如下：假设 decltype 中的表达式的类型为 T</p><ul><li>如果 decltype 中的表达式结果是左值，那么 decltype 推断得到的类型是 T&amp;</li><li>如果 decltype 中的表达式结果是将亡值，那么 decltype 推断得到的类型是 T&amp;&amp;</li><li>如果 decltype 中的表达式结果是纯右值，那么 decltype 推断得到的类型是 T</li></ul><p>左值、将亡值、纯右值的概念可以参见另一篇文章。</p><p>我们通过具体例子分析上面的规则。</p><p>第一条规则。<code>++p</code> 返回的是引用，即 <code>int *&amp;</code>，是左值，所以 decltype 推断是 <code>int *&amp; &amp;</code>，折叠得到 <code>int *&amp;</code>。<code>p[0]</code> 返回的也是引用，即 <code>int&amp;</code>，decltype 推断是 <code>int &amp; &amp;</code>，折叠得到 <code>int &amp;</code>。<code>f2()</code> 返回的也是引用，即 <code>int&amp;</code>，是左值，decltype 推断是 <code>int &amp; &amp;</code>，折叠得到 <code>int &amp;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="keyword">decltype</span>(++p) <span class="comment">// int *&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(p[<span class="number">0</span>]) <span class="comment">// int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f2</span>()) <span class="comment">// int&amp;</span></span><br></pre></td></tr></table></figure><p>第二条规则。<code>f1()</code> 返回将亡值，所以 decltype 推断得到 <code>int&amp;&amp; &amp;&amp;</code>，折叠得到 <code>int&amp;&amp;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f1</span>()) <span class="comment">/// int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>第三条规则。<code>i+0</code> 返回纯右值，是 int 类型，所以 decltype 推断得到 int</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i+<span class="number">0</span>)  <span class="comment">// int</span></span><br></pre></td></tr></table></figure><p>在 decltype 中最让人迷惑的是括号对 decltype 推断的影响。</p><p>括号运算符本身不对括号内表达式结果的属性做任何修改，就好像没有括号一样，如果括号内表达式是左值、将亡值、纯右值，那么括号表达式的结果也是左值、将亡值、纯右值，但是有了括号之后就是表达式了，不能再使用之前单个变量的推导规则（哪怕括号内只有一个变量）。</p><p>还是通过具体例子分析括号对 decltype 推断的影响。</p><p>下面的例子中，对单个变量加了括号，此时 decltype 内部表达式的类型还是 <code>int</code> <code>int&amp;</code> <code>int&amp;&amp;</code>，但是加了括号之后需要按表达式的规则进行推断，由于他们都是左值（括号不会改变内部表达式结果的值属性），所以要加&amp;，即 <code>int&amp;</code> <code>int&amp; &amp;</code> <code>int&amp;&amp; &amp;</code>，经过折叠就是 <code>int&amp;</code> <code>int&amp;</code> <code>int&amp;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp; j = i;</span><br><span class="line"><span class="type">int</span>&amp;&amp; k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>((i))  <span class="comment">// int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>((j))  <span class="comment">// int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>((k))  <span class="comment">// int&amp;</span></span><br></pre></td></tr></table></figure><p>下面例子则展示了括号对 <code>a.b</code> 推断的影响，此时要把 a 的类型考虑在内，即 <code>a.i</code> 得到 <code>int const&amp;</code> 类型，因为 a 是 const，而 <code>.</code> 运算符返回引用，最后 decltype 是 <code>int const&amp; &amp;</code>，折叠得到 <code>int const&amp;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> A a;</span><br><span class="line"><span class="keyword">decltype</span>((a.i)) k = i; <span class="comment">// k是int const&amp;类型</span></span><br></pre></td></tr></table></figure><p>下面的例子中，f1()返回将亡值，括号之后还是将亡值，decltype 推断时会加&amp;&amp;，即 <code>int&amp;&amp; &amp;&amp;</code>，折叠后就是 <code>int&amp;&amp;</code>，f2()返回左值引用，括号之后还是左值引用，decltype 推断时会加&amp;，即 <code>int&amp; &amp;</code>，折叠后就是 <code>int&amp;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>((<span class="built_in">f1</span>())) <span class="comment">// int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>((<span class="built_in">f2</span>())) <span class="comment">// int&amp;</span></span><br></pre></td></tr></table></figure><p>括号遇到纯右值的情况比较简单，就好像没有括号一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((<span class="number">1</span>+i)) <span class="comment">// int</span></span><br><span class="line"><span class="keyword">decltype</span>((<span class="number">1</span>))   <span class="comment">// int</span></span><br></pre></td></tr></table></figure><p>最后注意 decltype 推断时不需要像 auto 一样做退化处理，上面分析时是没有对表达式结果的类型做退化处理的。</p><p>参考资料：</p><p><a href="https://magodo.github.io/cpp-auto-decltype/">https://magodo.github.io/cpp-auto-decltype/</a></p><p><a href="http://thbecker.net/articles/auto_and_decltype/section_01.html">http://thbecker.net/articles/auto_and_decltype&#x2F;section_01.html</a></p><p><a href="https://learn.microsoft.com/en-us/cpp/cpp/decltype-cpp?view=msvc-170">https://learn.microsoft.com/en-us/cpp/cpp/decltype-cpp?view=msvc-170</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++新特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg AVFrame buffer的分配与对齐</title>
      <link href="/2023/04/23/ffmpeg-AVFrame-buffer%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%AF%B9%E9%BD%90/"/>
      <url>/2023/04/23/ffmpeg-AVFrame-buffer%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<p>之前有篇文章介绍了 AVFrame 的一些基本方法，最近遇到了需要确认 AVFrame 中数据的 stride 是否对齐的问题，于是又回过头去把 AVFrame 内存分配过程研究了一下，这篇文章就介绍一下 AVFrame buffer 的分配与对齐。</p><p>在通过 <code>AVFrame *av_frame_alloc(void)</code> 函数分配 AVFrame 之后，需要通过 av_frame_get_buffer 函数分配用于存储 YUV 或者 RGB 格式图像的内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_frame_get_buffer</span><span class="params">(AVFrame *frame, <span class="type">int</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;format &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;width &gt; <span class="number">0</span> &amp;&amp; frame-&gt;height &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_video_buffer</span>(frame, align);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (frame-&gt;nb_samples &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             (<span class="built_in">av_channel_layout_check</span>(&amp;frame-&gt;ch_layout)</span><br><span class="line">...</span><br><span class="line">             ))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_audio_buffer</span>(frame, align);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_frame_get_buffer 函数内部调用 get_video_buffer 函数，下面就以 get_video_buffer 函数为研究对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_video_buffer</span><span class="params">(AVFrame *frame, <span class="type">int</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVPixFmtDescriptor *desc = <span class="built_in">av_pix_fmt_desc_get</span>(frame-&gt;format);</span><br><span class="line">    <span class="type">int</span> ret, i, padded_height, total_size;</span><br><span class="line">    <span class="type">int</span> plane_padding = <span class="built_in">FFMAX</span>(<span class="number">16</span> + <span class="number">16</span><span class="comment">/*STRIDE_ALIGN*/</span>, align);</span><br><span class="line">    <span class="type">ptrdiff_t</span> linesizes[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> sizes[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!desc)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_check_size</span>(frame-&gt;width, frame-&gt;height, <span class="number">0</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;linesize[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (align &lt;= <span class="number">0</span>)</span><br><span class="line">            align = <span class="number">32</span>; <span class="comment">/* STRIDE_ALIGN. Should be av_cpu_max_align() */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=align; i+=i) &#123;</span><br><span class="line">            ret = <span class="built_in">av_image_fill_linesizes</span>(frame-&gt;linesize, frame-&gt;format,</span><br><span class="line">                                          <span class="built_in">FFALIGN</span>(frame-&gt;width, i));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(frame-&gt;linesize[<span class="number">0</span>] &amp; (align<span class="number">-1</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span> &amp;&amp; frame-&gt;linesize[i]; i++)</span><br><span class="line">            frame-&gt;linesize[i] = <span class="built_in">FFALIGN</span>(frame-&gt;linesize[i], align);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        linesizes[i] = frame-&gt;linesize[i];</span><br><span class="line"></span><br><span class="line">    padded_height = <span class="built_in">FFALIGN</span>(frame-&gt;height, <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_fill_plane_sizes</span>(sizes, frame-&gt;format,</span><br><span class="line">                                         padded_height, linesizes)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    total_size = <span class="number">4</span>*plane_padding;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sizes[i] &gt; INT_MAX - total_size)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        total_size += sizes[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame-&gt;buf[<span class="number">0</span>] = <span class="built_in">av_buffer_alloc</span>(total_size);</span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_fill_pointers</span>(frame-&gt;data, frame-&gt;format, padded_height,</span><br><span class="line">                                      frame-&gt;buf[<span class="number">0</span>]-&gt;data, frame-&gt;linesize)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;data[i])</span><br><span class="line">            frame-&gt;data[i] += i * plane_padding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame-&gt;extended_data = frame-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AVPixFmtDescriptor"><a href="#AVPixFmtDescriptor" class="headerlink" title="AVPixFmtDescriptor"></a>AVPixFmtDescriptor</h2><p>上面函数的第一步是查找 AVPixFmtDescriptor，AVPixFmtDescriptor 中有格式的存储信息，这些信息配合宽度高度可以计算需要多大的存储空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVPixFmtDescriptor</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">uint8_t</span> nb_components;  <span class="comment">///&lt; The number of components each pixel has, (1-4)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Amount to shift the luma width right to find the chroma width.</span></span><br><span class="line"><span class="comment">     * For YV12 this is 1 for example.</span></span><br><span class="line"><span class="comment">     * chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w)</span></span><br><span class="line"><span class="comment">     * The note above is needed to ensure rounding up.</span></span><br><span class="line"><span class="comment">     * This value only refers to the chroma components.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint8_t</span> log2_chroma_w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Amount to shift the luma height right to find the chroma height.</span></span><br><span class="line"><span class="comment">     * For YV12 this is 1 for example.</span></span><br><span class="line"><span class="comment">     * chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h)</span></span><br><span class="line"><span class="comment">     * The note above is needed to ensure rounding up.</span></span><br><span class="line"><span class="comment">     * This value only refers to the chroma components.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint8_t</span> log2_chroma_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Combination of AV_PIX_FMT_FLAG_... flags.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint64_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Parameters that describe how pixels are packed.</span></span><br><span class="line"><span class="comment">     * If the format has 1 or 2 components, then luma is 0.</span></span><br><span class="line"><span class="comment">     * If the format has 3 or 4 components:</span></span><br><span class="line"><span class="comment">     *   if the RGB flag is set then 0 is red, 1 is green and 2 is blue;</span></span><br><span class="line"><span class="comment">     *   otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If present, the Alpha channel is always the last component.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVComponentDescriptor comp[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alternative comma-separated names.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *alias;</span><br><span class="line">&#125; AVPixFmtDescriptor;</span><br></pre></td></tr></table></figure><ul><li><code>nb_components</code> 当前格式有多少个分量</li><li><code>log2_chroma_w</code> 色度分量的宽度 &#x3D; 亮度分量的宽度 &gt;&gt; log2_chroma_w，比如 yuv420p 格式，U、V 分量的宽度是 Y 分量的宽度的一半，那这个值就是 1</li><li><code>log2_chroma_h</code> 色度分量的高度 &#x3D; 亮度分量的高度 &gt;&gt; log2_chroma_w，和上面一样，比如 YUV420 格式，U、V 分量的宽度是 Y 分量的宽度的一半，那这个值就是 1</li><li><code>AVComponentDescriptor</code> 是对每个不同分量的存储信息的描述</li></ul><p>AVComponentDescriptor 结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVComponentDescriptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Which of the 4 planes contains the component.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> plane;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of elements between 2 horizontally consecutive pixels.</span></span><br><span class="line"><span class="comment">     * Elements are bits for bitstream formats, bytes otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of elements before the component of the first pixel.</span></span><br><span class="line"><span class="comment">     * Elements are bits for bitstream formats, bytes otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of least significant bits that must be shifted away</span></span><br><span class="line"><span class="comment">     * to get the value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of bits in the component.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">&#125; AVComponentDescriptor;</span><br></pre></td></tr></table></figure><ul><li><code>plane</code> 当前分量在那个平面上，比如 yuv420p 就分三个平面来存储不同的分量，那么 plane 分别是 0 1 2，而 yuyv422 是把三个分量在一个平面上存储，那么 plane 分别是 0 0 0</li><li><code>step</code> 水平方向相邻两个像素点之间距离的字节数（如果是比特流类型则是比特数），注意他指的是相同分量的像素点，对于 yuv420p 这种分平面的格式来说，step 是 1 1 1，对 yuyv422 这种交错存储在一个平面的格式，step 是 2 4 4，因为他的存储格式是先保存一个像素点的 YUV 再保存下一个像素点的 YUV，比如 y u y v y u y v …，可以看到 y 之间相差两字节，u 和 v 都是相差 4 字节</li><li><code>offset</code> 分量的第一个像素离起始地址的偏移，以上面的 yuyv422 交错存储格式，y 的 offset 是 0，u 的 offset 是 1，v 的 offset 是 3</li><li><code>shift</code> 这个参数一般用在非 8 比特的格式</li><li><code>depth</code> 像素的位深，比如 8 比特、10 比特</li></ul><p>具体看看 yuv420p 和 yuyv422 的 AVPixFmtDescriptor</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = &#123;</span><br><span class="line">    [AV_PIX_FMT_YUV420P] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;yuv420p&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">1</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        .flags = AV_PIX_FMT_FLAG_PLANAR,</span><br><span class="line">    &#125;,</span><br><span class="line">    [AV_PIX_FMT_YUYV422] = &#123;</span><br><span class="line">        .name = <span class="string">&quot;yuyv422&quot;</span>,</span><br><span class="line">        .nb_components = <span class="number">3</span>,</span><br><span class="line">        .log2_chroma_w = <span class="number">1</span>,</span><br><span class="line">        .log2_chroma_h = <span class="number">0</span>,</span><br><span class="line">        .comp = &#123;</span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* Y */</span></span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* U */</span></span><br><span class="line">            &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span> &#125;,        <span class="comment">/* V */</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>了解了具体格式后再看剩下的代码。</p><p>av_image_check_size 函数就是检查宽高是否合理，不再赘述。</p><p>av_image_fill_linesizes 函数则是计算每个平面的 linesize，linesize 就是行宽，很多编码器都要求输入 frame 的 linesize 对齐到 16 或者 32，经过对齐之后的 linesize 一般不等于图像的宽度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_image_fill_linesizes</span><span class="params">(<span class="type">int</span> linesizes[<span class="number">4</span>], <span class="keyword">enum</span> AVPixelFormat pix_fmt, <span class="type">int</span> width)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line">    <span class="type">const</span> AVPixFmtDescriptor *desc = <span class="built_in">av_pix_fmt_desc_get</span>(pix_fmt);</span><br><span class="line">    <span class="type">int</span> max_step     [<span class="number">4</span>];       <span class="comment">/* max pixel step for each plane */</span></span><br><span class="line">    <span class="type">int</span> max_step_comp[<span class="number">4</span>];       <span class="comment">/* the component for each plane which has the max pixel step */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(linesizes, <span class="number">0</span>, <span class="number">4</span>*<span class="built_in">sizeof</span>(linesizes[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!desc || desc-&gt;flags &amp; AV_PIX_FMT_FLAG_HWACCEL)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_image_fill_max_pixsteps</span>(max_step, max_step_comp, desc);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = <span class="built_in">image_get_linesize</span>(width, i, max_step[i], max_step_comp[i], desc)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        linesizes[i] = ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_image_fill_linesizes 先通过 av_image_fill_max_pixsteps 获取相邻像素间的 step，其实就是上面 AVComponentDescriptor 中的 step</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_image_fill_max_pixsteps</span><span class="params">(<span class="type">int</span> max_pixsteps[<span class="number">4</span>], <span class="type">int</span> max_pixstep_comps[<span class="number">4</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> AVPixFmtDescriptor *pixdesc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">memset</span>(max_pixsteps, <span class="number">0</span>, <span class="number">4</span>*<span class="built_in">sizeof</span>(max_pixsteps[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span> (max_pixstep_comps)</span><br><span class="line">        <span class="built_in">memset</span>(max_pixstep_comps, <span class="number">0</span>, <span class="number">4</span>*<span class="built_in">sizeof</span>(max_pixstep_comps[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">const</span> AVComponentDescriptor *comp = &amp;(pixdesc-&gt;comp[i]);</span><br><span class="line">        <span class="keyword">if</span> (comp-&gt;step &gt; max_pixsteps[comp-&gt;plane]) &#123;</span><br><span class="line">            max_pixsteps[comp-&gt;plane] = comp-&gt;step;</span><br><span class="line">            <span class="keyword">if</span> (max_pixstep_comps)</span><br><span class="line">                max_pixstep_comps[comp-&gt;plane] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过 image_get_linesize 计算未对齐时的 linesize</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">image_get_linesize</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> plane,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">int</span> max_step, <span class="type">int</span> max_step_comp,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> AVPixFmtDescriptor *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s, shifted_w, linesize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!desc)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (width &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    s = (max_step_comp == <span class="number">1</span> || max_step_comp == <span class="number">2</span>) ? desc-&gt;log2_chroma_w : <span class="number">0</span>;</span><br><span class="line">    shifted_w = ((width + (<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>)) &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (shifted_w &amp;&amp; max_step &gt; INT_MAX / shifted_w)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    linesize = max_step * shifted_w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc-&gt;flags &amp; AV_PIX_FMT_FLAG_BITSTREAM)</span><br><span class="line">        linesize = (linesize + <span class="number">7</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> linesize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面计算 linesize 对于不同分量不同平面，比如 yuv420p 格式比较好理解，但是对于所有分量同一平面的交错格式，比如 yuyv422，可能不是那么好理解，一起算算看：</p><p>在 av_image_fill_max_pixsteps 之后，max_step 为 4 0 0 0，max_step_comp 为 2 0 0 0，因为 yuyv422 只有一个平面，所以函数中只会更新 max_pixsteps[0]和 max_pixstep_comps[0]。读者可以自己验证一下。</p><p>在 image_get_linesize 中，由于只有一个平面，所以只有 linesizes[0]非 0，对第 0 个平面，输入参数 max_step 为 4，max_step_comp 为 2，那么 s 为 log2_chroma_w，也就是 1，shifted_w 就是 width&#x2F;2，最后 linesize 就是 2*width，刚好就是 yuyv422 存储一行需要的字节数。看来这种计算方法确实是经过精心设计的。</p><p>注意上面函数传给 av_image_fill_linesizes 的 width 是 <code>FFALIGN(frame-&gt;width, i)</code>，也就是会把 <code>frame-&gt;width</code> 对齐到 1 或 2 或 4…或 align 的整数倍</p><p>看下面这个循环，会在 <code>!(frame-&gt;linesize[0] &amp; (align-1))</code> 时退出，而这个条件其实是 frame-&gt;linesize[0]整除 align，也就是会在 1 或 2 或 4…或 align 这些对齐参数中，找到最小的让 frame-&gt;linesize[0]整除 align 的对齐参数。这样做是为了节约空间，让对齐得到宽度尽可能和 frame-&gt;width 接近</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=align; i+=i) &#123;</span><br><span class="line">            ret = <span class="built_in">av_image_fill_linesizes</span>(frame-&gt;linesize, frame-&gt;format,</span><br><span class="line">                                          <span class="built_in">FFALIGN</span>(frame-&gt;width, i));</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">if</span> (!(frame-&gt;linesize[<span class="number">0</span>] &amp; (align<span class="number">-1</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通过 av_image_fill_linesizes 计算 linesize 后，会进行下面的对齐操作，这一步把 linesize 进行对齐，而上面是把 frame-&gt;width 进行对齐</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span> &amp;&amp; frame-&gt;linesize[i]; i++)</span><br><span class="line">            frame-&gt;linesize[i] = <span class="built_in">FFALIGN</span>(frame-&gt;linesize[i], align);</span><br></pre></td></tr></table></figure><p>除了对宽度进行对齐，还会对高度进行对齐</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">padded_height = <span class="built_in">FFALIGN</span>(frame-&gt;height, <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_fill_plane_sizes</span>(sizes, frame-&gt;format,</span><br><span class="line">                                         padded_height, linesizes)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure><p>padded_height 就是把高度对齐到 32，av_image_fill_plane_sizes 则是计算每个平面需要的 size</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_image_fill_plane_sizes</span><span class="params">(<span class="type">size_t</span> sizes[<span class="number">4</span>], <span class="keyword">enum</span> AVPixelFormat pix_fmt,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> height, <span class="type">const</span> <span class="type">ptrdiff_t</span> linesizes[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, has_plane[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> AVPixFmtDescriptor *desc = <span class="built_in">av_pix_fmt_desc_get</span>(pix_fmt);</span><br><span class="line">    <span class="built_in">memset</span>(sizes    , <span class="number">0</span>, <span class="built_in">sizeof</span>(sizes[<span class="number">0</span>])*<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    sizes[<span class="number">0</span>] = linesizes[<span class="number">0</span>] * (<span class="type">size_t</span>)height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc-&gt;flags &amp; AV_PIX_FMT_FLAG_PAL) &#123;</span><br><span class="line">        sizes[<span class="number">1</span>] = <span class="number">256</span> * <span class="number">4</span>; <span class="comment">/* palette is stored here as 256 32 bits words */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        has_plane[desc-&gt;comp[i].plane] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">4</span> &amp;&amp; has_plane[i]; i++) &#123;</span><br><span class="line">        <span class="type">int</span> h, s = (i == <span class="number">1</span> || i == <span class="number">2</span>) ? desc-&gt;log2_chroma_h : <span class="number">0</span>;</span><br><span class="line">        h = (height + (<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>) &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (linesizes[i] &gt; SIZE_MAX / h)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        sizes[i] = (<span class="type">size_t</span>)h * linesizes[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_image_fill_plane_sizes 就是把 linesizes 和 height 相乘计算 plane size，同样对于 yuv420p 这种高度也是降采样的格式需要考虑 log2_chroma_h 参数</p><p>平面之间还会有一个 plane_padding 大小的间距，这个可能是避免平面之间连续，但是具体作用我也不清楚。计算总的 size 是将每个平面的 size 和 plane_padding 加起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total_size = <span class="number">4</span>*plane_padding;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sizes[i] &gt; INT_MAX - total_size)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        total_size += sizes[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>计算完总 size 后会分配一整块大的 buffer，然后通过 av_image_fill_pointers 函数将不同平面的 data 指针指向这个大 buffer 的不同部分。av_image_fill_pointers 让 data[0]指向 buffer 起始地址，后续的 buffer 则依次加上 plane size 递增</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_image_fill_pointers</span><span class="params">(<span class="type">uint8_t</span> *data[<span class="number">4</span>], <span class="keyword">enum</span> AVPixelFormat pix_fmt, <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">uint8_t</span> *ptr, <span class="type">const</span> <span class="type">int</span> linesizes[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line">    <span class="type">ptrdiff_t</span> linesizes1[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> sizes[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        linesizes1[i] = linesizes[i];</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_image_fill_plane_sizes</span>(sizes, pix_fmt, height, linesizes1);</span><br><span class="line"></span><br><span class="line">    data[<span class="number">0</span>] = ptr;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">4</span> &amp;&amp; sizes[i]; i++)</span><br><span class="line">        data[i] = data[i - <span class="number">1</span>] + sizes[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后对 data 指针的进行调整，加上之前说的 plane_padding</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;data[i])</span><br><span class="line">            frame-&gt;data[i] += i * plane_padding;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里就把 buffer 对齐介绍完了，可以看到 ffmpeg 在分配 buffer 的时候会把宽度、linesize、高度进行对齐，同时 plane 之间还会有一个 padding 间距。</p><p>最后再看看这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_image_get_buffer_size</span><span class="params">(<span class="keyword">enum</span> AVPixelFormat pix_fmt,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret, i;</span><br><span class="line">    <span class="type">int</span> linesize[<span class="number">4</span>];</span><br><span class="line">    <span class="type">ptrdiff_t</span> aligned_linesize[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> sizes[<span class="number">4</span>];</span><br><span class="line">    <span class="type">const</span> AVPixFmtDescriptor *desc = <span class="built_in">av_pix_fmt_desc_get</span>(pix_fmt);</span><br><span class="line">    <span class="keyword">if</span> (!desc)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_image_check_size</span>(width, height, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_image_fill_linesizes</span>(linesize, pix_fmt, width);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        aligned_linesize[i] = <span class="built_in">FFALIGN</span>(linesize[i], align);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_image_fill_plane_sizes</span>(sizes, pix_fmt, height, aligned_linesize);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sizes[i] &gt; INT_MAX - ret)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        ret += sizes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是计算 buffer size，基本流程和上面 get_video_buffer 函数是一样的，都有 av_image_check_size、av_image_fill_linesizes、对齐 linesize、av_image_fill_plane_sizes 步骤，但是 get_video_buffer 的对齐比 av_image_get_buffer_size 更严格，比 av_image_get_buffer_size 多了宽度对齐、高度对齐、plane padding。</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>move和forward</title>
      <link href="/2023/04/22/move%E5%92%8Cforward/"/>
      <url>/2023/04/22/move%E5%92%8Cforward/</url>
      
        <content type="html"><![CDATA[<p>之前的文章介绍了右值引用和将亡值，这篇博客谈一谈从右值引用引申出的移动和转发。</p><p>之前说过，左值引用和右值引用本质都是指针，所以可以用 static_cast 将他们进行互相转换。但是一般很少直接用 static_cast 进行转换，而是使用语义性更强的 move&#x2F;forward 获得输入的左值&#x2F;右值参数的左值引用&#x2F;将亡值。</p><p>move 的例子如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;j = i;</span><br><span class="line"><span class="type">int</span> &amp;&amp;k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">move</span>(i);</span><br><span class="line">std::<span class="built_in">move</span>(j);</span><br><span class="line">std::<span class="built_in">move</span>(k);</span><br><span class="line">std::<span class="built_in">move</span>(<span class="number">0</span>); <span class="comment">// 上面move返回的都是将亡值</span></span><br></pre></td></tr></table></figure><p>move 函数会返回输入的左值、右值参数的将亡值，move 函数实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE <span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type _Up;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Up&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入参数是模板参数的右值引用，也就是万能引用，表明 move 可以接受左值或者右值参数。万能引用经过模板参数推导后会发生引用折叠，最后 <code>__t</code> 一定是左值或者右值引用之一，以上面的代码为例</p><ul><li>输入为 i、j、k，那么 <code>_Tp</code> 推断 int &amp;，<code>__t</code> 最后折叠为 int &amp;类型</li><li>输入为 0，那么 <code>_Tp</code> 推断 int，<code>__t</code> 最后是 int &amp;&amp;类型</li></ul><p>在知道 <code>_Tp</code> 如何推断之后，就可以很轻松的理解上面的代码了。先看返回值，<code>typename remove_reference&lt;_Tp&gt;::type&amp;&amp;</code> 表示将 <code>_Tp</code> 去除引用后的类型加上右值引用，则返回值一定是右值引用，这和 move 的语义相符，就是返回将亡值。函数体中就是用 static_cast 将输入的不管是左值还是右值引用都强制转换为 <code>typename remove_reference&lt;_Tp&gt;::type&amp;&amp;</code>，也就是右值引用。</p><p>所以 move 的作用就是获得输入参数的将亡值，仅此而已。</p><p>无论输入参数是左值还是右值，move 都返回将亡值，如果现在需要根据输入参数的类型返回不同类型的引用，比如输入左值，返回左值引用，输入右值，返回右值引用，那么 move 将无能为力，所以引入了 forward。forward 例子如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;j = i;</span><br><span class="line"><span class="type">int</span> &amp;&amp;k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">std::forward&lt;<span class="type">int</span>&amp;&gt;(i); <span class="comment">// 返回左值引用</span></span><br><span class="line"></span><br><span class="line">std::forward&lt;<span class="type">int</span>&gt;(<span class="number">0</span>); <span class="comment">// 返回右值引用</span></span><br></pre></td></tr></table></figure><p>forward 实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span></span><br><span class="line"><span class="function">_Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span></span><br><span class="line"><span class="function">_Tp&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!is_lvalue_reference&lt;_Tp&gt;::value,</span><br><span class="line">                  <span class="string">&quot;can not forward an rvalue as an lvalue&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forwad 和 move 不一样，move 可以通过输入参数推断模板类型，但是 forward 必须指定模板参数，因为 foward 的参数是 <code>typename remove_reference&lt;_Tp&gt;::type</code>，无法通过输入参数进行模板参数推断。</p><p>在指定模板参数后，就有了两个版本的 forwad，一个参数是左值引用，另一个是右值引用，根据函数匹配原则，输入参数是左值，优先选择左值引用版本，输入参数是右值，优先是使用右值引用版本。</p><p>forwad 函数内部也是用 static_cast 对输入参数进行强制转换，但是 <code>static_cast&lt;_Tp&amp;&amp;&gt;</code> 进行转换的目标参数是 <code>_Tp&amp;&amp;</code>，根据引用折叠，要想得到左值引用，<code>_Tp</code> 必须形如 int&amp;，想要得到右值，<code>_Tp</code> 必须是 int 或者 int&amp;&amp;。这也是为什么上面例子中左值引用是 <code>std::forward&lt;int&amp;&gt;(i);</code> 右值引用是 <code>std::forward&lt;int&gt;(0);</code></p><p>返回值和上面 <code>static_cast&lt;_Tp&amp;&amp;&gt;</code> 一样都是 <code>_Tp&amp;&amp;</code>。</p><p>所以使用 forwad 一定要正确配置模板参数，比如使用 <code>std::forward&lt;int&gt;(i);</code> 返回的将是右值引用，而 <code>std::forward&lt;int&amp;&gt;(0);</code> 虽然可以返回左值，但是上面 static_assert 会报错。</p><p>forward 常常和模板一起使用，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gg</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据万能引用模板参数推断原则，如果输入参数是左值，那么 T 形如 int&amp;，如果输入右值，则 T 形如 int（不论输入是纯右值还是将亡值）。上面模板函数在使用 forwad 时传的模板参数 T，恰好和 forward 对模板参数的要求一致：要转发得到左值，T 必须形如 int&amp;，要转发得到右值引用，T 必须是 int 或者 int&amp;&amp;。</p><p>从上面的分析可以发现，move 和 foward 都是获得输入参数的引用，move 只能得到将亡值，forwad 则会根据输入参数类型返回左值引用或者将亡值，他们内部都是通过 static_cast 实现的。</p><p>本来还计划介绍 <code>forward as tuple</code>，但想了想，还是等 tuple 分析完以后再来介绍会好一些。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++新特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>左值、右值、左值引用、右值引用</title>
      <link href="/2023/04/22/%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>/2023/04/22/%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章想不自量力的分析 C++ 中的左值、右值、左值引用、右值引用，为后面分析其他新特性做铺垫。</p></blockquote><p>左值和右值是表达式的结果的属性，表达式就是“运算符 + 运算对象”，表达式加上末尾的分号就是语句，最简单的表达式是变量，下面例子都是表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span></span><br><span class="line">i</span><br><span class="line">i+<span class="number">1</span></span><br><span class="line">++i</span><br></pre></td></tr></table></figure><p>可以这样理解左值和右值：左值是指表达式的结果能被操纵、能被取地址，右值是指表达式的结果虽然存在，也可以使用，但是我们没有办法取地址。</p><p>区分左值、右值最容易的方法是：左值通常有名字，在程序里可以取地址；右值通常是某次计算的临时结果，虽然仿佛有一个变量来存储这个结果，但是该变量对程序员不可见，无法取地址。</p><p>但是注意要以能否取地址为判定准则，而不是以是否有名字来区分左右值，看以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i; <span class="comment">// i是左值</span></span><br><span class="line">i = <span class="number">1</span>; <span class="comment">// i是左值，1是右值</span></span><br><span class="line"><span class="type">int</span> j = i+<span class="number">1</span>; <span class="comment">// j是左值，i+1的结果是一个临时值，是右值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A&amp; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&amp;<span class="built_in">f</span>(); <span class="comment">// f()返回左值 虽然f()的返回值没有名字</span></span><br></pre></td></tr></table></figure><p>还要注意，不能用下面的方法来区分左值右值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A&amp; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">A <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>().<span class="built_in">hello</span>();</span><br><span class="line"><span class="built_in">g</span>().<span class="built_in">hello</span>(); <span class="comment">// 不能以这种方式来区分，因为左值右值都可以“使用”，像这样访问对象的成员函数是使用</span></span><br></pre></td></tr></table></figure><p>C++11 在原来的左值右值基础上做了扩展，原来的左值右值现在分成左值 lvalue、将亡值 xvalue、纯右值 prvalue。</p><p>纯右值和之前的右值概念是一致的，字面量、某些运算符计算得到的临时结果、返回非引用类型的函数是纯右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">1</span>; <span class="comment">// 等号右边是纯右值</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>; <span class="comment">// 等号右边是纯右值</span></span><br><span class="line">j = j + i; <span class="comment">// j + i 返回一个临时的运算结果，是纯右值</span></span><br><span class="line">j-- <span class="comment">// 纯右值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 纯右值</span></span><br><span class="line">&amp;a <span class="comment">// 纯右值</span></span><br><span class="line">a==b <span class="comment">// 纯右值</span></span><br><span class="line">a&gt;=b <span class="comment">// 纯右值</span></span><br><span class="line">a&lt;b <span class="comment">// 纯右值</span></span><br><span class="line">a&amp;&amp;b <span class="comment">// 纯右值</span></span><br><span class="line">a||b <span class="comment">// 纯右值</span></span><br><span class="line">~a <span class="comment">// 纯右值</span></span><br><span class="line">a+b <span class="comment">// 纯右值</span></span><br></pre></td></tr></table></figure><p>左值和之前左值的概念类似，都是指能被程序员操纵、使用的值，比如变量名、函数名、变量的左值&#x2F;右值引用，某些返回左值引用的运算符，返回左值引用的函数，如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, *p = &amp;i; <span class="comment">// i p都是左值</span></span><br><span class="line"><span class="type">int</span>&amp; j = i; <span class="comment">// j也是左值</span></span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">// *p 也是左值，解引用返回指向变量的左值引用</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">2</span>; <span class="comment">// 索引也返回左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; m = <span class="number">1</span>; <span class="comment">// m也是左值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">f</span>() <span class="comment">// 返回左值引用的函数的结果也是左值</span></span><br></pre></td></tr></table></figure><p><code>int i</code> <code>int&amp;j</code> 容易理解，某些返回左值引用的运算符需要注意，比如解引用、前缀 ++、前缀–、数组索引、+&#x3D;、-&#x3D;。</p><p>但是右值引用 <code>int&amp;&amp; m</code>，为什么也把他算到左值里面？</p><p>这是因为当我们定义一个右值引用后，我们就可以显式的使用这个引用了，就好像操作的是被绑定的变量，所以把他也当作左值，比如下面可以对 m 取地址，<strong>能进行取地址操作是左值的核心属性</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; m = <span class="number">1</span>;</span><br><span class="line">&amp;m</span><br></pre></td></tr></table></figure><p>将亡值和新引入的右值引用相关，哪些情况下会得到将亡值？返回右值引用的函数、转换为右值引用的转换函数，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">f</span><span class="params">(<span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(i) <span class="comment">// 将亡值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp;j = i;</span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(j) <span class="comment">// 将亡值</span></span><br></pre></td></tr></table></figure><p>可以看到，当右值引用出现在变量定义和函数返回值时，有不同的含义，当右值引用出现在函数返回值时，是将亡值，而当右值引用出现在变量定义时，是左值。</p><p>为什么要让函数返回右值引用是将亡值？为了支持新的移动语义。</p><p>当 C++ 中发生拷贝构造时，会把传入的引用指向的对象中的资源拷贝一份：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line"><span class="built_in">E</span>(<span class="type">const</span> E&amp;); <span class="comment">// 发生拷贝时会new一块buf，然后memcpy传入的对象中的buf</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *buf; <span class="comment">// 动态分配的内存，析构时释放</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果用户想提高效率，不想发生拷贝，而希望构造函数直接接管传入对象中分配的内存，那么需要一个标记提示函数 “输入参数指向的对象可以被安全的接管”，此时构造函数可以直接将输入对象的 buf 指针赋给自己，因为输入对象是可被安全接管的。我们称可以被安全接管的对象为将亡值。</p><p>首先可以确定这个 “标记” 一定是引用，只有引用传递才能保证函数访问到的是需要被接管的对象，传值会发生拷贝，这和我们上面节省拷贝的初衷不符。原有的左值引用是否可以呢？不可以，左值引用已经有了自己的语义，无法实现这一功能，所以就诞生了右值引用。</p><p>既然确定了这个“标记”是一个引用，接下来就要思考如何让一个变量标记为“可以被安全的接管”。可以像定义变量一样，定义一个右值引用的变量，然后将这个变量视为“将亡”，这其实也是可以的，但是为什么最后没有使用这种方式，个人猜测原因之一是这种显式定义的变量给人一种可以使用的感觉，可能有程序员会不小心在后面的代码中使用这个变量，所以最后使用函数返回右值引用作为“将亡”的标记。</p><p>在决定了函数返回右值引用作为“将亡”之后，还要考虑引入新的右值引用对原有语言规则的影响，比如能否在定义变量时使用右值引用，这样定义后又该怎么解释这个右值引用。出于语言一致性的考虑，C++ 允许在变量定义中使用右值引用，但此时的右值引用就像左值引用一样（毕竟右值引用也是一种引用），所以它也是左值。当我们定义一个右值引用的变量时，可以对他取地址，但是无法对函数返回右值引用取地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* q =&amp;i; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;<span class="built_in">hello</span>(); <span class="comment">// error. Cannot take the address of an rvalue of type &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure><p>既然允许在变量定义中定义右值引用，还要考虑右值引用能绑定到什么类型的值上，出于种种考虑，标准规定右值引用只能绑定到纯右值或者将亡值上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; m = <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; j = m; <span class="comment">// error. Rvalue reference to type &#x27;int&#x27; cannot bind to lvalue of type &#x27;int&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; p = <span class="built_in">hello</span>(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>C++ 标准中，左值和将亡值称为泛左值，纯右值和将亡值称为右值。将亡值是函数返回右值引用，而右值引用广义上来说也是引用，可以视为左值；将亡值无法取地址，这符合右值的特点，也可以视为右值。所以将亡值就是标记一个引用为临时值。</p><p><img src="/images/%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/%5Bignore%5D-l-x-r-value.png"></p><p>再谈一谈左值右值引用的转换。可以通过 static_cast 将一个左值引用转成右值引用，反之亦然。可以这样理解这种转换，左值&#x2F;右值引用都是对对象的引用，底层都是指针，只是在上层有不同的解释。当我们把一个左值引用通过 move 或者 static_cast 转换成一个将亡值的时候，表示将这个对象标记为将亡，并要求后续代码不能再使用这个对象，然后如果某个函数有接受右值引用参数的重载，就可以通过将亡值把对象移动出去。看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="comment">// 实现了移动构造</span></span><br><span class="line"><span class="type">void</span> *buff;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">ff</span><span class="params">(A b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    A a;</span><br><span class="line">    </span><br><span class="line">    A c = <span class="built_in">ff</span>(std::<span class="built_in">move</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中 A 对象有两块内存，一块是栈内存，一块是堆内存。当给 ff 函数传将亡值时，由于形参是值，实参是右值引用，所以发生移动构造，此时会在 ff 的参数栈上构造一个 A 对象，但是 a 的堆内存是直接转移到 b 的，真正拷贝的是栈内存的那一部分；ff 函数返回结果类似，也是进行了栈内存拷贝，其实 ff 内部可以直接返回 b，不需要 move，因为有返回值优化；最后在通过 ff 返回值构造 c 时，由于 ff 返回一个临时值，所以也调用移动构造函数，再拷贝一次栈内存，堆内存转移，但是通常编译器会把这次对象构造优化掉，直接把 ff 返回值当作 c。</p><p>参考：</p><p><a href="https://www.cnblogs.com/zpcdbky/p/5275959.html">https://www.cnblogs.com/zpcdbky/p/5275959.html</a></p><p><a href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/</a></p><p><a href="http://irootlee.com/juicer_pointer_reference/">http://irootlee.com/juicer_pointer_reference&#x2F;</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++新特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gobject初始化之类型注册</title>
      <link href="/2023/04/17/Gobject%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%86%8C/"/>
      <url>/2023/04/17/Gobject%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>这篇博客介绍 Gobject 的初始化流程，由于 Gobject 初始化的内容比较多，所以先介绍类型注册。</p><p>要使用一个 Gobject 类，我们必须将他注册到 Gobject 中，以前面博客中的代码为例，注册是在 my_obj_get_type_once 中调用 g_type_register_static_simple 实现的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> GType </span></span><br><span class="line"><span class="function"><span class="title">my_obj_get_type_once</span> <span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  GType g_define_type_id = </span><br><span class="line">        <span class="built_in">g_type_register_static_simple</span> (G_TYPE_OBJECT, </span><br><span class="line">                                       <span class="built_in">g_intern_static_string</span> (<span class="string">&quot;MyObj&quot;</span>), </span><br><span class="line">                                       <span class="built_in">sizeof</span> (MyObjClass), </span><br><span class="line">                                       (GClassInitFunc)(<span class="built_in">void</span> (*)(<span class="type">void</span>)) my_obj_class_intern_init, </span><br><span class="line">                                       <span class="built_in">sizeof</span> (MyObj), </span><br><span class="line">                                       (GInstanceInitFunc)(<span class="built_in">void</span> (*)(<span class="type">void</span>)) my_obj_init, </span><br><span class="line">                                       (GTypeFlags) <span class="number">0</span>); </span><br><span class="line">    &#123; <span class="comment">/* custom code follows */</span> </span><br><span class="line">    </span><br><span class="line">      <span class="comment">/* following custom code */</span> </span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> g_define_type_id; </span><br><span class="line">&#125; <span class="comment">/* closes my_obj_get_type_once() */</span></span><br></pre></td></tr></table></figure><h1 id="g-type-register-static-simple"><a href="#g-type-register-static-simple" class="headerlink" title="g_type_register_static_simple"></a>g_type_register_static_simple</h1><p>看看 g_type_register_static_simple 到底做了什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GType</span></span><br><span class="line"><span class="function"><span class="title">g_type_register_static_simple</span> <span class="params">(GType             parent_type,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> gchar      *type_name,</span></span></span><br><span class="line"><span class="params"><span class="function">             guint             class_size,</span></span></span><br><span class="line"><span class="params"><span class="function">             GClassInitFunc    class_init,</span></span></span><br><span class="line"><span class="params"><span class="function">             guint             instance_size,</span></span></span><br><span class="line"><span class="params"><span class="function">             GInstanceInitFunc instance_init,</span></span></span><br><span class="line"><span class="params"><span class="function">             GTypeFlags  flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GTypeInfo info;</span><br><span class="line">...</span><br><span class="line">  info.class_size = class_size;</span><br><span class="line">  info.base_init = <span class="literal">NULL</span>;</span><br><span class="line">  info.base_finalize = <span class="literal">NULL</span>;</span><br><span class="line">  info.class_init = class_init;</span><br><span class="line">  info.class_finalize = <span class="literal">NULL</span>;</span><br><span class="line">  info.class_data = <span class="literal">NULL</span>;</span><br><span class="line">  info.instance_size = instance_size;</span><br><span class="line">  info.n_preallocs = <span class="number">0</span>;</span><br><span class="line">  info.instance_init = instance_init;</span><br><span class="line">  info.value_table = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">g_type_register_static</span> (parent_type, type_name, &amp;info, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_GTypeInfo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* interface types, classed types, instantiated types */</span></span><br><span class="line">  guint16                class_size;</span><br><span class="line">  </span><br><span class="line">  GBaseInitFunc          base_init;</span><br><span class="line">  GBaseFinalizeFunc      base_finalize;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* interface types, classed types, instantiated types */</span></span><br><span class="line">  GClassInitFunc         class_init;</span><br><span class="line">  GClassFinalizeFunc     class_finalize;</span><br><span class="line">  gconstpointer          class_data;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* instantiated types */</span></span><br><span class="line">  guint16                instance_size;</span><br><span class="line">  guint16                n_preallocs;</span><br><span class="line">  GInstanceInitFunc      instance_init;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* value handling */</span></span><br><span class="line">  <span class="type">const</span> GTypeValueTable *value_table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="g-type-register-static"><a href="#g-type-register-static" class="headerlink" title="g_type_register_static"></a>g_type_register_static</h2><p>g_type_register_static_simple 函数内部把参数组装成 GTypeInfo 结构，然后调用 g_type_register_static 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GType</span></span><br><span class="line"><span class="function"><span class="title">g_type_register_static</span> <span class="params">(GType            parent_type,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> gchar     *type_name,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> GTypeInfo *info,</span></span></span><br><span class="line"><span class="params"><span class="function">      GTypeFlags   flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TypeNode *pnode, *node;</span><br><span class="line">  GType type = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_assert_type_system_initialized</span> ();</span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (parent_type &gt; <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">check_type_name_I</span> (type_name) ||</span><br><span class="line">      !<span class="built_in">check_derivation_I</span> (parent_type, type_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (info-&gt;class_finalize)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (<span class="string">&quot;class finalizer specified for static type &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">     type_name);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  pnode = <span class="built_in">lookup_type_node_I</span> (parent_type);</span><br><span class="line">  <span class="built_in">G_WRITE_LOCK</span> (&amp;type_rw_lock);</span><br><span class="line">  <span class="built_in">type_data_ref_Wm</span> (pnode);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">check_type_info_I</span> (pnode, <span class="built_in">NODE_FUNDAMENTAL_TYPE</span> (pnode), type_name, info))</span><br><span class="line">    &#123;</span><br><span class="line">      node = <span class="built_in">type_node_new_W</span> (pnode, type_name, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">type_add_flags_W</span> (node, flags);</span><br><span class="line">      type = <span class="built_in">NODE_TYPE</span> (node);</span><br><span class="line">      <span class="built_in">type_data_make_W</span> (node, info,</span><br><span class="line">      <span class="built_in">check_value_table_I</span> (type_name, info-&gt;value_table) ? info-&gt;value_table : <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">G_WRITE_UNLOCK</span> (&amp;type_rw_lock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="check-type-name-I-x2F-check-derivation-I"><a href="#check-type-name-I-x2F-check-derivation-I" class="headerlink" title="check_type_name_I&#x2F;check_derivation_I"></a>check_type_name_I&#x2F;check_derivation_I</h3><p>简单看看 check_type_name_I 和 check_derivation_I，check_type_name_I 就是从全局静态的 hash 表 static_type_nodes_ht 中查找是否已经有同名类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> gboolean</span></span><br><span class="line"><span class="function"><span class="title">check_type_name_I</span> <span class="params">(<span class="type">const</span> gchar *type_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g_type_from_name</span> (type_name))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (<span class="string">&quot;cannot register existing type &#x27;%s&#x27;&quot;</span>, type_name);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">GType</span></span><br><span class="line"><span class="function"><span class="title">g_type_from_name</span> <span class="params">(<span class="type">const</span> gchar *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GType type = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (name != <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">G_READ_LOCK</span> (&amp;type_rw_lock);</span><br><span class="line">  type = (GType) <span class="built_in">g_hash_table_lookup</span> (static_type_nodes_ht, name);</span><br><span class="line">  <span class="built_in">G_READ_UNLOCK</span> (&amp;type_rw_lock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>check_derivation_I 则是检查父类是否能被继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> gboolean</span></span><br><span class="line"><span class="function"><span class="title">check_derivation_I</span> <span class="params">(GType        parent_type,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> gchar *type_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TypeNode *pnode;</span><br><span class="line">  GTypeFundamentalInfo* finfo;</span><br><span class="line">  </span><br><span class="line">  pnode = <span class="built_in">lookup_type_node_I</span> (parent_type);</span><br><span class="line">  <span class="keyword">if</span> (!pnode)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (<span class="string">&quot;cannot derive type &#x27;%s&#x27; from invalid parent type &#x27;%s&#x27;&quot;</span>, ...);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">  finfo = <span class="built_in">type_node_fundamental_info_I</span> (pnode);</span><br><span class="line">  <span class="comment">/* ensure flat derivability */</span></span><br><span class="line">  <span class="keyword">if</span> (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DERIVABLE))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (<span class="string">&quot;cannot derive &#x27;%s&#x27; from non-derivable parent type &#x27;%s&#x27;&quot;</span>, ...);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* ensure deep derivability */</span></span><br><span class="line">  <span class="keyword">if</span> (parent_type != <span class="built_in">NODE_FUNDAMENTAL_TYPE</span> (pnode) &amp;&amp;</span><br><span class="line">      !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DEEP_DERIVABLE))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (<span class="string">&quot;cannot derive &#x27;%s&#x27; from non-fundamental parent type &#x27;%s&#x27;&quot;</span>, ...);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> ((G_TYPE_FLAG_FINAL &amp; <span class="built_in">GPOINTER_TO_UINT</span> (<span class="built_in">type_get_qdata_L</span> (pnode, static_quark_type_flags))) == G_TYPE_FLAG_FINAL)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (<span class="string">&quot;cannot derive &#x27;%s&#x27; from final parent type &#x27;%s&#x27;&quot;</span>, ...);</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lookup-type-node-I"><a href="#lookup-type-node-I" class="headerlink" title="lookup_type_node_I"></a>lookup_type_node_I</h4><p>lookup_type_node_I 通过输入的 GType 返回 TypeNode<em>，对于非基本类型，输入的 utype 经过掩码还原之后得到一个 TypeNode</em>，对于基本类型，输入的 utype 是全局数组 static_fundamental_type_nodes 的索引</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> TypeNode*</span></span><br><span class="line"><span class="function"><span class="title">lookup_type_node_I</span> <span class="params">(GType utype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (utype &gt; G_TYPE_FUNDAMENTAL_MAX)</span><br><span class="line">    <span class="keyword">return</span> (TypeNode*) (utype &amp; ~TYPE_ID_MASK);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> static_fundamental_type_nodes[utype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_ID_MASK        ((GType) ((1 &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT) - 1))</span></span><br></pre></td></tr></table></figure><h4 id="type-node-fundamental-info-I"><a href="#type-node-fundamental-info-I" class="headerlink" title="type_node_fundamental_info_I"></a>type_node_fundamental_info_I</h4><p>如果输入的 node 不是他继承体系中最顶层的 fundamental type，就获得最顶层的 fundamental type，然后从 fundamental type 中获得 GTypeFundamentalInfo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> GTypeFundamentalInfo*</span></span><br><span class="line"><span class="function"><span class="title">type_node_fundamental_info_I</span> <span class="params">(TypeNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GType ftype = <span class="built_in">NODE_FUNDAMENTAL_TYPE</span> (node);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (ftype != <span class="built_in">NODE_TYPE</span> (node))</span><br><span class="line">    node = <span class="built_in">lookup_type_node_I</span> (ftype);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> node ? <span class="built_in">G_STRUCT_MEMBER_P</span> (node, -SIZEOF_FUNDAMENTAL_INFO) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这几个宏涉及到父子类继承关系的表示，下面再分析</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_TYPE(node)       (node-&gt;supers[0])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_PARENT_TYPE(node)      (node-&gt;supers[1])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_FUNDAMENTAL_TYPE(node)   (node-&gt;supers[node-&gt;n_supers])</span></span><br></pre></td></tr></table></figure><h3 id="type-data-ref-Wm"><a href="#type-data-ref-Wm" class="headerlink" title="type_data_ref_Wm"></a>type_data_ref_Wm</h3><p>g_type_register_static 函数通过 lookup_type_node_I 查找到父类的 TypeNode 指针后，type_data_ref_Wm 父类 TypeNode 指针</p><p>type_data_ref_Wm 是一个递归的过程，如果传入的 node 指针指向的 TypeNode 还没初始化（识别条件为 node-&gt;data 为空），那么会对当前 node 进行初始化，初始化时又需要 type_data_ref_Wm 当前 node 的父类，如此递归向上逐级初始化父类，当父类初始化并 type_data_ref_Wm 结束后，再初始化当前 node，初始化 node 所需要的 GTypeInfo、GTypeValueTable 来自 node 关联的 plugin，一般在 plugin 加载时会创建 node 节点，但是 node 节点不会立即初始化，直到使用时才初始化</p><p>当 type_data_ref_Wm 执行时，如果当前 node 已经初始化，则增加他的引用计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">type_data_ref_Wm</span> <span class="params">(TypeNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">      TypeNode *pnode = <span class="built_in">lookup_type_node_I</span> (<span class="built_in">NODE_PARENT_TYPE</span> (node));</span><br><span class="line">      GTypeInfo tmp_info;</span><br><span class="line">      GTypeValueTable tmp_value_table;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">g_assert</span> (node-&gt;plugin != <span class="literal">NULL</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (pnode)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">type_data_ref_Wm</span> (pnode);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;data)</span><br><span class="line">      <span class="built_in">INVALID_RECURSION</span> (<span class="string">&quot;g_type_plugin_*&quot;</span>, node-&gt;plugin, <span class="built_in">NODE_NAME</span> (node));</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">memset</span> (&amp;tmp_info, <span class="number">0</span>, <span class="built_in">sizeof</span> (tmp_info));</span><br><span class="line">      <span class="built_in">memset</span> (&amp;tmp_value_table, <span class="number">0</span>, <span class="built_in">sizeof</span> (tmp_value_table));</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">G_WRITE_UNLOCK</span> (&amp;type_rw_lock);</span><br><span class="line">      <span class="built_in">g_type_plugin_use</span> (node-&gt;plugin);</span><br><span class="line">      <span class="built_in">g_type_plugin_complete_type_info</span> (node-&gt;plugin, <span class="built_in">NODE_TYPE</span> (node), &amp;tmp_info, &amp;tmp_value_table);</span><br><span class="line">      <span class="built_in">G_WRITE_LOCK</span> (&amp;type_rw_lock);</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;data)</span><br><span class="line">  <span class="built_in">INVALID_RECURSION</span> (<span class="string">&quot;g_type_plugin_*&quot;</span>, node-&gt;plugin, <span class="built_in">NODE_NAME</span> (node));</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">check_type_info_I</span> (pnode, <span class="built_in">NODE_FUNDAMENTAL_TYPE</span> (node), <span class="built_in">NODE_NAME</span> (node), &amp;tmp_info);</span><br><span class="line">      <span class="built_in">type_data_make_W</span> (node, &amp;tmp_info,</span><br><span class="line">      <span class="built_in">check_value_table_I</span> (<span class="built_in">NODE_NAME</span> (node),</span><br><span class="line">               &amp;tmp_value_table) ? &amp;tmp_value_table : <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_assert</span> (<span class="built_in">NODE_REFCOUNT</span> (node) &gt; <span class="number">0</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">g_atomic_int_inc</span> ((<span class="type">int</span> *) &amp;node-&gt;ref_count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-node-new-W"><a href="#type-node-new-W" class="headerlink" title="type_node_new_W"></a>type_node_new_W</h3><p>对父类的 TypeNode 指针调用 type_data_ref_Wm 之后，会调用 type_node_new_W 函数创建来创建子类的 TypeNode。由于 type_data_ref_Wm 会递归向上检查所有父类是否初始化，所以 type_data_ref_Wm 执行完成后保证父类处于已经初始化的状态。</p><p>这里要注意，node 要先创建才能初始化，但这两个过程不需要同时执行，比如上面 type_data_ref_Wm 里面的 node 就已经创建了但是可能没有初始化，所以只用调用 type_data_make_W 来初始化 node，但是在 g_type_register_static 中，当前的逻辑就是要创建并初始化 node，所以先通过 type_node_new_W 创建当前节点，然后同 type_data_make_W 初始化</p><p>还可以看到 type_node_new_W 传了一个 GTypePlugin *参数，这就和之前对上了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> TypeNode*</span></span><br><span class="line"><span class="function"><span class="title">type_node_new_W</span> <span class="params">(TypeNode    *pnode,</span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="type">const</span> gchar *name,</span></span></span><br><span class="line"><span class="params"><span class="function">     GTypePlugin *plugin)</span></span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">g_assert</span> (pnode);</span><br><span class="line">  <span class="built_in">g_assert</span> (pnode-&gt;n_supers &lt; MAX_N_SUPERS);</span><br><span class="line">  <span class="built_in">g_assert</span> (pnode-&gt;n_children &lt; MAX_N_CHILDREN);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">type_node_any_new_W</span> (pnode, <span class="built_in">NODE_FUNDAMENTAL_TYPE</span> (pnode), name, plugin, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_TYPE(node)       (node-&gt;supers[0])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_PARENT_TYPE(node)      (node-&gt;supers[1])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_FUNDAMENTAL_TYPE(node)   (node-&gt;supers[node-&gt;n_supers])</span></span><br></pre></td></tr></table></figure><h4 id="type-node-any-new-W"><a href="#type-node-any-new-W" class="headerlink" title="type_node_any_new_W"></a>type_node_any_new_W</h4><p>type_node_new_W 内部调用 type_node_any_new_W 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> TypeNode*</span></span><br><span class="line"><span class="function"><span class="title">type_node_any_new_W</span> <span class="params">(TypeNode             *pnode,</span></span></span><br><span class="line"><span class="params"><span class="function">         GType                 ftype, <span class="comment">// FUNDAMENTAL_TYPE</span></span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">const</span> gchar          *name,</span></span></span><br><span class="line"><span class="params"><span class="function">         GTypePlugin          *plugin,</span></span></span><br><span class="line"><span class="params"><span class="function">         GTypeFundamentalFlags type_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  guint n_supers;</span><br><span class="line">  GType type;</span><br><span class="line">  TypeNode *node;</span><br><span class="line">  guint i, node_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  n_supers = pnode ? pnode-&gt;n_supers + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果想注册基本类型时，那么传入的pnode指针需要为空</span></span><br><span class="line"><span class="comment">  此时会额外增加一个SIZEOF_FUNDAMENTAL_INFO大小的内存存储基本类型信息</span></span><br><span class="line"><span class="comment">  同时如果是注册基本类型，会把node指针放到static_fundamental_type_nodes数组中</span></span><br><span class="line"><span class="comment">  这和之前lookup_type_node逻辑对应</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!pnode)</span><br><span class="line">    node_size += SIZEOF_FUNDAMENTAL_INFO;       <span class="comment">/* fundamental type info */</span></span><br><span class="line">  node_size += <span class="built_in">SIZEOF_BASE_TYPE_NODE</span> ();        <span class="comment">/* TypeNode structure */</span></span><br><span class="line">  node_size += (<span class="built_in">sizeof</span> (GType) * (<span class="number">1</span> + n_supers + <span class="number">1</span>)); <span class="comment">/* self + ancestors + (0) for -&gt;supers[] */</span></span><br><span class="line">  node = <span class="built_in">g_malloc0</span> (node_size);</span><br><span class="line">  <span class="keyword">if</span> (!pnode)               <span class="comment">/* offset fundamental types */</span></span><br><span class="line">    &#123;</span><br><span class="line">      node = <span class="built_in">G_STRUCT_MEMBER_P</span> (node, SIZEOF_FUNDAMENTAL_INFO);</span><br><span class="line">      static_fundamental_type_nodes[ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT] = node;</span><br><span class="line">      type = ftype;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    type = (GType) node;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_assert</span> ((type &amp; TYPE_ID_MASK) == <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  node-&gt;n_supers = n_supers;</span><br><span class="line">  <span class="keyword">if</span> (!pnode)</span><br><span class="line">    &#123; <span class="comment">// 如果是注册基本类型，那么他没有super</span></span><br><span class="line">      node-&gt;supers[<span class="number">0</span>] = type;</span><br><span class="line">      node-&gt;supers[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      node-&gt;is_classed = (type_flags &amp; G_TYPE_FLAG_CLASSED) != <span class="number">0</span>;</span><br><span class="line">      node-&gt;is_instantiatable = (type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) != <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">NODE_IS_IFACE</span> (node))</span><br><span class="line">  &#123;</span><br><span class="line">          <span class="built_in">IFACE_NODE_N_PREREQUISITES</span> (node) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IFACE_NODE_PREREQUISITES</span> (node) = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">  _g_atomic_array_init (<span class="built_in">CLASSED_NODE_IFACES_ENTRIES</span> (node));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      node-&gt;supers[<span class="number">0</span>] = type;</span><br><span class="line">      <span class="built_in">memcpy</span> (node-&gt;supers + <span class="number">1</span>, pnode-&gt;supers, <span class="built_in">sizeof</span> (GType) * (<span class="number">1</span> + pnode-&gt;n_supers + <span class="number">1</span>));</span><br><span class="line">      </span><br><span class="line">      node-&gt;is_classed = pnode-&gt;is_classed;</span><br><span class="line">      node-&gt;is_instantiatable = pnode-&gt;is_instantiatable;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">NODE_IS_IFACE</span> (node))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">IFACE_NODE_N_PREREQUISITES</span> (node) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IFACE_NODE_PREREQUISITES</span> (node) = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    guint j;</span><br><span class="line">    IFaceEntries *entries;</span><br><span class="line"></span><br><span class="line">    entries = _g_atomic_array_copy (<span class="built_in">CLASSED_NODE_IFACES_ENTRIES</span> (pnode),</span><br><span class="line">            IFACE_ENTRIES_HEADER_SIZE,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (entries)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">IFACE_ENTRIES_N_ENTRIES</span> (entries); j++)</span><br><span class="line">    &#123;</span><br><span class="line">      entries-&gt;entry[j].vtable = <span class="literal">NULL</span>;</span><br><span class="line">      entries-&gt;entry[j].init_state = UNINITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line">        _g_atomic_array_update (<span class="built_in">CLASSED_NODE_IFACES_ENTRIES</span> (node),</span><br><span class="line">              entries);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把当前node加到pnode的子类中</span></span><br><span class="line">      i = pnode-&gt;n_children++;</span><br><span class="line">      pnode-&gt;children = <span class="built_in">g_renew</span> (GType, pnode-&gt;children, pnode-&gt;n_children);</span><br><span class="line">      pnode-&gt;children[i] = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="built_in">GOBJECT_TYPE_NEW</span>(name, node-&gt;supers[<span class="number">1</span>], type));</span><br><span class="line"></span><br><span class="line">  node-&gt;plugin = plugin;</span><br><span class="line">  node-&gt;n_children = <span class="number">0</span>;</span><br><span class="line">  node-&gt;children = <span class="literal">NULL</span>;</span><br><span class="line">  node-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">  node-&gt;qname = <span class="built_in">g_quark_from_string</span> (name);</span><br><span class="line">  node-&gt;global_gdata = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">g_hash_table_insert</span> (static_type_nodes_ht,</span><br><span class="line">           (gpointer) <span class="built_in">g_quark_to_string</span> (node-&gt;qname),</span><br><span class="line">           (gpointer) type);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_atomic_int_inc</span> ((gint *)&amp;type_registration_serial);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type_node_any_new_W 函数最主要的工作是配置父子类之间的继承关系，继承关系是通过 TypeNode 中的 n_supers、supers、n_children、children 成员来控制的：</p><ul><li><p>n_supers 是个整数，代表当前 TypeNode 有多少个父类</p></li><li><p>supers 是数组，他的第 0 项代表自己，第 1 到 n_supers 项代表父类的 TypeNode 指针，最后一项固定为 0</p><ul><li>对于基本类型，其没有父类，所以 supers 数组只有两项，0 项为自己，第 1 项为 0</li></ul></li><li><p>n_children 是个整数，代表当前 TypeNode 有多少个子类</p></li><li><p>children 是数组，每一项指向一个子类 TypeNode</p></li></ul><p>TypeNode 结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_TypeNode</span></span><br><span class="line">&#123;</span><br><span class="line">  guint        ref_count;  <span class="comment">/* (atomic) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> G_ENABLE_DEBUG</span></span><br><span class="line">  guint        instance_count;  <span class="comment">/* (atomic) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  GTypePlugin *plugin;</span><br><span class="line">  guint        n_children; <span class="comment">/* writable with lock */</span></span><br><span class="line">  guint        n_supers : <span class="number">8</span>;</span><br><span class="line">  guint        n_prerequisites : <span class="number">9</span>;</span><br><span class="line">  guint        is_classed : <span class="number">1</span>;</span><br><span class="line">  guint        is_instantiatable : <span class="number">1</span>;</span><br><span class="line">  guint        mutatable_check_cache : <span class="number">1</span>; <span class="comment">/* combines some common path checks */</span></span><br><span class="line">  GType       *children; <span class="comment">/* writable with lock */</span></span><br><span class="line">  TypeData    *data;</span><br><span class="line">  GQuark       qname;</span><br><span class="line">  GData       *global_gdata;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    GAtomicArray iface_entries;   <span class="comment">/* for !iface types */</span></span><br><span class="line">    GAtomicArray offsets;</span><br><span class="line">  &#125; _prot;</span><br><span class="line">  GType       *prerequisites;</span><br><span class="line">  GType        supers[<span class="number">1</span>]; <span class="comment">/* flexible array */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="type-data-make-W"><a href="#type-data-make-W" class="headerlink" title="type_data_make_W"></a>type_data_make_W</h3><p>TypeNode 创建好之后，调用 type_data_make_W 函数将 GTypeInfo 结构中的信息写入到 TypeNode 中，完成初始化。info 参数比较好理解，value_table 目前不知道是干什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">type_data_make_W</span> <span class="params">(TypeNode              *node,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> GTypeInfo       *info,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> GTypeValueTable *value_table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TypeData *data;</span><br><span class="line">  GTypeValueTable *vtable = <span class="literal">NULL</span>;</span><br><span class="line">  guint vtable_size = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_assert</span> (node-&gt;data == <span class="literal">NULL</span> &amp;&amp; info != <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!value_table)</span><br><span class="line">    &#123;</span><br><span class="line">      TypeNode *pnode = <span class="built_in">lookup_type_node_I</span> (<span class="built_in">NODE_PARENT_TYPE</span> (node));</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (pnode)</span><br><span class="line">  vtable = pnode-&gt;data-&gt;common.value_table;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">          <span class="type">static</span> <span class="type">const</span> GTypeValueTable zero_vtable =</span><br><span class="line">            &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    value_table = &amp;zero_vtable;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (value_table)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* need to setup vtable_size since we have to allocate it with data in one chunk */</span></span><br><span class="line">      vtable_size = <span class="built_in">sizeof</span> (GTypeValueTable);</span><br><span class="line">      <span class="keyword">if</span> (value_table-&gt;collect_format)</span><br><span class="line">  vtable_size += <span class="built_in">strlen</span> (value_table-&gt;collect_format);</span><br><span class="line">      <span class="keyword">if</span> (value_table-&gt;lcopy_format)</span><br><span class="line">  vtable_size += <span class="built_in">strlen</span> (value_table-&gt;lcopy_format);</span><br><span class="line">      vtable_size += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span> (node-&gt;is_instantiatable) <span class="comment">/* careful, is_instantiatable is also is_classed */</span></span><br><span class="line">    &#123;</span><br><span class="line">      TypeNode *pnode = <span class="built_in">lookup_type_node_I</span> (<span class="built_in">NODE_PARENT_TYPE</span> (node));</span><br><span class="line"></span><br><span class="line">      data = <span class="built_in">g_malloc0</span> (<span class="built_in">sizeof</span> (InstanceData) + vtable_size);</span><br><span class="line">      <span class="keyword">if</span> (vtable_size)</span><br><span class="line">  vtable = <span class="built_in">G_STRUCT_MEMBER_P</span> (data, <span class="built_in">sizeof</span> (InstanceData));</span><br><span class="line">      data-&gt;instance.class_size = info-&gt;class_size;</span><br><span class="line">      data-&gt;instance.class_init_base = info-&gt;base_init;</span><br><span class="line">      data-&gt;instance.class_finalize_base = info-&gt;base_finalize;</span><br><span class="line">      data-&gt;instance.class_init = info-&gt;class_init;</span><br><span class="line">      data-&gt;instance.class_finalize = info-&gt;class_finalize;</span><br><span class="line">      data-&gt;instance.class_data = info-&gt;class_data;</span><br><span class="line">      data-&gt;instance.<span class="keyword">class</span> = <span class="literal">NULL</span>;</span><br><span class="line">      data-&gt;instance.init_state = UNINITIALIZED;</span><br><span class="line">      data-&gt;instance.instance_size = info-&gt;instance_size;</span><br><span class="line">      <span class="comment">/* We&#x27;ll set the final value for data-&gt;instance.private size</span></span><br><span class="line"><span class="comment">       * after the parent class has been initialized</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      data-&gt;instance.private_size = <span class="number">0</span>;</span><br><span class="line">      data-&gt;instance.class_private_size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (pnode)</span><br><span class="line">        data-&gt;instance.class_private_size = pnode-&gt;data-&gt;instance.class_private_size;</span><br><span class="line">      data-&gt;instance.n_preallocs = <span class="built_in">MIN</span> (info-&gt;n_preallocs, <span class="number">1024</span>);</span><br><span class="line">      data-&gt;instance.instance_init = info-&gt;instance_init;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;is_classed) <span class="comment">/* only classed */</span></span><br><span class="line">    &#123;</span><br><span class="line">      TypeNode *pnode = <span class="built_in">lookup_type_node_I</span> (<span class="built_in">NODE_PARENT_TYPE</span> (node));</span><br><span class="line"></span><br><span class="line">      data = <span class="built_in">g_malloc0</span> (<span class="built_in">sizeof</span> (ClassData) + vtable_size);</span><br><span class="line">      <span class="keyword">if</span> (vtable_size)</span><br><span class="line">  vtable = <span class="built_in">G_STRUCT_MEMBER_P</span> (data, <span class="built_in">sizeof</span> (ClassData));</span><br><span class="line">      data-&gt;<span class="keyword">class</span>.class_size = info-&gt;class_size;</span><br><span class="line">      data-&gt;<span class="keyword">class</span>.class_init_base = info-&gt;base_init;</span><br><span class="line">      data-&gt;<span class="keyword">class</span>.class_finalize_base = info-&gt;base_finalize;</span><br><span class="line">      data-&gt;<span class="keyword">class</span>.class_init = info-&gt;class_init;</span><br><span class="line">      data-&gt;<span class="keyword">class</span>.class_finalize = info-&gt;class_finalize;</span><br><span class="line">      data-&gt;<span class="keyword">class</span>.class_data = info-&gt;class_data;</span><br><span class="line">      data-&gt;<span class="keyword">class</span>.<span class="keyword">class</span> = <span class="literal">NULL</span>;</span><br><span class="line">      data-&gt;<span class="keyword">class</span>.class_private_size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (pnode)</span><br><span class="line">        data-&gt;<span class="keyword">class</span>.class_private_size = pnode-&gt;data-&gt;<span class="keyword">class</span>.class_private_size;</span><br><span class="line">      data-&gt;<span class="keyword">class</span>.init_state = UNINITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">NODE_IS_IFACE</span> (node))</span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">NODE_IS_BOXED</span> (node))</span><br><span class="line">    &#123;</span><br><span class="line">      data = <span class="built_in">g_malloc0</span> (<span class="built_in">sizeof</span> (BoxedData) + vtable_size);</span><br><span class="line">      <span class="keyword">if</span> (vtable_size)</span><br><span class="line">  vtable = <span class="built_in">G_STRUCT_MEMBER_P</span> (data, <span class="built_in">sizeof</span> (BoxedData));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      data = <span class="built_in">g_malloc0</span> (<span class="built_in">sizeof</span> (CommonData) + vtable_size);</span><br><span class="line">      <span class="keyword">if</span> (vtable_size)</span><br><span class="line">  vtable = <span class="built_in">G_STRUCT_MEMBER_P</span> (data, <span class="built_in">sizeof</span> (CommonData));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  node-&gt;data = data;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (vtable_size)</span><br><span class="line">    &#123;</span><br><span class="line">      gchar *p;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* we allocate the vtable and its strings together with the type data, so</span></span><br><span class="line"><span class="comment">       * children can take over their parent&#x27;s vtable pointer, and we don&#x27;t</span></span><br><span class="line"><span class="comment">       * need to worry freeing it or not when the child data is destroyed</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      *vtable = *value_table;</span><br><span class="line">      p = <span class="built_in">G_STRUCT_MEMBER_P</span> (vtable, <span class="built_in">sizeof</span> (*vtable));</span><br><span class="line">      p[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      vtable-&gt;collect_format = p;</span><br><span class="line">      <span class="keyword">if</span> (value_table-&gt;collect_format)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strcat</span> (p, value_table-&gt;collect_format);</span><br><span class="line">    p += <span class="built_in">strlen</span> (value_table-&gt;collect_format);</span><br><span class="line">  &#125;</span><br><span class="line">      p++;</span><br><span class="line">      p[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      vtable-&gt;lcopy_format = p;</span><br><span class="line">      <span class="keyword">if</span> (value_table-&gt;lcopy_format)</span><br><span class="line">  <span class="built_in">strcat</span>  (p, value_table-&gt;lcopy_format);</span><br><span class="line">    &#125;</span><br><span class="line">  node-&gt;data-&gt;common.value_table = vtable;</span><br><span class="line">  node-&gt;mutatable_check_cache = (node-&gt;data-&gt;common.value_table-&gt;value_init != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">         !((G_TYPE_FLAG_VALUE_ABSTRACT | G_TYPE_FLAG_ABSTRACT) &amp;</span><br><span class="line">           <span class="built_in">GPOINTER_TO_UINT</span> (<span class="built_in">type_get_qdata_L</span> (node, static_quark_type_flags))));</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_assert</span> (node-&gt;data-&gt;common.value_table != <span class="literal">NULL</span>); <span class="comment">/* paranoid */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_atomic_int_set</span> ((<span class="type">int</span> *) &amp;node-&gt;ref_count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type_data_make_W 函数会创建 TypeData 实例，并把 GTypeInfo 的内容保存到 TypeData 实例中，最后会把创建的 TypeData 指针赋给 TypeNode 中的 TypeData 指针。TypeData 是个 union</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">_TypeData</span></span><br><span class="line">&#123;</span><br><span class="line">  CommonData         common;</span><br><span class="line">  BoxedData          boxed;</span><br><span class="line">  IFaceData          iface;</span><br><span class="line">  ClassData          <span class="keyword">class</span>;</span><br><span class="line">  InstanceData       instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只看 InstanceData</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_InstanceData</span></span><br><span class="line">&#123;</span><br><span class="line">  CommonData         common;</span><br><span class="line">  guint16            class_size;</span><br><span class="line">  guint16            class_private_size;</span><br><span class="line">  <span class="type">int</span>                init_state;  <span class="comment">/* (atomic) - g_type_class_ref reads it unlocked */</span></span><br><span class="line">  GBaseInitFunc      class_init_base;</span><br><span class="line">  GBaseFinalizeFunc  class_finalize_base;</span><br><span class="line">  GClassInitFunc     class_init;</span><br><span class="line">  GClassFinalizeFunc class_finalize;</span><br><span class="line">  gconstpointer      class_data;</span><br><span class="line">  gpointer           <span class="keyword">class</span>;</span><br><span class="line">  guint16            instance_size;</span><br><span class="line">  guint16            private_size;</span><br><span class="line">  guint16            n_preallocs;</span><br><span class="line">  GInstanceInitFunc  instance_init;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TypeNode 是类型注册中最重要的结构，父子继承关系、class_init、base_init、instance_init 等函数指针都保存在 TypeNode 中。TypeNode 还有一个 private_size 变量，和类的私有结构相关，他代表私有结构的大小，之前说的定义带私有结构的类会用到这个变量。</p><h1 id="基本类型的注册"><a href="#基本类型的注册" class="headerlink" title="基本类型的注册"></a>基本类型的注册</h1><p>最后再看一下基本类型的注册流程，以 G_TYPE_OBJECT 为例子。</p><h2 id="g-object-type-init"><a href="#g-object-type-init" class="headerlink" title="_g_object_type_init"></a>_g_object_type_init</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_g_object_type_init (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> gboolean initialized = FALSE;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> GTypeFundamentalInfo finfo = &#123;</span><br><span class="line">    G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE,</span><br><span class="line">  &#125;;</span><br><span class="line">  GTypeInfo info = &#123;</span><br><span class="line">    <span class="built_in">sizeof</span> (GObjectClass),</span><br><span class="line">    (GBaseInitFunc) g_object_base_class_init,</span><br><span class="line">    (GBaseFinalizeFunc) g_object_base_class_finalize,</span><br><span class="line">    (GClassInitFunc) g_object_do_class_init,</span><br><span class="line">    <span class="literal">NULL</span>  <span class="comment">/* class_destroy */</span>,</span><br><span class="line">    <span class="literal">NULL</span>  <span class="comment">/* class_data */</span>,</span><br><span class="line">    <span class="built_in">sizeof</span> (GObject),</span><br><span class="line">    <span class="number">0</span>   <span class="comment">/* n_preallocs */</span>,</span><br><span class="line">    (GInstanceInitFunc) g_object_init,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* value_table */</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> GTypeValueTable value_table = &#123;</span><br><span class="line">    g_value_object_init,    <span class="comment">/* value_init */</span></span><br><span class="line">    g_value_object_free_value,    <span class="comment">/* value_free */</span></span><br><span class="line">    g_value_object_copy_value,    <span class="comment">/* value_copy */</span></span><br><span class="line">    g_value_object_peek_pointer,  <span class="comment">/* value_peek_pointer */</span></span><br><span class="line">    <span class="string">&quot;p&quot;</span>,        <span class="comment">/* collect_format */</span></span><br><span class="line">    g_value_object_collect_value, <span class="comment">/* collect_value */</span></span><br><span class="line">    <span class="string">&quot;p&quot;</span>,        <span class="comment">/* lcopy_format */</span></span><br><span class="line">    g_value_object_lcopy_value,   <span class="comment">/* lcopy_value */</span></span><br><span class="line">  &#125;;</span><br><span class="line">  GType type G_GNUC_UNUSED  <span class="comment">/* when compiling with G_DISABLE_ASSERT */</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (initialized == FALSE);</span><br><span class="line">  initialized = TRUE;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* G_TYPE_OBJECT</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  info.value_table = &amp;value_table;</span><br><span class="line">  type = <span class="built_in">g_type_register_fundamental</span> (G_TYPE_OBJECT, <span class="built_in">g_intern_static_string</span> (<span class="string">&quot;GObject&quot;</span>), &amp;info, &amp;finfo, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">g_assert</span> (type == G_TYPE_OBJECT);</span><br><span class="line">  <span class="built_in">g_value_register_transform_func</span> (G_TYPE_OBJECT, G_TYPE_OBJECT, g_value_object_transform_value);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="g-type-register-fundamental"><a href="#g-type-register-fundamental" class="headerlink" title="g_type_register_fundamental"></a>g_type_register_fundamental</h3><p>基本类型注册使用的是 g_type_register_fundamental 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GType</span></span><br><span class="line"><span class="function"><span class="title">g_type_register_fundamental</span> <span class="params">(GType                       type_id,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> gchar                *type_name,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> GTypeInfo            *info,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> GTypeFundamentalInfo *finfo,</span></span></span><br><span class="line"><span class="params"><span class="function">           GTypeFlags      flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TypeNode *node;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_assert_type_system_initialized</span> ();</span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (type_id &gt; <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (type_name != <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (info != <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (finfo != <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">check_type_name_I</span> (type_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ((type_id &amp; TYPE_ID_MASK) ||</span><br><span class="line">      type_id &gt; G_TYPE_FUNDAMENTAL_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (<span class="string">&quot;attempt to register fundamental type &#x27;%s&#x27; with invalid type id (%&quot;</span> G_GSIZE_FORMAT <span class="string">&quot;)&quot;</span>,</span><br><span class="line">     type_name,</span><br><span class="line">     type_id);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> ((finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;</span><br><span class="line">      !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (<span class="string">&quot;cannot register instantiatable fundamental type &#x27;%s&#x27; as non-classed&quot;</span>,</span><br><span class="line">     type_name);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">lookup_type_node_I</span> (type_id))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_warning</span> (<span class="string">&quot;cannot register existing fundamental type &#x27;%s&#x27; (as &#x27;%s&#x27;)&quot;</span>,</span><br><span class="line">     <span class="built_in">type_descriptive_name_I</span> (type_id),</span><br><span class="line">     type_name);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">G_WRITE_LOCK</span> (&amp;type_rw_lock);</span><br><span class="line">  node = <span class="built_in">type_node_fundamental_new_W</span> (type_id, type_name, finfo-&gt;type_flags);</span><br><span class="line">  <span class="built_in">type_add_flags_W</span> (node, flags);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">check_type_info_I</span> (<span class="literal">NULL</span>, <span class="built_in">NODE_FUNDAMENTAL_TYPE</span> (node), type_name, info))</span><br><span class="line">    <span class="built_in">type_data_make_W</span> (node, info,</span><br><span class="line">          <span class="built_in">check_value_table_I</span> (type_name, info-&gt;value_table) ? info-&gt;value_table : <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">G_WRITE_UNLOCK</span> (&amp;type_rw_lock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NODE_TYPE</span> (node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="type-node-fundamental-new-W"><a href="#type-node-fundamental-new-W" class="headerlink" title="type_node_fundamental_new_W"></a>type_node_fundamental_new_W</h4><p>g_type_register_fundamental 函数使用 type_node_fundamental_new_W 函数创建 TypeNode，内部也是调用了 type_node_any_new_W 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> TypeNode*</span></span><br><span class="line"><span class="function"><span class="title">type_node_fundamental_new_W</span> <span class="params">(GType                 ftype,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> gchar          *name,</span></span></span><br><span class="line"><span class="params"><span class="function">           GTypeFundamentalFlags type_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GTypeFundamentalInfo *finfo;</span><br><span class="line">  TypeNode *node;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">g_assert</span> ((ftype &amp; TYPE_ID_MASK) == <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">g_assert</span> (ftype &lt;= G_TYPE_FUNDAMENTAL_MAX);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT == static_fundamental_next)</span><br><span class="line">    static_fundamental_next++;</span><br><span class="line">  </span><br><span class="line">  type_flags &amp;= TYPE_FUNDAMENTAL_FLAG_MASK;</span><br><span class="line">  </span><br><span class="line">  node = <span class="built_in">type_node_any_new_W</span> (<span class="literal">NULL</span>, ftype, name, <span class="literal">NULL</span>, type_flags);</span><br><span class="line">  </span><br><span class="line">  finfo = <span class="built_in">type_node_fundamental_info_I</span> (node);</span><br><span class="line">  finfo-&gt;type_flags = type_flags;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="type-data-make-W-1"><a href="#type-data-make-W-1" class="headerlink" title="type_data_make_W"></a>type_data_make_W</h4><p>g_type_register_fundamental 函数创建 TypeNode 后也是使用 type_data_make_W 函数初始化 TypeNode，和普通类型一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> G_TYPE_OBJECT     G_TYPE_MAKE_FUNDAMENTAL (20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_TYPE_MAKE_FUNDAMENTAL(x)  ((GType) ((x) &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT))</span></span><br></pre></td></tr></table></figure><p>可以看到 G_TYPE_OBJECT 宏返回值是 20 左移 G_TYPE_FUNDAMENTAL_SHIFT。这是因为 Gobject 内部会把基本类型的 TypeNode 指针放在一个全局的数组中，类型注册时返回的 GType 是该数组的索引，对自定义类型，类型注册时返回的 GType 就是 TypeNode 指针。</p><p>参考资料：</p><p><a href="http://garfileo.is-programmer.com/2011/7/14/gobject-notes.27977.html">http://garfileo.is-programmer.com/2011/7/14/gobject-notes.27977.html</a></p><p><a href="https://docs.gtk.org/gobject/index.html">https://docs.gtk.org/gobject/index.html</a></p><p><a href="https://www.jianshu.com/p/a5103d08a7f0">https://www.jianshu.com/p/a5103d08a7f0</a></p>]]></content>
      
      
      <categories>
          
          <category> gobject </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gobject之定义带私有结构的类</title>
      <link href="/2023/04/14/Gobject%E4%B9%8B%E5%AE%9A%E4%B9%89%E5%B8%A6%E7%A7%81%E6%9C%89%E7%BB%93%E6%9E%84%E7%9A%84%E7%B1%BB/"/>
      <url>/2023/04/14/Gobject%E4%B9%8B%E5%AE%9A%E4%B9%89%E5%B8%A6%E7%A7%81%E6%9C%89%E7%BB%93%E6%9E%84%E7%9A%84%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>之前的博客介绍了如何定义一个最简单的 Gobject 类，但是 gstreamer 中经常会定义带有私有结构的 Gobject 类，这篇博客就介绍一下如何定义带有私有结构的 Gobject 类。</p><p>在很多 gstreamer 代码中，都是用如下方法定义带有私有结构的 Gobject 类：</p><ul><li><p>在头文件的 <code>实例struct</code> 内定义一个私有结构的指针</p></li><li><p>在 c 文件中定义私有结构</p></li><li><p>在 c 文件中用宏 G_DEFINE_TYPE_WITH_PRIVATE 定义类型</p><ul><li>需要注意的是这个宏输入 3 个参数，没有显式的要求输入私有变量结构的类型名字，这是因为他默认约定了私有变量结构的名字是 TNPrivate 形式的。</li></ul></li><li><p>在 instance init 函数中获得私有变量指针，然后赋给实例结构中定义的私有结构的指针。后续代码可以通过该指针访问私有变量。</p></li></ul><p>还是以之前博客中的代码为基础，我们定义一个带有私有结构的 Gobject 类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glib-object.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TYPE_OBJ (my_obj_get_type())</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ(o)              (G_TYPE_CHECK_INSTANCE_CAST ((o), MY_TYPE_OBJ, MyObj))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_IS_OBJ(o)           (G_TYPE_CHECK_INSTANCE_TYPE ((o), MY_TYPE_OBJ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class), MY_TYPE_OBJ, MyObjClass))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_IS_OBJ_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class), MY_TYPE_OBJ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ_GET_CLASS(o)    (G_TYPE_INSTANCE_GET_CLASS ((o), MY_TYPE_OBJ, MyObjClass))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MyObj</span> MyObj;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MyObjClass</span> MyObjClass;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MyObjPrivate</span> MyObjPrivate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MyObj</span>&#123;</span><br><span class="line">    GObject obj;</span><br><span class="line">    MyObjPrivate    *priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MyObjClass</span>&#123;</span><br><span class="line">    GObjectClass <span class="keyword">class</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">GType <span class="title">my_obj_get_type</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MyObjPrivate</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">G_DEFINE_TYPE_WITH_PRIVATE</span> (MyObj, my_obj, G_TYPE_OBJECT);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_obj_init</span><span class="params">(MyObj *self)</span></span>&#123;</span><br><span class="line">    self-&gt;priv = <span class="built_in">my_obj_get_instance_private</span> (self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_obj_class_init</span><span class="params">(MyObjClass *klass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">void</span> * f = <span class="built_in">g_object_new</span>(MY_TYPE_OBJ, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">g_print</span>(<span class="string">&quot;first program\n&quot;</span>);</span><br><span class="line">    <span class="built_in">g_object_unref</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>G_DEFINE_TYPE_WITH_PRIVATE</code> 宏，也是使用了 <code>G_DEFINE_TYPE_EXTENDED</code> 宏，但是相比 <code>G_DEFINE_TYPE</code> 多了一段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> G_DEFINE_TYPE_WITH_PRIVATE(TN, t_n, T_P) \</span></span><br><span class="line"><span class="meta">    G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, 0, G_ADD_PRIVATE (TN))</span></span><br></pre></td></tr></table></figure><p><code>G_ADD_PRIVATE</code> 宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> G_ADD_PRIVATE(TypeName) &#123; \</span></span><br><span class="line"><span class="meta">  TypeName##_private_offset = \</span></span><br><span class="line"><span class="meta">    g_type_add_instance_private (g_define_type_id, sizeof (TypeName##Private)); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>把用 <code>G_DEFINE_TYPE_WITH_PRIVATE</code> 定义的代码进行替换，得到以下内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glib-object.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TYPE_OBJ (my_obj_get_type())</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ(o)              (G_TYPE_CHECK_INSTANCE_CAST ((o), MY_TYPE_OBJ, MyObj))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_IS_OBJ(o)           (G_TYPE_CHECK_INSTANCE_TYPE ((o), MY_TYPE_OBJ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class), MY_TYPE_OBJ, MyObjClass))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_IS_OBJ_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class), MY_TYPE_OBJ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ_GET_CLASS(o)    (G_TYPE_INSTANCE_GET_CLASS ((o), MY_TYPE_OBJ, MyObjClass))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MyObj</span> MyObj;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MyObjClass</span> MyObjClass;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MyObjPrivate</span> MyObjPrivate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MyObj</span>&#123;</span><br><span class="line">    GObject obj;</span><br><span class="line">    MyObjPrivate    *priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MyObjClass</span>&#123;</span><br><span class="line">    GObjectClass <span class="keyword">class</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">GType <span class="title">my_obj_get_type</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MyObjPrivate</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>     <span class="title">my_obj_init</span>              <span class="params">(MyObj        *self)</span></span>; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>     <span class="title">my_obj_class_init</span>        <span class="params">(MyObjClass *klass)</span></span>; </span><br><span class="line"><span class="function"><span class="type">static</span> GType    <span class="title">my_obj_get_type_once</span>     <span class="params">(<span class="type">void</span>)</span></span>; </span><br><span class="line"><span class="type">static</span> gpointer my_obj_parent_class = <span class="literal">NULL</span>; </span><br><span class="line"><span class="type">static</span> gint     MyObj_private_offset; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>     <span class="title">my_obj_class_intern_init</span> <span class="params">(gpointer klass)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  my_obj_parent_class = <span class="built_in">g_type_class_peek_parent</span> (klass); </span><br><span class="line">  <span class="keyword">if</span> (MyObj_private_offset != <span class="number">0</span>) </span><br><span class="line">    <span class="built_in">g_type_class_adjust_private_offset</span> (klass, &amp;MyObj_private_offset); </span><br><span class="line">  <span class="built_in">my_obj_class_init</span> ((MyObjClass*) klass); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> gpointer </span></span><br><span class="line"><span class="function"><span class="title">my_obj_get_instance_private</span> <span class="params">(MyObj *self)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">G_STRUCT_MEMBER_P</span> (self, MyObj_private_offset)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">GType </span></span><br><span class="line"><span class="function"><span class="title">my_obj_get_type</span> <span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">static</span> gsize static_g_define_type_id = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Prelude goes here */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g_once_init_enter</span> (&amp;static_g_define_type_id)) </span><br><span class="line">    &#123; </span><br><span class="line">      GType g_define_type_id = <span class="built_in">my_obj_get_type_once</span> (); </span><br><span class="line">      <span class="built_in">g_once_init_leave</span> (&amp;static_g_define_type_id, g_define_type_id); </span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> static_g_define_type_id; </span><br><span class="line">&#125; <span class="comment">/* closes my_obj_get_type() */</span> </span><br><span class="line"></span><br><span class="line"><span class="function">G_NO_INLINE </span></span><br><span class="line"><span class="function"><span class="type">static</span> GType </span></span><br><span class="line"><span class="function"><span class="title">my_obj_get_type_once</span> <span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  GType g_define_type_id = </span><br><span class="line">        <span class="built_in">g_type_register_static_simple</span> (G_TYPE_OBJECT, </span><br><span class="line">                                       <span class="built_in">g_intern_static_string</span> (<span class="string">&quot;MyObj&quot;</span>), </span><br><span class="line">                                       <span class="built_in">sizeof</span> (MyObjClass), </span><br><span class="line">                                       (GClassInitFunc)(<span class="built_in">void</span> (*)(<span class="type">void</span>)) my_obj_class_intern_init, </span><br><span class="line">                                       <span class="built_in">sizeof</span> (MyObj), </span><br><span class="line">                                       (GInstanceInitFunc)(<span class="built_in">void</span> (*)(<span class="type">void</span>)) my_obj_init, </span><br><span class="line">                                       (GTypeFlags) <span class="number">0</span>); </span><br><span class="line">    &#123; <span class="comment">/* custom code follows */</span> </span><br><span class="line">    &#123; </span><br><span class="line">      MyObj_private_offset = </span><br><span class="line">        <span class="built_in">g_type_add_instance_private</span> (g_define_type_id, <span class="built_in">sizeof</span> (MyObjPrivate)); </span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/* following custom code */</span> </span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> g_define_type_id; </span><br><span class="line">&#125; <span class="comment">/* closes my_obj_get_type_once() */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_obj_init</span><span class="params">(MyObj *self)</span></span>&#123;</span><br><span class="line">    self-&gt;priv = <span class="built_in">my_obj_get_instance_private</span> (self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_obj_class_init</span><span class="params">(MyObjClass *klass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">void</span> * f = <span class="built_in">g_object_new</span>(MY_TYPE_OBJ, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">g_print</span>(<span class="string">&quot;first program\n&quot;</span>);</span><br><span class="line">    <span class="built_in">g_object_unref</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了 my_obj_get_instance_private 函数和 MyObj_private_offset 这个 gint 类型的变量。my_obj_get_instance_private 函数的意思是取得实例中私有变量的地址，MyObj_private_offset 则是存储了私有变量在实例结构中的偏移。</p><p>上面添加的额外代码是将 MyObj_private_offset 赋值为 g_type_add_instance_private 函数的返回值。那么 g_type_add_instance_private 返回了什么？他返回的其实是私有 struct 的 size。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gint</span></span><br><span class="line"><span class="function"><span class="title">g_type_add_instance_private</span> <span class="params">(GType class_gtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                             gsize private_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TypeNode *node = <span class="built_in">lookup_type_node_I</span> (class_gtype);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> private_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>g_type_class_adjust_private_offset 做了什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">g_type_class_adjust_private_offset</span> <span class="params">(gpointer  g_class,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    gint     *private_size_or_offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GType class_gtype = ((GTypeClass *) g_class)-&gt;g_type;</span><br><span class="line">  TypeNode *node = <span class="built_in">lookup_type_node_I</span> (class_gtype);</span><br><span class="line">  gssize private_size;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_return_if_fail</span> (private_size_or_offset != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* if we have been passed the offset instead of the private data size,</span></span><br><span class="line"><span class="comment">   * then we consider this as a no-op, and just return the value. see the</span></span><br><span class="line"><span class="comment">   * comment in g_type_add_instance_private() for the full explanation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (*private_size_or_offset &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">g_return_if_fail</span> (*private_size_or_offset &lt;= <span class="number">0xffff</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">G_WRITE_LOCK</span> (&amp;type_rw_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父类也可能有private data的情况</span></span><br><span class="line">  private_size = <span class="built_in">ALIGN_STRUCT</span> (node-&gt;data-&gt;instance.private_size + *private_size_or_offset);</span><br><span class="line">  <span class="built_in">g_assert</span> (private_size &lt;= <span class="number">0xffff</span>);</span><br><span class="line">  node-&gt;data-&gt;instance.private_size = private_size;</span><br><span class="line"></span><br><span class="line">  *private_size_or_offset = -(gint) node-&gt;data-&gt;instance.private_size;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">G_WRITE_UNLOCK</span> (&amp;type_rw_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 g_type_add_instance_private 中设置了 MyObj_private_offset 为私有结构的 size，g_type_class_adjust_private_offset 则是先把 MyObj_private_offset（也就是当前子类的私有结构的 size）加到父类的 private_size 上，进行对齐，然后把 private_size 的负值设到 MyObj_private_offset 中。这是因为 gobject 私有变量的内存是在实例变量起始地址的上方，类似下面</p><p><img src="/images/Gobject%E4%B9%8B%E5%AE%9A%E4%B9%89%E5%B8%A6%E7%A7%81%E6%9C%89%E7%BB%93%E6%9E%84%E7%9A%84%E7%B1%BB/Mgggbx9pnoOHArxBjGicv4MtnHg.jpg"></p><p>取私有结构的地址是通过 my_obj_get_instance_private 函数，该函数内使用宏 <code>G_STRUCT_MEMBER_P</code> 获得私有结构的地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> G_STRUCT_MEMBER_P(struct_p, struct_offset)   \</span></span><br><span class="line"><span class="meta">    ((gpointer) ((guint8*) (struct_p) + (glong) (struct_offset)))</span></span><br></pre></td></tr></table></figure><p>struct_p 是 object 的指针，struct_offset 是偏移，所以上面就是 <code>object的指针+私有变量的偏移</code>。</p>]]></content>
      
      
      <categories>
          
          <category> gobject </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gobject之定义类</title>
      <link href="/2023/04/10/Gobject%E4%B9%8B%E5%AE%9A%E4%B9%89%E7%B1%BB/"/>
      <url>/2023/04/10/Gobject%E4%B9%8B%E5%AE%9A%E4%B9%89%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇博客介绍如何定义一个 Gobject 类，为后续分析 Gobject 源码做铺垫。</p></blockquote><p>Gobject 是一个 C 语言库，它希望用 C 实现类似 C++ 的面向对象、继承等特性。</p><p>几大特点：</p><ul><li>类似 C++ 的面向对象、继承、虚函数机制</li><li>基于引用计数的内存管理</li><li>get、set 属性设置</li><li>闭包和回调函数机制</li></ul><p>下面的代码使用 Gobject 定义了一个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gobj.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glib-object.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TYPE_OBJ (my_obj_get_type())</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ(o)              (G_TYPE_CHECK_INSTANCE_CAST ((o), MY_TYPE_OBJ, MyObj))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_IS_OBJ(o)           (G_TYPE_CHECK_INSTANCE_TYPE ((o), MY_TYPE_OBJ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class), MY_TYPE_OBJ, MyObjClass))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_IS_OBJ_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class), MY_TYPE_OBJ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ_GET_CLASS(o)    (G_TYPE_INSTANCE_GET_CLASS ((o), MY_TYPE_OBJ, MyObjClass))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MyObj</span> MyObj;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MyObjClass</span> MyObjClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MyObj</span>&#123;</span><br><span class="line">    GObject obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MyObjClass</span>&#123;</span><br><span class="line">    GObjectClass <span class="keyword">class</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">GType <span class="title">my_obj_get_type</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上通常放在头文件中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">G_DEFINE_TYPE</span>(MyObj, my_obj, G_TYPE_OBJECT);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_obj_init</span><span class="params">(MyObj *self)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_obj_class_init</span><span class="params">(MyObjClass *klass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">void</span> * f = <span class="built_in">g_object_new</span>(MY_TYPE_OBJ, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">g_print</span>(<span class="string">&quot;first program\n&quot;</span>);</span><br><span class="line">    <span class="built_in">g_object_unref</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译</span></span><br><span class="line"><span class="comment">// gcc  -o main gobj.c `pkg-config --cflags --libs gstreamer-1.0`</span></span><br></pre></td></tr></table></figure><p>使用 Gobject 定义一个类，有特定的流程，下面以上面的代码为例介绍如何使用 Gobject 定义一个类：</p><p>首先要想好自己的项目名和要定义的类的名字，上面例子中项目名是 My，类名是 Obj，项目名和类名要求首字母大写，其余字母小写。</p><p>第一步，定义一个宏来代表这个类，后面会使用该宏来引用这个类型，宏名必须是 <code>项目名_TYPE_类名</code>，必须全大写，这个宏的替换部分是一个函数，函数名必须是 <code>项目名_类名_get_type</code>，且全部小写。</p><p>这里还需要定义一系列的辅助宏：MY_OBJ 用于将一个输入指针转换为 MyObj 的指针，转化时会检查输入指针是否指向 MyObj 或者他的子类，MY_IS_OBJ 用于判断一个输入指针是否指向 MyObj 或者他的子类，MY_OBJ_CLASS 用于把一个输入指针转换为 MyObjClass 的指针，转换时也会检查输入指针是否指向 MyObjClass 或者他的子类，MY_IS_OBJ_CLASS 用于判断一个输入指针是否指向 MyObjClass 或者他的子类，MY_OBJ_GET_CLASS 从输入的 MyObj&#x2F;其子类 中获得 MyObjClass&#x2F;其子类 的指针。</p><p>第二步，对 struct 使用 typedef 重新定义，方便后续使用 struct。</p><p>第三步，定义两个 struct：一个 <code>实例struct</code>，一个 <code>类struct</code>。<code>实例struct</code> 存储实例数据；<code>类struct</code> 保存函数指针，用于实现类似 C++ 的虚函数覆盖机制。每一个类都有唯一的 <code>类struct</code> 的实例，而每一个类的实例则分别对应一个 <code>实例struct</code> 的实例。</p><p>上面第三步在定义 MyObj 和 MyObjClass 时，他们的第一个成员分别是 GObject 和 GObjectClass。Gobject 库通过这种方式实现继承：当子类要继承一个父类时，会把父类的 <code>实例struct</code> 和 <code>类struct</code> 的 实例 作为自己的 <code>实例struct</code> 和 <code>类struct</code> 的第一个成员，这样子类内部相当于内嵌了一个父类（和 C++ 的继承很像）。</p><p>第四步，声明第一步中的函数。</p><p>上面几步通常在头文件中，但是例子中为了方便一起放在 c 文件中了。</p><p>第五步，使用 G_DEFINE_TYPE 宏定义类。</p><p>第六步，定义 init 和 class_init 等函数。</p><p>Gobject 的命名约定：</p><ul><li>Gobject 约定项目名和类名都是首字母大写，其余字母小写，比如上面的 My 和 Obj。</li><li>Gobject 约定 <code>实例struct</code> 名字是 <code>项目名类名</code>，<code>类struct</code> 名字是 <code>项目名类名Class</code>，遵循驼峰命名规则，比如上面 MyObj、MyObjClass。</li><li>Gobject 约定函数前缀是全小写的 <code>项目名_类名</code>，用下划线分隔，比如 my_obj。上面例子中的 init 和 class_init 函数全名分别是 my_obj_init、my_obj_class_init。</li></ul><p>下面看看 <code>G_DEFINE_TYPE</code> 宏到底做了什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> G_DEFINE_TYPE(TN, t_n, T_P)   \</span></span><br><span class="line"><span class="meta">    G_DEFINE_TYPE_EXTENDED (TN, t_n, T_P, 0, &#123;&#125;)</span></span><br></pre></td></tr></table></figure><p><code>G_DEFINE_TYPE</code> 宏有 3 个参数，TN 是 TypeName，类型名，就是 <code>实例struct</code> 的名字，t_n 是函数前缀，T_P 是父类的类型标识宏。<code>G_DEFINE_TYPE</code> 内部使用了 <code>G_DEFINE_TYPE_EXTENDED</code>。<code>G_DEFINE_TYPE_EXTENDED</code> 多了两个参数，_f_是 flag，_C_则是额外想要插入的在初始化时执行的 code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> G_DEFINE_TYPE_EXTENDED(TN, t_n, T_P, _f_, _C_)    \</span></span><br><span class="line"><span class="meta">    _G_DEFINE_TYPE_EXTENDED_BEGIN (TN, t_n, T_P, _f_) &#123;_C_;&#125; \</span></span><br><span class="line"><span class="meta">    _G_DEFINE_TYPE_EXTENDED_END()</span></span><br></pre></td></tr></table></figure><p><code>_G_DEFINE_TYPE_EXTENDED_BEGIN</code> 宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _G_DEFINE_TYPE_EXTENDED_BEGIN(TypeName, type_name, TYPE_PARENT, flags) \</span></span><br><span class="line"><span class="meta">  _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE(TypeName, type_name, TYPE_PARENT) \</span></span><br><span class="line"><span class="meta">  _G_DEFINE_TYPE_EXTENDED_BEGIN_REGISTER(TypeName, type_name, TYPE_PARENT, flags) \</span></span><br></pre></td></tr></table></figure><p><code>_G_DEFINE_TYPE_EXTENDED_END</code> 宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _G_DEFINE_TYPE_EXTENDED_END() \</span></span><br><span class="line"><span class="meta">      <span class="comment">/* following custom code */</span> \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">  return g_define_type_id; \</span></span><br><span class="line"><span class="meta">&#125; <span class="comment">/* closes type_name##_get_type_once() */</span></span></span><br></pre></td></tr></table></figure><p><code>_G_DEFINE_TYPE_EXTENDED_BEGIN_PRE</code> 宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE(TypeName, type_name, TYPE_PARENT) \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">static void     type_name##_init              (TypeName        *self); \</span></span><br><span class="line"><span class="meta">static void     type_name##_class_init        (TypeName##Class *klass); \</span></span><br><span class="line"><span class="meta">static GType    type_name##_get_type_once     (void); \</span></span><br><span class="line"><span class="meta">static gpointer type_name##_parent_class = NULL; \</span></span><br><span class="line"><span class="meta">static gint     TypeName##_private_offset; \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">_G_DEFINE_TYPE_EXTENDED_CLASS_INIT(TypeName, type_name) \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">G_GNUC_UNUSED \</span></span><br><span class="line"><span class="meta">static inline gpointer \</span></span><br><span class="line"><span class="meta">type_name##_get_instance_private (TypeName *self) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">  return (G_STRUCT_MEMBER_P (self, TypeName##_private_offset)); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">GType \</span></span><br><span class="line"><span class="meta">type_name##_get_type (void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">  static gsize static_g_define_type_id = 0;</span></span><br><span class="line">  <span class="comment">/* Prelude goes here */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Added for _G_DEFINE_TYPE_EXTENDED_WITH_PRELUDE */</span></span><br></pre></td></tr></table></figure><p><code>_G_DEFINE_TYPE_EXTENDED_BEGIN_REGISTER</code> 宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _G_DEFINE_TYPE_EXTENDED_BEGIN_REGISTER(TypeName, type_name, TYPE_PARENT, flags) \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (g_once_init_enter (&amp;static_g_define_type_id)) \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">      GType g_define_type_id = type_name##_get_type_once (); \</span></span><br><span class="line"><span class="meta">      g_once_init_leave (&amp;static_g_define_type_id, g_define_type_id); \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">  return static_g_define_type_id; \</span></span><br><span class="line"><span class="meta">&#125; <span class="comment">/* closes type_name##_get_type() */</span> \</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">G_NO_INLINE \</span></span><br><span class="line"><span class="meta">static GType \</span></span><br><span class="line"><span class="meta">type_name##_get_type_once (void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">  GType g_define_type_id = \</span></span><br><span class="line"><span class="meta">        g_type_register_static_simple (TYPE_PARENT, \</span></span><br><span class="line"><span class="meta">                                       g_intern_static_string (#TypeName), \</span></span><br><span class="line"><span class="meta">                                       sizeof (TypeName##Class), \</span></span><br><span class="line"><span class="meta">                                       (GClassInitFunc)(void (*)(void)) type_name##_class_intern_init, \</span></span><br><span class="line"><span class="meta">                                       sizeof (TypeName), \</span></span><br><span class="line"><span class="meta">                                       (GInstanceInitFunc)(void (*)(void)) type_name##_init, \</span></span><br><span class="line"><span class="meta">                                       (GTypeFlags) flags); \</span></span><br><span class="line"><span class="meta">    &#123; <span class="comment">/* custom code follows */</span></span></span><br></pre></td></tr></table></figure><p><code>_G_DEFINE_TYPE_EXTENDED_CLASS_INIT</code> 宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _G_DEFINE_TYPE_EXTENDED_CLASS_INIT(TypeName, type_name) \</span></span><br><span class="line"><span class="meta">static void     type_name##_class_intern_init (gpointer klass) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">  type_name##_parent_class = g_type_class_peek_parent (klass); \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (TypeName##_private_offset != 0) \</span></span><br><span class="line"><span class="meta">    g_type_class_adjust_private_offset (klass, &amp;TypeName##_private_offset); \</span></span><br><span class="line"><span class="meta">  type_name##_class_init ((TypeName##Class*) klass); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>把上面的宏进行替换，整理一下，上面的例子可以得到下面的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glib-object.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TYPE_OBJ (my_obj_get_type())</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ(o)              (G_TYPE_CHECK_INSTANCE_CAST ((o), MY_TYPE_OBJ, MyObj))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_IS_OBJ(o)           (G_TYPE_CHECK_INSTANCE_TYPE ((o), MY_TYPE_OBJ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ_CLASS(class)    (G_TYPE_CHECK_CLASS_CAST ((class), MY_TYPE_OBJ, MyObjClass))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_IS_OBJ_CLASS(class) (G_TYPE_CHECK_CLASS_TYPE ((class), MY_TYPE_OBJ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_OBJ_GET_CLASS(o)    (G_TYPE_INSTANCE_GET_CLASS ((o), MY_TYPE_OBJ, MyObjClass))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MyObj</span> MyObj;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MyObjClass</span> MyObjClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MyObj</span>&#123;</span><br><span class="line">    GObject obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MyObjClass</span>&#123;</span><br><span class="line">    GObjectClass <span class="keyword">class</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">GType <span class="title">my_obj_get_type</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>     <span class="title">my_obj_init</span>              <span class="params">(MyObj        *self)</span></span>; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>     <span class="title">my_obj_class_init</span>        <span class="params">(MyObjClass *klass)</span></span>; </span><br><span class="line"><span class="function"><span class="type">static</span> GType    <span class="title">my_obj_get_type_once</span>     <span class="params">(<span class="type">void</span>)</span></span>; </span><br><span class="line"><span class="type">static</span> gpointer my_obj_parent_class = <span class="literal">NULL</span>; </span><br><span class="line"><span class="type">static</span> gint     MyObj_private_offset; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>     <span class="title">my_obj_class_intern_init</span> <span class="params">(gpointer klass)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  my_obj_parent_class = <span class="built_in">g_type_class_peek_parent</span> (klass); </span><br><span class="line">  <span class="keyword">if</span> (MyObj_private_offset != <span class="number">0</span>) </span><br><span class="line">    <span class="built_in">g_type_class_adjust_private_offset</span> (klass, &amp;MyObj_private_offset); </span><br><span class="line">  <span class="built_in">my_obj_class_init</span> ((MyObjClass*) klass); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> gpointer </span></span><br><span class="line"><span class="function"><span class="title">my_obj_get_instance_private</span> <span class="params">(MyObj *self)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">G_STRUCT_MEMBER_P</span> (self, MyObj_private_offset)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">GType </span></span><br><span class="line"><span class="function"><span class="title">my_obj_get_type</span> <span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="type">static</span> gsize static_g_define_type_id = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Prelude goes here */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g_once_init_enter</span> (&amp;static_g_define_type_id)) </span><br><span class="line">    &#123; </span><br><span class="line">      GType g_define_type_id = <span class="built_in">my_obj_get_type_once</span> (); </span><br><span class="line">      <span class="built_in">g_once_init_leave</span> (&amp;static_g_define_type_id, g_define_type_id); </span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> static_g_define_type_id; </span><br><span class="line">&#125; <span class="comment">/* closes my_obj_get_type() */</span> </span><br><span class="line"></span><br><span class="line"><span class="function">G_NO_INLINE </span></span><br><span class="line"><span class="function"><span class="type">static</span> GType </span></span><br><span class="line"><span class="function"><span class="title">my_obj_get_type_once</span> <span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  GType g_define_type_id = </span><br><span class="line">        <span class="built_in">g_type_register_static_simple</span> (G_TYPE_OBJECT, </span><br><span class="line">                                       <span class="built_in">g_intern_static_string</span> (<span class="string">&quot;MyObj&quot;</span>), </span><br><span class="line">                                       <span class="built_in">sizeof</span> (MyObjClass), </span><br><span class="line">                                       (GClassInitFunc)(<span class="built_in">void</span> (*)(<span class="type">void</span>)) my_obj_class_intern_init, </span><br><span class="line">                                       <span class="built_in">sizeof</span> (MyObj), </span><br><span class="line">                                       (GInstanceInitFunc)(<span class="built_in">void</span> (*)(<span class="type">void</span>)) my_obj_init, </span><br><span class="line">                                       (GTypeFlags) <span class="number">0</span>); </span><br><span class="line">    &#123; <span class="comment">/* custom code follows */</span> </span><br><span class="line">    </span><br><span class="line">      <span class="comment">/* following custom code */</span> </span><br><span class="line">    &#125; </span><br><span class="line">  <span class="keyword">return</span> g_define_type_id; </span><br><span class="line">&#125; <span class="comment">/* closes my_obj_get_type_once() */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_obj_init</span><span class="params">(MyObj *self)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_obj_class_init</span><span class="params">(MyObjClass *klass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">void</span> * f = <span class="built_in">g_object_new</span>(MY_TYPE_OBJ, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">g_print</span>(<span class="string">&quot;first program\n&quot;</span>);</span><br><span class="line">    <span class="built_in">g_object_unref</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把宏展开之后就好理解了，<code>G_DEFINE_TYPE</code> 宏帮我们定义了一些函数，比如定义 my_obj_get_type 函数用于类型注册，同时还声明了 init、class_init 函数。</p><p>这里简单的介绍一下 Gobject 类的初始化过程：</p><ul><li>当用户使用类型标识宏（比如 MY_TYPE_OBJ）时，由于类型标识宏实际就是一个函数调用，所以会调用具体函数，上面例子中就是调用 my_obj_get_type 函数，my_obj_get_type 函数会调用 my_obj_get_type_once 函数执行类型注册，这是一个 thread_once 的过程。</li><li>注册类型过程中会创建 <code>类struct</code>（上面例子中是 MyObjClass）的实例，同时执行类初始化函数 my_obj_class_intern_init，在 my_obj_class_intern_init 中调用用户定义的类初始化函数 my_obj_class_init。</li><li>创建 <code>类struct</code> 的实例后，才能创建 <code>实例struct</code>（上面例子中是 MyObj）的实例，创建实例后会调用用户定义的实例初始化函数 my_obj_init 进行初始化。</li></ul><p>参考资料：</p><p><a href="http://garfileo.is-programmer.com/2011/7/14/gobject-notes.27977.html">http://garfileo.is-programmer.com/2011/7/14/gobject-notes.27977.html</a></p><p><a href="https://docs.gtk.org/gobject/index.html">https://docs.gtk.org/gobject/index.html</a></p><p><a href="https://www.jianshu.com/p/a5103d08a7f0">https://www.jianshu.com/p/a5103d08a7f0</a></p>]]></content>
      
      
      <categories>
          
          <category> gobject </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言的变长参数函数</title>
      <link href="/2023/04/06/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0/"/>
      <url>/2023/04/06/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>之前在研究 gobject 的时候，遇到了很多 C 语言的变长参数函数，这篇博客分析一下 C 语言的变长参数函数。</p><p>我们都用过 printf 函数，给定一个格式字符串，然后可以根据这个字符串输入不定长度的参数，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %s %d\n&quot;</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">2</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>他的实现类似下面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mini_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_start</span>(ap, fmt);</span><br><span class="line">    ret = <span class="built_in">vprintf</span>(fmt, &amp;ap);</span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, va_list* ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* val_s;</span><br><span class="line">    <span class="type">int64_t</span> val_i64;</span><br><span class="line">    <span class="type">int32_t</span> val_i32;</span><br><span class="line">    <span class="type">int16_t</span> val_i16;</span><br><span class="line">    <span class="type">int8_t</span> val_i8, c;</span><br><span class="line">    <span class="type">double</span> val_dbl;</span><br><span class="line">    <span class="type">float</span> val_flt;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((c = *fmt++)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            val_dbl = <span class="built_in">va_arg</span>(*ap, <span class="type">double</span>);</span><br><span class="line">            ret = <span class="built_in">printf_double</span>(val_dbl); <span class="comment">// 交给特定类型的函数去做</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            val_s = <span class="built_in">va_arg</span>(*ap, <span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">            ret = <span class="built_in">printf_string</span>(val_s); <span class="comment">// 交给特定类型的函数去做</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子的核心是以下几步</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">va_list ap;</span><br><span class="line"><span class="built_in">va_start</span>(ap, fmt);</span><br><span class="line"><span class="built_in">va_end</span>(ap);</span><br><span class="line"><span class="type">double</span> val_dbl = <span class="built_in">va_arg</span>(ap, <span class="type">double</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* val_s = <span class="built_in">va_arg</span>(ap, <span class="type">const</span> <span class="type">char</span>*);</span><br></pre></td></tr></table></figure><ul><li><code>va_list ap;</code> 表示声明一个 char <em>类型的变量 ap，<code>va_list</code> 就是 char</em>类型</li><li><code>va_start(ap, fmt);</code> 表示把 ap 指针的值指向 fmt 变量的下一个变量的地址值，可以这样理解：<code>ap=&amp;fmt+sizeof(fmt)</code></li><li><code>va_end(ap);</code> 表示把 ap 赋值为空，做清理工作</li><li><code>double val_dbl = va_arg(ap, double);</code> 表示把 ap 指针指向的内存解释为 double 类型，同时返回该值，然后将 ap 指针移动到当前变量的下一个变量。</li><li><code>const char* val_s = va_arg(ap, const char*);</code> 和上面一样，把 ap 指针指向的内存解释为 const char*类型，同时返回该值，然后将 ap 指针移动到当前变量的下一个变量。</li></ul><p>从上面分析可知，使用变长参数需要两个条件：变长参数连续保存，变长参数的类型和数目要通过某种方式传递给函数。只有这样才能正确解释当前 ap 指针指向的内存，以及移动 ap 到下一个变长参数的地址。</p><p>正确理解变长参数需要知道函数调用约定的知识，这里以 CDECL 为例（<a href="https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions">https://en.wikibooks.org/wiki/X86_Disassembly&#x2F;Calling_Conventions</a>），CDECL 函数调用约定：</p><ul><li>参数从右向左入栈，返回值通过 eax 寄存器返回</li><li>函数调用者清理栈空间</li></ul><p>这个调用方式的好处是支持变长参数，因为栈空间是由函数调用者清理，调用者肯定知道他传了多少参数，缺点是被调用者无法检查传给自己的参数是否合法（比如参数数目是否正确）</p><p>下图展示了 CDECL 下如何从栈中取变长参数</p><p>变长参数有两种常见的使用方式，一种是像 printf 一样，输入一个格式字符串，变长参数的类型通过该格式字符串得到。第二种是固定变长参数的类型为一种，比如下面的函数要求变长参数类型都为指针类型，对这种情况，往往还需要一个参数标识变长参数结尾，下面函数以 NULL 指针标志变长参数结尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>* s, ...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">void</span>* pre = s;</span><br><span class="line">    <span class="type">void</span>* node = <span class="literal">NULL</span>;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">va_start</span>(ap, s);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        node = <span class="built_in">va_arg</span>(ap, <span class="type">void</span>*);</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">do_something</span>(pre, node);</span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 f 时最后一个参数必须为 NULL 指针，比如 <code>f(&amp;a,&amp;b,&amp;c,NULL)</code>。</p><p>总结：使用 C 语言变长参数函数的核心是能正确从栈中取得每一个参数。</p><p>参考资料：</p><p><a href="https://www.cnblogs.com/chinazhangjie/archive/2012/08/18/2645475.html">https://www.cnblogs.com/chinazhangjie/archive/2012/08/18/2645475.html</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>delete[]和delete</title>
      <link href="/2023/04/02/delete-%E5%92%8Cdelete/"/>
      <url>/2023/04/02/delete-%E5%92%8Cdelete/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近看到这个帖子上介绍的 C++ delete[]的实现 <a href="https://zhuanlan.zhihu.com/p/74897601">https://zhuanlan.zhihu.com/p/74897601</a>，这篇博客记录一下自己的验证。</p></blockquote><p>当 C++ delete 一个数组时，不仅仅是简单的释放内存，还需要对数组中的每一个对象都调用析构函数，所以需要知道数组元素的个数，那么数组个数信息到底保存在哪里呢？上面帖子中最高赞同的答案是：C++ new 一个数组时，会在数组的最开始额外分配一块小内存（比如 4 或 8 字节）用于记录数组个数，下面对这个结论进行验证。</p><p>cpp 文件如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        i++;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    i++;</span><br><span class="line">    i = <span class="number">45</span>;</span><br><span class="line">    A* a = <span class="keyword">new</span> A[i];</span><br><span class="line">    <span class="keyword">delete</span>[] a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面文件编译后用 gdb 进行调试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b <span class="number">18</span> </span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11ef</span>: file m2.cpp, line <span class="number">18.</span> </span><br><span class="line">(gdb) r</span><br><span class="line">...</span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at m2.cpp:<span class="number">18</span> </span><br><span class="line"><span class="number">18</span>          <span class="keyword">delete</span>[] a;  </span><br><span class="line">(gdb) p a </span><br><span class="line">$<span class="number">1</span> = (A *) <span class="number">0x55555556aeb8</span> </span><br><span class="line">(gdb) x/<span class="number">8</span>db <span class="number">0x55555556aeb8</span><span class="number">-8</span> </span><br><span class="line"><span class="number">0x55555556aeb0</span>: <span class="number">45</span>      <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在 18 行打了个断点，然后查看 a 变量的值，a 变量存储了新创建的数组的地址，接着查看这个地址向前移动 8 后的内存，可以看到，确实出现了数组个数信息，当把数组长度调整时，45 也会随之改变。所以上面的结论是对的，当 new 一个数组时，会在头部额外分配一块内存记录数组个数。</p><p>接着又进行了以下实验，这次把析构函数注释掉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">/* ~A()&#123;</span></span><br><span class="line"><span class="comment">        i++;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    i++;</span><br><span class="line">    i = <span class="number">45</span></span><br><span class="line">    A* a = <span class="keyword">new</span> A[i];</span><br><span class="line">    <span class="keyword">delete</span> a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上面文件然后用 gdb 调试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ m2.cpp -o main -g</span><br><span class="line">gdb main</span><br><span class="line"></span><br><span class="line">info breakpoints</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b <span class="number">18</span> </span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x11b7</span>: file m2.cpp, line <span class="number">18.</span> </span><br><span class="line">(gdb) r</span><br><span class="line">...</span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at m2.cpp:<span class="number">18</span> </span><br><span class="line"><span class="number">18</span>          <span class="keyword">delete</span>[] a;  </span><br><span class="line">(gdb) p a </span><br><span class="line">$<span class="number">1</span> = (A *) <span class="number">0x55555556aeb0</span> </span><br><span class="line">(gdb) x/<span class="number">8</span>db <span class="number">0x55555556aeb0</span><span class="number">-8</span> </span><br><span class="line"><span class="number">0x55555556aea8</span>: <span class="number">-63</span>      <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span> </span><br><span class="line">(gdb) exit</span><br></pre></td></tr></table></figure><p>这次在数组头部往前 8 字节的地方没有出现数组个数信息，经测试-63 处的内存每次调试都会得到不同的值。<strong>所以编译器只会在必要的时候保存数组长度信息</strong>，当析构函数是编译器合成并且是 trivial 的（也就是没有做什么具体工作），那么析构时没有必要调用析构函数，因此也就不需要数组长度信息了。</p><p>参考资料：</p><p>深度探索 C++ 对象模型</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++对象模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg filter之AVFilterLink</title>
      <link href="/2023/03/28/ffmpeg-filter%E4%B9%8BAVFilterLink/"/>
      <url>/2023/03/28/ffmpeg-filter%E4%B9%8BAVFilterLink/</url>
      
        <content type="html"><![CDATA[<p>这篇博客介绍一下 AVFilterLink 中部分重要的字段。</p><p>AVFilterLink 用于管理 filter 之间的连接状态，filter 之间的数据流通，比如下游向上游申请数据，上游向下游传输数据，都需要通过 AVFilterLink 实现。</p><p>AVFilterLink 部分关键字段如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AVFilterLink</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lists of supported formats / etc. supported by the input filter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVFilterFormatsConfig incfg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lists of supported formats / etc. supported by the output filter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVFilterFormatsConfig outcfg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * True if a frame is currently wanted on the output of this link.</span></span><br><span class="line"><span class="comment">     * Set when ff_request_frame() is called by the output,</span></span><br><span class="line"><span class="comment">     * cleared when a frame is filtered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> frame_wanted_out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If set, the source filter can not generate a frame as is.</span></span><br><span class="line"><span class="comment">     * The goal is to avoid repeatedly calling the request_frame() method on</span></span><br><span class="line"><span class="comment">     * the same link.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> frame_blocked_in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link input status.</span></span><br><span class="line"><span class="comment">     * If not zero, all attempts of filter_frame will fail with the</span></span><br><span class="line"><span class="comment">     * corresponding code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> status_in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Link output status.</span></span><br><span class="line"><span class="comment">     * If not zero, all attempts of request_frame will fail with the</span></span><br><span class="line"><span class="comment">     * corresponding code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> status_out;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/ffmpeg-avfilterlink/filter.jpg"></p><ul><li><p>incfg&#x2F;outcfg  是当前 link 的输入端支持的 format 和输出端支持的 format，注意这里的输入输出是相对 link 而言的，如上图，incfg 来自 src filter，因为 src filter 是 link 的输入，outcfg 来自 sink filter，因为 sink filter 是 link 的输出，而这条 link 在 src filter 中被视为 output link，在 sink filter 中被视为 input link，这里容易弄混。</p></li><li><p>frame_wanted_out  当下游 filter 向自己的 input link 请求 frame 时，如果此时 link 的 fifo 中没有数据，那么就会设置 frame_wanted_out 为 1，表示 link 的 ouput 想要数据；当上游往下游送数据时（可能是下游的申请导致的），会把 frame_wanted_out 变为 0</p></li><li><p>frame_blocked_in  当 filter 需要向上传递 request_frame 请求时，会把当前想要传递 request_frame 请求的 output link 的 frame_blocked_in 设为 1，当下次再向上传递该 output link 的 request_frame 请求时会检查他的 frame_blocked_in，如果 frame_blocked_in 为 1 则跳过这次传递 request_frame 请求过程。</p><ul><li>frame_blocked_in 不太好理解，我最开始以为是：当下游 filter 往自己的 input link 请求 frame 时，会设置 input link 的 frame_blocked_in 为 1，而上游向下游送数据时会把 frame_blocked_in 赋为 0。这个理解只对了一半：上游向下游送数据时会把 frame_blocked_in 赋为 0，而下游向上游请求 frame 时不设置 frame_blocked_in 为 1，而是在上游 filter 激活时发现自己无法满足下游的 request_frame 请求（比如没有 frame），从而向自己的 input link 发起 request_frame 时会设置下游 output link 的 frame_blocked_in 为 1</li><li>但是据我观察，很多 filter 没有在自己的 activate function 中检查这个变量。目前官方的默认激活函数 ff_filter_activate_default 检查了 frame_blocked_in 来避免重复的 request_frame 请求。</li></ul></li><li><p>status_in  表示当前 link 的输入端的状态，0 为正常，大于 0 为异常，这里输入端的概念和 incfg 是一样的</p></li><li><p>status_out  表示当前 link 的输出端的状态，0 为正常，大于 0 为异常，这里输出端的概念和 outcfg 是一样的</p></li></ul><p>参考资料：</p><p><a href="https://www.cnblogs.com/TaigaCon/p/10111326.html">https://www.cnblogs.com/TaigaCon/p/10111326.html</a></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg filter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg filter之dump排错</title>
      <link href="/2023/03/25/ffmpeg-filter%E4%B9%8Bdump%E6%8E%92%E9%94%99/"/>
      <url>/2023/03/25/ffmpeg-filter%E4%B9%8Bdump%E6%8E%92%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>最近在使用 ffmpeg filter 的时候，发现了 dump 这个工具，这个工具用起来很方便，能够快速查看整个 filtergraph 的状态，对于排错很有帮助，特此写篇博客介绍一下这个工具。</p><p>dump 的输出类似下面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Axxx -&gt; Bxxx   f:1|1 fmt:fltp sr:8000   cl:1 channels       st:1 wn:1 cnt:496      cur:4|512      ex:N/A</span><br><span class="line">Cxxx -&gt; Dxxx   f:0|0 fmt:?    sr:0      cl:0 channels       st:0 wn:0 cnt:0        cur:0|0        ex:hello world </span><br><span class="line">Dxxx -&gt; NULL                                                                                      ex:st: 0</span><br><span class="line">Exxx -&gt; Fxxx   f:1|1 fmt:yuv420p wh:   640|480    ra:   1|1    st:1 wn:1 cnt:355      cur:0|0        ex:N/A</span><br><span class="line">Fxxx -&gt; Gxxx   f:0|0 fmt:?    wh:     0|0      ra:   0|0    st:0 wn:0 cnt:0        cur:0|0        ex:hello </span><br><span class="line">Gxxx -&gt; NULL                                                                                                   ex:N/A</span><br><span class="line">Fxxx -&gt; Bxxx   f:1|1 fmt:yuv420p wh:   640|480    ra:   1|1    st:1 wn:1 cnt:355      cur:0|0        ex:world </span><br><span class="line">Fxxx -&gt; Hxxx   f:0|0 fmt:?    wh:     0|0      ra:   0|0    st:0 wn:0 cnt:0        cur:0|0        ex:world</span><br></pre></td></tr></table></figure><p>其中每一行代表一个 link，’-&gt;’左边是 link 的输入 filter，右边是输出 filter，’-&gt;’右边为 NULL 代表 filter 左边是 sink filter。其他字段，比如 <code>f fmt sr</code> 等都表示 link 上的数据，这里先不解释具体含义，到下面代码部分结合代码一起介绍。</p><p>dump 最终会作用到 avfilter_graph_dump_ext，所以我们从这个函数开始。该函数会调用 graph_filter_dump 对每一个 filter 进行 dump</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">avfilter_graph_dump_ext</span><span class="params">(AVFilterGraph *graph, <span class="type">const</span> <span class="type">char</span> *options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext *cur;</span><br><span class="line">    AVBPrint buf;</span><br><span class="line">    <span class="type">char</span> *dump = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_bprint_init</span>(&amp;buf, <span class="number">0</span>, AV_BPRINT_SIZE_UNLIMITED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">        cur = graph-&gt;filters[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;nb_inputs || cur-&gt;nb_inputs &gt; <span class="number">1</span> || cur-&gt;nb_outputs &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">graph_filter_dump</span>(&amp;buf, cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_bprint_finalize</span>(&amp;buf, &amp;dump);</span><br><span class="line">    <span class="keyword">return</span> dump;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>graph_filter_dump 会对当前 filter 的每一条 output link 进行 dump，先打印 “A -&gt; B” 信息，然后调用 graph_link_dump 打印 link 上的信息，graph_link_dump 函数对理解上面 dump 的输出至关重要。在 dump 完 link 后会通过 avfilter_process_command 函数执行每个 filter 自己定义的 dump 动作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">graph_filter_dump</span><span class="params">(AVBPrint *buf, AVFilterContext *cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        AVFilterLink *link = <span class="literal">NULL</span>;</span><br><span class="line">        AVFilterContext *next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;nb_outputs) &#123;</span><br><span class="line">            link = cur-&gt;outputs[i];</span><br><span class="line">            next = link-&gt;dst;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;%-24s -&gt; %-24s&quot;</span>, cur-&gt;name, next ? next-&gt;name : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">        <span class="built_in">graph_link_dump</span>(buf, cur, link);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">avfilter_process_command</span>(cur, <span class="string">&quot;dump&quot;</span>, <span class="literal">NULL</span>, tmp, <span class="built_in">sizeof</span>(tmp), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;ex:%s\n&quot;</span>, tmp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;ex:N/A\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next &amp;&amp; !(next-&gt;nb_inputs &gt; <span class="number">1</span> || next-&gt;nb_outputs &gt; <span class="number">1</span>))</span><br><span class="line">            <span class="built_in">graph_filter_dump</span>(buf, next);</span><br><span class="line">    &#125; <span class="keyword">while</span> (++i &lt; cur-&gt;nb_outputs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看 graph_link_dump 函数，他会将 link 上信息打印出来。从下面代码中可以知道：</p><ul><li><code>f:0|0</code> 表示 link 的 input format 和 output format 是否非空，0 为空，1 为非空</li><li>fmt 代表 link-&gt;format，wh 代表 link-&gt;w 和 link-&gt;h，ra 代表 link-&gt;sample_aspect_ratio，sr 代表 link-&gt;sample_rate，cl 代表 channel layout。wh 和 ra 是针对视频，sr 和 cl 是针对音频</li><li>st 代表 link 的 status_in，但是注意，代码中得到 st 是!ff_outlink_get_status(link)，而 link 中 status_in 为 0 表示正常，大于 0 表示异常，所以这里 st 为 0 表示异常，1 表示正常</li><li>wn 代表 link 的 frame_wanted_out，如果 frame_wanted_out 大于 0，表示下游向上游请求数据</li><li>cnt 代表 link 的 link-&gt;frame_count_in，表示有多少数据流入了当前 link</li><li><code>cur:0|0</code> 代表 link 上的 fifo 中有多少数据，左边代表视频，右边代表音频，通常 <code>|</code> 两边只能有一个大于 0，因为 link 只能有一种数据，但是我也见过两边都大于 0 的情况。这个字段很有用，因为如果见到 cur 不断增长，那么表明当前 link 的下游没有取数据，那么就很有可能是下游 filter 发生了问题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">graph_link_dump</span><span class="params">(AVBPrint *buf, AVFilterContext *cur, AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *format;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!link) &#123;</span><br><span class="line">        <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;%79s&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;f:%d|%d &quot;</span>, !!link-&gt;incfg.formats, !!link-&gt;outcfg.formats);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (link-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            format = <span class="built_in">av_x_if_null</span>(<span class="built_in">av_get_pix_fmt_name</span>(link-&gt;format), <span class="string">&quot;?&quot;</span>);</span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;fmt:%-4s wh:%6d|%-6d ra:%4d|%-4d &quot;</span>,</span><br><span class="line">                       format, link-&gt;w, link-&gt;h,</span><br><span class="line">                       link-&gt;sample_aspect_ratio.num,</span><br><span class="line">                       link-&gt;sample_aspect_ratio.den);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            <span class="built_in">av_channel_layout_describe</span>(&amp;link-&gt;ch_layout, tmp, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">            format = <span class="built_in">av_x_if_null</span>(<span class="built_in">av_get_sample_fmt_name</span>(link-&gt;format), <span class="string">&quot;?&quot;</span>);</span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;fmt:%-4s sr:%-6d cl:%-16s &quot;</span>,</span><br><span class="line">                       format, link-&gt;sample_rate, tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;?&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;st:%d wn:%d cnt:%-8lld cur:%d|%-8d &quot;</span>, !<span class="built_in">ff_outlink_get_status</span>(link),</span><br><span class="line">               <span class="built_in">ff_outlink_frame_wanted</span>(link), link-&gt;frame_count_in,</span><br><span class="line">               <span class="built_in">ff_inlink_queued_frames</span>(link), <span class="built_in">ff_inlink_queued_samples</span>(link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_outlink_get_status</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> link-&gt;status_in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ff_inlink_queued_frames</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ff_framequeue_queued_frames</span>(&amp;link-&gt;fifo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the number of queued frames.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">ff_framequeue_queued_frames</span><span class="params">(<span class="type">const</span> FFFrameQueue *fq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fq-&gt;queued;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the number of queued samples.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint64_t</span> <span class="title">ff_framequeue_queued_samples</span><span class="params">(<span class="type">const</span> FFFrameQueue *fq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fq-&gt;total_samples_head - fq-&gt;total_samples_tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲到这里，dump 输出的含义基本上就讲完了，最后还剩下一个 <code>ex</code>。ex 是在 graph_link_dump 之后执行的，其逻辑是如果 filter 在自己的 process_command 函数中定义了如何相应 dump 指令，则将 process_command 函数返回结果打印，否则打印 N&#x2F;A。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">graph_filter_dump</span><span class="params">(AVBPrint *buf, AVFilterContext *cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;%-24s -&gt; %-24s&quot;</span>, cur-&gt;name, next ? next-&gt;name : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">        <span class="built_in">graph_link_dump</span>(buf, cur, link);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">avfilter_process_command</span>(cur, <span class="string">&quot;dump&quot;</span>, <span class="literal">NULL</span>, tmp, <span class="built_in">sizeof</span>(tmp), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;ex:%s\n&quot;</span>, tmp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">av_bprintf</span>(buf, <span class="string">&quot;ex:N/A\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">while</span> (++i &lt; cur-&gt;nb_outputs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg filter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg filter之状态变化与数据流转</title>
      <link href="/2023/03/21/ffmpeg-filter%E4%B9%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC/"/>
      <url>/2023/03/21/ffmpeg-filter%E4%B9%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>这篇博客介绍一下 filter 的状态变化与数据流转过程，是 filter 系列的最后一篇，后续可能还会写一些小文章介绍一些之前略过的细节内容。</p><p>filter 有两种方法实现滤波函数，第一种方法是在 filter 的 input AVFilterPad 上实现 filter_frame 函数，这种方法通常配合默认 activate 函数使用，一般用于简单的一个输入，一个输出的场景，第二个方法是实现 filter 的 activate 函数，在 activate 函数中执行 frame 的传输，这个方法一般用于复杂一些的，多个输入输出的 filter。</p><p>对于上面第二种方法，一个典型的 sink filter 的 activate 函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">activate</span><span class="params">(AVFilterContext *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">0</span>， pts;</span><br><span class="line">    AVFilterLink *link;</span><br><span class="line">    AVFrame *frame;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ctx-&gt;nb_inputs; i++) &#123;</span><br><span class="line"></span><br><span class="line">        link = ctx-&gt;inputs[i];</span><br><span class="line">        <span class="built_in">ff_inlink_acknowledge_status</span>(link, &amp;ret, &amp;pts);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">ff_inlink_consume_frame</span>(link, &amp;frame);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process with frame</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ff_inlink_request_frame</span>(link);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本流程是：</p><ul><li>更新 inlink 的状态，比如上游把 status_in 设为 1 后，下游要相应的更新 status_out</li><li>如果 inlink 的状态没问题，就尝试从 inlink 的 fifo 中取数据</li><li>取到数据后对数据进行处理</li><li>最后再向 inlink 发送 request_frame 请求</li></ul><p>看看上面用到的状态调整函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_inlink_acknowledge_status</span><span class="params">(AVFilterLink *link, <span class="type">int</span> *rstatus, <span class="type">int64_t</span> *rpts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *rpts = link-&gt;current_pts;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ff_framequeue_queued_frames</span>(&amp;link-&gt;fifo))</span><br><span class="line">        <span class="keyword">return</span> *rstatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;status_out)</span><br><span class="line">        <span class="keyword">return</span> *rstatus = link-&gt;status_out;</span><br><span class="line">    <span class="keyword">if</span> (!link-&gt;status_in)</span><br><span class="line">        <span class="keyword">return</span> *rstatus = <span class="number">0</span>;</span><br><span class="line">    *rstatus = link-&gt;status_out = link-&gt;status_in;</span><br><span class="line">    <span class="built_in">ff_update_link_current_pts</span>(link, link-&gt;status_in_pts);</span><br><span class="line">    *rpts = link-&gt;current_pts;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_inlink_acknowledge_status 主要工作是把 status_in 的状态传递到 status_out。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_inlink_consume_frame</span><span class="params">(AVFilterLink *link, AVFrame **rframe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFrame *frame;</span><br><span class="line"></span><br><span class="line">    *rframe = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ff_inlink_check_available_frame</span>(link))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (link-&gt;fifo.samples_skipped) &#123;</span><br><span class="line">        frame = <span class="built_in">ff_framequeue_peek</span>(&amp;link-&gt;fifo, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ff_inlink_consume_samples</span>(link, frame-&gt;nb_samples, frame-&gt;nb_samples, rframe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame = <span class="built_in">ff_framequeue_take</span>(&amp;link-&gt;fifo);</span><br><span class="line">    <span class="built_in">consume_update</span>(link, frame);</span><br><span class="line">    *rframe = frame;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_inlink_check_available_frame</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ff_framequeue_queued_frames</span>(&amp;link-&gt;fifo) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">consume_update</span><span class="params">(AVFilterLink *link, <span class="type">const</span> AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ff_update_link_current_pts</span>(link, frame-&gt;pts);</span><br><span class="line">    <span class="built_in">ff_inlink_process_commands</span>(link, frame);</span><br><span class="line">    link-&gt;dst-&gt;is_disabled = !<span class="built_in">ff_inlink_evaluate_timeline_at_frame</span>(link, frame);</span><br><span class="line">    link-&gt;frame_count_out++;</span><br><span class="line">    link-&gt;sample_count_out += frame-&gt;nb_samples;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_inlink_consume_frame 就是从 inlink 中取一个 frame。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_inlink_request_frame</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_assert1</span>(!link-&gt;status_in);</span><br><span class="line">    <span class="built_in">av_assert1</span>(!link-&gt;status_out);</span><br><span class="line">    link-&gt;frame_wanted_out = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ff_filter_set_ready</span>(link-&gt;src, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_inlink_request_frame 就是把 inlink 的 frame_wanted_out 设为 1，然后激活上游 filter，让上游 filter 去处理下游的 request_frame 请求。</p><p>上面的例子展示的是 sink filter 的 activate 函数，从该函数中可以看到下游向上游请求数据的过程，但是没有上游收到下游 request_frame 请求，然后往下游 filter_frame 的过程。接下来我们看一个既有输入又有输出的 filter 的 activate 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">activate</span><span class="params">(AVFilterContext *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ctx-&gt;nb_inputs; i++) &#123;</span><br><span class="line">        AVFrame *frame = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> rpts;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ff_inlink_acknowledge_status</span>(ctx-&gt;inputs[i], &amp;status, &amp;rpts);</span><br><span class="line">        <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">            ret = <span class="built_in">ff_inlink_consume_frame</span>(ctx-&gt;inputs[i], &amp;frame);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ctx-&gt;nb_outputs; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ff_outlink_get_status</span>(ctx-&gt;outputs[j]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status) &#123;</span><br><span class="line">                <span class="comment">// 在某些条件下，根据inlink状态设置outlink的状态</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="comment">/* some condition */</span>)</span><br><span class="line">                    <span class="built_in">ff_outlink_set_status</span>(ctx-&gt;outputs[j], AVERROR_EOF, AV_NOPTS_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frame) &#123;</span><br><span class="line">                <span class="comment">// 进行滤波处理并将frame传给下游</span></span><br><span class="line">                ...</span><br><span class="line">                ret = <span class="built_in">ff_filter_frame</span>(ctx-&gt;outputs[j], frame);</span><br><span class="line">                <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在满足一定条件后向上游申请数据</span></span><br><span class="line">        <span class="comment">// 或者发送eof给上游</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* some condition */</span>)</span><br><span class="line">            <span class="built_in">ff_inlink_request_frame</span>(ctx-&gt;inputs[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* some condition */</span>)</span><br><span class="line">            <span class="built_in">ff_inlink_set_status</span>(ctx-&gt;inputs[i], AVERROR_EOF);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数的流程和 sink filter 类似，但是多了往下游传输 frame 的过程：</p><ul><li>对每个 inlink，先检查并传递该 link 上的 status</li><li>如果这个 inlink 异常，则需要把异常传递给和该 inlink 有关联的下游 outlink</li><li>如果这个 inlink 正常，从 inlink 上取 frame，进行处理，并传给下游 outlink</li><li>最后还要决定是继续往 inlink 中请求数据，还是设置 AVERROR_EOF 来断开 inlink</li></ul><p>可以发现，激活函数中做了这几件事：检查 inlink 的状态；从上往下传递异常 或者 从上往下传输 frame；从下往上传递异常 或者 从下往上传递 request frame 请求。</p><p>接下来也看看相关函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_outlink_get_status</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> link-&gt;status_in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_outlink_get_status 就是取得 outlink 的状态，outlink 是相对 src filter 而言的，所以 ff_outlink_get_status 就是取得 link 的 input 状态 status_in</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">ff_outlink_set_status</span><span class="params">(AVFilterLink *link, <span class="type">int</span> status, <span class="type">int64_t</span> pts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ff_avfilter_link_set_in_status</span>(link, status, pts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_avfilter_link_set_in_status</span><span class="params">(AVFilterLink *link, <span class="type">int</span> status, <span class="type">int64_t</span> pts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;status_in == status)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">av_assert0</span>(!link-&gt;status_in);</span><br><span class="line">    link-&gt;status_in = status;</span><br><span class="line">    link-&gt;status_in_pts = pts;</span><br><span class="line">    link-&gt;frame_wanted_out = <span class="number">0</span>;</span><br><span class="line">    link-&gt;frame_blocked_in = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ff_frame_pool_uninit</span>((FFFramePool**)&amp;link-&gt;frame_pool);</span><br><span class="line">    <span class="built_in">filter_unblock</span>(link-&gt;dst);</span><br><span class="line">    <span class="comment">/* Fast forward EOF and other error status, with priority 300;</span></span><br><span class="line"><span class="comment">     * otherwise, reconfig may occur ahead of time, resulting in link format not being cleared,</span></span><br><span class="line"><span class="comment">     * then getting error reconfig result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">ff_filter_set_ready</span>(link-&gt;dst, status ? <span class="number">300</span> : <span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">filter_unblock</span><span class="params">(AVFilterContext *filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter-&gt;nb_outputs; i++)</span><br><span class="line">        filter-&gt;outputs[i]-&gt;frame_blocked_in = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_outlink_set_status 就是设置 outlink 的状态，同样 outlink 是相对 src filter 而言的，所以这里也是设置 status_in。</p><p>除了 outlink 可以 get&#x2F;set status，inlink 也可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_inlink_set_status</span><span class="params">(AVFilterLink *link, <span class="type">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;status_out)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    link-&gt;frame_wanted_out = <span class="number">0</span>;</span><br><span class="line">    link-&gt;frame_blocked_in = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ff_avfilter_link_set_out_status</span>(link, status, AV_NOPTS_VALUE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ff_framequeue_queued_frames</span>(&amp;link-&gt;fifo)) &#123;</span><br><span class="line">           AVFrame *frame = <span class="built_in">ff_framequeue_take</span>(&amp;link-&gt;fifo);</span><br><span class="line">           <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!link-&gt;status_in)</span><br><span class="line">        link-&gt;status_in = status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_avfilter_link_set_out_status</span><span class="params">(AVFilterLink *link, <span class="type">int</span> status, <span class="type">int64_t</span> pts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_assert0</span>(!link-&gt;frame_wanted_out);</span><br><span class="line">    <span class="built_in">av_assert0</span>(!link-&gt;status_out);</span><br><span class="line">    link-&gt;status_out = status;</span><br><span class="line">    <span class="keyword">if</span> (pts != AV_NOPTS_VALUE)</span><br><span class="line">        <span class="built_in">ff_update_link_current_pts</span>(link, pts);</span><br><span class="line">    <span class="built_in">ff_frame_pool_uninit</span>((FFFramePool**)&amp;link-&gt;frame_pool);</span><br><span class="line">    <span class="built_in">filter_unblock</span>(link-&gt;dst);</span><br><span class="line">    <span class="built_in">ff_filter_set_ready</span>(link-&gt;src, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_inlink_set_status 中除了设置 status_out，还会设置 status_in，这和 ff_outlink_set_status 不一样</p><p>注意没有 ff_inlink_get_status，但是有 ff_inlink_acknowledge_status，这个函数是把 link 上的 status_in 传递到 status_out，然后返回 status_out。</p><p>可以看到 status_in 和 status_out 的设置有特殊的规定：可以单独设置 status_in；不能单独设置 status_out，设置 status_out 时会一起设置 status_in；可以单独取得 status_in；当取得 status_out 时一定会检查 status_in 并尝试改变 status_out。</p><p>注意到上面还出现了一个新的函数 ff_filter_frame，用于从上游往下游送数据，该函数主要是把 frame 添加到 filter 的 output link 的 fifo 中，该函数会清除 frame_blocked_in 和 frame_wanted_out，最后还会激活下游 filter，而之前的 ff_inlink_request_frame 会激活上游的 filter。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_filter_frame</span><span class="params">(AVFilterLink *link, AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!link-&gt;incfg.formats) &#123;</span><br><span class="line">        <span class="built_in">link_uninit_dump_pcm</span>(link, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Consistency checks */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    link-&gt;frame_blocked_in = link-&gt;frame_wanted_out = <span class="number">0</span>;</span><br><span class="line">    link-&gt;frame_count_in++;</span><br><span class="line">    link-&gt;sample_count_in += frame-&gt;nb_samples;</span><br><span class="line">    <span class="built_in">filter_unblock</span>(link-&gt;dst);</span><br><span class="line">    ret = <span class="built_in">ff_framequeue_add</span>(&amp;link-&gt;fifo, frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ff_filter_set_ready</span>(link-&gt;dst, <span class="number">300</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    <span class="keyword">return</span> AVERROR_PATCHWELCOME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面的两个激活函数，filter 的整体的运转逻辑就不难理解了：</p><p><img src="/images/filter%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96/filter-request.jpg"></p><p>数据请求总是由下游 sink 发起，会逐步把 request 请求往 src 传递，这是一个拉的过程；当传递到某个有数据的 filter 时，就开始往下游推数据。关键点是每次 request_frame 时会激活上游 filter，每次 filter_frame 时会激活下游 filter。</p><p>介绍完自定义 activate 函数中的数据流转逻辑，再来看看默认激活函数配合 pad 上 filter_frame 和 request_frame 函数的数据流转过程</p><p><img src="/images/filter%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96/pad.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ff_filter_activate_default</span><span class="params">(AVFilterContext *filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter-&gt;nb_inputs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">samples_ready</span>(filter-&gt;inputs[i], filter-&gt;inputs[i]-&gt;min_samples)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ff_filter_frame_to_filter</span>(filter-&gt;inputs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter-&gt;nb_inputs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter-&gt;inputs[i]-&gt;status_in &amp;&amp; !filter-&gt;inputs[i]-&gt;status_out) &#123;</span><br><span class="line">            <span class="built_in">av_assert1</span>(!<span class="built_in">ff_framequeue_queued_frames</span>(&amp;filter-&gt;inputs[i]-&gt;fifo));</span><br><span class="line">            <span class="keyword">return</span> forward_status_change(filter, filter-&gt;inputs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter-&gt;nb_outputs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter-&gt;outputs[i]-&gt;frame_wanted_out &amp;&amp;</span><br><span class="line">            !filter-&gt;outputs[i]-&gt;frame_blocked_in) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ff_request_frame_to_filter</span>(filter-&gt;outputs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FFERROR_NOT_READY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_filter_activate_default 会优先从自己的 inlink 上取数据并将数据传递给下游，通过 ff_filter_frame_to_filter 函数实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ff_filter_frame_to_filter</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFrame *frame = <span class="literal">NULL</span>;</span><br><span class="line">    AVFilterContext *dst = link-&gt;dst;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert1</span>(<span class="built_in">ff_framequeue_queued_frames</span>(&amp;link-&gt;fifo));</span><br><span class="line">    ret = link-&gt;min_samples ?</span><br><span class="line">          <span class="built_in">ff_inlink_consume_samples</span>(link, link-&gt;min_samples, link-&gt;max_samples, &amp;frame) :</span><br><span class="line">          <span class="built_in">ff_inlink_consume_frame</span>(link, &amp;frame);</span><br><span class="line">    <span class="built_in">av_assert1</span>(ret);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_assert1</span>(!frame);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* The filter will soon have received a new frame, that may allow it to</span></span><br><span class="line"><span class="comment">       produce one or more: unblock its outputs. */</span></span><br><span class="line">    <span class="built_in">filter_unblock</span>(dst);</span><br><span class="line">    <span class="comment">/* AVFilterPad.filter_frame() expect frame_count_out to have the value</span></span><br><span class="line"><span class="comment">       before the frame; ff_filter_frame_framed() will re-increment it. */</span></span><br><span class="line">    link-&gt;frame_count_out--;</span><br><span class="line">    ret = <span class="built_in">ff_filter_frame_framed</span>(link, frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != link-&gt;status_out) &#123;</span><br><span class="line">        <span class="built_in">ff_avfilter_link_set_out_status</span>(link, ret, AV_NOPTS_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Run once again, to see if several frames were available, or if</span></span><br><span class="line"><span class="comment">           the input status has also changed, or any other reason. */</span></span><br><span class="line">        <span class="built_in">ff_filter_set_ready</span>(dst, <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ff_filter_frame_framed</span><span class="params">(AVFilterLink *link, AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*filter_frame)(AVFilterLink *, AVFrame *);</span><br><span class="line">    AVFilterContext *dstctx = link-&gt;dst;</span><br><span class="line">    AVFilterPad *dst = link-&gt;dstpad;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(filter_frame = dst-&gt;filter_frame))</span><br><span class="line">        filter_frame = default_filter_frame;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dst-&gt;flags &amp; AVFILTERPAD_FLAG_NEEDS_WRITABLE) &#123;</span><br><span class="line">        ret = <span class="built_in">ff_inlink_make_frame_writable</span>(link, &amp;frame);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ff_inlink_process_commands</span>(link, frame);</span><br><span class="line">    dstctx-&gt;is_disabled = !<span class="built_in">ff_inlink_evaluate_timeline_at_frame</span>(link, frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dstctx-&gt;is_disabled &amp;&amp;</span><br><span class="line">        (dstctx-&gt;filter-&gt;flags &amp; AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC))</span><br><span class="line">        filter_frame = default_filter_frame;</span><br><span class="line">    ret = <span class="built_in">filter_frame</span>(link, frame);</span><br><span class="line">    link-&gt;frame_count_out++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">default_filter_frame</span><span class="params">(AVFilterLink *link, AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ff_filter_frame</span>(link-&gt;dst-&gt;outputs[<span class="number">0</span>], frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pad 的默认 filter_frame 函数是 ff_filter_frame，就是不作滤波处理，直接传递到 output link 的 fifo 上。</p><p>其次优先执行 input link 的状态调整：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">forward_status_change</span><span class="params">(AVFilterContext *filter, AVFilterLink *in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> out = <span class="number">0</span>, progress = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert0</span>(!in-&gt;status_out);</span><br><span class="line">    <span class="keyword">if</span> (!filter-&gt;nb_outputs) &#123;</span><br><span class="line">        <span class="comment">/* not necessary with the current API and sinks */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!in-&gt;status_out) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!filter-&gt;outputs[out]-&gt;status_in) &#123;</span><br><span class="line">            progress++;</span><br><span class="line">            ret = <span class="built_in">ff_request_frame_to_filter</span>(filter-&gt;outputs[out]);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++out == filter-&gt;nb_outputs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!progress) &#123;</span><br><span class="line">                <span class="comment">/* Every output already closed: input no longer interesting</span></span><br><span class="line"><span class="comment">                   (example: overlay in shortest mode, other input closed). */</span></span><br><span class="line">                <span class="built_in">ff_avfilter_link_set_out_status</span>(in, in-&gt;status_in, in-&gt;status_in_pts);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            progress = <span class="number">0</span>;</span><br><span class="line">            out = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ff_filter_set_ready</span>(filter, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数比较有趣，他没有直接调用 ff_inlink_acknowledge_status 来改变 inlink 的 status_out，而是让 output link 发送 request 请求，在 request 过程中会检查 inlink 的 status_in 并更新 status_out：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ff_request_frame_to_filter</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FF_TPRINTF_START</span>(<span class="literal">NULL</span>, request_frame_to_filter); <span class="built_in">ff_tlog_link</span>(<span class="literal">NULL</span>, link, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* Assume the filter is blocked, let the method clear it if not */</span></span><br><span class="line">    link-&gt;frame_blocked_in = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;srcpad-&gt;request_frame)</span><br><span class="line">        ret = link-&gt;srcpad-&gt;<span class="built_in">request_frame</span>(link);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (link-&gt;src-&gt;inputs[<span class="number">0</span>])</span><br><span class="line">        ret = <span class="built_in">ff_request_frame</span>(link-&gt;src-&gt;inputs[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="built_in">AVERROR</span>(EAGAIN) &amp;&amp; ret != link-&gt;status_in)</span><br><span class="line">            <span class="built_in">ff_avfilter_link_set_in_status</span>(link, ret, <span class="built_in">guess_status_pts</span>(link-&gt;src, ret, link-&gt;time_base));</span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR_EOF)</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff_request_frame</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!link-&gt;outcfg.formats)</span><br><span class="line">        <span class="keyword">return</span> AVERROR_EOF;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert1</span>(!link-&gt;dst-&gt;filter-&gt;activate);</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;status_out)</span><br><span class="line">        <span class="keyword">return</span> link-&gt;status_out;</span><br><span class="line">    <span class="keyword">if</span> (link-&gt;status_in) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ff_framequeue_queued_frames</span>(&amp;link-&gt;fifo)) &#123;</span><br><span class="line">            <span class="built_in">av_assert1</span>(!link-&gt;frame_wanted_out);</span><br><span class="line">            <span class="built_in">av_assert1</span>(link-&gt;dst-&gt;ready &gt;= <span class="number">300</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Acknowledge status change. Filters using ff_request_frame() will</span></span><br><span class="line"><span class="comment">               handle the change automatically. Filters can also check the</span></span><br><span class="line"><span class="comment">               status directly but none do yet. */</span></span><br><span class="line">            <span class="built_in">ff_avfilter_link_set_out_status</span>(link, link-&gt;status_in, link-&gt;status_in_pts);</span><br><span class="line">            <span class="keyword">return</span> link-&gt;status_out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    link-&gt;frame_wanted_out = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ff_filter_set_ready</span>(link-&gt;src, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ff_request_frame_to_filter 在让 outlink 发送 request 请求的同时还把 inlink 的状态传递给了 outlink。</p><p>如果上面两步都没有执行，那么 ff_filter_activate_default 最后会尝试执行 ff_request_frame_to_filter 往上游传递 request_frame 请求。在传递 request_frame 请求时会检查 outlink 的 frame_wanted_out 和 frame_blocked_in，frame_wanted_out 比较好理解，而 frame_blocked_in 则是 ff_request_frame_to_filter 函数内设置的，也就是说避免 ff_request_frame_to_filter 对同一个 link 多次执行。</p><p>经过对比可以发现，默认激活函数做的事情也是那么几件：从上往下送数据，从上往下传递状态，从下往上传递 request 请求。默认激活函数通常和 pad 的 request_frame 和 filter_frame 配合使用。</p><p>最后再总结一下 pad 的 request_frame 和 filter_frame 函数：request_frame 只出现在 output pad，用于把 outlink 上的 request 请求传递给 inlink；filter_frame 只出现在 input pad，用于把 inlink 上的 frame 传递到 outlink 的 fifo。</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg filter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg filter之格式协商（format negotiation）</title>
      <link href="/2023/03/19/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86%EF%BC%88format-negotiation%EF%BC%89/"/>
      <url>/2023/03/19/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86%EF%BC%88format-negotiation%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这篇博客接着上一篇介绍一下 filter 的格式协商。</p><p>从个人的学习经验来看，格式协商算是 filter 中最不容易理解的一部分了，但反过来说，理解了格式协商那么 filter 就基本上摸清楚了。</p><p>还是以上篇博客中的例子为研究对象，但是这次把目光聚焦在 avfilter_graph_config 函数上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> AVFilter *buffersrc  = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;buffer&quot;</span>);</span><br><span class="line"><span class="type">const</span> AVFilter *buffersink = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;buffersink&quot;</span>);</span><br><span class="line"><span class="type">const</span> AVFilter *myfilter   = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;myfilter&quot;</span>);</span><br><span class="line"></span><br><span class="line">AVFilterGraph *filter_graph = <span class="built_in">avfilter_graph_alloc</span>();</span><br><span class="line"></span><br><span class="line">AVFilterContext *in_video_filter = <span class="literal">NULL</span>;</span><br><span class="line">AVFilterContext *out_video_filter = <span class="literal">NULL</span>;</span><br><span class="line">AVFilterContext *my_video_filter = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">avfilter_graph_create_filter</span>(&amp;in_video_filter, buffersrc, <span class="string">&quot;in&quot;</span>, args, <span class="literal">NULL</span>, filter_graph);</span><br><span class="line"><span class="built_in">avfilter_graph_create_filter</span>(&amp;out_video_filter, buffersink, <span class="string">&quot;out&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, filter_graph);</span><br><span class="line"><span class="built_in">avfilter_graph_create_filter</span>(&amp;my_video_filter, myfilter, <span class="string">&quot;myfilter&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, filter_graph);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avfilter_link</span>(in_video_filter, <span class="number">0</span>, my_video_filter, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">avfilter_link</span>(my_video_filter, <span class="number">0</span>, out_video_filter, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avfilter_graph_config</span>(filter_graph, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>为了简单起见，假设我们得到的 filtergraph 如下（下面的 filtergraph 涉及到多路连接，需要使用支持多路连接的 filter，这里省略了创建该 filtergraph 的过程，读者可以自己尝试）：</p><p><img src="/images/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86/graph.jpg"></p><h1 id="avfilter-graph-config"><a href="#avfilter-graph-config" class="headerlink" title="avfilter_graph_config"></a>avfilter_graph_config</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avfilter_graph_config</span><span class="params">(AVFilterGraph *graphctx, <span class="type">void</span> *log_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">graph_check_validity</span>(graphctx, log_ctx)))</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">graph_config_formats</span>(graphctx, log_ctx)))</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">graph_config_links</span>(graphctx, log_ctx)))</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">graph_check_links</span>(graphctx, log_ctx)))</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">graph_config_pointers</span>(graphctx, log_ctx)))</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 avfilter_graph_config 函数分成了几个小函数。下面逐一分析每个小函数。</p><h2 id="graph-check-validity"><a href="#graph-check-validity" class="headerlink" title="graph_check_validity"></a>graph_check_validity</h2><p>graph_check_validity 就是检查所有 input 和 output pad 是否都已经连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">graph_check_validity</span><span class="params">(AVFilterGraph *graph, <span class="type">void</span> *log_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext *filt;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">        <span class="type">const</span> AVFilterPad *pad;</span><br><span class="line">        filt = graph-&gt;filters[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filt-&gt;nb_inputs; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!filt-&gt;inputs[j] || !filt-&gt;inputs[j]-&gt;src) &#123;</span><br><span class="line">                pad = &amp;filt-&gt;input_pads[j];</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filt-&gt;nb_outputs; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!filt-&gt;outputs[j] || !filt-&gt;outputs[j]-&gt;dst) &#123;</span><br><span class="line">                pad = &amp;filt-&gt;output_pads[j];</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="graph-config-formats"><a href="#graph-config-formats" class="headerlink" title="graph_config_formats"></a>graph_config_formats</h2><p>graph_config_formats 中进行了格式协商，是 avfilter_graph_config 的核心</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">graph_config_formats</span><span class="params">(AVFilterGraph *graph, <span class="type">void</span> *log_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find supported formats from sub-filters, and merge along links */</span></span><br><span class="line">    <span class="keyword">while</span> ((ret = <span class="built_in">query_formats</span>(graph, log_ctx)) == <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">        <span class="built_in">av_log</span>(graph, AV_LOG_DEBUG, <span class="string">&quot;query_formats not finished\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Once everything is merged, it&#x27;s possible that we&#x27;ll still have</span></span><br><span class="line"><span class="comment">     * multiple valid media format choices. We try to minimize the amount</span></span><br><span class="line"><span class="comment">     * of format conversion inside filters */</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">reduce_formats</span>(graph)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for audio filters, ensure the best format, sample rate and channel layout</span></span><br><span class="line"><span class="comment">     * is selected */</span></span><br><span class="line">    <span class="built_in">swap_sample_fmts</span>(graph);</span><br><span class="line">    <span class="built_in">swap_samplerates</span>(graph);</span><br><span class="line">    <span class="built_in">swap_channel_layouts</span>(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">pick_formats</span>(graph)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>graph_config_formats 中最重要的三步</p><ul><li>1.query_formats()</li><li>2.reduce_formats()</li><li>3.pick_formats()</li></ul><h3 id="query-formats"><a href="#query-formats" class="headerlink" title="query_formats"></a>query_formats</h3><p>query_formats 主要的工作是</p><ul><li><p>查询 filter 上每个 input&#x2F;output 支持的 format</p><ul><li><p>如果每个 input&#x2F;output 上都有 format，就不继续 query</p></li><li><p>否则进行 query</p><ul><li>在 query 之前，如果没有定义 sanitize 方法，就尝试把 agreed format 复制到没有 format 的 input&#x2F;output 上，如果上一步复制 format 后所有 input&#x2F;output 都有了 format，那么跳过下面的 query 过程。这一步是为了优化，避免冗余的查询。对于运行前后过程中 format 会发生变化（比如有时候为空，有时候有值）的 filter，这里需要注意。</li><li>执行 query，填充 link 上的 format</li><li>如果没有 sanitize 方法，填充 query 后还没有 format 的 input&#x2F;output</li></ul></li></ul></li><li><p>执行 sanitize 方法断开无效的 link</p></li><li><p>对每一个 link 上的 input&#x2F;output format 进行合并，如果无法合并，尝试插入 scale、resample filter 进行格式转换</p></li></ul><h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>查询 format 可以简单的认为就是调用 filter 的 query_format 来给 filter 的每个 input&#x2F;output 上的 format 赋值，但实际查询时会作优化处理，比如：</p><ul><li>如果 filter 的每个输入输出都有格式，那么就不调用 query_format；</li><li>如果 filter 没有定义 sanitize 方法，会尝试 ref_agreed_format 用协商好的 format 填充其他为空的 format，以及把 link 上为空的 input&#x2F;output format 自动填充</li></ul><p>经过查询之后，filter 的 input&#x2F;output 就有 format 了，如下图所示</p><p><img src="/images/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86/negation.jpg"></p><p>上图显示了两种可能的查询结果，通常来说经过查询后 filter 的每一个 input&#x2F;output 都会有 format，但是有些 filter 有动态输入输出的需求，会<strong>特意</strong>在某些情况下让 query_format 函数不设置某个 input&#x2F;output 的 format，让其保持为空。将 format 保持为空是为了让后续的 sanitize 过程能剔除这条 link，具体过程留到下面 sanitize 中再介绍。</p><h4 id="sanitize-formats"><a href="#sanitize-formats" class="headerlink" title="sanitize_formats"></a>sanitize_formats</h4><p>sanitize_formats 会把一端有 format、一端没有 format 的 link 的 input&#x2F;output format 都清空，如果一个 link 的 input&#x2F;output format 都为空，那么这个 link 就是断开的。</p><p>对一个 filter 的所有 link 都剔除一遍后，会执行 filter 自定义的 sanitize 方法（如果定义），给 filter 一个调整输入输出的机会，如果 filter 没有定义 sanitize 方法，会执行默认的 sanitize 方法：如果 filter 的 input&#x2F;output 有一端的 format 全部为空，则释放所有 input&#x2F;output 的 format。</p><p>此外 sanitize 过程会反复执行，比如先剔除了一个 filter 的 output link，然后再通过该 filter 的 sanitize 函数改变他的 input link，接着这个 input link 又会影响到他连接的另一个 filter，这个过程会不断执行，直到整个 graph 不再发生变化。</p><p>sanitize 过程可以用下图来表示</p><p><img src="/images/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86/sanitize.jpg"></p><p>第一幅图是 query 之后的初始 format；第二幅图是剔除了一端有 format，一端没有 format 的 link；第三幅图是 filter 默认的 sanitize 函数的作用：如果有一端全部为空，则释放所有的 format；第四幅图还是剔除了一端有 format，一端没有 format 的 link，但是这个是因为 filter 默认的 sanitize 函数剔除了 link 上某端的 format 而重新引起的。第四幅图就是最后的稳定状态，可以看到在稳定状态下只有最上面的链路是连通的，其他的都是断开的。</p><p>下面是 sanitize_formats 的具体代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">sanitize_formats</span><span class="params">(AVFilterGraph *graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext *f;</span><br><span class="line">    <span class="type">bool</span> changed = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">unsigned</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">        f = graph-&gt;filters[i];</span><br><span class="line">        <span class="comment">// 对每个filter，先剔除一端有format，一端没有format的input link</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; f-&gt;nb_inputs; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!f-&gt;inputs[j]-&gt;outcfg.formats &amp;&amp; f-&gt;inputs[j]-&gt;incfg.formats) &#123;</span><br><span class="line">                <span class="built_in">ff_avfilter_link_unref_formats</span>(f-&gt;inputs[j]);</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后剔除一端有format，一端没有format的output link</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; f-&gt;nb_outputs; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!f-&gt;outputs[j]-&gt;incfg.formats &amp;&amp; f-&gt;outputs[j]-&gt;outcfg.formats) &#123;</span><br><span class="line">                <span class="built_in">ff_avfilter_link_unref_formats</span>(f-&gt;outputs[j]);</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用filter的sanitize_formats方法或者默认的sanitize_formats方法</span></span><br><span class="line">        <span class="keyword">if</span> (f-&gt;filter-&gt;sanitize_formats) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f-&gt;filter-&gt;<span class="built_in">sanitize_formats</span>(f) == <span class="built_in">AVERROR</span>(EAGAIN))</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (formats_useless(f)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; f-&gt;nb_inputs; j++)</span><br><span class="line">                <span class="built_in">ff_avfilter_link_unref_formats</span>(f-&gt;inputs[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; f-&gt;nb_outputs; j++)</span><br><span class="line">                <span class="built_in">ff_avfilter_link_unref_formats</span>(f-&gt;outputs[j]);</span><br><span class="line"></span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果filter有一端全部没有format，那么整个filter是无用的</span></span><br><span class="line"><span class="comment">// 所以可以把输入、输出format全部置为空</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">formats_useless</span><span class="params">(AVFilterContext *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> in, out;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;nb_inputs == <span class="number">0</span> || f-&gt;nb_outputs == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    in = out = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;nb_inputs; i++)</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;inputs[i]-&gt;outcfg.formats) &#123;</span><br><span class="line">            in = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;nb_outputs; i++)</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;outputs[i]-&gt;incfg.formats) &#123;</span><br><span class="line">            out = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> in ^ out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_avfilter_link_unref_formats</span><span class="params">(AVFilterLink *link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ff_formats_unref</span>(&amp;link-&gt;incfg.formats);</span><br><span class="line">    <span class="built_in">ff_formats_unref</span>(&amp;link-&gt;outcfg.formats);</span><br><span class="line">    <span class="built_in">ff_formats_unref</span>(&amp;link-&gt;incfg.samplerates);</span><br><span class="line">    <span class="built_in">ff_formats_unref</span>(&amp;link-&gt;outcfg.samplerates);</span><br><span class="line">    <span class="built_in">ff_channel_layouts_unref</span>(&amp;link-&gt;incfg.channel_layouts);</span><br><span class="line">    <span class="built_in">ff_channel_layouts_unref</span>(&amp;link-&gt;outcfg.channel_layouts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>sanitize 之后是对同一个 link 上的 input&#x2F;output format 进行 merge，merge 的思路是：如果 input&#x2F;output format 有一个共有的 format，就把这个 format 移到最前面，并且让 input&#x2F;output format 都指向同一个 format</p><p>如果无法合并，则尝试插入 scale 或者 resample filter 进行格式转换</p><p><img src="/images/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86/merge.jpg"></p><p>下面是 merge 的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">merge_pix_fmts</span><span class="params">(<span class="type">void</span> *a, <span class="type">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge_formats_internal</span>(a, b, AVMEDIA_TYPE_VIDEO, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">merge_formats_internal</span><span class="params">(AVFilterFormats *a, AVFilterFormats *b,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">enum</span> AVMediaType type, <span class="type">int</span> check)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> alpha1=<span class="number">0</span>, alpha2=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> chroma1=<span class="number">0</span>, chroma2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert2</span>(check || (a-&gt;refcount &amp;&amp; b-&gt;refcount));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MERGE_FORMATS</span>(a, b, formats, nb_formats, AVFilterFormats, check, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把a和b共有的format添加到a中，然后让b的所有引用都指向a并且销毁b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add all formats common to a and b to a, add b&#x27;s refs to a and destroy b.</span></span><br><span class="line"><span class="comment"> * If check is set, nothing is modified and it is only checked whether</span></span><br><span class="line"><span class="comment"> * the formats are compatible.</span></span><br><span class="line"><span class="comment"> * If empty_allowed is set and one of a,b-&gt;nb is zero, the lists are</span></span><br><span class="line"><span class="comment"> * merged; otherwise, 0 (for nonmergeability) is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MERGE_FORMATS(a, b, fmts, nb, type, check, empty_allowed)          \</span></span><br><span class="line"><span class="meta">do &#123;                                                                       \</span></span><br><span class="line"><span class="meta">    int i, j, k = 0, skip = 0;                                             \</span></span><br><span class="line"><span class="meta">                                                                           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (empty_allowed) &#123;                                                   \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!a-&gt;nb || !b-&gt;nb) &#123;                                            \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (check)                                                     \</span></span><br><span class="line"><span class="meta">                return 1;                                                  \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (!a-&gt;nb)                                                    \</span></span><br><span class="line"><span class="meta">                FFSWAP(type *, a, b);                                      \</span></span><br><span class="line"><span class="meta">            skip = 1;                                                      \</span></span><br><span class="line"><span class="meta">        &#125;                                                                  \</span></span><br><span class="line"><span class="meta">    &#125;                                                                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!skip) &#123;                                                           \</span></span><br><span class="line"><span class="meta">        for (i = 0; i <span class="string">&lt; a-&gt;</span>nb; i++)                                        \</span></span><br><span class="line"><span class="meta">            for (j = 0; j <span class="string">&lt; b-&gt;</span>nb; j++)                                    \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (a-&gt;fmts[i] == b-&gt;fmts[j]) &#123;                            \</span></span><br><span class="line"><span class="meta">                    <span class="keyword">if</span> (check)                                             \</span></span><br><span class="line"><span class="meta">                        return 1;                                          \</span></span><br><span class="line"><span class="meta">                    a-&gt;fmts[k++] = a-&gt;fmts[i];                             \</span></span><br><span class="line"><span class="meta">                    break;                                                 \</span></span><br><span class="line"><span class="meta">                &#125;                                                          \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* Check that there was at least one common format.                \</span></span></span><br><span class="line"><span class="comment"><span class="meta">         * Notice that both a and b are unchanged if not. */</span>               \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!k)                                                            \</span></span><br><span class="line"><span class="meta">            return 0;                                                      \</span></span><br><span class="line"><span class="meta">        av_assert2(!check);                                                \</span></span><br><span class="line"><span class="meta">        a-&gt;nb = k;                                                         \</span></span><br><span class="line"><span class="meta">    &#125;                                                                      \</span></span><br><span class="line"><span class="meta">                                                                           \</span></span><br><span class="line"><span class="meta">    MERGE_REF(a, b, fmts, type, return AVERROR(ENOMEM););                  \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add all refs from a to ret and destroy a.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MERGE_REF(ret, a, fmts, type, fail_statement)                      \</span></span><br><span class="line"><span class="meta">do &#123;                                                                       \</span></span><br><span class="line"><span class="meta">    type ***tmp;                                                           \</span></span><br><span class="line"><span class="meta">    int i;                                                                 \</span></span><br><span class="line"><span class="meta">                                                                           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!(tmp = av_realloc_array(ret-&gt;refs, ret-&gt;refcount + a-&gt;refcount,   \</span></span><br><span class="line"><span class="meta">                                 sizeof(*tmp))))                           \</span></span><br><span class="line"><span class="meta">        &#123; fail_statement &#125;                                                 \</span></span><br><span class="line"><span class="meta">    ret-&gt;refs = tmp;                                                       \</span></span><br><span class="line"><span class="meta">                                                                           \</span></span><br><span class="line"><span class="meta">    for (i = 0; i <span class="string">&lt; a-&gt;</span>refcount; i ++) &#123;                                   \</span></span><br><span class="line"><span class="meta">        ret-&gt;refs[ret-&gt;refcount] = a-&gt;refs[i];                             \</span></span><br><span class="line"><span class="meta">        *ret-&gt;refs[ret-&gt;refcount++] = ret;                                 \</span></span><br><span class="line"><span class="meta">    &#125;                                                                      \</span></span><br><span class="line"><span class="meta">                                                                           \</span></span><br><span class="line"><span class="meta">    av_freep(&amp;a-&gt;refs);                                                    \</span></span><br><span class="line"><span class="meta">    av_freep(&amp;a-&gt;fmts);                                                    \</span></span><br><span class="line"><span class="meta">    av_freep(&amp;a);                                                          \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><h3 id="reduce-formats"><a href="#reduce-formats" class="headerlink" title="reduce_formats"></a>reduce_formats</h3><p>reduce_formats 主要是对同一个 filter 的输入输出格式进行优化，减小在同一个 filter 内的格式转换次数，如下所示</p><p><img src="/images/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86/reduce_formats.jpg"></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">reduce_formats</span><span class="params">(AVFilterGraph *graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, reduced, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        reduced = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">reduce_formats_on_filter</span>(graph-&gt;filters[i])) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            reduced |= ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (reduced);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">reduce_formats_on_filter</span><span class="params">(AVFilterContext *filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">REDUCE_FORMATS</span>(<span class="type">int</span>,      AVFilterFormats,        formats,         formats,</span><br><span class="line">                   nb_formats, ff_add_format);</span><br><span class="line">    <span class="built_in">REDUCE_FORMATS</span>(<span class="type">int</span>,      AVFilterFormats,        samplerates,     formats,</span><br><span class="line">                   nb_formats, ff_add_format);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reduce channel layouts */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDUCE_FORMATS(fmt_type, list_type, list, var, nb, add_format) \</span></span><br><span class="line"><span class="meta">do &#123;                                                                   \</span></span><br><span class="line"><span class="meta">    for (i = 0; i <span class="string">&lt; filter-&gt;</span>nb_inputs; i++) &#123;                          \</span></span><br><span class="line"><span class="meta">        AVFilterLink *link = filter-&gt;inputs[i];                        \</span></span><br><span class="line"><span class="meta">        fmt_type fmt;                                                  \</span></span><br><span class="line"><span class="meta">                                                                       \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!link-&gt;outcfg.list || link-&gt;outcfg.list-&gt;nb != 1)          \</span></span><br><span class="line"><span class="meta">            continue;                                                  \</span></span><br><span class="line"><span class="meta">        fmt = link-&gt;outcfg.list-&gt;var[0];                               \</span></span><br><span class="line"><span class="meta">                                                                       \</span></span><br><span class="line"><span class="meta">        for (j = 0; j <span class="string">&lt; filter-&gt;</span>nb_outputs; j++) &#123;                     \</span></span><br><span class="line"><span class="meta">            AVFilterLink *out_link = filter-&gt;outputs[j];               \</span></span><br><span class="line"><span class="meta">            list_type *fmts;                                           \</span></span><br><span class="line"><span class="meta">                                                                       \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (link-&gt;type != out_link-&gt;type ||                        \</span></span><br><span class="line"><span class="meta">                out_link-&gt;incfg.list-&gt;nb == 1)                         \</span></span><br><span class="line"><span class="meta">                continue;                                              \</span></span><br><span class="line"><span class="meta">            fmts = out_link-&gt;incfg.list;                               \</span></span><br><span class="line"><span class="meta">                                                                       \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (!out_link-&gt;incfg.list-&gt;nb) &#123;                           \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> ((ret = add_format(&amp;out_link-&gt;incfg.list, fmt)) &lt; 0)\</span></span><br><span class="line"><span class="meta">                    return ret;                                        \</span></span><br><span class="line"><span class="meta">                ret = 1;                                               \</span></span><br><span class="line"><span class="meta">                break;                                                 \</span></span><br><span class="line"><span class="meta">            &#125;                                                          \</span></span><br><span class="line"><span class="meta">                                                                       \</span></span><br><span class="line"><span class="meta">            for (k = 0; k <span class="string">&lt; out_link-&gt;</span>incfg.list-&gt;nb; k++)             \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (fmts-&gt;var[k] == fmt) &#123;                             \</span></span><br><span class="line"><span class="meta">                    fmts-&gt;var[0]  = fmt;                               \</span></span><br><span class="line"><span class="meta">                    fmts-&gt;nb = 1;                                      \</span></span><br><span class="line"><span class="meta">                    ret = 1;                                           \</span></span><br><span class="line"><span class="meta">                    break;                                             \</span></span><br><span class="line"><span class="meta">                &#125;                                                      \</span></span><br><span class="line"><span class="meta">        &#125;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                  \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><h3 id="pick-formats"><a href="#pick-formats" class="headerlink" title="pick_formats"></a>pick_formats</h3><p>pick_formats 主要是将每个 link 上的格式固定下来</p><p>如果 link 上的 input format 或者 output format 的 number 只有一个，那么就使用那个格式作为最终格式，否则会借助<code>inputs[0]</code>的格式来决定输出 link 该选择哪个格式最优</p><p><img src="/images/ffmpeg-filter%E4%B9%8B%E6%A0%BC%E5%BC%8F%E5%8D%8F%E5%95%86/pick_formats.jpg"></p><p>下面是具体代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pick_formats</span><span class="params">(AVFilterGraph *graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, ret;</span><br><span class="line">    <span class="type">int</span> change;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        change = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">            AVFilterContext *filter = graph-&gt;filters[i];</span><br><span class="line">            <span class="keyword">if</span> (filter-&gt;nb_inputs)&#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filter-&gt;nb_inputs; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (filter-&gt;inputs[j]-&gt;incfg.formats &amp;&amp; filter-&gt;inputs[j]-&gt;incfg.formats-&gt;nb_formats == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((ret = <span class="built_in">pick_format</span>(filter-&gt;inputs[j], <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> ret;</span><br><span class="line">                        change = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (filter-&gt;nb_outputs)&#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filter-&gt;nb_outputs; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (filter-&gt;outputs[j]-&gt;incfg.formats &amp;&amp; filter-&gt;outputs[j]-&gt;incfg.formats-&gt;nb_formats == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((ret = <span class="built_in">pick_format</span>(filter-&gt;outputs[j], <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> ret;</span><br><span class="line">                        change = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (filter-&gt;nb_inputs &amp;&amp; filter-&gt;nb_outputs &amp;&amp; filter-&gt;inputs[<span class="number">0</span>]-&gt;format&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filter-&gt;nb_outputs; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (filter-&gt;outputs[j]-&gt;format&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((ret = <span class="built_in">pick_format</span>(filter-&gt;outputs[j], filter-&gt;inputs[<span class="number">0</span>])) &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> ret;</span><br><span class="line">                        change = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(change);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">        AVFilterContext *filter = graph-&gt;filters[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filter-&gt;nb_inputs; j++)</span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">pick_format</span>(filter-&gt;inputs[j], <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; filter-&gt;nb_outputs; j++)</span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">pick_format</span>(filter-&gt;outputs[j], <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pick_format</span><span class="params">(AVFilterLink *link, AVFilterLink *ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!link || !link-&gt;incfg.formats)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (link-&gt;type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ref &amp;&amp; ref-&gt;type == AVMEDIA_TYPE_VIDEO)&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">FIXME:</span> This should check for AV_PIX_FMT_FLAG_ALPHA after PAL8 pixel format without alpha is implemented</span></span><br><span class="line">            <span class="type">int</span> has_alpha= <span class="built_in">av_pix_fmt_desc_get</span>(ref-&gt;format)-&gt;nb_components % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">enum</span> <span class="title class_">AVPixelFormat</span> best= AV_PIX_FMT_NONE;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; link-&gt;incfg.formats-&gt;nb_formats; i++) &#123;</span><br><span class="line">                <span class="keyword">enum</span> <span class="title class_">AVPixelFormat</span> p = link-&gt;incfg.formats-&gt;formats[i];</span><br><span class="line">                best= <span class="built_in">av_find_best_pix_fmt_of_2</span>(best, p, ref-&gt;format, has_alpha, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">av_log</span>(link-&gt;src,AV_LOG_DEBUG, <span class="string">&quot;picking %s out of %d ref:%s alpha:%d\n&quot;</span>,</span><br><span class="line">                   <span class="built_in">av_get_pix_fmt_name</span>(best), link-&gt;incfg.formats-&gt;nb_formats,</span><br><span class="line">                   <span class="built_in">av_get_pix_fmt_name</span>(ref-&gt;format), has_alpha);</span><br><span class="line">            link-&gt;incfg.formats-&gt;formats[<span class="number">0</span>] = best;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (link-&gt;type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ref &amp;&amp; ref-&gt;type == AVMEDIA_TYPE_AUDIO)&#123;</span><br><span class="line">            <span class="keyword">enum</span> AVSampleFormat best= AV_SAMPLE_FMT_NONE;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; link-&gt;incfg.formats-&gt;nb_formats; i++) &#123;</span><br><span class="line">                <span class="keyword">enum</span> <span class="title class_">AVSampleFormat</span> p = link-&gt;incfg.formats-&gt;formats[i];</span><br><span class="line">                best = <span class="built_in">find_best_sample_fmt_of_2</span>(best, p, ref-&gt;format);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">av_log</span>(link-&gt;src,AV_LOG_DEBUG, <span class="string">&quot;picking %s out of %d ref:%s\n&quot;</span>,</span><br><span class="line">                   <span class="built_in">av_get_sample_fmt_name</span>(best), link-&gt;incfg.formats-&gt;nb_formats,</span><br><span class="line">                   <span class="built_in">av_get_sample_fmt_name</span>(ref-&gt;format));</span><br><span class="line">            link-&gt;incfg.formats-&gt;formats[<span class="number">0</span>] = best;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    link-&gt;incfg.formats-&gt;nb_formats = <span class="number">1</span>;</span><br><span class="line">    link-&gt;format = link-&gt;incfg.formats-&gt;formats[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (link-&gt;type == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="graph-config-links"><a href="#graph-config-links" class="headerlink" title="graph_config_links"></a>graph_config_links</h2><p>这一步是配置 link，graph_config_links 函数会调用 src&#x2F;sink pad 上的 config props 函数传递 width、height 等信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">graph_config_links</span><span class="params">(AVFilterGraph *graph, <span class="type">void</span> *log_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext *filt;</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; graph-&gt;nb_filters; i++) &#123;</span><br><span class="line">        filt = graph-&gt;filters[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!filt-&gt;nb_outputs) &#123; <span class="comment">// 从sink filter开始从后向前</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">avfilter_config_links</span>(filt)))</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avfilter_config_links</span><span class="params">(AVFilterContext *filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*config_link)(AVFilterLink *);</span><br><span class="line">    <span class="type">unsigned</span> i;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; filter-&gt;nb_inputs; i ++) &#123;</span><br><span class="line">        AVFilterLink *link = filter-&gt;inputs[i];</span><br><span class="line">        AVFilterLink *inlink;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!link || !link-&gt;incfg.formats || !link-&gt;outcfg.formats)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!link-&gt;src || !link-&gt;dst) &#123;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inlink = link-&gt;src-&gt;nb_inputs ? link-&gt;src-&gt;inputs[<span class="number">0</span>] : <span class="literal">NULL</span>;</span><br><span class="line">        link-&gt;current_pts =</span><br><span class="line">        link-&gt;current_pts_us = AV_NOPTS_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (link-&gt;init_state) &#123;</span><br><span class="line">        <span class="keyword">case</span> AVLINK_INIT:</span><br><span class="line">            <span class="comment">/* For part graph re-negotiation.</span></span><br><span class="line"><span class="comment">               For example: output-filter link has config_props(),</span></span><br><span class="line"><span class="comment">               but the input-filter still need config_props(). */</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">avfilter_config_links</span>(link-&gt;src)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> AVLINK_STARTINIT:</span><br><span class="line">            <span class="built_in">av_log</span>(filter, AV_LOG_INFO, <span class="string">&quot;circular filter chain detected\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> AVLINK_UNINIT:</span><br><span class="line">            link-&gt;init_state = AVLINK_STARTINIT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((ret = <span class="built_in">avfilter_config_links</span>(link-&gt;src)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(config_link = link-&gt;srcpad-&gt;config_props)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (link-&gt;src-&gt;nb_inputs != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(link-&gt;src, AV_LOG_ERROR, <span class="string">&quot;Source filters and filters &quot;</span></span><br><span class="line">                                                    <span class="string">&quot;with more than one input &quot;</span></span><br><span class="line">                                                    <span class="string">&quot;must set config_props() &quot;</span></span><br><span class="line">                                                    <span class="string">&quot;callbacks on all outputs\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((ret = <span class="built_in">config_link</span>(link)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">av_log</span>(link-&gt;src, AV_LOG_ERROR,</span><br><span class="line">                       <span class="string">&quot;Failed to configure output pad on %s\n&quot;</span>,</span><br><span class="line">                       link-&gt;src-&gt;name);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (link-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">                <span class="keyword">if</span> (!link-&gt;time_base.num &amp;&amp; !link-&gt;time_base.den)</span><br><span class="line">                    link-&gt;time_base = inlink ? inlink-&gt;time_base : AV_TIME_BASE_Q;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!link-&gt;sample_aspect_ratio.num &amp;&amp; !link-&gt;sample_aspect_ratio.den)</span><br><span class="line">                    link-&gt;sample_aspect_ratio = inlink ?</span><br><span class="line">                        inlink-&gt;sample_aspect_ratio : (AVRational)&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (inlink) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!link-&gt;frame_rate.num &amp;&amp; !link-&gt;frame_rate.den)</span><br><span class="line">                        link-&gt;frame_rate = inlink-&gt;frame_rate;</span><br><span class="line">                    <span class="keyword">if</span> (!link-&gt;w)</span><br><span class="line">                        link-&gt;w = inlink-&gt;w;</span><br><span class="line">                    <span class="keyword">if</span> (!link-&gt;h)</span><br><span class="line">                        link-&gt;h = inlink-&gt;h;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!link-&gt;w || !link-&gt;h) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(link-&gt;src, AV_LOG_ERROR,</span><br><span class="line">                           <span class="string">&quot;Video source filters must set their output link&#x27;s &quot;</span></span><br><span class="line">                           <span class="string">&quot;width and height\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">                <span class="keyword">if</span> (inlink) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!link-&gt;time_base.num &amp;&amp; !link-&gt;time_base.den)</span><br><span class="line">                        link-&gt;time_base = inlink-&gt;time_base;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!link-&gt;time_base.num &amp;&amp; !link-&gt;time_base.den)</span><br><span class="line">                    link-&gt;time_base = (AVRational) &#123;<span class="number">1</span>, link-&gt;sample_rate&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (link-&gt;src-&gt;nb_inputs &amp;&amp; link-&gt;src-&gt;inputs[<span class="number">0</span>]-&gt;hw_frames_ctx &amp;&amp;</span><br><span class="line">                !(link-&gt;src-&gt;filter-&gt;flags_internal &amp; FF_FILTER_FLAG_HWFRAME_AWARE)) &#123;</span><br><span class="line">                <span class="built_in">av_assert0</span>(!link-&gt;hw_frames_ctx &amp;&amp;</span><br><span class="line">                           <span class="string">&quot;should not be set by non-hwframe-aware filter&quot;</span>);</span><br><span class="line">                link-&gt;hw_frames_ctx = <span class="built_in">av_buffer_ref</span>(link-&gt;src-&gt;inputs[<span class="number">0</span>]-&gt;hw_frames_ctx);</span><br><span class="line">                <span class="keyword">if</span> (!link-&gt;hw_frames_ctx)</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((config_link = link-&gt;dstpad-&gt;config_props))</span><br><span class="line">                <span class="keyword">if</span> ((ret = <span class="built_in">config_link</span>(link)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">av_log</span>(link-&gt;dst, AV_LOG_ERROR,</span><br><span class="line">                           <span class="string">&quot;Failed to configure input pad on %s\n&quot;</span>,</span><br><span class="line">                           link-&gt;dst-&gt;name);</span><br><span class="line">                    <span class="keyword">return</span> ret;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            link-&gt;init_state = AVLINK_INIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>graph_config_links 会从 sink filter 开始向前递归，然后从 src filter 开始配置 link，是一个 dfs 过程。</p><p>graph_check_links 和 graph_config_pointers 都比较简单，这里就不再仔细介绍。</p><p>参考资料：</p><p><a href="https://www.cnblogs.com/TaigaCon/p/10111326.html">https://www.cnblogs.com/TaigaCon/p/10111326.html</a></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg filter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg filter之创建filter与filtergraph</title>
      <link href="/2023/03/16/ffmpeg-filter%E4%B9%8B%E5%88%9B%E5%BB%BAfilter%E4%B8%8Efiltergraph/"/>
      <url>/2023/03/16/ffmpeg-filter%E4%B9%8B%E5%88%9B%E5%BB%BAfilter%E4%B8%8Efiltergraph/</url>
      
        <content type="html"><![CDATA[<p>这篇博客介绍一下 ffmpeg 中 filter 和 filtergraph 的使用，为后续介绍具体原理作铺垫。</p><p>下面是一个 filter 和 filtergraph 的简单示例：</p><ul><li>先从 filtergraph 中创建 3 个 filter 的实例</li><li>将 filter 实例连接起来</li><li>配置整个 filtergraph，然后就可以使用该 filtergraph 对数据进行处理</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> AVFilter *buffersrc  = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;buffer&quot;</span>);</span><br><span class="line"><span class="type">const</span> AVFilter *buffersink = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;buffersink&quot;</span>);</span><br><span class="line"><span class="type">const</span> AVFilter *myfilter   = <span class="built_in">avfilter_get_by_name</span>(<span class="string">&quot;myfilter&quot;</span>);</span><br><span class="line"></span><br><span class="line">AVFilterGraph *filter_graph = <span class="built_in">avfilter_graph_alloc</span>();</span><br><span class="line"></span><br><span class="line">AVFilterContext *in_video_filter = <span class="literal">NULL</span>;</span><br><span class="line">AVFilterContext *out_video_filter = <span class="literal">NULL</span>;</span><br><span class="line">AVFilterContext *my_video_filter = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">avfilter_graph_create_filter</span>(&amp;in_video_filter, buffersrc, <span class="string">&quot;in&quot;</span>, args, <span class="literal">NULL</span>, filter_graph);</span><br><span class="line"><span class="built_in">avfilter_graph_create_filter</span>(&amp;out_video_filter, buffersink, <span class="string">&quot;out&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, filter_graph);</span><br><span class="line"><span class="built_in">avfilter_graph_create_filter</span>(&amp;my_video_filter, myfilter, <span class="string">&quot;myfilter&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, filter_graph);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avfilter_link</span>(in_video_filter, <span class="number">0</span>, my_video_filter, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">avfilter_link</span>(my_video_filter, <span class="number">0</span>, out_video_filter, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">avfilter_graph_config</span>(filter_graph, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>上面代码的逻辑比较好理解，这里不作过多介绍。下面直接分析相关 api 的代码实现</p><h1 id="avfilter-get-by-name"><a href="#avfilter-get-by-name" class="headerlink" title="avfilter_get_by_name"></a>avfilter_get_by_name</h1><p>avfilter_get_by_name 就是通过 name 字符串得到 AVFilter 的指针，AVFilter 相当于一个描述符，指明了将要创建的 AVFilterContext 的特性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVFilter *<span class="title">avfilter_get_by_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVFilter *f = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span> *opaque = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!name)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((f = <span class="built_in">av_filter_iterate</span>(&amp;opaque)))</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(f-&gt;name, name))</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="avfilter-graph-alloc"><a href="#avfilter-graph-alloc" class="headerlink" title="avfilter_graph_alloc"></a>avfilter_graph_alloc</h1><p>avfilter_graph_alloc 则是创建 AVFilterGraph 实例，该实例管理所有的 AVFilterContext</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVFilterGraph *<span class="title">avfilter_graph_alloc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterGraph *ret = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*ret));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret-&gt;internal = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*ret-&gt;internal));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret-&gt;av_class = &amp;filtergraph_class;</span><br><span class="line">    <span class="built_in">av_opt_set_defaults</span>(ret);</span><br><span class="line">    <span class="built_in">ff_framequeue_global_init</span>(&amp;ret-&gt;internal-&gt;frame_queues);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_framequeue_global_init</span><span class="params">(FFFrameQueueGlobal *fqg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="avfilter-graph-create-filter"><a href="#avfilter-graph-create-filter" class="headerlink" title="avfilter_graph_create_filter"></a>avfilter_graph_create_filter</h1><p>这个函数是在 AVFilterGraph 实例内创建 AVFilterContext，具体来说就是先创建 AVFilterContext，然后将 AVFilterContext 添加到 AVFilterGraph 中，当然用户也可以手动进行这两个过程，但是 avfilter_graph_create_filter 在把 AVFilterContext 添加到 AVFilterGraph 时会自动处理 AVFilterGraph 中的 AVFilterContext 指针数组，不建议用户直接使用底层接口。</p><p>avfilter_graph_create_filter 中还会执行 AVFilterContext 的初始化，也就是会调用 AVFilter 中定义的 init&#x2F;init_dict 函数初始化 AVFilterContext。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avfilter_graph_create_filter</span><span class="params">(AVFilterContext **filt_ctx, <span class="type">const</span> AVFilter *filt,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *args, <span class="type">void</span> *opaque,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 AVFilterGraph *graph_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    *filt_ctx = <span class="built_in">avfilter_graph_alloc_filter</span>(graph_ctx, filt, name);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">avfilter_init_str</span>(*filt_ctx, args);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVFilterContext *<span class="title">avfilter_graph_alloc_filter</span><span class="params">(AVFilterGraph *graph,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> AVFilter *filter,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext **filters, *s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (graph-&gt;thread_type &amp;&amp; !graph-&gt;internal-&gt;thread_execute) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph-&gt;execute) &#123;</span><br><span class="line">            graph-&gt;internal-&gt;thread_execute = graph-&gt;execute;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> ret = <span class="built_in">ff_graph_thread_init</span>(graph);</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filters = <span class="built_in">av_realloc_array</span>(graph-&gt;filters, graph-&gt;nb_filters + <span class="number">1</span>, <span class="built_in">sizeof</span>(*filters));</span><br><span class="line">...</span><br><span class="line">    graph-&gt;filters = filters;</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">ff_filter_alloc</span>(filter, name);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    graph-&gt;filters[graph-&gt;nb_filters++] = s;</span><br><span class="line"></span><br><span class="line">    s-&gt;graph = graph;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVFilterContext *<span class="title">ff_filter_alloc</span><span class="params">(<span class="type">const</span> AVFilter *filter, <span class="type">const</span> <span class="type">char</span> *inst_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterContext *ret;</span><br><span class="line">    <span class="type">int</span> preinited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filter)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(AVFilterContext));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret-&gt;av_class = &amp;avfilter_class;</span><br><span class="line">    ret-&gt;filter   = filter;</span><br><span class="line">    ret-&gt;name     = inst_name ? <span class="built_in">av_strdup</span>(inst_name) : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (filter-&gt;priv_size) &#123;</span><br><span class="line">        ret-&gt;priv     = <span class="built_in">av_mallocz</span>(filter-&gt;priv_size);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (filter-&gt;preinit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter-&gt;<span class="built_in">preinit</span>(ret) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        preinited = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_opt_set_defaults</span>(ret);</span><br><span class="line">    <span class="keyword">if</span> (filter-&gt;priv_class) &#123;</span><br><span class="line">        *(<span class="type">const</span> AVClass**)ret-&gt;priv = filter-&gt;priv_class;</span><br><span class="line">        <span class="built_in">av_opt_set_defaults</span>(ret-&gt;priv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret-&gt;internal = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*ret-&gt;internal));</span><br><span class="line">...</span><br><span class="line">    ret-&gt;internal-&gt;execute = default_execute;</span><br><span class="line"></span><br><span class="line">    ret-&gt;nb_inputs  = filter-&gt;nb_inputs;</span><br><span class="line">    <span class="keyword">if</span> (ret-&gt;nb_inputs ) &#123;</span><br><span class="line">        ret-&gt;input_pads   = <span class="built_in">av_memdup</span>(filter-&gt;inputs,  ret-&gt;nb_inputs  * <span class="built_in">sizeof</span>(*filter-&gt;inputs));</span><br><span class="line">...</span><br><span class="line">        ret-&gt;inputs      = <span class="built_in">av_calloc</span>(ret-&gt;nb_inputs, <span class="built_in">sizeof</span>(*ret-&gt;inputs));</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret-&gt;nb_outputs = filter-&gt;nb_outputs;</span><br><span class="line">    <span class="keyword">if</span> (ret-&gt;nb_outputs) &#123;</span><br><span class="line">        ret-&gt;output_pads  = <span class="built_in">av_memdup</span>(filter-&gt;outputs, ret-&gt;nb_outputs * <span class="built_in">sizeof</span>(*filter-&gt;outputs));</span><br><span class="line">...</span><br><span class="line">        ret-&gt;outputs     = <span class="built_in">av_calloc</span>(ret-&gt;nb_outputs, <span class="built_in">sizeof</span>(*ret-&gt;outputs));</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avfilter_init_str</span><span class="params">(AVFilterContext *filter, <span class="type">const</span> <span class="type">char</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVDictionary *options = <span class="literal">NULL</span>;</span><br><span class="line">    AVDictionaryEntry *e;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args &amp;&amp; *args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!filter-&gt;filter-&gt;priv_class) &#123;</span><br><span class="line">            <span class="built_in">av_log</span>(filter, AV_LOG_ERROR, <span class="string">&quot;This filter does not take any &quot;</span></span><br><span class="line">                   <span class="string">&quot;options, but options were provided: %s.\n&quot;</span>, args);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">process_options</span>(filter, &amp;options, args);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">avfilter_init_dict</span>(filter, &amp;options);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((e = <span class="built_in">av_dict_get</span>(options, <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span>, AV_DICT_IGNORE_SUFFIX))) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(filter, AV_LOG_ERROR, <span class="string">&quot;No such option: %s.\n&quot;</span>, e-&gt;key);</span><br><span class="line">        ret = AVERROR_OPTION_NOT_FOUND;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">avfilter_init_dict</span><span class="params">(AVFilterContext *ctx, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_opt_set_dict</span>(ctx, options);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;filter-&gt;flags &amp; AVFILTER_FLAG_SLICE_THREADS &amp;&amp;</span><br><span class="line">        ctx-&gt;thread_type &amp; ctx-&gt;graph-&gt;thread_type &amp; AVFILTER_THREAD_SLICE &amp;&amp;</span><br><span class="line">        ctx-&gt;graph-&gt;internal-&gt;thread_execute) &#123;</span><br><span class="line">        ctx-&gt;thread_type       = AVFILTER_THREAD_SLICE;</span><br><span class="line">        ctx-&gt;internal-&gt;execute = ctx-&gt;graph-&gt;internal-&gt;thread_execute;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx-&gt;thread_type = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;filter-&gt;priv_class) &#123;</span><br><span class="line">        ret = <span class="built_in">av_opt_set_dict2</span>(ctx-&gt;priv, options, AV_OPT_SEARCH_CHILDREN);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">av_log</span>(ctx, AV_LOG_ERROR, <span class="string">&quot;Error applying options to the filter.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;filter-&gt;init)</span><br><span class="line">        ret = ctx-&gt;filter-&gt;<span class="built_in">init</span>(ctx);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ctx-&gt;filter-&gt;init_dict)</span><br><span class="line">        ret = ctx-&gt;filter-&gt;<span class="built_in">init_dict</span>(ctx, options);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;enable_str) &#123;</span><br><span class="line">        ret = <span class="built_in">set_enable_expr</span>(ctx, ctx-&gt;enable_str);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="avfilter-link"><a href="#avfilter-link" class="headerlink" title="avfilter_link"></a>avfilter_link</h1><p>avfilter_link 函数将两个 filter 的 src、sink 端连接起来，他会创建一个 AVFilterLink 的实例管理该连接。该 AVFilterLink 实例中有很多重要的字段，这些数据控制了这条连接的通断状态和数据缓存，后面会单独写一篇文章介绍 AVFilterLink 上的字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">avfilter_link</span><span class="params">(AVFilterContext *src, <span class="type">unsigned</span> srcpad,</span></span></span><br><span class="line"><span class="params"><span class="function">                  AVFilterContext *dst, <span class="type">unsigned</span> dstpad)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFilterLink *link;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert0</span>(src-&gt;graph);</span><br><span class="line">    <span class="built_in">av_assert0</span>(dst-&gt;graph);</span><br><span class="line">    <span class="built_in">av_assert0</span>(src-&gt;graph == dst-&gt;graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (src-&gt;nb_outputs &lt;= srcpad || dst-&gt;nb_inputs &lt;= dstpad ||</span><br><span class="line">        src-&gt;outputs[srcpad]      || dst-&gt;inputs[dstpad])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (src-&gt;output_pads[srcpad].type != dst-&gt;input_pads[dstpad].type) &#123;</span><br><span class="line">        <span class="built_in">av_log</span>(src, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;Media type mismatch between the &#x27;%s&#x27; filter output pad %d (%s) and the &#x27;%s&#x27; filter input pad %d (%s)\n&quot;</span>,</span><br><span class="line">               src-&gt;name, srcpad, (<span class="type">char</span> *)<span class="built_in">av_x_if_null</span>(<span class="built_in">av_get_media_type_string</span>(src-&gt;output_pads[srcpad].type), <span class="string">&quot;?&quot;</span>),</span><br><span class="line">               dst-&gt;name, dstpad, (<span class="type">char</span> *)<span class="built_in">av_x_if_null</span>(<span class="built_in">av_get_media_type_string</span>(dst-&gt; input_pads[dstpad].type), <span class="string">&quot;?&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    link = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*link));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    src-&gt;outputs[srcpad] = dst-&gt;inputs[dstpad] = link;</span><br><span class="line"></span><br><span class="line">    &lt;u&gt;link-&gt;src     = src;&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;link-&gt;dst     = dst;&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;link-&gt;srcpad  = &amp;src-&gt;output_pads[srcpad];&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;link-&gt;dstpad  = &amp;dst-&gt;input_pads[dstpad];&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;link-&gt;type    = src-&gt;output_pads[srcpad].type;&lt;/u&gt;</span><br><span class="line">    <span class="built_in">av_assert0</span>(AV_PIX_FMT_NONE == <span class="number">-1</span> &amp;&amp; AV_SAMPLE_FMT_NONE == <span class="number">-1</span>);</span><br><span class="line">    &lt;u&gt;link-&gt;format  = <span class="number">-1</span>;&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;link-&gt;status_in  = AVERROR_EOF;&lt;/u&gt;</span><br><span class="line">    &lt;u&gt;link-&gt;status_out = AVERROR_EOF;&lt;/u&gt;</span><br><span class="line">    <span class="built_in">ff_framequeue_init</span>(&amp;link-&gt;fifo, &amp;src-&gt;graph-&gt;internal-&gt;frame_queues);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff_framequeue_init</span><span class="params">(FFFrameQueue *fq, FFFrameQueueGlobal *fqg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fq-&gt;queue = &amp;fq-&gt;first_bucket;</span><br><span class="line">    fq-&gt;allocated = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面介绍了通过 api 直接构建 filtergraph 的方法，除了这种方法以外还可以通过配置文件来构建 filtergraph，其内部也是使用的上面的 api，只是多了一层解析配置文件、根据配置自动创建并连接 filter 的包装，读者可以参考其他资料，这里不再赘述。下篇博客针对 avfilter_graph_config 函数介绍一下 filter 的格式协商。</p><p>参考资料：</p><p><a href="https://www.cnblogs.com/TaigaCon/p/10067871.html">https://www.cnblogs.com/TaigaCon/p/10067871.html</a></p><p><a href="http://beyoung.xyz/2018/03/24/2018-3-24-FFmpeg%E4%B8%ADAVFilter%E6%A8%A1%E5%9D%97%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/">http://beyoung.xyz/2018/03/24/2018-3-24-FFmpeg%E4%B8%ADAVFilter%E6%A8%A1%E5%9D%97%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</a></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
          <category> ffmpeg filter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg之AVFrame和AVPacket</title>
      <link href="/2023/03/13/ffmpeg%E4%B9%8BAVFrame%E5%92%8CAVPacket/"/>
      <url>/2023/03/13/ffmpeg%E4%B9%8BAVFrame%E5%92%8CAVPacket/</url>
      
        <content type="html"><![CDATA[<p>AVFrame 和 AVPacket 是 ffmpeg 中对 buffer 进行管理的结构，AVFrame 用于管理解码好的数据，比如 yuv、rgb 格式的图像，AVPacket 用于管理编码完成后的数据，比如 h264 码流。</p><p>先介绍 AVFrame，他的结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVFrame</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_NUM_DATA_POINTERS 8</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">All pointers in data and extended_data must point into one of the</span></span><br><span class="line"><span class="comment">AVBufferRef in buf or extended_buf.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Some filters and swscale can read</span></span><br><span class="line"><span class="comment">up to 16 bytes beyond the planes, if these filters are to be used,</span></span><br><span class="line"><span class="comment">then 16 extra bytes must be allocated.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">In case of video, the data[] pointers can point to the</span></span><br><span class="line"><span class="comment">end of image data in order to reverse line order, when used in</span></span><br><span class="line"><span class="comment">combination with negative values in the linesize[] array.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">uint8_t</span> *data[AV_NUM_DATA_POINTERS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">For video, a positive or negative value, which is typically indicating</span></span><br><span class="line"><span class="comment">the size in bytes of each picture line,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">int</span> linesize[AV_NUM_DATA_POINTERS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// extended_data指向所有的data，他里面包含了data的内容，也就是说extended_data数组的前面部分就是data的内容</span></span><br><span class="line">    <span class="type">uint8_t</span> **extended_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AVBuffer references backing the data for this frame. All the pointers in</span></span><br><span class="line"><span class="comment">data and extended_data must point inside one of the buffers in buf or extended_buf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    AVBufferRef *buf[AV_NUM_DATA_POINTERS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Note that this is different from AVFrame.extended_data, which always</span></span><br><span class="line"><span class="comment">contains all the pointers. This array only contains the extra pointers,</span></span><br><span class="line"><span class="comment">which cannot fit into AVFrame.buf.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    AVBufferRef **extended_buf;</span><br><span class="line">    <span class="type">int</span>        nb_extended_buf;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>data 是一个指针数组，里面的每一项指向一个内存地址。</li><li>linesize 用于图像，表示这个图像一行的宽度。由于对齐的要求，linesize 通常大于图像的尺寸宽度。</li><li>extended_data 看名字就知道是对 data 数组的扩展，一般用在音频数据中，如果音频数据的 layout 有多个 plane，那么 AV_NUM_DATA_POINTERS 大小的 data 数组可能不够用，此时需要新分配更大的数组来保存这些指针。需要注意，extended_data 是包含 data 数组中的指针的，不是说新分配的指针才保存在 extended_data 中，而是 extended_data 会先把 data 的内容拷贝过来，然后再存储新的 buffer 指针。如果 data 数组够用，那么 extended_data 就指向 data 数组。</li><li>buf 是一个指针数组，每一项指向一个 AVBufferRef，他和 buffer 的引用计数有关，后面介绍引用计数时会具体分析这个成员。</li><li>extended_buf 是一个指针的指针，也可以当成指针数组，看名字就知道 extended_buf 是 buf 的扩展，但是和 extended_data 相较于 data 不一样，extended_buf 数组的前面部分不是 buf，就是新分配的 AVBufferRef*，也就是不用先把 buf 拷贝到 extended_buf，这和 extended_data 不一样。</li><li>nb_extended_buf 是 extended_buf 的辅助信息，指明 extended_buf 数组有多少个元素。为什么 extended_data 没有类似的辅助信息？先留一个疑问，下面再讲。</li></ul><p>了解了 AVFrame 的结构后，再看一下相关的方法。</p><p>要使用 AVFrame，需要先分配 AVFrame 这个结构体本身。下面的 av_frame_alloc 仅仅只分配了 AVFrame，同时作了一些初始化工作。可以看到 extended_data 最开始就是指向 data。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this only allocates the AVFrame itself, not the data buffers.</span></span><br><span class="line"><span class="comment">// The resulting struct must be freed using av_frame_free().</span></span><br><span class="line"><span class="comment">// allocated once and then reused multiple times to hold different data</span></span><br><span class="line"><span class="function">AVFrame *<span class="title">av_frame_alloc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFrame *frame = <span class="built_in">av_malloc</span>(<span class="built_in">sizeof</span>(*frame));</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">get_frame_defaults</span>(frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_frame_defaults</span><span class="params">(AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这一步把width、height等都归0了</span></span><br><span class="line">    <span class="built_in">memset</span>(frame, <span class="number">0</span>, <span class="built_in">sizeof</span>(*frame));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    frame-&gt;pts                   =</span><br><span class="line">    frame-&gt;pkt_dts               = AV_NOPTS_VALUE;</span><br><span class="line">    frame-&gt;best_effort_timestamp = AV_NOPTS_VALUE;</span><br><span class="line">    frame-&gt;pkt_duration        = <span class="number">0</span>;</span><br><span class="line">    frame-&gt;pkt_pos             = <span class="number">-1</span>;</span><br><span class="line">    frame-&gt;pkt_size            = <span class="number">-1</span>;</span><br><span class="line">    frame-&gt;time_base           = (AVRational)&#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    frame-&gt;key_frame           = <span class="number">1</span>;</span><br><span class="line">    frame-&gt;sample_aspect_ratio = (AVRational)&#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    frame-&gt;format              = <span class="number">-1</span>; <span class="comment">/* unknown */</span></span><br><span class="line">    frame-&gt;extended_data       = frame-&gt;data;</span><br><span class="line">    frame-&gt;color_primaries     = AVCOL_PRI_UNSPECIFIED;</span><br><span class="line">    frame-&gt;color_trc           = AVCOL_TRC_UNSPECIFIED;</span><br><span class="line">    frame-&gt;colorspace          = AVCOL_SPC_UNSPECIFIED;</span><br><span class="line">    frame-&gt;color_range         = AVCOL_RANGE_UNSPECIFIED;</span><br><span class="line">    frame-&gt;chroma_location     = AVCHROMA_LOC_UNSPECIFIED;</span><br><span class="line">    frame-&gt;flags               = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_frame_alloc 之后，AVFrame 内部还没有真正可以用来存储数据的内存，需要通过 av_frame_get_buffer 或者其他方式申请内存。使用 av_frame_get_buffer 时，必须指定 format，width&#x2F;height（对视频），nb_samples&#x2F;ch_layout（对音频）。</p><blockquote><p>The following fields must be set on frame before calling this function:<br/> - format (pixel format for video, sample format for audio)<br/> - width and height for video<br/> - nb_samples and ch_layout for audio</p></blockquote><p>此外输入的 AVFrame 必须是“fresh”的，“fresh”是指新 av_frame_alloc 或者 av_frame_unref 后。</p><p>如果 AVFrame 不是“fresh”的，则可能发生内存泄漏：在 get_video_buffer 函数里面是直接对 frame-&gt;data、frame-&gt;buf 赋值，没有内存释放动作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_frame_get_buffer</span><span class="params">(AVFrame *frame, <span class="type">int</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;format &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"><span class="function">FF_DISABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(frame-&gt;width &gt; <span class="number">0</span> &amp;&amp; frame-&gt;height &gt; <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="title">get_video_buffer</span><span class="params">(frame, align)</span></span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (frame-&gt;nb_samples &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             (<span class="built_in">av_channel_layout_check</span>(&amp;frame-&gt;ch_layout)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_OLD_CHANNEL_LAYOUT</span></span><br><span class="line">              || frame-&gt;channel_layout || frame-&gt;channels &gt; <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">             ))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_audio_buffer</span>(frame, align);</span><br><span class="line"><span class="function">FF_ENABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">AVERROR</span><span class="params">(EINVAL)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get_video_buffer</span><span class="params">(AVFrame *frame, <span class="type">int</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVPixFmtDescriptor *desc = <span class="built_in">av_pix_fmt_desc_get</span>(frame-&gt;format);</span><br><span class="line">    <span class="type">int</span> ret, i, padded_height, total_size;</span><br><span class="line">    <span class="type">int</span> plane_padding = <span class="built_in">FFMAX</span>(<span class="number">16</span> + <span class="number">16</span><span class="comment">/*STRIDE_ALIGN*/</span>, align);</span><br><span class="line">    <span class="type">ptrdiff_t</span> linesizes[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> sizes[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!desc)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_check_size</span>(frame-&gt;width, frame-&gt;height, <span class="number">0</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;linesize[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (align &lt;= <span class="number">0</span>)</span><br><span class="line">            align = <span class="number">32</span>; <span class="comment">/* STRIDE_ALIGN. Should be av_cpu_max_align() */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=align; i+=i) &#123;</span><br><span class="line">            ret = <span class="built_in">av_image_fill_linesizes</span>(frame-&gt;linesize, frame-&gt;format,</span><br><span class="line">                                          <span class="built_in">FFALIGN</span>(frame-&gt;width, i));</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">if</span> (!(frame-&gt;linesize[<span class="number">0</span>] &amp; (align<span class="number">-1</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span> &amp;&amp; frame-&gt;linesize[i]; i++)</span><br><span class="line">            frame-&gt;linesize[i] = <span class="built_in">FFALIGN</span>(frame-&gt;linesize[i], align);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        linesizes[i] = frame-&gt;linesize[i];</span><br><span class="line"></span><br><span class="line">    padded_height = <span class="built_in">FFALIGN</span>(frame-&gt;height, <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_fill_plane_sizes</span>(sizes, frame-&gt;format,</span><br><span class="line">                                         padded_height, linesizes)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    total_size = <span class="number">4</span>*plane_padding;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sizes[i] &gt; INT_MAX - total_size)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        total_size += sizes[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame-&gt;buf[<span class="number">0</span>] = <span class="built_in">av_buffer_alloc</span>(total_size);</span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        ret = <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">av_image_fill_pointers</span>(frame-&gt;data, frame-&gt;format, padded_height,</span><br><span class="line">                                      frame-&gt;buf[<span class="number">0</span>]-&gt;data, frame-&gt;linesize)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;data[i])</span><br><span class="line">            frame-&gt;data[i] += i * plane_padding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame-&gt;extended_data = frame-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 get_video_buffer 里面还可以看到，先分配一大块内存到 buf[0]，然后把 data 指针指向这块大 buf 的不同部分。</p><p>再看一下 AVFrame 的引用计数特性。在上面 get_video_buffer 中，是通过 av_buffer_alloc 函数来真正进行内存分配工作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVBufferRef *<span class="title">av_buffer_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">uint8_t</span>    *data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    data = <span class="built_in">av_malloc</span>(size);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_buffer_create</span>(data, size, av_buffer_default_free, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVBufferRef *<span class="title">av_buffer_create</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> (*free)(<span class="type">void</span> *opaque, <span class="type">uint8_t</span> *data),</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">void</span> *opaque, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *ret;</span><br><span class="line">    AVBuffer *buf = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*buf));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">buffer_create</span>(buf, data, size, free, opaque, flags);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> AVBufferRef *<span class="title">buffer_create</span><span class="params">(AVBuffer *buf, <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">void</span> (*free)(<span class="type">void</span> *opaque, <span class="type">uint8_t</span> *data),</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">void</span> *opaque, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *ref = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    buf-&gt;data     = data;</span><br><span class="line">    buf-&gt;size     = size;</span><br><span class="line">    buf-&gt;free     = free ? free : av_buffer_default_free;</span><br><span class="line">    buf-&gt;opaque   = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">atomic_init</span>(&amp;buf-&gt;refcount, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    buf-&gt;flags = flags;</span><br><span class="line"></span><br><span class="line">    ref = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*ref));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ref-&gt;buffer = buf;</span><br><span class="line">    ref-&gt;data   = data;</span><br><span class="line">    ref-&gt;size   = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先分配真正存储数据的内存，然后创建一个 AVBufferRef 的实例，AVBufferRef 实例中有指向 AVBuffer 的指针，而 AVBuffer 里面有引用计数、释放时调用的 free 函数地址等信息。通过在不同 AVFrame 共享 AVBuffer 指针来实现引用计数。</p><p>从上面可以看到，AVFrame 的 data 数组只是存放内存地址，真正管理内存的是 buf 指向的 AVBufferRef，下面的 ref、unref 操作都是操作的 AVBufferRef</p><p>如果我们不想用引用计数，该怎么办呢？很简单，我们可以直接给 AVFrame 的 data 赋值，赋一个自己申请的内存，同时让 buf 数组为空，这样的 AVFrame 就不是引用计数的。但是这样的 AVFrame 在 ref 时会进行 copy 操作，而且使用带引用计数的 AVFrame 是未来的趋势。</p><p>再看看 AVFrame 的其他操作。</p><p>先看 ref 操作，ref 操作同样要求 dst 是 fresh 的。ref 操作主要做了：</p><ul><li>把 src 的属性，比如 width、height 等拷贝到 dest</li><li>如果 src 不是引用计数，则会把 src 的 data 拷贝到 dst</li><li>否则增加引用计数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_frame_ref</span><span class="params">(AVFrame *dst, <span class="type">const</span> AVFrame *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_assert1</span>(dst-&gt;width == <span class="number">0</span> &amp;&amp; dst-&gt;height == <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">av_assert1</span>(dst-&gt;ch_layout.nb_channels == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               dst-&gt;ch_layout.order == AV_CHANNEL_ORDER_UNSPEC);</span><br><span class="line"></span><br><span class="line">    dst-&gt;format         = src-&gt;format;</span><br><span class="line">    dst-&gt;width          = src-&gt;width;</span><br><span class="line">    dst-&gt;height         = src-&gt;height;</span><br><span class="line">    dst-&gt;nb_samples     = src-&gt;nb_samples;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里面会处理side data</span></span><br><span class="line">    ret = <span class="built_in">frame_copy_props</span>(dst, src, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* duplicate the frame data if it&#x27;s not refcounted */</span></span><br><span class="line">    <span class="keyword">if</span> (!src-&gt;buf[<span class="number">0</span>]) &#123;</span><br><span class="line">        ret = <span class="built_in">av_frame_get_buffer</span>(dst, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">        ret = <span class="built_in">av_frame_copy</span>(dst, src);</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ref the buffers */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">FF_ARRAY_ELEMS</span>(src-&gt;buf); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!src-&gt;buf[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dst-&gt;buf[i] = <span class="built_in">av_buffer_ref</span>(src-&gt;buf[i]);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (src-&gt;extended_buf) &#123;</span><br><span class="line">        dst-&gt;extended_buf = <span class="built_in">av_calloc</span>(src-&gt;nb_extended_buf,</span><br><span class="line">                                      <span class="built_in">sizeof</span>(*dst-&gt;extended_buf));</span><br><span class="line">...</span><br><span class="line">        dst-&gt;nb_extended_buf = src-&gt;nb_extended_buf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; src-&gt;nb_extended_buf; i++) &#123;</span><br><span class="line">            dst-&gt;extended_buf[i] = <span class="built_in">av_buffer_ref</span>(src-&gt;extended_buf[i]);</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* duplicate extended data */</span></span><br><span class="line">    <span class="keyword">if</span> (src-&gt;extended_data != src-&gt;data) &#123;</span><br><span class="line">        <span class="type">int</span> ch = dst-&gt;ch_layout.nb_channels;</span><br><span class="line">...</span><br><span class="line">        dst-&gt;extended_data = <span class="built_in">av_malloc_array</span>(<span class="built_in">sizeof</span>(*dst-&gt;extended_data), ch);</span><br><span class="line">...</span><br><span class="line">        <span class="built_in">memcpy</span>(dst-&gt;extended_data, src-&gt;extended_data, <span class="built_in">sizeof</span>(*src-&gt;extended_data) * ch);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        dst-&gt;extended_data = dst-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;data,     src-&gt;data,     <span class="built_in">sizeof</span>(src-&gt;data));</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;linesize, src-&gt;linesize, <span class="built_in">sizeof</span>(src-&gt;linesize));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVBufferRef *<span class="title">av_buffer_ref</span><span class="params">(<span class="type">const</span> AVBufferRef *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *ret = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*ret));</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    *ret = *buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">atomic_fetch_add_explicit</span>(&amp;buf-&gt;buffer-&gt;refcount, <span class="number">1</span>, memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以解答为什么 extended_data 不需要指明数组元素的个数：上面在分配 extended_data 时，数组长度是以 ch_layout.nb_channels 来算的，所以 extended_data 一般用在 audio 数据中。</p><p>再看一下 unref 操作。unref 主要作了：</p><ul><li>释放所有 buf、data</li><li>恢复 AVFrame 中的字段为默认值</li></ul><p>可以认为 unref 之后和新 alloc 得到的 AVFrame 的状态是一样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_frame_unref</span><span class="params">(AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清扫 side_data，暂时不管</span></span><br><span class="line">    <span class="built_in">wipe_side_data</span>(frame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 和 extended_buf都要被释放</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">FF_ARRAY_ELEMS</span>(frame-&gt;buf); i++)</span><br><span class="line">        <span class="built_in">av_buffer_unref</span>(&amp;frame-&gt;buf[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; frame-&gt;nb_extended_buf; i++)</span><br><span class="line">        <span class="built_in">av_buffer_unref</span>(&amp;frame-&gt;extended_buf[i]);</span><br><span class="line">    <span class="built_in">av_freep</span>(&amp;frame-&gt;extended_buf);</span><br><span class="line">    <span class="built_in">av_dict_free</span>(&amp;frame-&gt;metadata);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_buffer_unref</span>(&amp;frame-&gt;hw_frames_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_buffer_unref</span>(&amp;frame-&gt;opaque_ref);</span><br><span class="line">    <span class="built_in">av_buffer_unref</span>(&amp;frame-&gt;private_ref);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;extended_data != frame-&gt;data)</span><br><span class="line">        <span class="built_in">av_freep</span>(&amp;frame-&gt;extended_data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_channel_layout_uninit</span>(&amp;frame-&gt;ch_layout);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_frame_defaults</span>(frame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_buffer_unref</span><span class="params">(AVBufferRef **buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!buf || !*buf)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">buffer_replace</span>(buf, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">buffer_replace</span><span class="params">(AVBufferRef **dst, AVBufferRef **src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBuffer *b;</span><br><span class="line"></span><br><span class="line">    b = (*dst)-&gt;buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (src) &#123;</span><br><span class="line">        **dst = **src;</span><br><span class="line">        <span class="built_in">av_freep</span>(src);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">av_freep</span>(dst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">atomic_fetch_sub_explicit</span>(&amp;b-&gt;refcount, <span class="number">1</span>, memory_order_acq_rel) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* b-&gt;free below might already free the structure containing *b,</span></span><br><span class="line"><span class="comment">         * so we have to read the flag now to avoid use-after-free. */</span></span><br><span class="line">        <span class="type">int</span> free_avbuffer = !(b-&gt;flags_internal &amp; BUFFER_FLAG_NO_FREE);</span><br><span class="line">        b-&gt;<span class="built_in">free</span>(b-&gt;opaque, b-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (free_avbuffer)</span><br><span class="line">            <span class="built_in">av_free</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动 move 操作。和 C++ 中的移动语义类似，把内存从一个 AVFrame 转移到另一个 frame，dst 同样要求是 fresh 的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_frame_move_ref</span><span class="params">(AVFrame *dst, AVFrame *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_assert1</span>(dst-&gt;width == <span class="number">0</span> &amp;&amp; dst-&gt;height == <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">av_assert1</span>(dst-&gt;ch_layout.nb_channels == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               dst-&gt;ch_layout.order == AV_CHANNEL_ORDER_UNSPEC);</span><br><span class="line"></span><br><span class="line">    *dst = *src;</span><br><span class="line">    <span class="keyword">if</span> (src-&gt;extended_data == src-&gt;data)</span><br><span class="line">        dst-&gt;extended_data = dst-&gt;data;</span><br><span class="line">    <span class="built_in">get_frame_defaults</span>(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clone 操作。相当于 av_frame_alloc()+av_frame_ref()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVFrame *<span class="title">av_frame_clone</span><span class="params">(<span class="type">const</span> AVFrame *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFrame *ret = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">av_frame_ref</span>(ret, src) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">av_frame_free</span>(&amp;ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 操作。他和 unref 的区别是，unref 会释放 get_video_buffer 分配的内存，但是 av_frame_alloc 得到的 AVFrame 本身不会释放，而 free 会先 unref，然后释放 AVFrame 本身：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_frame_free</span><span class="params">(AVFrame **frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">av_frame_unref</span>(*frame);</span><br><span class="line">    <span class="built_in">av_freep</span>(frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy 操作。和 clone 操作有很大区别。copy 是把 src 的 buffer 拷贝到 dest，dest 和 src 必须都是相同维度（宽&#x2F;高），而且都已经 av_frame_get_buffer 分配了 buffer，copy 仅仅只是把 av_frame_get_buffer 分配的 buffer 内容进行拷贝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_frame_copy</span><span class="params">(AVFrame *dst, <span class="type">const</span> AVFrame *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dst-&gt;format != src-&gt;format || dst-&gt;format &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"><span class="function">FF_DISABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(dst-&gt;width &gt; <span class="number">0</span> &amp;&amp; dst-&gt;height &gt; <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="title">frame_copy_video</span><span class="params">(dst, src)</span></span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dst-&gt;nb_samples &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             (<span class="built_in">av_channel_layout_check</span>(&amp;dst-&gt;ch_layout)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FF_API_OLD_CHANNEL_LAYOUT</span></span><br><span class="line">              || dst-&gt;channels &gt; <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">frame_copy_audio</span>(dst, src);</span><br><span class="line"><span class="function">FF_ENABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">AVERROR</span><span class="params">(EINVAL)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断当前 AVFrame 是否可写，只有 AVFrame 非引用计数，或者当 frame 的引用计数为 1 时，也就是只有自己拥有时才能写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_frame_is_writable</span><span class="params">(AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* assume non-refcounted frames are not writable */</span></span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;buf[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">FF_ARRAY_ELEMS</span>(frame-&gt;buf); i++)</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;buf[i])</span><br><span class="line">            ret &amp;= !!<span class="built_in">av_buffer_is_writable</span>(frame-&gt;buf[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; frame-&gt;nb_extended_buf; i++)</span><br><span class="line">        ret &amp;= !!<span class="built_in">av_buffer_is_writable</span>(frame-&gt;extended_buf[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让当前 AVFrame 可写。如果 AVFrame 是引用计数的并且计数不为 1，就拷贝一份当前 AVFrame 的内存到新的 AVFrame 中，同时 unref 老的 AVFrame，在把新的 AVFrame 赋值给老的 AVFrame 作为返回，这样使得当前 AVFrame 可写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_frame_make_writable</span><span class="params">(AVFrame *frame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVFrame tmp;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frame-&gt;buf[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">av_frame_is_writable</span>(frame))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tmp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">    tmp.format         = frame-&gt;format;</span><br><span class="line">    tmp.width          = frame-&gt;width;</span><br><span class="line">    tmp.height         = frame-&gt;height;</span><br><span class="line">...</span><br><span class="line">    tmp.nb_samples     = frame-&gt;nb_samples;</span><br><span class="line">    ret = <span class="built_in">av_channel_layout_copy</span>(&amp;tmp.ch_layout, &amp;frame-&gt;ch_layout);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;hw_frames_ctx)</span><br><span class="line">        ret = <span class="built_in">av_hwframe_get_buffer</span>(frame-&gt;hw_frames_ctx, &amp;tmp, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = <span class="built_in">av_frame_get_buffer</span>(&amp;tmp, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_frame_copy</span>(&amp;tmp, frame);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_frame_copy_props</span>(&amp;tmp, frame);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_frame_unref</span>(frame);</span><br><span class="line"></span><br><span class="line">    *frame = tmp;</span><br><span class="line">    <span class="keyword">if</span> (tmp.data == tmp.extended_data)</span><br><span class="line">        frame-&gt;extended_data = frame-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面介绍了部分 AVFrame 相关的函数及其实现，包括 alloc、get_buffer、ref、unref、free，可以看到，大部分方法还是围绕引用计数这个点来做文章，其他没有介绍到的方法大体也离不开这一点，抓住引用计数这个点就能正确理解 AVFrame。</p><p>接下来再分析一下 AVPacket，AVPacket 原理和 AVFrame 基本一样，比 AVFrame 可能还要简单一些，有了上面 AVFrame 的基础理解起来也不难。</p><p>AVPacket 存储的是等待 decode 的数据</p><blockquote><p>This structure stores compressed data. It is typically exported by demuxers and then passed as input to decoders, or received as output from encoders and then passed to muxers.<br/>For video, it should typically contain one compressed frame. For audio it may contain several compressed frames. Encoders are allowed to output empty packets, with no compressed data, containing only side data (e.g. to update some stream parameters at the end of encoding).</p></blockquote><p>AVPacket 的结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVPacket</span> &#123;</span><br><span class="line">    AVBufferRef *buf;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> pts;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> dts;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>   size;</span><br><span class="line">    <span class="type">int</span>   stream_index;</span><br><span class="line"></span><br><span class="line">    AVRational time_base;</span><br><span class="line">...</span><br><span class="line">&#125; AVPacket;</span><br></pre></td></tr></table></figure><p>AVPacket 只有一个 data 指针，而不是 data 数组，他也有 AVBufferRef 指针，也支持引用计数。</p><p>创建 AVPacket，也是通过 alloc 方法：将字段初始化为默认值，并不分配真正存储数据的内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVPacket *<span class="title">av_packet_alloc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVPacket *pkt = <span class="built_in">av_malloc</span>(<span class="built_in">sizeof</span>(AVPacket));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_packet_defaults</span>(pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pkt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_packet_defaults</span><span class="params">(AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pkt, <span class="number">0</span>, <span class="built_in">sizeof</span>(*pkt));</span><br><span class="line"></span><br><span class="line">    pkt-&gt;pts             = AV_NOPTS_VALUE;</span><br><span class="line">    pkt-&gt;dts             = AV_NOPTS_VALUE;</span><br><span class="line">    pkt-&gt;pos             = <span class="number">-1</span>;</span><br><span class="line">    pkt-&gt;time_base       = <span class="built_in">av_make_q</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ref 操作：dest 必须 fresh 的，比如新 alloc 或者 unref 之后</p><ul><li>如果 src 不是 refcouted，将 src 的 buffer 拷贝到 dest，否则拷贝引用</li><li>其他字段比如 sidedata 会从 src 拷贝内存到 dest，因为 side data 不是 ref counted 的，他在 ref 时总是拷贝，unref 时会释放</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_packet_ref</span><span class="params">(AVPacket *dst, <span class="type">const</span> AVPacket *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    dst-&gt;buf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_packet_copy_props</span>(dst, src);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!src-&gt;buf) &#123; <span class="comment">// 非引用计数</span></span><br><span class="line">        ret = <span class="built_in">packet_alloc</span>(&amp;dst-&gt;buf, src-&gt;size);</span><br><span class="line">...</span><br><span class="line">        <span class="built_in">av_assert1</span>(!src-&gt;size || src-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (src-&gt;size)</span><br><span class="line">            <span class="built_in">memcpy</span>(dst-&gt;buf-&gt;data, src-&gt;data, src-&gt;size);</span><br><span class="line"></span><br><span class="line">        dst-&gt;data = dst-&gt;buf-&gt;data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dst-&gt;buf = <span class="built_in">av_buffer_ref</span>(src-&gt;buf);</span><br><span class="line">...</span><br><span class="line">        dst-&gt;data = src-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dst-&gt;size = src-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">av_packet_unref</span>(dst);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请 AVPacket 内部 payload 的内存，pkt 必须 fresh</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_new_packet</span><span class="params">(AVPacket *pkt, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *buf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">packet_alloc</span>(&amp;buf, size);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_packet_defaults</span>(pkt);</span><br><span class="line">    pkt-&gt;buf      = buf;</span><br><span class="line">    pkt-&gt;data     = buf-&gt;data;</span><br><span class="line">    pkt-&gt;size     = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">packet_alloc</span><span class="params">(AVBufferRef **buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span> || size &gt;= INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">av_buffer_realloc</span>(buf, size + AV_INPUT_BUFFER_PADDING_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>((*buf)-&gt;data + size, <span class="number">0</span>, AV_INPUT_BUFFER_PADDING_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_buffer_realloc</span><span class="params">(AVBufferRef **pbuf, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *buf = *pbuf;</span><br><span class="line">    <span class="type">uint8_t</span> *tmp;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!buf) &#123;</span><br><span class="line">        <span class="comment">/* allocate a new buffer with av_realloc(), so it will be reallocatable</span></span><br><span class="line"><span class="comment">         * later */</span></span><br><span class="line">        <span class="type">uint8_t</span> *data = <span class="built_in">av_realloc</span>(<span class="literal">NULL</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (!data)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line"></span><br><span class="line">        buf = <span class="built_in">av_buffer_create</span>(data, size, av_buffer_default_free, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!buf) &#123;</span><br><span class="line">            <span class="built_in">av_freep</span>(&amp;data);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buf-&gt;buffer-&gt;flags_internal |= BUFFER_FLAG_REALLOCATABLE;</span><br><span class="line">        *pbuf = buf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf-&gt;size == size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(buf-&gt;buffer-&gt;flags_internal &amp; BUFFER_FLAG_REALLOCATABLE) ||</span><br><span class="line">        !<span class="built_in">av_buffer_is_writable</span>(buf) || buf-&gt;data != buf-&gt;buffer-&gt;data) &#123;</span><br><span class="line">        <span class="comment">/* cannot realloc, allocate a new reallocable buffer and copy data */</span></span><br><span class="line">        AVBufferRef *<span class="keyword">new</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">av_buffer_realloc</span>(&amp;<span class="keyword">new</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="keyword">new</span>-&gt;data, buf-&gt;data, <span class="built_in">FFMIN</span>(size, buf-&gt;size));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">buffer_replace</span>(pbuf, &amp;<span class="keyword">new</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="built_in">av_realloc</span>(buf-&gt;buffer-&gt;data, size);</span><br><span class="line">    <span class="keyword">if</span> (!tmp)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line"></span><br><span class="line">    buf-&gt;buffer-&gt;data = buf-&gt;data = tmp;</span><br><span class="line">    buf-&gt;buffer-&gt;size = buf-&gt;size = size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unref 操作：如果 AVPacket 不是 refcounted，释放 data 指向的内存，否则释放 buf 这个 AVBufferRef，同时将字段恢复成 alloc 时的默认值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_unref</span><span class="params">(AVPacket *pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_packet_free_side_data</span>(pkt);</span><br><span class="line">    <span class="built_in">av_buffer_unref</span>(&amp;pkt-&gt;opaque_ref);</span><br><span class="line">    <span class="built_in">av_buffer_unref</span>(&amp;pkt-&gt;buf);</span><br><span class="line">    <span class="built_in">get_packet_defaults</span>(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动操作：将 src 的内容移动到 dest，dest 必须是 fresh 的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_move_ref</span><span class="params">(AVPacket *dst, AVPacket *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *dst = *src;</span><br><span class="line">    <span class="built_in">get_packet_defaults</span>(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 操作：释放 AVPacket 本身，此外如果是 refcounted，还会先进行 unref 操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_packet_free</span><span class="params">(AVPacket **pkt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pkt || !*pkt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_packet_unref</span>(*pkt);</span><br><span class="line">    <span class="built_in">av_freep</span>(pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他操作就不再列举，AVPacket 原理和 AVFrame 基本一致，操作也是相通的。</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg之AVDictionary</title>
      <link href="/2023/03/10/ffmpeg%E4%B9%8BAVDictionary/"/>
      <url>/2023/03/10/ffmpeg%E4%B9%8BAVDictionary/</url>
      
        <content type="html"><![CDATA[<p>这篇博客接着之前的  ffmpeg 之 AVOption 和 AVClass  介绍一下 AVDictionary。</p><p>AVDictionary 从字面上看就是字典的意思，所以他的功能也不难猜到，就是一次性操作多个 AVOption。</p><p>先看一下 AVDictionary 的 struct 结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AVDictionary</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    AVDictionaryEntry *elems;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVDictionaryEntry</span> &#123;</span><br><span class="line">    <span class="type">char</span> *key;</span><br><span class="line">    <span class="type">char</span> *value;</span><br><span class="line">&#125; AVDictionaryEntry;</span><br></pre></td></tr></table></figure><p>AVDictionary 用于一次性 set 多个属性，有 av_opt_set_dict 这个专门的函数，他的第一个参数是 struct 实例，它必须支持 AVOption，第二个参数是指向 AVDictionary 的指针的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_opt_set_dict</span><span class="params">(<span class="type">void</span> *obj, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">av_opt_set_dict2</span>(obj, options, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_opt_set_dict 内部调用了 av_opt_set_dict2。</p><p>av_opt_set_dict2 中通过 av_dict_get 遍历每个 AVDictionaryEntry，然后也是通过 av_opt_set 设置属性到 struct 实例中，如果在 av_opt_set 时没找到相应的 key，该 AVDictionaryEntry 会被插入到一个新的 AVDictionary 中，最后把输入的 AVDictionary 的指针变为新的 AVDictionary，原来的 AVDictionary 会被释放，此时 options 指向的 AVDictionary*指向的就是包含未被设置的 AVDictionaryEntry 的 AVDictionary 了。</p><p>也就是说 av_opt_set_dict2 会把设置成功的 AVDictionaryEntry 给去掉，将未被设置的 AVDictionaryEntry 保留下来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_opt_set_dict2</span><span class="params">(<span class="type">void</span> *obj, AVDictionary **options, <span class="type">int</span> search_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVDictionaryEntry *t = <span class="literal">NULL</span>;</span><br><span class="line">    AVDictionary    *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!options)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((t = <span class="built_in">av_dict_get</span>(*options, <span class="string">&quot;&quot;</span>, t, AV_DICT_IGNORE_SUFFIX))) &#123;</span><br><span class="line">        ret = <span class="built_in">av_opt_set</span>(obj, t-&gt;key, t-&gt;value, search_flags);</span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR_OPTION_NOT_FOUND)</span><br><span class="line">            ret = <span class="built_in">av_dict_set</span>(&amp;tmp, t-&gt;key, t-&gt;value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">av_log</span>(obj, AV_LOG_ERROR, <span class="string">&quot;Error setting option %s to value %s.\n&quot;</span>, t-&gt;key, t-&gt;value);</span><br><span class="line">            <span class="built_in">av_dict_free</span>(&amp;tmp);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">av_dict_free</span>(options);</span><br><span class="line">    *options = tmp;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg之AVOption和AVClass</title>
      <link href="/2023/03/07/ffmpeg%E4%B9%8BAVOption%E5%92%8CAVClass/"/>
      <url>/2023/03/07/ffmpeg%E4%B9%8BAVOption%E5%92%8CAVClass/</url>
      
        <content type="html"><![CDATA[<p>这篇博客介绍一下 ffmpeg 中的 AVOption 和 AVClass。</p><p>和 gstreamer 一样，ffmpeg 也提供了对 struct 实例的 get、set 方法，但是 ffmpeg 没有提供一套面向对象的编程机制，所以他的 get、set 方法看起来有些怪怪的。</p><p>ffmpeg 中要让一个 struct 支持 get、set，那么这个 struct 的第一个成员必须是一个指向 AVClass 的指针，其指向的 AVClass 中必须有 AVOption 数组，该数组最后一个元素必须是 NULL，而 AVOption 中描述了属性的信息，比如属性的名字、默认值、存储的位置。</p><p>看一个官方的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">test_struct</span> &#123;</span><br><span class="line">    <span class="type">const</span> AVClass *<span class="keyword">class</span>;</span><br><span class="line">    <span class="type">int</span>      int_opt;</span><br><span class="line">    <span class="type">char</span>    *str_opt;</span><br><span class="line">    <span class="type">uint8_t</span> *bin_opt;</span><br><span class="line">    <span class="type">int</span>      bin_len;</span><br><span class="line">&#125; test_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AVOption test_options[] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;test_int&quot;</span>, <span class="string">&quot;This is a test option of int type.&quot;</span>, <span class="built_in">offsetof</span>(test_struct, int_opt),</span><br><span class="line">    AV_OPT_TYPE_INT, &#123; .i64 = <span class="number">-1</span> &#125;, INT_MIN, INT_MAX &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;test_str&quot;</span>, <span class="string">&quot;This is a test option of string type.&quot;</span>, <span class="built_in">offsetof</span>(test_struct, str_opt),</span><br><span class="line">    AV_OPT_TYPE_STRING &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;test_bin&quot;</span>, <span class="string">&quot;This is a test option of binary type.&quot;</span>, <span class="built_in">offsetof</span>(test_struct, bin_opt),</span><br><span class="line">    AV_OPT_TYPE_BINARY &#125;,</span><br><span class="line">  &#123; <span class="literal">NULL</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AVClass test_class = &#123;</span><br><span class="line">    .class_name = <span class="string">&quot;test class&quot;</span>,</span><br><span class="line">    .item_name  = av_default_item_name,</span><br><span class="line">    .option     = test_options,</span><br><span class="line">    .version    = LIBAVUTIL_VERSION_INT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">test_struct *<span class="title">alloc_test_struct</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test_struct *ret = <span class="built_in">av_mallocz</span>(<span class="built_in">sizeof</span>(*ret));</span><br><span class="line">    ret-&gt;<span class="keyword">class</span> = &amp;test_class;</span><br><span class="line">    <span class="built_in">av_opt_set_defaults</span>(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free_test_struct</span><span class="params">(test_struct **foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_opt_free</span>(*foo);</span><br><span class="line">    <span class="built_in">av_freep</span>(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中想要描述的是 test_struct，他的第一个成员是指向 test_class 的指针，而 test_class 中有 test_options 这个数组首地址，该数组的每一项都描述了一个属性，get、set 时会使用 AVOption 中的信息。</p><p>AVOption 结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVOption</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * short English help text</span></span><br><span class="line"><span class="comment">     * @todo What about other languages?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *help;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The offset relative to the context structure where the option</span></span><br><span class="line"><span class="comment">     * value is stored. It should be 0 for named constants.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AVOptionType</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * the default value for scalar options</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int64_t</span> i64;</span><br><span class="line">        <span class="type">double</span> dbl;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *str;</span><br><span class="line">        <span class="comment">/* TODO those are unused now */</span></span><br><span class="line">        AVRational q;</span><br><span class="line">    &#125; default_val;</span><br><span class="line">    <span class="type">double</span> min;                 <span class="comment">///&lt; minimum valid value for the option</span></span><br><span class="line">    <span class="type">double</span> max;                 <span class="comment">///&lt; maximum valid value for the option</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_OPT_FLAG_ENCODING_PARAM  1   <span class="comment">///&lt; a generic parameter which can be set by the user for muxing or encoding</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_OPT_FLAG_DECODING_PARAM  2   <span class="comment">///&lt; a generic parameter which can be set by the user for demuxing or decoding</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_OPT_FLAG_AUDIO_PARAM     8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_OPT_FLAG_VIDEO_PARAM     16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AV_OPT_FLAG_SUBTITLE_PARAM  32</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The logical unit to which the option belongs. Non-constant</span></span><br><span class="line"><span class="comment">     * options and corresponding named constants share the same</span></span><br><span class="line"><span class="comment">     * unit. May be NULL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *unit;</span><br><span class="line">&#125; AVOption;</span><br></pre></td></tr></table></figure><p>每一个字段上面都有注释，就不一一解释了。</p><p>看一下 offset 字段，他指的是被管理的属性存在 struct 的哪里，结合上面的例子就知道 offset 是被管理的字段在 struct 中的偏移。</p><p>default_val 字段，表示默认值，是一个 union，不同类型共用这一个 union。当 AVOption 的类型指定后 default_val 需要与之对应。</p><p>一般来说，每个 AVOption 必须有非空的 name 字段、type 字段、默认值字段，对于数字类型，最大值、最小值字段同样不能为空。offset 字段也是必须的，他指明了被设置的属性保存到 struct 的哪里。其他字段就不是必须的了，但 flag 字段通常会被设置。</p><p>AVClass 结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Describe the class of an AVClass context structure. That is an</span></span><br><span class="line"><span class="comment"> * arbitrary struct of which the first field is a pointer to an</span></span><br><span class="line"><span class="comment"> * AVClass struct (e.g. AVCodecContext, AVFormatContext etc.).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVClass</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of the class; usually it is the same name as the</span></span><br><span class="line"><span class="comment">     * context structure type to which the AVClass is associated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* class_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A pointer to a function which returns the name of a context</span></span><br><span class="line"><span class="comment">     * instance ctx associated with the class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* (*item_name)(<span class="type">void</span>* ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * a pointer to the first option specified in the class if any or NULL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @see av_set_default_options()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">AVOption</span> *option;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LIBAVUTIL_VERSION with which this structure was created.</span></span><br><span class="line"><span class="comment">     * This is used to allow fields to be added without requiring major</span></span><br><span class="line"><span class="comment">     * version bumps everywhere.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> version;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callback to return the supported/allowed ranges.</span></span><br><span class="line"><span class="comment">     * available since version (52.12)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">int</span> (*query_ranges)(<span class="keyword">struct</span> AVOptionRanges **, <span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *key, <span class="type">int</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return next AVOptions-enabled child or NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span>* (*child_next)(<span class="type">void</span> *obj, <span class="type">void</span> *prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Iterate over the AVClasses corresponding to potential AVOptions-enabled</span></span><br><span class="line"><span class="comment">     * children.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param iter pointer to opaque iteration state. The caller must initialize</span></span><br><span class="line"><span class="comment">     *             *iter to NULL before the first call.</span></span><br><span class="line"><span class="comment">     * @return AVClass for the next AVOptions-enabled child or NULL if there are</span></span><br><span class="line"><span class="comment">     *         no more such children.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @note The difference between child_next and this is that child_next</span></span><br><span class="line"><span class="comment">     *       iterates over _already existing_ objects, while child_class_iterate</span></span><br><span class="line"><span class="comment">     *       iterates over _all possible_ children.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">AVClass</span>* (*child_class_iterate)(<span class="type">void</span> **iter);</span><br><span class="line">&#125; AVClass;</span><br></pre></td></tr></table></figure><p>目前看来 AVClass 最重要的就是 option 这个数组，他里面的 AVOption 指明了如何对被管理的 struct 进行 get、set 操作，其他的字段一般用得很少，保持默认值就行，但是 child_next 和 child_class_iterate 在 get、set 中也有用处，这个后面再介绍。</p><p>接下来分析一下 av_opt_set 的代码。</p><p>av_opt_set 用于设置属性，第一个参数是 struct 的实例，第二个参数是属性名，需要和 AVOption 中的 name 对应，第三个参数是属性值，注意是一个字符串，如果是数字类型在 set 时会把字符串转换为数字类型，第四个是搜索属性，如果想搜索嵌套属性时需要设置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_opt_set</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *val, <span class="type">int</span> search_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">av_opt_set2</span>(obj, name, val, <span class="number">0</span>, search_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_opt_set 内部调用 av_opt_set2 函数，av_opt_set2 先通过 name 查找 AVOption，找到之后获得 AVOption 中的 offset 信息，然后把输入的 val 根据类型进行转换（比如字符串转 int），最后把值设置到 struct 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_opt_set2</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *val, <span class="type">int</span> opt_flags, <span class="type">int</span> search_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span> *dst, *target_obj;</span><br><span class="line">    <span class="type">const</span> AVOption *o = <span class="built_in">av_opt_find2</span>(obj, name, <span class="literal">NULL</span>, opt_flags, search_flags, &amp;target_obj);</span><br><span class="line">    <span class="keyword">if</span> (!o || !target_obj)</span><br><span class="line">        <span class="keyword">return</span> AVERROR_OPTION_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!val &amp;&amp; (o-&gt;type != AV_OPT_TYPE_STRING &amp;&amp;</span><br><span class="line">                 o-&gt;type != AV_OPT_TYPE_PIXEL_FMT &amp;&amp; o-&gt;type != AV_OPT_TYPE_SAMPLE_FMT &amp;&amp;</span><br><span class="line">                 o-&gt;type != AV_OPT_TYPE_IMAGE_SIZE &amp;&amp;</span><br><span class="line">                 o-&gt;type != AV_OPT_TYPE_DURATION &amp;&amp; o-&gt;type != AV_OPT_TYPE_COLOR &amp;&amp;</span><br><span class="line">                 o-&gt;type != AV_OPT_TYPE_BOOL))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;flags &amp; AV_OPT_FLAG_READONLY)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;flags &amp; AV_OPT_FLAG_DEPRECATED)</span><br><span class="line">        <span class="built_in">av_log</span>(obj, AV_LOG_WARNING, <span class="string">&quot;The \&quot;%s\&quot; option is deprecated: %s\n&quot;</span>, name, o-&gt;help);</span><br><span class="line"></span><br><span class="line">    dst = ((<span class="type">uint8_t</span> *)target_obj) + o-&gt;offset;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_BOOL:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set_string_bool</span>(obj, o, val, dst);</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_STRING:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set_string</span>(obj, o, val, dst);</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_BINARY:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set_string_binary</span>(obj, o, val, dst);</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_FLAGS:</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_INT:</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_INT64:</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_UINT64:</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_FLOAT:</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_DOUBLE:</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_RATIONAL:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set_string_number</span>(obj, target_obj, o, val, dst);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">av_log</span>(obj, AV_LOG_ERROR, <span class="string">&quot;Invalid option type.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一下查找 AVOption，是通过 av_opt_find2 函数进行查找，av_opt_find2 会根据 search_flags 选择是否查找嵌套的 AVOption，这个留到后面再说，先看只在当前 struct 中进行查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVOption *<span class="title">av_opt_find2</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">int</span> opt_flags, <span class="type">int</span> search_flags, <span class="type">void</span> **target_obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVClass  *c;</span><br><span class="line">    <span class="type">const</span> AVOption *o = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    c= *(AVClass**)obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (search_flags &amp; AV_OPT_SEARCH_CHILDREN) &#123;</span><br><span class="line">        <span class="comment">// 嵌套查找，先不管</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (o = <span class="built_in">av_opt_next</span>(obj, o)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(o-&gt;name, name) &amp;&amp; (o-&gt;flags &amp; opt_flags) == opt_flags &amp;&amp;</span><br><span class="line">            ((!unit &amp;&amp; o-&gt;type != AV_OPT_TYPE_CONST) ||</span><br><span class="line">             (unit  &amp;&amp; o-&gt;type == AV_OPT_TYPE_CONST &amp;&amp; o-&gt;unit &amp;&amp; !<span class="built_in">strcmp</span>(o-&gt;unit, unit)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target_obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(search_flags &amp; AV_OPT_SEARCH_FAKE_OBJ))</span><br><span class="line">                    *target_obj = obj;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    *target_obj = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_opt_find2 通过 av_opt_next 逐个的遍历当前 struct 的 AVClass 中的 AVOption 数组，把每一项的 name 和输入的 name 进行比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVOption *<span class="title">av_opt_next</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *obj, <span class="type">const</span> AVOption *last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVClass *<span class="keyword">class</span>;</span><br><span class="line">    <span class="keyword">if</span> (!obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">class</span> = *(<span class="type">const</span> AVClass**)obj;</span><br><span class="line">    <span class="keyword">if</span> (!last &amp;&amp; <span class="keyword">class</span> &amp;&amp; <span class="keyword">class</span>-&gt;option &amp;&amp; <span class="keyword">class</span>-&gt;option[<span class="number">0</span>].name)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">class</span>-&gt;option;</span><br><span class="line">    <span class="keyword">if</span> (last &amp;&amp; last[<span class="number">1</span>].name)</span><br><span class="line">        <span class="keyword">return</span> ++last;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到 AVOption 后把偏移 offset 信息取出来，然后进行属性设置操作。</p><p>看一个 string 类型的设置操作，可以看到，会把输入的字符串复制一份出来，所以这部分内存后面还需要释放。当调用 av_opt_free 时，这部分动态分配的内存会被释放，如果 struct 有 string 类型的属性，析构时需要调用 av_opt_free 函数。（注意 binary 类型也会进行动态内存分配）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">set_string</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> AVOption *o, <span class="type">const</span> <span class="type">char</span> *val, <span class="type">uint8_t</span> **dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_freep</span>(dst);</span><br><span class="line">    *dst = <span class="built_in">av_strdup</span>(val);</span><br><span class="line">    <span class="keyword">return</span> *dst ? <span class="number">0</span> : <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个 bool 类型的设置操作，他会对输入的字符串进行分析，如果是 true,y,yes 之类的会将字段设置为 true，反之如果是 false,n,no 之类的则会设为 false</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">set_string_bool</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> AVOption *o, <span class="type">const</span> <span class="type">char</span> *val, <span class="type">int</span> *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!val)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(val, <span class="string">&quot;auto&quot;</span>)) &#123;</span><br><span class="line">        n = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">av_match_name</span>(val, <span class="string">&quot;true,y,yes,enable,enabled,on&quot;</span>)) &#123;</span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">av_match_name</span>(val, <span class="string">&quot;false,n,no,disable,disabled,off&quot;</span>)) &#123;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> *end = <span class="literal">NULL</span>;</span><br><span class="line">        n = <span class="built_in">strtol</span>(val, &amp;end, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (val + <span class="built_in">strlen</span>(val) != end)</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; o-&gt;min || n &gt; o-&gt;max)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    *dst = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">av_log</span>(obj, AV_LOG_ERROR, <span class="string">&quot;Unable to parse option value \&quot;%s\&quot; as boolean\n&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数字类型的设置函数就不看了，基本原理就是把用字符串表示的数字转成 AVOption 中的类型，然后进行设置，同时数字类型还会检查输入值是否在最大最小值范围内。</p><p>再看一下 av_opt_set_defaults。这个函数就是把 struct 中的字段赋值为 AVOption 中的默认值，基本过程和 av_opt_set 一致。从下面可以看到，调用 av_opt_next 遍历每一个 AVOption，取偏移信息，然后把默认值设到字段中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_opt_set_defaults</span><span class="params">(<span class="type">void</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">av_opt_set_defaults2</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">av_opt_set_defaults2</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> mask, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVOption *opt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = <span class="built_in">av_opt_next</span>(s, opt))) &#123;</span><br><span class="line">        <span class="type">void</span> *dst = ((<span class="type">uint8_t</span>*)s) + opt-&gt;offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((opt-&gt;flags &amp; mask) != flags)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opt-&gt;flags &amp; AV_OPT_FLAG_READONLY)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (opt-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_CONST:</span><br><span class="line">                <span class="comment">/* Nothing to be done here */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_BOOL:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_FLAGS:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_INT:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_INT64:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_UINT64:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_DURATION:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_PIXEL_FMT:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_SAMPLE_FMT:</span><br><span class="line">                <span class="built_in">write_number</span>(s, opt, dst, <span class="number">1</span>, <span class="number">1</span>, opt-&gt;default_val.i64);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_DOUBLE:</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_FLOAT: &#123;</span><br><span class="line">                <span class="type">double</span> val;</span><br><span class="line">                val = opt-&gt;default_val.dbl;</span><br><span class="line">                <span class="built_in">write_number</span>(s, opt, dst, val, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> AV_OPT_TYPE_STRING:</span><br><span class="line">                <span class="comment">// 发生字符串拷贝</span></span><br><span class="line">                <span class="built_in">set_string</span>(s, opt, opt-&gt;default_val.str, dst);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">av_log</span>(s, AV_LOG_DEBUG, <span class="string">&quot;AVOption type %d of option %s not implemented yet\n&quot;</span>,</span><br><span class="line">                   opt-&gt;type, opt-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了上面的 set 过程，av_opt_get 就很简单了。</p><p>同样先用 av_opt_find2 查找 AVOption，找到之后取偏移信息，通过偏移信息就可以从 struct 中访问到字段，由于输出是 char 字符串，所以对某些类型，比如 bool、数字类型需要转成字符串，这里同样涉及到动态分配的内存，out_val 指向的指针需要自己在外面手动释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">av_opt_get</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> search_flags, <span class="type">uint8_t</span> **out_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> *dst, *target_obj;</span><br><span class="line">    <span class="type">const</span> AVOption *o = <span class="built_in">av_opt_find2</span>(obj, name, <span class="literal">NULL</span>, <span class="number">0</span>, search_flags, &amp;target_obj);</span><br><span class="line">    <span class="type">uint8_t</span> *bin, buf[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> len, i, ret;</span><br><span class="line">    <span class="type">int64_t</span> i64;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!o || !target_obj || (o-&gt;offset&lt;=<span class="number">0</span> &amp;&amp; o-&gt;type != AV_OPT_TYPE_CONST))</span><br><span class="line">        <span class="keyword">return</span> AVERROR_OPTION_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;flags &amp; AV_OPT_FLAG_DEPRECATED)</span><br><span class="line">        <span class="built_in">av_log</span>(obj, AV_LOG_WARNING, <span class="string">&quot;The \&quot;%s\&quot; option is deprecated: %s\n&quot;</span>, name, o-&gt;help);</span><br><span class="line"></span><br><span class="line">    dst = (<span class="type">uint8_t</span> *)target_obj + o-&gt;offset;</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;type) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_INT:</span><br><span class="line">        ret = <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%d&quot;</span>, *(<span class="type">int</span> *)dst);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_INT64:</span><br><span class="line">        ret = <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%&quot;</span>PRId64, *(<span class="type">int64_t</span> *)dst);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_UINT64:</span><br><span class="line">        ret = <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%&quot;</span>PRIu64, *(<span class="type">uint64_t</span> *)dst);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_FLOAT:</span><br><span class="line">        ret = <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%f&quot;</span>, *(<span class="type">float</span> *)dst);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_DOUBLE:</span><br><span class="line">        ret = <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%f&quot;</span>, *(<span class="type">double</span> *)dst);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_STRING:</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">uint8_t</span> **)dst) &#123;</span><br><span class="line">            *out_val = <span class="built_in">av_strdup</span>(*(<span class="type">uint8_t</span> **)dst); <span class="comment">// 外面需要自己释放</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (search_flags &amp; AV_OPT_ALLOW_NULL) &#123;</span><br><span class="line">            *out_val = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *out_val = <span class="built_in">av_strdup</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *out_val ? <span class="number">0</span> : <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">    <span class="keyword">case</span> AV_OPT_TYPE_BINARY:</span><br><span class="line">        <span class="keyword">if</span> (!*(<span class="type">uint8_t</span> **)dst &amp;&amp; (search_flags &amp; AV_OPT_ALLOW_NULL)) &#123;</span><br><span class="line">            *out_val = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = *(<span class="type">int</span> *)(((<span class="type">uint8_t</span> *)dst) + <span class="built_in">sizeof</span>(<span class="type">uint8_t</span> *));</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">uint64_t</span>)len * <span class="number">2</span> + <span class="number">1</span> &gt; INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">        <span class="keyword">if</span> (!(*out_val = <span class="built_in">av_malloc</span>(len * <span class="number">2</span> + <span class="number">1</span>))) <span class="comment">// 外面需要自己释放</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">        <span class="keyword">if</span> (!len) &#123;</span><br><span class="line">            *out_val[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bin = *(<span class="type">uint8_t</span> **)dst;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            <span class="built_in">snprintf</span>(*out_val + i * <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;%02X&quot;</span>, bin[i]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">   &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="built_in">sizeof</span>(buf))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">AVERROR</span>(EINVAL);</span><br><span class="line">    *out_val = <span class="built_in">av_strdup</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> *out_val ? <span class="number">0</span> : <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 binary 要注意，从上面 AV_OPT_TYPE_BINARY 分支可以看到，binary 在 struct 中占据两部分，一个是 binary 的地址，一个是 binary 的长度。</p><p>最后再介绍一下嵌套 AVOption。</p><p>gobject 中支持属性的继承，也就是子类可以使用父类的属性，也可以覆盖父类的属性，这种需求是很常见的。而 ffmpeg 没有实现面向对象的机制，但是他也想支持类似的属性继承功能，于是就提供了嵌套 AVOption 特性。</p><p>嵌套 AVOption 是指当前 struct 支持 AVOption，同时他还有一个成员也支持 AVOption，现在希望 get、set 时能从当前 struct 以及他的成员中进行操作。看一个官方的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">child_struct</span> &#123;</span><br><span class="line">    AVClass *<span class="keyword">class</span>;</span><br><span class="line">    <span class="type">int</span> flags_opt;</span><br><span class="line">&#125; child_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AVOption child_opts[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;test_flags&quot;</span>, <span class="string">&quot;This is a test option of flags type.&quot;</span>,</span><br><span class="line">    <span class="built_in">offsetof</span>(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, &#123; .i64 = <span class="number">0</span> &#125;, INT_MIN, INT_MAX &#125;,</span><br><span class="line">    &#123; <span class="literal">NULL</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AVClass child_class = &#123;</span><br><span class="line">    .class_name = <span class="string">&quot;child class&quot;</span>,</span><br><span class="line">    .item_name  = av_default_item_name,</span><br><span class="line">    .option     = child_opts,</span><br><span class="line">    .version    = LIBAVUTIL_VERSION_INT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">test_struct</span> &#123;</span><br><span class="line">    <span class="type">const</span> AVClass *<span class="keyword">class</span>;</span><br><span class="line">    <span class="type">int</span>      int_opt;</span><br><span class="line">    <span class="type">char</span>    *str_opt;</span><br><span class="line">    <span class="type">uint8_t</span> *bin_opt;</span><br><span class="line">    <span class="type">int</span>      bin_len;</span><br><span class="line">    child_struct *child_struct;</span><br><span class="line">&#125; test_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AVOption test_options[] = &#123;</span><br><span class="line">  &#123; <span class="string">&quot;test_int&quot;</span>, <span class="string">&quot;This is a test option of int type.&quot;</span>, <span class="built_in">offsetof</span>(test_struct, int_opt),</span><br><span class="line">    AV_OPT_TYPE_INT, &#123; .i64 = <span class="number">-1</span> &#125;, INT_MIN, INT_MAX &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;test_str&quot;</span>, <span class="string">&quot;This is a test option of string type.&quot;</span>, <span class="built_in">offsetof</span>(test_struct, str_opt),</span><br><span class="line">    AV_OPT_TYPE_STRING &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;test_bin&quot;</span>, <span class="string">&quot;This is a test option of binary type.&quot;</span>, <span class="built_in">offsetof</span>(test_struct, bin_opt),</span><br><span class="line">    AV_OPT_TYPE_BINARY &#125;,</span><br><span class="line">  &#123; <span class="literal">NULL</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">child_next</span><span class="params">(<span class="type">void</span> *obj, <span class="type">void</span> *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test_struct *t = obj;</span><br><span class="line">    <span class="keyword">if</span> (!prev &amp;&amp; t-&gt;child_struct)</span><br><span class="line">        <span class="keyword">return</span> t-&gt;child_struct;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> AVClass* <span class="title">child_class_iterate</span><span class="params">(<span class="type">void</span> **iter)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 只返回一次child_class</span></span><br><span class="line">    <span class="type">const</span> AVClass *c = *iter ? <span class="literal">NULL</span> : &amp;child_class;</span><br><span class="line">    *iter = (<span class="type">void</span>*)(<span class="type">uintptr_t</span>)c;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> AVClass test_class = &#123;</span><br><span class="line">    .class_name = <span class="string">&quot;test class&quot;</span>,</span><br><span class="line">    .item_name  = av_default_item_name,</span><br><span class="line">    .option     = test_options,</span><br><span class="line">    .version    = LIBAVUTIL_VERSION_INT,</span><br><span class="line">    .child_next = child_next,</span><br><span class="line">    .child_class_iterate = child_class_iterate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的例子中，有 test_struct 和 child_struct 两个结构，他们都支持 AVOption。test_struct 有一个指针指向 child_struct，可以把 child_struct 视为 test_struct 的子结构。</p><p>要让 test_struct 支持嵌套 AVOption（也就是 set、get test_struct 时可以设置到 child_struct），只需要在 test_struct 的 AVClass 中实现 child_next、child_class_iterate 两个函数。child_next 是对真实存在的子 struct 进行遍历，child_class_iterate 是对所有可能存在的子 struct 进行遍历。这样说可能不太好理解，看一下 AVCodecContext 中的 child_next 和 child_class_iterate 函数：</p><p>先通过 avcodec_alloc_context3 来创建 AVCodecContext 实例，AVCodecContext 实例中的 AVClass 是 av_codec_context_class 这个 struct。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVCodecContext *<span class="title">avcodec_alloc_context3</span><span class="params">(<span class="type">const</span> AVCodec *codec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecContext *avctx= <span class="built_in">av_malloc</span>(<span class="built_in">sizeof</span>(AVCodecContext));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!avctx)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">init_context_defaults</span>(avctx, codec) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">av_free</span>(avctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> avctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">init_context_defaults</span><span class="params">(AVCodecContext *s, <span class="type">const</span> AVCodec *codec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FFCodec *<span class="type">const</span> codec2 = <span class="built_in">ffcodec</span>(codec);</span><br><span class="line">    <span class="type">int</span> flags=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in">sizeof</span>(AVCodecContext));</span><br><span class="line"></span><br><span class="line">    s-&gt;av_class = &amp;av_codec_context_class;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>av_codec_context_class 的 child_next、child_class_iterate 分别是 codec_child_next、codec_child_class_iterate。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> AVClass av_codec_context_class = &#123;</span><br><span class="line">    .class_name              = <span class="string">&quot;AVCodecContext&quot;</span>,</span><br><span class="line">    .item_name               = context_to_name,</span><br><span class="line">    .option                  = avcodec_options,</span><br><span class="line">    .version                 = LIBAVUTIL_VERSION_INT,</span><br><span class="line">    .log_level_offset_offset = <span class="built_in">offsetof</span>(AVCodecContext, log_level_offset),</span><br><span class="line">    .child_next              = codec_child_next,</span><br><span class="line">    .child_class_iterate     = codec_child_class_iterate,</span><br><span class="line">    .category                = AV_CLASS_CATEGORY_ENCODER,</span><br><span class="line">    .get_category            = get_category,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到 codec_child_next 就是返回 AVCodecContext 中的 priv_data 指针，而 priv_data 指向的是每个 codec 自定义的一个也支持 get、set 操作的 struct 的实例，该实例在创建 AVCodecContext 通常也会被创建，他是当前 AVCodecContext 中必然真实存在的一个实例。</p><p>而 codec_child_class_iterate 是通过 av_codec_iterate 对每个 AVCodec 实例进行遍历，返回每个 AVCodec 实例中的 priv_class（也是一个 AVClass），codec_child_class_iterate 返回的 AVClass 肯定不能进行 get、set 操作，因为该 AVClass 对应的 struct 都不知道有没有创建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">codec_child_next</span><span class="params">(<span class="type">void</span> *obj, <span class="type">void</span> *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVCodecContext *s = obj;</span><br><span class="line">    <span class="keyword">if</span> (!prev &amp;&amp; s-&gt;codec &amp;&amp; s-&gt;codec-&gt;priv_class &amp;&amp; s-&gt;priv_data)</span><br><span class="line">        <span class="keyword">return</span> s-&gt;priv_data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> AVClass *<span class="title">codec_child_class_iterate</span><span class="params">(<span class="type">void</span> **iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVCodec *c;</span><br><span class="line">    <span class="comment">/* find next codec with priv options */</span></span><br><span class="line">    <span class="keyword">while</span> (c = <span class="built_in">av_codec_iterate</span>(iter))</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;priv_class)</span><br><span class="line">            <span class="keyword">return</span> c-&gt;priv_class;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到之前 av_opt_find2 中略过的 search_flags 相关部分。</p><p>av_opt_find2 在查找 AVOption 时，会根据 search_flags 决定调用 child_next 还是 child_class_iterate 来遍历子 struct，如果 AV_OPT_SEARCH_CHILDREN 为 true 而 AV_OPT_SEARCH_FAKE_OBJ 为 false 则会使用 child_next。</p><p>可以看到下面的搜索过程其实是一个深度优先搜索，所以子 struct 可以覆盖父 struct 的属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> AVOption *<span class="title">av_opt_find2</span><span class="params">(<span class="type">void</span> *obj, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">int</span> opt_flags, <span class="type">int</span> search_flags, <span class="type">void</span> **target_obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVClass  *c;</span><br><span class="line">    <span class="type">const</span> AVOption *o = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    c= *(AVClass**)obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (search_flags &amp; AV_OPT_SEARCH_CHILDREN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (search_flags &amp; AV_OPT_SEARCH_FAKE_OBJ) &#123;</span><br><span class="line">            <span class="type">void</span> *iter = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="type">const</span> AVClass *child;</span><br><span class="line">            <span class="keyword">while</span> (child = <span class="built_in">av_opt_child_class_iterate</span>(c, &amp;iter))</span><br><span class="line">                <span class="keyword">if</span> (o = <span class="built_in">av_opt_find2</span>(&amp;child, name, unit, opt_flags, search_flags, <span class="literal">NULL</span>))</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">void</span> *child = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">while</span> (child = <span class="built_in">av_opt_child_next</span>(obj, child))</span><br><span class="line">                <span class="keyword">if</span> (o = <span class="built_in">av_opt_find2</span>(child, name, unit, opt_flags, search_flags, target_obj))</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (o = <span class="built_in">av_opt_next</span>(obj, o)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(o-&gt;name, name) &amp;&amp; (o-&gt;flags &amp; opt_flags) == opt_flags &amp;&amp;</span><br><span class="line">            ((!unit &amp;&amp; o-&gt;type != AV_OPT_TYPE_CONST) ||</span><br><span class="line">             (unit  &amp;&amp; o-&gt;type == AV_OPT_TYPE_CONST &amp;&amp; o-&gt;unit &amp;&amp; !<span class="built_in">strcmp</span>(o-&gt;unit, unit)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target_obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(search_flags &amp; AV_OPT_SEARCH_FAKE_OBJ))</span><br><span class="line">                    *target_obj = obj;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    *target_obj = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">av_opt_child_next</span><span class="params">(<span class="type">void</span> *obj, <span class="type">void</span> *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> AVClass *c = *(AVClass **)obj;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;child_next)</span><br><span class="line">        <span class="keyword">return</span> c-&gt;<span class="built_in">child_next</span>(obj, prev);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> AVClass *<span class="title">av_opt_child_class_iterate</span><span class="params">(<span class="type">const</span> AVClass *parent, <span class="type">void</span> **iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;child_class_iterate)</span><br><span class="line">        <span class="keyword">return</span> parent-&gt;<span class="built_in">child_class_iterate</span>(iter);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44268323">https://blog.csdn.net/leixiaohua1020/article/details/44268323</a></p><p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44279329">https://blog.csdn.net/leixiaohua1020/article/details/44279329</a></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>declval是什么</title>
      <link href="/2023/03/04/declval%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2023/03/04/declval%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>C++ 中，我想 decltype 大家应该都知道，那么 declval 又是什么呢？</p><p>declval 定义在<utility>中，他可能的实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> always_false = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::add_rvalue_reference&lt;T&gt;::<span class="function">type <span class="title">declval</span><span class="params">()</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(always_false&lt;T&gt;, <span class="string">&quot;declval not allowed in an evaluated context&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，declval 就是为输入类型增加了右值引用，然后返回。</p><p>declval 是一个模板函数，通常要配合 decltype 使用，在 decltype 中，用 declval 去“定义”某个类型的变量，然后用这个变量来组成表达式，这里定义打引号是因为 declval 定义的变量不能访问他的值，只能进行类型计算，举个例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">hello</span><span class="params">(<span class="type">const</span> B&amp;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ff</span><span class="params">(B&amp; b)</span> -&gt; <span class="title">decltype</span><span class="params">(declval&lt;A&gt;().hello(declval&lt;B&gt;()))</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子只做演示，实际不可能写这种代码。上面的例子跳过了 A 和 B 的构造函数，直接定义他们的变量，并且访问他们的成员函数。</p><p>个人觉得 declval 最让人困惑的一点是：为什么 declval 返回一个右值引用类型就可以访问到该类型的成员函数和成员变量？</p><p>我的理解是 declval 的关键在于<strong>借助函数返回值返回一个虚拟的变量</strong>：C++ 的函数总被视为返回一个变量，但是在 decltype 类型计算中并不关心返回的变量是否真正存在，只是在编译的时候计算、推导类型。值的一提，C++ 很多其他特性其实都借助了函数返回值这一点，比如 move、forward。</p><p>看一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">hello</span><span class="params">(<span class="type">const</span> B&amp;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> AA = A&amp;&amp;;</span><br><span class="line"><span class="keyword">using</span> BB = B&amp;&amp;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ff</span><span class="params">(B&amp; b)</span> -&gt; <span class="title">decltype</span><span class="params">(AA.hello(BB))</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子编译不过，虽然他看上去和上面的例子做的工作一样，但是违反了 C++ 的语义，我们不能从类型去访问成员函数，所以需要借助函数返回值来迂回实现。</p><p>为什么返回右值引用，左值引用可以吗？</p><p>个人觉得是可以的，只要把引用想象成对一个虚拟变量的引用，不管左值还是右值引用，都可以访问成员变量和成员函数。但 declval 设计成返回右值引用应该有其他方面的考虑。</p><p>参考资料：</p><p><a href="https://en.cppreference.com/w/cpp/utility/declval">https://en.cppreference.com/w/cpp/utility/declval</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++新特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>decltype(auto)用法</title>
      <link href="/2023/03/04/decltype-auto-%E7%94%A8%E6%B3%95/"/>
      <url>/2023/03/04/decltype-auto-%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中，经常使用 decltype 和 auto 进行类型推导，auto 用于表达式左边，根据赋值语句（广义包括函数返回、普通赋值）右边进行类型推断，decltype 则是对表达式、变量进行推断得到类型。那么 decltype(auto)又是什么呢？</p><p>decltype(auto)一般用于函数的返回值，先看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; </span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">( T&amp; t )</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">value</span>() ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; </span><br><span class="line"><span class="function"><span class="keyword">auto</span>&amp; <span class="title">bar</span><span class="params">( T&amp; t )</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">value</span>() ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道 auto 不会主动推断为引用类型，哪怕赋值语句右边是引用类型，他也会推断为引用的值类型，除非我们主动在 auto 后面加引用。上面的第一个例子返回值永远是值类型，第二个则返回引用类型。</p><p>decltype(auto)会根据函数的 return 表达式的类型来推断自己的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; </span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">bar</span><span class="params">( T&amp; t )</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">value</span>() ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数可以等价于下面的尾置返回推断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; </span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bar</span><span class="params">( T&amp; t )</span> -&gt; <span class="title">decltype</span><span class="params">(t.value())</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">value</span>() ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 decltype(auto)把返回值表达式进行 decltype 推断得到自己的类型，比如下面例子，ff 返回值永远是右值引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">ff</span><span class="params">(F&amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和尾置返回相比，decltype(auto)更灵活，他能推断的表达式可以和输入参数无关，尾置返回通常从和输入参数相关的表达式进行推断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">B b;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">ff</span><span class="params">(F&amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，ff 函数返回一个全局变量的右值，完全和输入参数无关。尾置返回通常不能这么灵活，他通常根据输入参数进行类型推断。但是对于上面的例子，我们使用尾置返回 +declval 也可以实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">B b;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ff</span><span class="params">(F&amp;s)</span> -&gt; <span class="title">decltype</span><span class="params">(std::move(declval&lt;B&gt;()))</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，decltype(auto)就相当于对 return 表达式进行了 decltype 推断。最后看一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">ff</span><span class="params">(F&amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; k = <span class="built_in">ff</span>(j);</span><br><span class="line">    <span class="type">int</span>&amp; m = <span class="built_in">ff</span>(j); <span class="comment">// error: cannot bind non-const lvalue reference of type ‘int&amp;’ to</span></span><br><span class="line">                    <span class="comment">// an rvalue of type ‘std::remove_reference&lt;int&amp;&gt;::type’ &#123;aka ‘int’&#125;</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://cplusplus.com/forum/general/188645/">https://cplusplus.com/forum/general/188645/</a></p><p><a href="https://en.cppreference.com/w/cpp/language/function">https://en.cppreference.com/w/cpp/language/function</a> Return type deduction 一节</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++新特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++标准库之shared_ptr和weak_ptr</title>
      <link href="/2023/03/01/C-%E6%A0%87%E5%87%86%E5%BA%93%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E4%B9%8Bshared-ptr%E5%92%8Cweak-ptr/"/>
      <url>/2023/03/01/C-%E6%A0%87%E5%87%86%E5%BA%93%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E4%B9%8Bshared-ptr%E5%92%8Cweak-ptr/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍一下 shared_ptr 和 weak_ptr。<br><img src="/images/C-%E6%A0%87%E5%87%86%E5%BA%93%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E4%B9%8Bshared-ptr%E5%92%8Cweak-ptr/shared_ptr.jpg" alt="shared_ptr和weak_ptr"></p><h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p>shared_ptr 通过引用计数来管理指向的内存，当引用计数为 0 时，释放指向的内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> shared_ptr</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    element_type*      __ptr_;</span><br><span class="line">    __shared_weak_count* __cntrl_;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>shared_ptr 内部只有两个指针，<code>__ptr_</code> 就是我们管理的指针，<code>__cntrl_</code> 和引用计数有关。</p><h2 id="接受裸指针的构造函数"><a href="#接受裸指针的构造函数" class="headerlink" title="接受裸指针的构造函数"></a>接受裸指针的构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(_Yp* __p,</span><br><span class="line">                            <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)</span><br><span class="line">    : __ptr_(__p)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;_Yp&gt; __hold(__p);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;</span><br><span class="line">    <span class="keyword">typedef</span> __shared_ptr_pointer&lt;_Yp*, default_delete&lt;_Yp&gt;, _AllocT &gt; _CntrlBlk;</span><br><span class="line">    __cntrl_ = <span class="keyword">new</span> _CntrlBlk(__p, <span class="built_in">default_delete</span>&lt;_Yp&gt;(), _AllocT());</span><br><span class="line">    __hold.<span class="built_in">release</span>();</span><br><span class="line">    __enable_weak_this(__p, __p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数生效的前提是 <code>is_convertible&lt;_Yp*, element_type*&gt;</code> 这个条件要满足，也就是说，<code>_Yp*</code> 不一定要是 <code>element_type*</code> 类型，可以是他的子类</p><p><code>__shared_ptr_default_allocator</code> 定义如下，对于非函数，上面的 <code>_AllocT</code> 就是 <code>allocator&lt;_Yp&gt;</code>，allocator 类还没有仔细看过，不做深入讨论</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>, <span class="type">bool</span> = is_function&lt;_Yp&gt;::value&gt;</span><br><span class="line">    <span class="keyword">struct</span> __shared_ptr_default_allocator</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> allocator&lt;_Yp&gt; type;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__shared_ptr_default_allocator</span>&lt;_Yp, <span class="literal">true</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> allocator&lt;__shared_ptr_dummy_rebind_allocator_type&gt; type;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="shared-ptr-pointer"><a href="#shared-ptr-pointer" class="headerlink" title="__shared_ptr_pointer"></a>__shared_ptr_pointer</h3><p><code>__cntrl_</code> 的类型是 <code>__shared_weak_count*</code>，而 <code>__shared_ptr_pointer</code> 是 <code>__shared_weak_count</code> 的子类，<code>__shared_weak_count</code> 又是 <code>__shared_count</code> 的子类，接下来我们从上往下逐个看这些类。</p><h4 id="shared-count"><a href="#shared-count" class="headerlink" title="__shared_count"></a>__shared_count</h4><p><code>__shared_count</code> 如下，他有一个 <code>__shared_owners_</code> 成员，代表共享引用计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TYPE_VIS</span> __shared_count</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">long</span> __shared_owners_;</span><br><span class="line">    <span class="keyword">virtual</span> ~__shared_count() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared() _NOEXCEPT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> __shared_count(<span class="type">long</span> __refs = <span class="number">0</span>) _NOEXCEPT</span><br><span class="line">        : __shared_owners_(__refs) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __add_shared() _NOEXCEPT &#123;</span><br><span class="line">      __libcpp_atomic_refcount_increment(__shared_owners_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> __release_shared() _NOEXCEPT &#123;</span><br><span class="line">      <span class="keyword">if</span> (__libcpp_atomic_refcount_decrement(__shared_owners_) == <span class="number">-1</span>) &#123;</span><br><span class="line">        __on_zero_shared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __libcpp_relaxed_load(&amp;__shared_owners_) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>增加和减少引用计数都是在这个类里。引用计数最开始创建时为 0，也就是说引用计数是从 0 开始的，真正的引用计数需要在 <code>__shared_owners_</code> 基础上加 1。</p><p>通过 <code>__release_shared()</code> 释放引用计数，如果当前已经没有引用计数了，就会调用 <code>__on_zero_shared()</code>（这个函数的作用是释放真正被管理的内存），并返回 true 或者 false 给调用者。</p><p><code>__on_zero_shared()</code> 是虚函数，留给子类实现。</p><h4 id="shared-weak-count"><a href="#shared-weak-count" class="headerlink" title="__shared_weak_count"></a>__shared_weak_count</h4><p><code>__shared_weak_count</code> 继承 <code>__shared_count</code>，有一个 <code>__shared_weak_owners_</code> 成员，就是弱引用计数。</p><p><code>__add_shared()</code> 会调用父类 <code>__shared_count</code> 的 <code>__add_shared()</code></p><p><code>__add_weak()</code> 就是增加 <code>__shared_weak_owners_</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TYPE_VIS</span> __shared_weak_count</span><br><span class="line">    : <span class="keyword">private</span> __shared_count</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> __shared_weak_owners_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> __shared_weak_count(<span class="type">long</span> __refs = <span class="number">0</span>) _NOEXCEPT</span><br><span class="line">        : __shared_count(__refs), <span class="comment">// 父类</span></span><br><span class="line">          __shared_weak_owners_(__refs) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~__shared_weak_count() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __add_shared() _NOEXCEPT &#123;</span><br><span class="line">      __shared_count::__add_shared();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __add_weak() _NOEXCEPT &#123;</span><br><span class="line">      __libcpp_atomic_refcount_increment(__shared_weak_owners_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __release_shared() _NOEXCEPT &#123; <span class="comment">// 调用父类的__release_shared函数</span></span><br><span class="line">      <span class="keyword">if</span> (&lt;u&gt;__shared_count::__release_shared()&lt;/u&gt;)</span><br><span class="line">        __release_weak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __release_weak() _NOEXCEPT &#123;</span><br><span class="line">        <span class="keyword">if</span> (__libcpp_atomic_load(&amp;__shared_weak_owners_, _AO_Acquire) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            __on_zero_shared_weak();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__libcpp_atomic_refcount_decrement(__shared_weak_owners_) == <span class="number">-1</span>)</span><br><span class="line">            __on_zero_shared_weak();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __shared_count::<span class="built_in">use_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__shared_weak_count::lock</span></span><br><span class="line"><span class="function">    __shared_weak_count* <span class="title">lock</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        <span class="type">long</span> object_owners = __libcpp_atomic_load(&amp;__shared_owners_);</span><br><span class="line">        <span class="keyword">while</span> (object_owners != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (__libcpp_atomic_compare_exchange(&amp;__shared_owners_,</span><br><span class="line">                                                 &amp;object_owners,</span><br><span class="line">                                                 object_owners+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared_weak() _NOEXCEPT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__release_shared()</code> 先调用父类的 <code>__shared_count::__release_shared()</code>，如果返回 true，表示当前是最后一个 shared 计数，则调用 <code>__release_weak()</code> 来减小弱引用计数。这背后的逻辑是：所有的 shared 引用整体要对应一个 weak 引用，因为最开始创建 shared_ptr 时，shared 引用和 weak 引用都被初始化为 0（需要 +1，结果就是 1）。这个逻辑很关键，理解了这一点就理解了 shared_ptr。</p><p>在 <code>__release_weak()</code> 中，先尝试用 Acquire 的内存序去读取 <code>__shared_weak_owners_</code>，如果返回 0（引用计数初始值为 0，要加 1），表示当前一定没有其他的 weak_reference（只有自己这一个 weak_reference），因为如果有了其他的 weak_reference，一定会增加引用计数；如果第一步读取的 <code>__shared_weak_owners_</code> 大于 0，表明还有其他的 weak_reference，这个时候再尝试 compare and swap 操作来减小 <code>__shared_weak_owners_</code>。这其实是一种优化手段，如果 Acquire 读就能判定当前是最后一个 weak_reference，那就不需要再使用 compare and swap 操作，Acquire 读更轻量级一些。</p><p><code>__on_zero_shared_weak()</code> 也是一个纯虚函数需要子类实现，在这个函数里会释放辅助内存。</p><p>再看 <code>__shared_weak_count::lock</code> 函数，这个函数被 weak_ptr 里的 lock 函数调用。它先进行 load 读取引用计数，然后尝试 compare and swap 来增加引用计数，不理解这种 cas 操作的可以查查相关资料。</p><h4 id="shared-ptr-pointer-1"><a href="#shared-ptr-pointer-1" class="headerlink" title="__shared_ptr_pointer"></a>__shared_ptr_pointer</h4><p><code>__shared_ptr_pointer</code> 继承自 <code>__shared_weak_count</code>。</p><p><code>__shared_ptr_pointer</code> 存储了指针、删除器、allocator 成员。他还实现了父类的 <code>__on_zero_shared()</code>、<code>__on_zero_shared_weak()</code> 两个纯虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_ptr_pointer</span></span><br><span class="line">    : <span class="keyword">public</span> __shared_weak_count &#123;</span><br><span class="line">    __compressed_pair&lt;__compressed_pair&lt;_Tp, _Dp&gt;, _Alloc&gt; __data_;</span><br><span class="line"></span><br><span class="line">    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)</span><br><span class="line">        :  __data_(__compressed_pair&lt;_Tp, _Dp&gt;(__p, _VSTD::<span class="built_in">move</span>(__d)), _VSTD::<span class="built_in">move</span>(__a)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared() _NOEXCEPT </span><br><span class="line">    &#123;</span><br><span class="line">        __data_.<span class="built_in">first</span>().<span class="built_in">second</span>()(__data_.<span class="built_in">first</span>().<span class="built_in">first</span>());</span><br><span class="line">        __data_.<span class="built_in">first</span>().<span class="built_in">second</span>().~_Dp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared_weak() _NOEXCEPT</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> __allocator_traits_rebind&lt;_Alloc, __shared_ptr_pointer&gt;::type _Al;</span><br><span class="line">        <span class="keyword">typedef</span> allocator_traits&lt;_Al&gt; _ATraits;</span><br><span class="line">        <span class="keyword">typedef</span> pointer_traits&lt;<span class="keyword">typename</span> _ATraits::pointer&gt; _PTraits;</span><br><span class="line">    </span><br><span class="line">        _Al __a(__data_.<span class="built_in">second</span>());</span><br><span class="line">        __data_.<span class="built_in">second</span>().~_Alloc();</span><br><span class="line">        __a.<span class="built_in">deallocate</span>(_PTraits::<span class="built_in">pointer_to</span>(*<span class="keyword">this</span>), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__on_zero_shared()</code> 是共享计数为 0 时调用，该函数会释放真正管理的指针，同时析构删除器</p><ul><li><code>__data_.first().first()</code> 就是被管理的指针</li><li><code>__data_.first().second()</code> 就是删除器</li></ul><p><code>__on_zero_shared_weak()</code> 是弱引用为 0 时调用，该函数会析构 allocator，然后释放 <code>__shared_ptr_pointer</code> 自己的内存（注意下面 shared_ptr 中有两个指针，都需要 delete）。也就是说其实有两块内存需要释放，一块是被管理的内存，一块是辅助的内存，被管理内存是共享引用为 0 时释放，辅助内存是弱引用计数为 0 时释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> shared_ptr</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    element_type*      __ptr_; <span class="comment">// 这两个指针指向的内存都需要释放</span></span><br><span class="line">    __shared_weak_count* __cntrl_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的分析可以发现：智能指针本质就是通过一个生命周期比目标指针长的引用计数对象来管理目标指针。</p><p>再回到上面的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(_Yp* __p,</span><br><span class="line">                            <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)</span><br><span class="line">    : __ptr_(__p)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;_Yp&gt; __hold(__p);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;</span><br><span class="line">    <span class="keyword">typedef</span> __shared_ptr_pointer&lt;_Yp*, default_delete&lt;_Yp&gt;, _AllocT &gt; _CntrlBlk;</span><br><span class="line">    __cntrl_ = <span class="keyword">new</span> _CntrlBlk(__p, <span class="built_in">default_delete</span>&lt;_Yp&gt;(), _AllocT());</span><br><span class="line">    __hold.<span class="built_in">release</span>();</span><br><span class="line">    __enable_weak_this(__p, __p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数中 new 了一个 <code>__shared_ptr_pointer</code> 后还调用了 <code>__enable_weak_this()</code>，这个函数一看名字就和 enable_shared_from_this 有关，等我们讲完 weak_ptr 后讲 enable_shared_from_this 时再来分析</p><h2 id="接受裸指针-删除器的构造函数"><a href="#接受裸指针-删除器的构造函数" class="headerlink" title="接受裸指针 + 删除器的构造函数"></a>接受裸指针 + 删除器的构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>&gt;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(_Yp* __p, _Dp __d,</span><br><span class="line">                            <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)</span><br><span class="line">    : __ptr_(__p)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;</span><br><span class="line">        <span class="keyword">typedef</span> __shared_ptr_pointer&lt;_Yp*, _Dp, _AllocT &gt; _CntrlBlk;</span><br><span class="line">        __cntrl_ = <span class="keyword">new</span> _CntrlBlk(__p, __d, _AllocT());</span><br><span class="line">        __enable_weak_this(__p, __p);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面差不多，只是使用了自定义的删除器类型</p><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; __r) _NOEXCEPT</span><br><span class="line">    : __ptr_(__r.__ptr_),</span><br><span class="line">      __cntrl_(__r.__cntrl_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__add_shared();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是增加了引用计数</p><h2 id="接受对象的内部对象指针的拷贝构造函数"><a href="#接受对象的内部对象指针的拷贝构造函数" class="headerlink" title="接受对象的内部对象指针的拷贝构造函数"></a>接受对象的内部对象指针的拷贝构造函数</h2><p>这个构造函数比较有意思，它的 <code>__ptr_</code> 初始化为输入的 <code>__p</code>，而不是 <code>__r.__ptr_</code>，这允许构造得到的 <code>__ptr_</code> 不是真正被管理的指针，可以是其内部对象的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;_Yp&gt;&amp; __r, element_type *__p) _NOEXCEPT</span><br><span class="line">    : __ptr_(__p),</span><br><span class="line">      __cntrl_(__r.__cntrl_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__add_shared();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a, &amp;a-&gt;i)</span></span>;</span><br></pre></td></tr></table></figure><p>通过 A 的 shared_ptr 创建另一个 shared_ptr，这个 shared_ptr 返回的是 A 内部对象的指针，但是和 A 共享引用计数。</p><h2 id="接受泛型-shared-ptr-的拷贝构造函数"><a href="#接受泛型-shared-ptr-的拷贝构造函数" class="headerlink" title="接受泛型 shared_ptr 的拷贝构造函数"></a>接受泛型 shared_ptr 的拷贝构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;_Yp&gt;&amp; __r,</span><br><span class="line">                            <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)</span><br><span class="line">         _NOEXCEPT</span><br><span class="line">    : __ptr_(__r.__ptr_),</span><br><span class="line">      __cntrl_(__r.__cntrl_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__add_shared();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">shared_ptr&lt;_Tp&gt;&amp;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&amp; __r) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(__r).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型拷贝赋值"><a href="#泛型拷贝赋值" class="headerlink" title="泛型拷贝赋值"></a>泛型拷贝赋值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">typename</span> enable_if</span><br><span class="line">&lt;</span><br><span class="line">    is_convertible&lt;_Yp*, <span class="keyword">typename</span> shared_ptr&lt;_Tp&gt;::element_type*&gt;::value,</span><br><span class="line">    shared_ptr&lt;_Tp&gt;&amp;</span><br><span class="line">&gt;::type</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;_Yp&gt;&amp; __r) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(__r).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">reset</span>() _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>().<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于把自己恢复到默认构造时的状态。</p><p>下面则是将当前智能指针变为以输入裸指针为参数构造的智能指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">typename</span> enable_if</span><br><span class="line">&lt;</span><br><span class="line">    is_convertible&lt;_Yp*, <span class="keyword">typename</span> shared_ptr&lt;_Tp&gt;::element_type*&gt;::value,</span><br><span class="line">    <span class="type">void</span></span><br><span class="line">&gt;::type</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">reset</span>(_Yp* __p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(__p).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function">element_type* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>获得管理的指针。</p><h2 id="use-count"><a href="#use-count" class="headerlink" title="use_count()"></a>use_count()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __cntrl_ ? __cntrl_-&gt;<span class="built_in">use_count</span>() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回共享引用的计数。</p><h2 id="unique"><a href="#unique" class="headerlink" title="unique()"></a>unique()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unique</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">use_count</span>() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当前共享引用计数是否为 1。</p><h2 id="make-shared"><a href="#make-shared" class="headerlink" title="make_shared"></a>make_shared</h2><p>这个函数很有用，而且和常规的接受裸指针的构造函数有一些不一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> ..._Args&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="keyword">typename</span> enable_if</span><br><span class="line">&lt;</span><br><span class="line">    !is_array&lt;_Tp&gt;::value,</span><br><span class="line">    shared_ptr&lt;_Tp&gt;</span><br><span class="line">&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">make_shared</span><span class="params">(_Args&amp;&amp; ...__args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(is_constructible&lt;_Tp, _Args...&gt;::value, <span class="string">&quot;Can&#x27;t construct object in make_shared&quot;</span>);</span><br><span class="line">    <span class="keyword">typedef</span> __shared_ptr_emplace&lt;_Tp, allocator&lt;_Tp&gt; &gt; _CntrlBlk;</span><br><span class="line">    <span class="keyword">typedef</span> allocator&lt;_CntrlBlk&gt; _A2;</span><br><span class="line">    <span class="keyword">typedef</span> __allocator_destructor&lt;_A2&gt; _D2;</span><br><span class="line"></span><br><span class="line">    _A2 __a2;</span><br><span class="line">    unique_ptr&lt;_CntrlBlk, _D2&gt; __hold2(__a2.<span class="built_in">allocate</span>(<span class="number">1</span>), _D2(__a2, <span class="number">1</span>));</span><br><span class="line">    ::<span class="keyword">new</span>(__hold2.<span class="built_in">get</span>()) _CntrlBlk(__a2, _VSTD::forward&lt;_Args&gt;(__args)...);</span><br><span class="line"></span><br><span class="line">    _Tp *__ptr = __hold2.<span class="built_in">get</span>()-&gt;<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> shared_ptr&lt;_Tp&gt;::__create_with_control_block(__ptr, __hold2.<span class="built_in">release</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数生效的前提是 <code>_Tp</code> 不能是数组类型，也就是下面的代码是不允许的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>[<span class="number">2</span>]&gt;(...);</span><br></pre></td></tr></table></figure><h3 id="shared-ptr-emplace"><a href="#shared-ptr-emplace" class="headerlink" title="__shared_ptr_emplace"></a>__shared_ptr_emplace</h3><p>make_shared 中使用了 <code>__shared_ptr_emplace</code> 类来作为 <code>_CntrlBlk</code>，<code>__shared_ptr_emplace</code> 也继承自 <code>__shared_weak_count</code>，但是 <code>__shared_ptr_emplace</code> 中 <code>__data_</code> 成员里的模板参数是 <code>_Tp</code>，不是 <code>_Tp*</code>，也就是说被管理的对象会和 <code>__shared_ptr_emplace</code> 一起分配内存。这就是为什么 <strong>make_shared 要少分配一次内存</strong>。</p><p>此外在 <code>__on_zero_shared</code> 只析构了对象，但是没有释放内存的操作，因为 <code>_Tp</code> 是和 <code>__shared_ptr_emplace</code> 一起分配的，释放 <code>__shared_ptr_emplace</code> 时就释放了 <code>_Tp</code>，所以这里不需要释放内存。而 <code>__on_zero_shared_weak</code> 不仅析构了 allocator，还释放了 <code>__shared_ptr_emplace</code> 的内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_ptr_emplace</span></span><br><span class="line">    : <span class="keyword">public</span> __shared_weak_count</span><br><span class="line">&#123;</span><br><span class="line">    __compressed_pair&lt;_Alloc, _Tp&gt; __data_; <span class="comment">// 没有deleter</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_HAS_NO_VARIADICS</span></span><br><span class="line"></span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    __shared_ptr_emplace(_Alloc __a)</span><br><span class="line">        :  __data_(_VSTD::<span class="built_in">move</span>(__a)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ..._Args&gt;</span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">        __shared_ptr_emplace(_Alloc __a, _Args&amp;&amp; ...__args)</span><br><span class="line">            :  __data_(piecewise_construct, _VSTD::&lt;u&gt;forward_as_tuple&lt;/u&gt;(__a),</span><br><span class="line">                   _VSTD::forward_as_tuple(_VSTD::forward&lt;_Args&gt;(__args)...)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  <span class="comment">// _LIBCPP_HAS_NO_VARIADICS</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// _LIBCPP_HAS_NO_VARIADICS</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared() _NOEXCEPT</span><br><span class="line">    &#123;</span><br><span class="line">        __data_.<span class="built_in">second</span>().~_Tp(); <span class="comment">// 不用delete释放，会和__shared_ptr_emplace一起释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared_weak() _NOEXCEPT</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> __allocator_traits_rebind&lt;_Alloc, __shared_ptr_emplace&gt;::type _Al;</span><br><span class="line">        <span class="keyword">typedef</span> allocator_traits&lt;_Al&gt; _ATraits;</span><br><span class="line">        <span class="keyword">typedef</span> pointer_traits&lt;<span class="keyword">typename</span> _ATraits::pointer&gt; _PTraits;</span><br><span class="line">        _Al __a(__data_.<span class="built_in">first</span>());</span><br><span class="line">        __data_.<span class="built_in">first</span>().~_Alloc();</span><br><span class="line">        __a.<span class="built_in">deallocate</span>(_PTraits::<span class="built_in">pointer_to</span>(*<span class="keyword">this</span>), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    _Tp* <span class="title">get</span><span class="params">()</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> _VSTD::<span class="built_in">addressof</span>(__data_.<span class="built_in">second</span>());&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>make_shared 先分配 <code>__shared_ptr_emplace</code> 对象的内存，然后调用 inplacement new 去实例化 <code>__shared_ptr_emplace</code> 对象，得到 <code>__shared_ptr_emplace</code> 对象后调用 <code>shared_ptr::__create_with_control_block</code> 静态函数创建 shared_ptr：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>, <span class="keyword">class</span> <span class="title class_">_CntrlBlk</span>&gt;</span><br><span class="line"><span class="type">static</span> shared_ptr&lt;_Tp&gt;</span><br><span class="line">__create_with_control_block(_Yp* __p, _CntrlBlk* __cntrl)</span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;_Tp&gt; __r;</span><br><span class="line">    __r.__ptr_ = __p;</span><br><span class="line">    __r.__cntrl_ = __cntrl;</span><br><span class="line">    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);</span><br><span class="line">    <span class="keyword">return</span> __r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么父类-shared-ptr-接受子类指针后，释放时会调用子类的析构"><a href="#为什么父类-shared-ptr-接受子类指针后，释放时会调用子类的析构" class="headerlink" title="为什么父类 shared_ptr 接受子类指针后，释放时会调用子类的析构"></a>为什么父类 shared_ptr 接受子类指针后，释放时会调用子类的析构</h2><p>看一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;I&#x27;m A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>: A&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;I&#x27;m B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="function">shared_ptr&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function">shared_ptr&lt;A&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I<span class="number">&#x27;</span>m B</span><br><span class="line">I<span class="number">&#x27;</span>m A</span><br><span class="line">I<span class="number">&#x27;</span>m A</span><br></pre></td></tr></table></figure><p>从上面的例子中可以发现，<code>shared_ptr&lt;父类&gt;</code> 接受 子类指针参数 时，会根据实际指针参数类型来决定如何删除。</p><p>也就是说 shared_ptr 能够根据实际输入的指针类型进行 delete 操作，而不需要虚析构函数。</p><p>这是因为 shared_ptr 的接受裸指针参数的构造函数是一个模板函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(_Yp* __p,</span><br><span class="line">                            <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)</span><br><span class="line">    : __ptr_(__p)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;_Yp&gt; __hold(__p);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;</span><br><span class="line">    <span class="keyword">typedef</span> __shared_ptr_pointer&lt;_Yp*, default_delete&lt;_Yp&gt;, _AllocT &gt; _CntrlBlk;</span><br><span class="line">    __cntrl_ = <span class="keyword">new</span> _CntrlBlk(__p, <span class="built_in">default_delete</span>&lt;_Yp&gt;(), _AllocT());</span><br><span class="line">    __hold.<span class="built_in">release</span>();</span><br><span class="line">    __enable_weak_this(__p, __p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数有两个模板，<code>_Tp</code> 是显式指定的，<code>_Yp</code> 是根据输入参数推断的。上面在创建 <code>__shared_ptr_pointer</code> 时，删除器是<strong>default_delete&lt;_Yp&gt;</strong>，而不是<strong>default_delete&lt;_Tp&gt;</strong></p><p>调用析构是在 <code>__on_zero_shared</code> 中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_ptr_pointer</span></span><br><span class="line">    : <span class="keyword">public</span> __shared_weak_count &#123;</span><br><span class="line">    __compressed_pair&lt;__compressed_pair&lt;_Tp, _Dp&gt;, _Alloc&gt; __data_;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared() _NOEXCEPT </span><br><span class="line">    &#123;</span><br><span class="line">        __data_.<span class="built_in">first</span>().<span class="built_in">second</span>()(__data_.<span class="built_in">first</span>().<span class="built_in">first</span>());</span><br><span class="line">        __data_.<span class="built_in">first</span>().<span class="built_in">second</span>().~_Dp();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__data_.first().second()(__data_.first().first());</code> 就是调用了<strong>default_delete&lt;</strong><strong>_Yp</strong><strong>&gt;</strong>的 operator()()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp* __ptr)</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">delete</span> __ptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是说 <code>_Yp</code> 这个类型信息会被传递到 default_delete 中，default_delete 的 operator()()接受的就是 <code>_Yp*</code> 类型的参数，相当于做了一个强制转型，不管传什么指针，都当作 <code>_Yp*</code> 处理</p><p>再举个例子加深一下理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;I&#x27;m A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>: A&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;I&#x27;m B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>: B&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    ~<span class="built_in">C</span>()&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;I&#x27;m C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C* c1 = <span class="keyword">new</span> C;</span><br><span class="line">    C* c2 = <span class="keyword">new</span> C;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;A&gt; <span class="title">b</span><span class="params">(<span class="keyword">static_cast</span>&lt;B*&gt;(c1))</span></span>;</span><br><span class="line">        <span class="function">shared_ptr&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">static_cast</span>&lt;A*&gt;(c2))</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I<span class="number">&#x27;</span>m A</span><br><span class="line">I<span class="number">&#x27;</span>m B</span><br><span class="line">I<span class="number">&#x27;</span>m A</span><br></pre></td></tr></table></figure><p>看懂了吗？shared_ptr 的删除器是根据<strong>输入参数的静态类型</strong>确定的</p><h1 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h1><p>在上面的 shared_ptr 中，有强弱两种引用计数，强引用（或者叫共享引用）计数为 0 时释放被管理的内存，弱引用计数为 0 时释放辅助对象的内存。</p><p>标准库中除了 shared_ptr，还有 weak_ptr。weak_ptr 看名字就知道是“弱指针”，肯定和弱引用计数有关，我们大概可以推测创建一个 weak_ptr 就会增加弱引用计数，而事实也确实如此</p><p>weak_ptr 需要和 shared_ptr 一起使用，用来避免循环引用问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">b.<span class="built_in">use_count</span>(); <span class="comment">// 1</span></span><br><span class="line">b.<span class="built_in">expired</span>(); <span class="comment">// false</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; c = b.<span class="built_in">lock</span>(); <span class="comment">// 如果b关联的强引用计数不为0，就+1并创建shared_ptr</span></span><br></pre></td></tr></table></figure><p>weak_ptr 的成员数据很简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> weak_ptr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    element_type*        __ptr_;</span><br><span class="line">    __shared_weak_count* __cntrl_;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">weak_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">            __cntrl_-&gt;__release_weak();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __cntrl_ ? __cntrl_-&gt;<span class="built_in">use_count</span>() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __cntrl_ == <span class="number">0</span> || __cntrl_-&gt;<span class="built_in">use_count</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;_Tp&gt; <span class="title">lock</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        shared_ptr&lt;_Tp&gt; __r;</span><br><span class="line">        __r.__cntrl_ = __cntrl_ ? __cntrl_-&gt;<span class="built_in">lock</span>() : __cntrl_;</span><br><span class="line">        <span class="keyword">if</span> (__r.__cntrl_)</span><br><span class="line">            __r.__ptr_ = __ptr_;</span><br><span class="line">        <span class="keyword">return</span> __r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个指向被管理对象的指针 <code>__ptr_</code>，一个指向 <code>__shared_weak_count</code> 的指针 <code>__cntrl_</code>，也就是说 weak_ptr 同样也持有 shared_ptr 中的辅助对象指针</p><p>weak_ptr 的构造函数接受一个 shared_ptr 对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">weak_ptr&lt;_Tp&gt;::<span class="built_in">weak_ptr</span>(shared_ptr&lt;_Yp&gt; <span class="type">const</span>&amp; __r,</span><br><span class="line">                        <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Yp*, _Tp*&gt;::value, __nat*&gt;::type)</span><br><span class="line">                         _NOEXCEPT</span><br><span class="line">    : __ptr_(__r.__ptr_),</span><br><span class="line">      __cntrl_(__r.__cntrl_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__add_weak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面构造函数内部就是把 shared_ptr 的辅助对象指针赋值到 weak_ptr 内部的辅助对象指针。所以 weak_ptr 和他关联的 shared_ptr 共享一个辅助对象</p><p>在上面的构造函数中还调用了辅助对象的 <code>__add_weak</code> 方法增加弱引用计数。而 weak_ptr 析构时调用辅助对象的 <code>__release_weak()</code> 方法减少弱引用计数</p><p>通过上面 shared_ptr 和 weak_ptr 可知，如果使用 make_shared 创建 shared_ptr，然后用创建的 shared_ptr 再去创建 weak_ptr，此时如果 shared_ptr 析构，那么就没有共享引用只有弱引用，但 make_shared 创建的对象内存是在辅助对象中，也就是在这种情况下可以通过 weak_ptr 得到还没被释放内存的被管理对象的指针。但是要注意，通过这种方式得到的对象是调用了析构函数的。</p><h1 id="enable-shared-from-this"><a href="#enable-shared-from-this" class="headerlink" title="enable_shared_from_this"></a>enable_shared_from_this</h1><p>enable_shared_from_this 是让一个类能够通过成员函数得到指向自己的 shared_ptr。使用方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>: enable_shared_from_this &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> b = a-&gt;<span class="built_in">shared_from_this</span>(); <span class="comment">// a 和 b 共享一个辅助对象</span></span><br></pre></td></tr></table></figure><p>而下面的例子（来自 <a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">std::enable_shared_from_this - cppreference.com</a>）是不对的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Bad</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Bad&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Bad</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bad::~Bad() called\n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;Bad&gt; bad0 = std::<span class="built_in">make_shared</span>&lt;Bad&gt;();</span><br><span class="line">std::shared_ptr&lt;Bad&gt; bad1 = bad0-&gt;<span class="built_in">getptr</span>();</span><br></pre></td></tr></table></figure><p>bad0 和 bad1 没有共享辅助对象，析构时会析构两次</p><p>enable_shared_from_this 类结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> enable_shared_from_this</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt; __weak_this_;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span></span><br><span class="line"><span class="function">    <span class="title">enable_shared_from_this</span><span class="params">()</span> _NOEXCEPT </span>&#123;&#125;</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    <span class="title">enable_shared_from_this</span><span class="params">(enable_shared_from_this <span class="type">const</span>&amp;)</span> _NOEXCEPT </span>&#123;&#125;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    enable_shared_from_this&amp; <span class="keyword">operator</span>=(enable_shared_from_this <span class="type">const</span>&amp;) _NOEXCEPT</span><br><span class="line">        &#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    ~<span class="built_in">enable_shared_from_this</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    shared_ptr&lt;_Tp&gt; <span class="title">shared_from_this</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(__weak_this_);&#125;</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    shared_ptr&lt;_Tp <span class="type">const</span>&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> _Tp&gt;(__weak_this_);&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_STD_VER &gt; 14</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _LIBCPP_STD_VER &gt; 14</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它里面只有一个类型为 <code>weak_ptr&lt;_Tp&gt;</code> 的 <code>__weak_this_</code> 数据，而 <code>weak_ptr&lt;_Tp&gt;</code> 内部持有辅助对象的指针</p><p>假设有一个类 A 继承 <code>enable_shared_from_this&lt;A&gt;</code>，看看当创建 A 的 shared_ptr 时发生了什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(_Yp* __p,</span><br><span class="line">                            <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)</span><br><span class="line">    : __ptr_(__p)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;_Yp&gt; __hold(__p);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;</span><br><span class="line">    <span class="keyword">typedef</span> __shared_ptr_pointer&lt;_Yp*, default_delete&lt;_Yp&gt;, _AllocT &gt; _CntrlBlk;</span><br><span class="line">    __cntrl_ = <span class="keyword">new</span> _CntrlBlk(__p, <span class="built_in">default_delete</span>&lt;_Yp&gt;(), _AllocT());</span><br><span class="line">    __hold.<span class="built_in">release</span>();</span><br><span class="line">    __enable_weak_this(__p, __p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面几步在上面已经看过了，现在来分析一下 <code>__enable_weak_this</code> 做了什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>, <span class="keyword">class</span> <span class="title class_">_OrigPtr</span>&gt;</span><br><span class="line">        <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_OrigPtr*,</span><br><span class="line">                                          <span class="type">const</span> enable_shared_from_this&lt;_Yp&gt;*</span><br><span class="line">        &gt;::value,</span><br><span class="line">            <span class="type">void</span>&gt;::type</span><br><span class="line">        __enable_weak_this(<span class="type">const</span> enable_shared_from_this&lt;_Yp&gt;* __e,</span><br><span class="line">                           _OrigPtr* __ptr) _NOEXCEPT</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_cv&lt;_Yp&gt;::type _RawYp;</span><br><span class="line">            <span class="keyword">if</span> (__e &amp;&amp; __e-&gt;__weak_this_.<span class="built_in">expired</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                __e-&gt;__weak_this_ = <span class="built_in">shared_ptr</span>&lt;_RawYp&gt;(*<span class="keyword">this</span>,</span><br><span class="line">                    <span class="built_in">const_cast</span>&lt;_RawYp*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> _Yp*&gt;(__ptr)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __enable_weak_this(...) _NOEXCEPT &#123;&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__e</code> 和 <code>__ptr</code> 输入参数都是 <code>A*</code> 类型，所以 <code>_Yp</code> 和 <code>_OrigPtr</code> 都是 A 类型，<code>_RawYp</code> 则是 <code>_Yp</code> 去除 const、volatile 限定符，我们简单考虑 <code>_RawYp</code> 就是 <code>_Yp</code>，所以 <code>_RawYp</code> 就是 A</p><p>下面这一行代码比较有意思</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__e-&gt;__weak_this_ = <span class="built_in">shared_ptr</span>&lt;_RawYp&gt;(*<span class="keyword">this</span>,</span><br><span class="line">    <span class="built_in">const_cast</span>&lt;_RawYp*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> _Yp*&gt;(__ptr)));</span><br></pre></td></tr></table></figure><p>创建了一个 shared_ptr，这个 ptr 解引用时的指针和管理对象内部管理的指针不一样，用到了上面说的 接受对象的内部对象指针的拷贝构造函数。然后用 shared_ptr 对 <code>__weak_this_</code> 进行赋值。</p><p>所以 <code>__e-&gt;__weak_this_ = ...</code> 这行代码实际上就是把当前 shared_ptr 的辅助对象指针 <code>__cntrl_</code> 赋给 <code>__e-&gt;__weak_this_</code> 内部的辅助对象指针。这样在 A 对象内部就有了辅助对象指针。</p><p><code>enable_shared_from_this&lt;T&gt;</code> 内部有一个 <code>weak_ptr&lt;T&gt;</code>，通过这个 <code>weak_ptr&lt;T&gt;</code> 就可以创建 <code>shared_ptr&lt;T&gt;</code>。</p><p>为什么有 <code>weak_ptr&lt;T&gt;</code> 就可以了，他不是弱引用吗？这是因为 shared_from_this()只能从 shared_ptr 中进行调用，这就保证在对 <code>weak_ptr&lt;T&gt;</code> 进行 lock 时至少有一个共享引用，所以 <code>enable_shared_from_this&lt;T&gt;</code> 内部的 <code>weak_ptr&lt;T&gt;</code> 的 lock 是必定成功的。</p><p>参考资料：</p><p><a href="https://github.com/llvm-mirror/libcxx/blob/master/include/memory">https://github.com/llvm-mirror/libcxx/blob/master/include/memory</a></p><p><a href="https://github.com/llvm-mirror/libcxx/blob/master/src/memory.cpp">https://github.com/llvm-mirror/libcxx/blob/master/src/memory.cpp</a></p><p><a href="https://github.com/zyuchuan/unique_cpp/blob/master/ch04_smart_pointers.md">https://github.com/zyuchuan/unique_cpp&#x2F;blob&#x2F;master&#x2F;ch04_smart_pointers.md</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++标准库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++标准库之unique_ptr</title>
      <link href="/2023/03/01/C-%E6%A0%87%E5%87%86%E5%BA%93%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E4%B9%8Bunique-ptr/"/>
      <url>/2023/03/01/C-%E6%A0%87%E5%87%86%E5%BA%93%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E4%B9%8Bunique-ptr/</url>
      
        <content type="html"><![CDATA[<p>这篇博客分析一下标准库的 unique_ptr。</p><p>先看一下 unique_ptr 的使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个裸指针作为构造函数参数</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放指针指向的内存</span></span><br><span class="line">b.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放指针指针指向的内存，同时接管另一片内存</span></span><br><span class="line">b.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得unique_ptr内部的指针值</span></span><br><span class="line"><span class="keyword">auto</span> pp = b.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放指针，但不释放内存</span></span><br><span class="line"><span class="keyword">auto</span> p = b.<span class="built_in">release</span>();</span><br><span class="line"><span class="comment">// 手动释放内存</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法拷贝，但是可以移动</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; c = std::<span class="built_in">move</span>(b);</span><br></pre></td></tr></table></figure><p>unique_ptr 相对 shared_ptr 要简单一些，就是使用了 RAII 机制来包装一个裸指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span> = default_delete&lt;_Tp&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> _LIBCPP_TEMPLATE_VIS unique_ptr &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Dp deleter_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __pointer_type&lt;_Tp, deleter_type&gt;::type pointer;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  __compressed_pair&lt;pointer, deleter_type&gt; __ptr_;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>unique_ptr 内部只有 <code>__compressed_pair&lt;pointer, deleter_type&gt; __ptr_;</code> 这一个数据成员。<code>__compressed_pair</code> 后面再单独写一篇文章介绍，暂时可以将其视为 pair。</p><h2 id="pointer-type"><a href="#pointer-type" class="headerlink" title="__pointer_type"></a>__pointer_type</h2><p>看看 <code>__pointer_type</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__pointer_type</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __pointer_type_imp::__pointer_type&lt;_Tp, <span class="keyword">typename</span> remove_reference&lt;_Dp&gt;::type&gt;::type type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> __pointer_type_imp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>, <span class="type">bool</span> = __has_pointer_type&lt;_Dp&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> __pointer_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> &lt;u&gt;_Dp::pointer&lt;/u&gt; type; <span class="comment">// 如果_Dp定义了pointer类型，就用这个类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__pointer_type</span>&lt;_Tp, _Dp, <span class="literal">false</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* type; <span class="comment">// 否则使用_Tp*</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> __has_pointer_type : &lt;u&gt;false_type&lt;/u&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__has_pointer_type</span>&lt;_Tp,</span><br><span class="line">          <span class="keyword">typename</span> <span class="type">__void_t</span>&lt;<span class="keyword">typename</span> _Tp::pointer&gt;::type&gt; : &lt;u&gt;true_type&lt;/u&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>从上面代码可知，如果 <code>_Dp</code>（也就是删除器）中定义了 pointer 类型，那么 pointer 就是 <code>_Dp::pointer</code>，否则 pointer 就是 <code>_Tp*</code>。使用 default_delete 作为删除器的话，default_delete 是没有 pointer 类型的，所以最终推导出来就是 <code>_Tp*</code>。</p><p>deleter_type 通常是一个空的类型（比如默认的 default_delete 就是空的），<code>__compressed_pair</code> 会针对此进行空间优化，<code>__ptr_</code> 的大小通常就是 pointer 的大小。</p><h2 id="接受裸指针参数的构造函数"><a href="#接受裸指针参数的构造函数" class="headerlink" title="接受裸指针参数的构造函数"></a>接受裸指针参数的构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">class</span> = _EnableIfDeleterDefaultConstructible&lt;_Dummy&gt; &gt;</span><br><span class="line">  <span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer __p) _NOEXCEPT : __ptr_(__p) &#123;&#125;</span><br></pre></td></tr></table></figure><p>此构造函数就是用指针参数 <code>__p</code> 来构造 <code>__ptr_</code>，由于没有给删除器参数，所以使用 <code>_EnableIfDeleterDefaultConstructible</code> 来检查删除器是否可以默认构造。</p><p>对于初学者，像这种 EnableIf 的检查条件可以暂时忽略，先从整体去理解模板，只需要知道该模板函数需要在一定条件下才会生效即可。</p><p>但是这里还是简要分析一下这个条件，<code>_EnableIfDeleterDefaultConstructible</code> 如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy, <span class="keyword">class</span> <span class="title class_">_Deleter</span> = <span class="keyword">typename</span> __dependent_type&lt;</span><br><span class="line">                         __identity&lt;&lt;u&gt;deleter_type&lt;/u&gt;&gt;, _Dummy&gt;::type&gt;</span><br><span class="line"><span class="keyword">using</span> _EnableIfDeleterDefaultConstructible =</span><br><span class="line">  <span class="keyword">typename</span> enable_if&lt;is_default_constructible&lt;_Deleter&gt;::value &amp;&amp;</span><br><span class="line">                     !is_pointer&lt;_Deleter&gt;::value&gt;::type;</span><br></pre></td></tr></table></figure><p><code>__identity</code> 如下，<code>__identity&lt;deleter_type&gt;</code> 内部定义了 deleter_type 为 type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__identity</span> &#123; <span class="keyword">typedef</span> _Tp type; &#125;;</span><br></pre></td></tr></table></figure><p><code>__dependent_type</code> 如下，所以上面 <code>__dependent_type&lt;__identity&lt;deleter_type&gt;, _Dummy&gt;::type</code> 就是 deleter_type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="type">bool</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__dependent_type</span> : <span class="keyword">public</span> _Tp &#123;&#125;;</span><br></pre></td></tr></table></figure><p>所以上面 <code>_EnableIfDeleterDefaultConstructible</code> 检查的就是下面两个条件要满足</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_default_constructible&lt;deleter_type&gt;::value</span><br><span class="line">!is_pointer&lt;deleter_type&gt;::value</span><br></pre></td></tr></table></figure><p>第一个条件要求 deleter_type 能够默认构造，第二个条件要求 deleter_type 不是指针类型。</p><h2 id="接受裸指针-删除器的构造函数"><a href="#接受裸指针-删除器的构造函数" class="headerlink" title="接受裸指针 + 删除器的构造函数"></a>接受裸指针 + 删除器的构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">class</span> = _EnableIfDeleterConstructible&lt;_LValRefType&lt;_Dummy&gt; &gt; &gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">  <span class="built_in">unique_ptr</span>(pointer __p, _LValRefType&lt;_Dummy&gt; __d) _NOEXCEPT</span><br><span class="line">      : __ptr_(__p, __d) &#123;&#125;</span><br></pre></td></tr></table></figure><p>基本逻辑不难理解，还是看看 <code>_EnableIfDeleterConstructible</code> 和 <code>_LValRefType</code></p><p><code>__dependent_type</code> 和之前一样，所以 <code>__dependent_type&lt;_DeleterSFINAE, _Dummy&gt;::__lval_ref_type</code> 就是 <code>_DeleterSFINAE::__lval_ref_type</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy&gt;</span><br><span class="line"><span class="keyword">using</span> _LValRefType _LIBCPP_NODEBUG_TYPE =</span><br><span class="line">    <span class="keyword">typename</span> __dependent_type&lt;_DeleterSFINAE, _Dummy&gt;::__lval_ref_type;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE __unique_ptr_deleter_sfinae&lt;_Dp&gt; _DeleterSFINAE;</span><br></pre></td></tr></table></figure><p><code>__unique_ptr_deleter_sfinae</code> 如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Deleter</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unique_ptr_deleter_sfinae</span> &#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(!is_reference&lt;_Deleter&gt;::value, <span class="string">&quot;incorrect specialization&quot;</span>);</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Deleter&amp; __lval_ref_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Deleter&amp;&amp; __good_rval_ref_type;</span><br><span class="line">  <span class="keyword">typedef</span> true_type __enable_rval_overload;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Deleter</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unique_ptr_deleter_sfinae</span>&lt;_Deleter <span class="type">const</span>&amp;&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Deleter&amp; __lval_ref_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Deleter&amp;&amp; __bad_rval_ref_type;</span><br><span class="line">  <span class="keyword">typedef</span> false_type __enable_rval_overload;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Deleter</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unique_ptr_deleter_sfinae</span>&lt;_Deleter&amp;&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Deleter&amp; __lval_ref_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Deleter&amp;&amp; __bad_rval_ref_type;</span><br><span class="line">  <span class="keyword">typedef</span> false_type __enable_rval_overload;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在使用 unique_ptr 的时候，是允许这样的：<code>unique_ptr&lt;some_type, some_deleter&gt;</code>、<code>unique_ptr&lt;some_type, some_deleter&amp;&gt;</code>、<code>unique_ptr&lt;some_type, some_deleter const&amp;&gt;</code>，<code>__unique_ptr_deleter_sfinae</code> 根据不同的 deleter 类型定义不同的 lval_ref_type、rval_ref_type。</p><p>此外不允许这样定义 <code>unique_ptr&lt;some_type, some_deleter&amp;&amp;&gt;</code>，因为 <code>static_assert(!is_reference&lt;_Deleter&gt;::value, &quot;incorrect specialization&quot;);</code> 会失败。</p><p>再回过头看这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">class</span> = _EnableIfDeleterConstructible&lt;_LValRefType&lt;_Dummy&gt; &gt; &gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">  <span class="built_in">unique_ptr</span>(pointer __p, _LValRefType&lt;_Dummy&gt; __d) _NOEXCEPT</span><br><span class="line">      : __ptr_(__p, __d) &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果删除器类型是 default_delete，那么 <code>_LValRefType&lt;_Dummy&gt;</code> 就是 <code>const default_delete&amp;</code>，如果删除器类型是 <code>default_delete&amp;</code>，那么 <code>_LValRefType&lt;_Dummy&gt;</code> 就是 <code>default_delete&amp;</code></p><p>再看看 <code>_EnableIfDeleterConstructible</code>，这个和 <code>_EnableIfDeleterDefaultConstructible</code> 类似，但是它是检查删除器是否可以由 <code>__d</code> 参数构造。内部是使用了 is_constructible 进行检查。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_ArgType</span>&gt;</span><br><span class="line">  <span class="keyword">using</span> _EnableIfDeleterConstructible _LIBCPP_NODEBUG_TYPE  =</span><br><span class="line">      <span class="keyword">typename</span> enable_if&lt;is_constructible&lt;deleter_type, _ArgType&gt;::value&gt;::type;</span><br></pre></td></tr></table></figure><p>再看下面这个构造函数，它的删除器允许接受右值引用参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">class</span> = _EnableIfDeleterConstructible&lt;_GoodRValRefType&lt;_Dummy&gt; &gt; &gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">  <span class="built_in">unique_ptr</span>(pointer __p, _GoodRValRefType&lt;_Dummy&gt; __d) _NOEXCEPT</span><br><span class="line">      : __ptr_(__p, _VSTD::<span class="built_in">move</span>(__d)) &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!is_reference&lt;deleter_type&gt;::value,</span><br><span class="line">                  <span class="string">&quot;rvalue deleter bound to reference&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>只有当删除器类型是值类型，比如 default_delete 时，才有 <code>_GoodRValRefType</code>，其他场合是不允许的。当我们对删除器定义为值类型时，可以传删除器的将亡值来调用移动构造。</p><h2 id="接受右值引用的构造函数"><a href="#接受右值引用的构造函数" class="headerlink" title="接受右值引用的构造函数"></a>接受右值引用的构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">  <span class="title">unique_ptr</span><span class="params">(unique_ptr&amp;&amp; __u)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">      : __ptr_(__u.release(), _VSTD::forward&lt;deleter_type&gt;(__u.get_deleter())) &#123;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>unique_ptr 可以发生移动。如果 deleter_type 是值类型，那么 forward 会得到将亡值，deleter 可能发生移动构造，如果 deleter_type 是引用类型，那么 forward 得到左值，deleter 可能传递引用。</p><h2 id="接受泛型-unique-ptr-的构造函数"><a href="#接受泛型-unique-ptr-的构造函数" class="headerlink" title="接受泛型 unique_ptr 的构造函数"></a>接受泛型 unique_ptr 的构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>, <span class="keyword">class</span> <span class="title class_">_Ep</span>,</span><br><span class="line">      <span class="keyword">class</span> = _EnableIfMoveConvertible&lt;unique_ptr&lt;_Up, _Ep&gt;, _Up&gt;,</span><br><span class="line">      <span class="keyword">class</span> = _EnableIfDeleterConvertible&lt;_Ep&gt;</span><br><span class="line">  &gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">  <span class="built_in">unique_ptr</span>(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) _NOEXCEPT</span><br><span class="line">      : __ptr_(__u.<span class="built_in">release</span>(), _VSTD::forward&lt;_Ep&gt;(__u.<span class="built_in">get_deleter</span>())) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数接受一个泛型 unique_ptr，它的指针类型和删除器类型都可以和当前 unique_ptr 不一样，但要满足 <code>_EnableIfMoveConvertible</code> 和 <code>_EnableIfDeleterConvertible</code> 条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_UPtr</span>, <span class="keyword">class</span> <span class="title class_">_Up</span>&gt;</span><br><span class="line">  <span class="keyword">using</span> _EnableIfMoveConvertible _LIBCPP_NODEBUG_TYPE  = <span class="keyword">typename</span> enable_if&lt;</span><br><span class="line">      is_convertible&lt;<span class="keyword">typename</span> _UPtr::pointer, pointer&gt;::value &amp;&amp;</span><br><span class="line">      !is_array&lt;_Up&gt;::value</span><br><span class="line">  &gt;::type;</span><br></pre></td></tr></table></figure><p><code>_EnableIfMoveConvertible</code> 就是检查两个 unique_ptr 他们的 pointer 类型是否兼容（比如父子类关系）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_UDel</span>&gt;</span><br><span class="line">  <span class="keyword">using</span> _EnableIfDeleterConvertible _LIBCPP_NODEBUG_TYPE  = <span class="keyword">typename</span> enable_if&lt;</span><br><span class="line">      (is_reference&lt;_Dp&gt;::value &amp;&amp; is_same&lt;_Dp, _UDel&gt;::value) ||</span><br><span class="line">      (!is_reference&lt;_Dp&gt;::value &amp;&amp; is_convertible&lt;_UDel, _Dp&gt;::value)</span><br><span class="line">    &gt;::type;</span><br></pre></td></tr></table></figure><p><code>_EnableIfDeleterConvertible</code> 则是检查删除器类型是否兼容：如果当前 unique_ptr 的删除器是引用，那么输入 unique_ptr 的删除器必须和当前的删除器类型一样；如果当前删除器不是引用，那么要求两者是 convertible 的</p><h2 id="移动赋值函数"><a href="#移动赋值函数" class="headerlink" title="移动赋值函数"></a>移动赋值函数</h2><p>接受右值引用的移动赋值比较简单，和之前接受右值的移动构造类似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line">  unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; __u) _NOEXCEPT &#123;</span><br><span class="line">    <span class="built_in">reset</span>(__u.<span class="built_in">release</span>());</span><br><span class="line">    __ptr_.<span class="built_in">second</span>() = _VSTD::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接受泛型 unique_ptr 的移动赋值也和相应场景的移动构造类似，但此时对 deleter 是检查 <code>_EnableIfDeleterAssignable</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>, <span class="keyword">class</span> <span class="title class_">_Ep</span>,</span><br><span class="line">      <span class="keyword">class</span> = _EnableIfMoveConvertible&lt;unique_ptr&lt;_Up, _Ep&gt;, _Up&gt;,</span><br><span class="line">      <span class="keyword">class</span> = _EnableIfDeleterAssignable&lt;_Ep&gt;</span><br><span class="line">  &gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">  unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) _NOEXCEPT &#123;</span><br><span class="line">    <span class="built_in">reset</span>(__u.<span class="built_in">release</span>());</span><br><span class="line">    __ptr_.<span class="built_in">second</span>() = _VSTD::forward&lt;_Ep&gt;(__u.<span class="built_in">get_deleter</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_UDel</span>&gt;</span><br><span class="line">  <span class="keyword">using</span> _EnableIfDeleterAssignable = <span class="keyword">typename</span> enable_if&lt;</span><br><span class="line">      is_assignable&lt;_Dp&amp;, _UDel&amp;&amp;&gt;::value</span><br><span class="line">    &gt;::type;</span><br></pre></td></tr></table></figure><p>注意如果 <code>_Dp</code> 是引用类型，那么这里赋值是会改变引用指向的对象，而不是让当前的 deleter 指向输入的对象。这种操作容易出错，所以应当避免使用引用类型的删除器。</p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数内部调用 reset()，reset()就是将__ptr_的第一个元素（也就是指针）取出，然后调用第二个元素（也就是删除器），把第一个元素作为参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">unique_ptr</span>() &#123; <span class="built_in">reset</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    pointer __tmp = __ptr_.<span class="built_in">first</span>();</span><br><span class="line">    __ptr_.<span class="built_in">first</span>() = __p;</span><br><span class="line">    <span class="keyword">if</span> (__tmp)</span><br><span class="line">      __ptr_.<span class="built_in">second</span>()(__tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><p>取出 <code>__ptr_</code> 的第一个元素，然后将之置为空指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">release</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    pointer <span class="type">__t</span> = __ptr_.<span class="built_in">first</span>();</span><br><span class="line">    __ptr_.<span class="built_in">first</span>() = <span class="built_in">pointer</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="type">__t</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>取出 <code>__ptr_</code> 的第一个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __ptr_.<span class="built_in">first</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="make-unique"><a href="#make-unique" class="headerlink" title="make_unique"></a>make_unique</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> __unique_if&lt;_Tp&gt;::<span class="function">__unique_single</span></span><br><span class="line"><span class="function"><span class="title">make_unique</span><span class="params">(_Args&amp;&amp;... __args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;_Tp&gt;(<span class="keyword">new</span> _Tp(_VSTD::forward&lt;_Args&gt;(__args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部就是调用 <code>unique_ptr&lt;_Tp&gt;</code> 的构造函数，使用了默认删除器</p><p><code>__unique_if</code> 是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unique_if</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> unique_ptr&lt;_Tp&gt; __unique_single;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unique_if</span>&lt;_Tp[]&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> unique_ptr&lt;_Tp[]&gt; __unique_array_unknown_bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果 <code>_Tp</code> 是非数组类型，<code>__unique_if&lt;_Tp&gt;::__unique_single</code> 就是 <code>unique_ptr&lt;_Tp&gt;</code></p><h2 id="default-delete"><a href="#default-delete" class="headerlink" title="default_delete"></a>default_delete</h2><p>最后再看看 default_delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> default_delete &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!is_function&lt;_Tp&gt;::value,</span><br><span class="line">                  <span class="string">&quot;default_delete cannot be instantiated for function types&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_CXX03_LANG</span></span><br><span class="line">  <span class="function">_LIBCPP_INLINE_VISIBILITY <span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> _NOEXCEPT </span>= <span class="keyword">default</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="function">_LIBCPP_INLINE_VISIBILITY <span class="title">default_delete</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>&gt;</span><br><span class="line">  <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">  <span class="title">default_delete</span><span class="params">(<span class="type">const</span> default_delete&lt;_Up&gt;&amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Up*, _Tp*&gt;::value&gt;::type* =</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="number">0</span>)</span> _NOEXCEPT </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">_LIBCPP_INLINE_VISIBILITY <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp* __ptr)</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(_Tp) &gt; <span class="number">0</span>,</span><br><span class="line">                  <span class="string">&quot;default_delete can not delete incomplete type&quot;</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(!is_void&lt;_Tp&gt;::value,</span><br><span class="line">                  <span class="string">&quot;default_delete can not delete incomplete type&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> __ptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>default_delete 是一个空类型，他重载了 operator()调用运算符，是一个可调用类型</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
          <category> C++标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C++标准库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
